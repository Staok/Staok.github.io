[{"categories":["EE-CS-Study"],"content":"编程经验、调试、性能和内存检查工具集合","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"编程经验、调试、性能和内存检查工具集合 程序调试、在检测工具手段上对程序评估和优化 的 综合。 尚有 一些 标记了 TODO 的地方 有待施工。没有三头六臂，很多资料 手头和脑里 都有 只是尚未没有整理出来。 虽抱文章，开口谁亲。且陶陶、乐尽天真。几时归去，作个闲人。对一张琴，一壶酒，一溪云。 编程经验 这里只总结一些精华的点、易忘的点，高频出问题的点。 顶层指导： 多看一些 最佳实践 的 文章 和 工程 来对自己进行提高。 基础语法和例子，实践的时候可举一反三使用。 写东西时候先多思考架构。不必一上来就写 等 情况的出现，减少后面 debug 和 重构的时间。 设计模式相关综合 Staok/C-Cpp-design-patterns: C/C++设计模式相关优秀资料集子 (github.com)。 可以设计 和 使用一些自动化工具来帮助完成 重复性的操作（也避免人工操作的可能的失误，所以工具也要写的健壮一些，识别和处理一些常会出现的错误），或者 用来检查 容易出错的地方，借由机器来给脑卸去些负担。 易错注意：p.s 这些地方易错且无法静态检查出，只能运行起来碰到，目前还没有好的静态工具来检出，所以靠人来保证程序的健壮性，是良好的 程序框架设计 和 一些规则（比如不写主动抛异常）、规范 的 教育、培训、落实 来。 一个资源可能多个线程使用，必加锁（单纯的互斥量，或者读写锁 等，选择适当的锁类型）。 使用指针之前 若有必要 则 必 检查 判空（包括std::shared_ptr等类型的指针）。释放指针后必置其为 nullptr / null。动态创建的资源，尽量使用智能指针来管理。 会抛异常的 API 若有必要 / 尽量 加异常捕获。 使用系统调用、库函数等，查看文档确定其是否会抛异常，处理其执行错误的情况。自己写程序可以尽量不用主动抛异常，运行出错当下解决（视情况严重性，是直接终止程序（后面依靠比较完备的测试来逐渐收敛程序 bug 来提高程序健壮性），还是及时在当下来处理错误（如给个默认值等））。 调用有可能抛出异常的API（一般是库的），都要加 try cache 来打印 log 并处理现场。自己写的就不要抛异常了，只接不抛，否则代码规模一大不好控制。 良好实践经验 / 惯例写法： 每个项目最好都有统一的 .clang_format 文件，时常 format 下。有 clangd 配置文件 也好。 chengxumiaodaren/cpp-learning (github.com)。 你最喜欢的c++编程风格惯用法是什么?_51CTO博客_c++编程惯用法。其中的一些精华总结到下面。 基类/抽象类、派生类 的结构设计尽量按照实际情况，尽量分层次处理，基类/抽象类中列好公共 变量 和 接口/虚函数/纯虚函数 等。 创建和销毁资源务必成对去写。创建资源（类、结构体、数组等）用于承接的指针尽量使用 std::shared_ptr / std::unique_ptr 这种（尤其是 在异常等情况发生时，资源可以自动释放）。 类的析构，实例的删除等等的函数，尽量做到可重复多次调用（因为外部有可能重复调），可用 mIsInit 变量来记录这个类是否初始化成功，类的各个方法开头先判断一下这个。delete 前 先 判断指针 是否不为空，delete 后指针再置空（nullptr）。 推荐 多做/多用 RAII（利用对象生命周期管理资源）风格编码。 如 使用 智能指针。 常用大括号控制生命周期，能提前结束的就可以提前结束。 一些表达式，使用 constexpr 替代 宏，且多用 编译期计算。宏有全局作用域，项目一大易混乱。 可以更多的使用模板元编程。 单例类只用 .h 文件里面 放一个 extern class classType Global\u003cname\u003eInst; 这种方式（在 .cpp 里面去声明 calss classType Global\u003cname\u003eInst;），之后全局调用 Global\u003cname\u003eInst 即可。 细节写法： 编译优化 - OI Wiki (oi-wiki.org)。 函数形参超过三个的，可考虑 使用 struct 打包（后续补充形参也可直接修改这个结构体，比较方便维护），传递参数尽量不用 std::array, std::pair, std::tuple 等这种破坏可动性的东西。 打印 log 的一些规范，有用的 log 优化常用方法： 降频；比较前后数据，有变化时再打印；只打印 error 错误信息，以及关键 info 信息。 比较稳定且不重要的模块尽可能精简，出了问题再加 log 也来的及。 log 描述尽量简化，单词用缩写，函数名不用打全。 TODO：参考 木须 的 编码规范的文档，补充到这里。 环境搭建 / 最佳实践 这里面也是对本文下面各种工具的整理。 TODO 引用 自己的 cmake模板工程仓库目录 GDB / binutils / GCC options ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:0:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"GDB / GDBServer 基本步骤 Debugging With gdb Mini-Tutorial | hacking C++ (hackingcpp.com)。 更丰富各种资料 ARM-Linux-Study/【1 GCC \u0026 GDB \u0026 GDBServer】 at main · Staok/ARM-Linux-Study (github.com)。 对于 gdb 工具，若是单步调试等这种，一般有 VsCode、VS 这种界面工具，对于 GDBServer 则需要 一些单步调试命令。而对于 linux 产生的 coredump，更多是在使用 gdb 的各种信息查看命令。 GDB 常用命令总结： bt 显示调用栈 f \u003cnum\u003e 设置当前处于哪一层栈，再用 info \u003cxxx\u003e 的命令看看信息，常用的：info locals、info args、info frame，然后可以用 print 打印变量、结构体、指针等等 thread apply all bt 显示所有线程在干什么 thread \u003cthread-id\u003e 跳转到对应的线程号，再用 bt 查看调用栈，同上 gdb 查看 coredump gdb {binary} {coredump_file}。指定 sysroot 目录，在 gdb 后添加 -ex \"set sysroot $SYSROOT_PATH\"。 Linux 程序调试，产生 coredump 方法 浅谈 Linux 中的 core dump 分析方法-CSDN博客 Linux内核调试方法总结之coredump - 知乎 (zhihu.com) 需要编译程序 添加调试 -g，将符号表导出到 bin，可供 gdb 查询；可以开发阶段都是用这种编译，最后 release 的时候，可以稍微使用优化比如 -O2，然后去掉 -g 或者 使用 gcc 的 strip 工具给 bin 去掉 符号表。 程序编译时候 -g 会带上函数等符号，使用以上工具可以根据内存地址反查出函数名，若只有内存地址，可以用 gdb 工具 c++ - How to use GDB to find what function a memory address corresponds to - Stack Overflow——在 gdb 工具里面使用 info 系列命令来查看 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:1:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"binutils 工具集 binutils 工具集介绍和使用 GNU开发工具——GNU Binutils快速入门_51CTO博客_GNU Binutils。 包括 addr2line、ar、gprof、nm、objcopy、objdump、ranlib、size、strings、strip。 addr2line 使用详解 在Linux中使用addr2line的参数有哪些 - 问答 - 亿速云 (yisu.com) addr2line使用详解_addr2line命令用法-CSDN博客 调试厉器addr2line-CSDN博客 程序地址、库方法地址、内核模块的地址 一般用法 addr2line -e \u003cbin\u003e -Cfp \u003caddr(0xXXXX)\u003e ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:2:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"GCC 实用选项 gcc 选项-finstrument-functions实现函数调用栈追踪 gcc 选项-finstrument-functions实现函数调用栈追踪-CSDN博客。 gcc 扩展关键字，可多了解和积累 __attribute__： attribute 的详解 - 简书 (jianshu.com) GNU C中不为人知的特色：__attribute__机制-CSDN博客 __attribute__机制介绍-CSDN博客 __attribute__机制介绍_使用-finstrument-CSDN博客 性能 / 内存相关工具 参考：会列出很多工具，选择自己趁手的即可。 一般Linux性能调优都用什么工具？ - 知乎 (zhihu.com)。 C/C++ 编程有哪些值得推荐的工具？ - 知乎 (zhihu.com)。 C++ 怎么检测内存泄露，怎么定位内存泄露？ - 知乎 (zhihu.com)。 大型c++项目在linux下如何调试? - 知乎 (zhihu.com)。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:3:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"Linux 系统常用工具 网络I/O：dstat、tcpdump（推荐）、sar 磁盘I/O：iostat（推荐）、dstat、sar 文件系统空间：df、du 内存容量：free、vmstat（推荐）、sar 进程内存分布：pmap CPU负载：uptime、top CPU使用率：pidstat（推荐）、vmstat、mpstat、top、sar、time 系统调用追踪：strace（推荐） 网络吞吐量：iftop、nethogs、sar 网络延迟：ping 上下文切换：pidstat（推荐）、vmstat、perf 软中断/硬中断：/proc/softirqs、/proc/interrupts 各种工具用处可视化的各种图 Linux Performance (brendangregg.com)。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:4:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"内存统计基本命令 Linux 下查看内存使用情况方法总结 - 知乎 (zhihu.com)。 linux进程VSZ（Virtual Memory Size 虚拟内存）RSS（Resident Set Size 驻留集大小，实际占用的物理内存）PSS、USS、ANON、RESVIRTDirty-CSDN博客。 procrank 查看各进程的 VSS RSS PSS USS 内存占用情况 VSS RSS PSS USS 内存 介绍 VSS/RSS/PSS/USS - 简书 (jianshu.com) procrank -u -R watch -n 1 procrank -u（循环执行） watch -n 1 \"procrank -u | grep \u003cprocess_name\u003e\" ps aux --sort -rss free -h 对 /proc/meminfo 收集到的信息的一个概述 进程的内存使用信息也可以通过 /proc/\u003cpid\u003e/statm 和 /proc/\u003cpid\u003e/status 来查看，但比较抽象，有具体的格式 pmap 命令 如何在 Linux 上使用 pmap 命令_linux pmap使用-CSDN博客 Linux内存管理 – smaps讲解-CSDN博客 [anon] 内存段 系统调用mmap的内核实现分析-腾讯云开发者社区-腾讯云 (tencent.com) 该内存段就是操作系统为mmap系统调用新分配出来的区域。 frame buffer 算，其它的还有可能是 别的系统调用 通过 mmap 读写 驱动文件 产生的 pmap -p -x \u003cpid\u003e 查看某一个进程的内存占用各个文件的信息，-x 以及 -X 和 -XX 选项增加显示信息 pmap -p -x \u003cpid\u003e \u003e /tmp/xxx 写入到文件，再取出到 pc 上，导入到 excel，排序查看，或者用别的方法排下序来看。 循环监视： watch -n 1 \"pmap -p -X $(pidof \u003cprocss_name\u003e)| grep heap\" ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:5:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"动态检查 * 几个主要工具对比 工具 使用命令 是否需要重新编译 Profiling速度 是否支持多线程热点分析 是否支持链接库热点分析 gprof ./test; gprof ./test ./gmon.out 是 慢 否 否 valgrind Valgrind –tool=callgrind ./test 否 非常慢 是 是 gperftools LD_PRELOAD=/usr/lib/libprofiler.so CPUPROFILE=./test.prof ./test 否 快 是 是 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"valgrind 拖慢程序比较严重，不推荐使用了其实。后面的 prof 工具类 和 AddressSanitizer 推荐使用。 可参考： valgrind Introduction | hacking C++ (hackingcpp.com)。 一些使用和调试经验 可以查看程序的堆内存分配情况，包括哪些函数分配了大块内存。 https://www.cnblogs.com/jj-Must-be-sucessful/p/17005792.html 编译和添加环境变量 https://baijiahao.baidu.com/s?id=1652356863601374476\u0026wfr=spider\u0026for=pc 检测内存泄漏 https://blog.csdn.net/asitMJ/article/details/135371794 linux多线程互斥锁程序卡死排查 qt creator 中自带：（在Linux中）需要先安装 Valgrind 并添加环境变量，并测试能用，然后在 qt creator 中实用如下功能启用监控和生成结果（火焰图等）Valgrind Memory Analyzer (External Application) 和 Valgrind Function Profiler (External Application)。 QT-Valgrind内存分析_我不是萧海哇的技术博客_51CTO博客，qt（linux pc）中执行 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:1","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"gperftools gmc: gperf memory check, 内存检查（泄漏，错误等）内存泄漏检测工具 gmp: gperf memory profile, 内存性能分析（哪个函数内存分配多）内存占用分析。内存申请记录（定位到函数）。 gcp: gperf cpu profile, CPU性能分析（函数消耗CPU多）能够通过统计一定时间内各个功能单元（线程、函数等）的执行时间并给出其占用比例。cpu（函数调用 / 火焰图）。 相比与其他性能分析工具，gperftools有Profiling速度快，灵活性较高的优点。 但是配置起来需要安装一堆东西，需要专门用时间进行 学习、细细配置和使用起来。 Gperftools 在 Windows 上提供了 tcmalloc_minimal 的支持，这是一个内存分配器，可以在 Windows 上使用。然而，一些依赖于 Linux 特有功能（如signal.h）的功能（如 ProfilerStart() 和 ProfilerStop() 函数）在 Windows 上不可用‌ 基本使用： 1、以链接动态库的形式链接进程序。 2、也可以不重新编译程序，将库放到机器上，使用 LD_PRELOAD 环境变量指定加载库。 让程序启用，然后 pprof 打印内存申请情况。 使用上，建议不要自己编译 gperftools 生成库来给自己 程序 链接 和 编译，坑很多（大多数人生苦短，若你人生自由有时间，可以多研究多鼓捣），所以建议尽量使用编译好的lib 或者 现成的 package 来用（本文作者截止到 23.10（自己编译 gperftools 源码 然后链接成功，但是 bin 没有跑起来..） 还没有这么做过），推荐探索下（本文作者目前还没有这方面需求所以就没有花时间再深入研究，若日后正式再去用，则会记录成功的普适的步骤并补充到这里）。 参考： gperftools/gperftools: Main gperftools repository (github.com)。 官方文档： TCMALLOC -------- Just link in -ltcmalloc or -ltcmalloc_minimal to get the advantages of tcmalloc -- a replacement for malloc and new. See below for some environment variables you can use with tcmalloc, as well. tcmalloc functionality is available on all systems we've tested; see INSTALL for more details. See README_windows.txt for instructions on using tcmalloc on Windows. when compiling. gcc makes some optimizations assuming it is using its own, built-in malloc; that assumption obviously isn't true with tcmalloc. In practice, we haven't seen any problems with this, but the expected risk is highest for users who register their own malloc hooks with tcmalloc (using gperftools/malloc_hook.h). The risk is lowest for folks who use tcmalloc_minimal (or, of course, who pass in the above flags :-) ). HEAP PROFILER ------------- See docs/heapprofile.html for information about how to use tcmalloc's heap profiler and analyze its output. As a quick-start, do the following after installing this package: 1) Link your executable with -ltcmalloc 2) Run your executable with the HEAPPROFILE environment var set: $ HEAPPROFILE=/tmp/heapprof \u003cpath/to/binary\u003e [binary args] 3) Run pprof to analyze the heap usage $ pprof \u003cpath/to/binary\u003e /tmp/heapprof.0045.heap # run 'ls' to see options $ pprof --gv \u003cpath/to/binary\u003e /tmp/heapprof.0045.heap You can also use LD_PRELOAD to heap-profile an executable that you didn't compile. There are other environment variables, besides HEAPPROFILE, you can set to adjust the heap-profiler behavior; c.f. \"ENVIRONMENT VARIABLES\" below. The heap profiler is available on all unix-based systems we've tested; see INSTALL for more details. It is not currently available on Windows. CPU PROFILER ------------ See docs/cpuprofile.html for information about how to use the CPU profiler and analyze its output. As a quick-start, do the following after installing this package: 1) Link your executable with -lprofiler 2) Run your executable with the CPUPROFILE environment var set: $ CPUPROFILE=/tmp/prof.out \u003cpath/to/binary\u003e [binary args] 3) Run pprof to analyze the CPU usage $ pprof \u003cpath/to/binary\u003e /tmp/prof.out # -pg-like text output $ pprof --gv \u003cpath/to/binary\u003e /tmp/prof.out # really cool graphical output There are other environment variables, besides CPUPROFILE, you can set to adjust the cpu-profiler behavior; cf \"ENVIRONMENT VARIABLES\" below. The CPU profiler is available on all unix-based systems we've tested; see INSTALL for more details. It is not currently available on Windows. NOTE: CPU profiling doesn't work after fork (unless you immediately do an exec()-like call afterwards). Furthermore, if you do fork, and the child calls exit(), it may corrupt the profile data. You can use _exit() to work around this. We hope to have a fix for both problems in the next release of perftools (hopefully perftools 1.2). EVERYTHING IN ONE ----------------- If you want the CPU profiler, heap profiler, and heap leak-checker to all be available for your application, you can do: gcc -o myapp ... -lprofiler -ltcmalloc However, if you have a reason to use the static versions of the library,","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:2","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"gprof / gcc -pg 一种用于分析程序性能的工具，它能够生成函数级别的性能分析报告，帮助开发人员找出程序中的瓶颈和性能问题。gprof 通常与 GNU 编译器集合中的 gcc 配合使用，它通过在程序中插入一些特殊的代码来收集运行时的函数调用信息，然后生成性能分析报告。 gprof可以用来分析系统在运行时各函数调用的次数，耗时等情况，可以方便地帮助我们定位系统的瓶颈，同时也能让我们知道对程序的那个位置就行优化能够带来尽可能大的性能提升。gprof 优化尤其适用于CPU、内存密集性的应用模块。 -p / -pg： gcc 中的一个编译选项，用于在生成的可执行文件中插入性能分析代码，以便进行性能分析和 profiling（性能剖析）。以帮助开发人员了解程序的运行时间分布、函数调用关系以及性能瓶颈，从而指导优化工作。需要注意的是，由于插入了额外的代码，使用 -pg 选项可能会稍微影响程序的执行速度，因此在进行性能分析时需要权衡是否使用该选项。 不适用于 多线程 程序 分析（默认只记录主线程，分析多线程需要一些方法来做到。个人觉得，与其这折腾这个，不如直接用 gperftools 等来做分析） 和 动态链接库 的 分析。 gprof 可以统计出各个函数的调用次数、时间、以及函数调用图。 在编译和链接程序的时候，使用 -pg 选项；执行程序；再 gprof \u003capp\u003e \u003c运行结束后生成的分析结果文件\u003e。 gcc -pg 编译程序 运行程序，程序退出时生成 gmon.out gprof ./prog gmon.out -b 查看输出 可通过gprof -h命令查看可用参数。 性能优化之性能分析工具gprof - 懒人李冰 (lazybing.github.io)。 生成的分析文件 analysis.txt 中有两种形式的分析数据。 Flat Profile 和 Call Graph。都是用于表示 每个函数的 占用时间 和 调用次数等。 程序性能分析工具—gprof-CSDN博客。 由于结果report.txt分析不太直观，可以借助gprof2dot.py与dot工具生成函数调用图 gprof性能分析工具详解-CSDN博客。 注意事项 程序如果不是从main return或exit()退出，则可能不生成gmon.out。 程序如果崩溃，可能不生成gmon.out。 测试发现在虚拟机上运行，可能不生成gmon.out。 一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated。 如果程序运行时间非常短，则gprof可能无效。因为受到启动、初始化、退出等函数运行时间的影响。 程序忽略SIGPROF信号！ ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:3","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"perf 命令行工具，有很多子功能，包含 函数调用 / 火焰图、内存申请记录（定位到函数）、内存泄漏检测 工具。 可以使用命令 生成 text、pdf（火焰图、函数调用关系图） 等形式的展示。 系统性能分析工具–Perf - 知乎 (zhihu.com) 基本使用，基本选项 包罗万象-perf命令介绍 - 知乎 (zhihu.com) 各个命令介绍 生成的 perf.data 可以放到这个可视化网站上看 speedscope perf 的一个可视化工具，也是一个 perf 的 UI 工具（推荐）： KDAB 的 hotspot，linux（带图形界面的）平台运行 .appImage 文件，或者在如 ubuntu 平台安装 hotspot 软件即可用。具体参考官方文档。KDAB/hotspot: The Linux perf GUI for performance analysis. (github.com)。 The main feature of Hotspot is the graphical visualization of a perf.data file. ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:4","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"自实现内存泄露检测工具原理 对 malloc / free 或 new / delete 做 插桩函数 或者 对其重载 来实现。 源自 C++不用工具，如何检测内存泄漏？ - 知乎 (zhihu.com)。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:5","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"ASAN / Address Sanitizer C++ ASAN (Address Sanitizer) Introduction | hacking C++ (hackingcpp.com)。 detects memory corruption bugs memory leaks access to already freed memory access to incorrect stack areas … instruments your code with additional instructions roughly 70% runtime increase roughly 3-fold increase in memory usage 内存检测工具 AddressSanitizer - 简书 (jianshu.com)。 AddressSanitizer 是一个内存检测工具。支持GCC 4.8 及以上。在编译时添加-fsanitize=address选项，如果为了得到更全面的信息可以用-fno-omit-frame-pointer。 该工具为gcc自带，4.8以上版本都可以使用，支持Linux、OS、Android等多种平台，不止可以检测内存泄漏，它其实是一个内存错误检测工具，可以检测的问题有： 内存泄漏 堆栈和全局内存越界访问 free后继续使用 局部内存被外层使用 Initialization order bugs 具体文档 AddressSanitizer · google/sanitizers Wiki (github.com)。 更多详情： 内存错误检测工具-AddressSanitizer（ASAN）_asan安装-CSDN博客。 Valgrind 其会极大的降低程序运行速度，大约降低10倍，而 AddressSanitizer 大约只降低2倍！ 深入理解Asan：内存错误检测工具与实践-CSDN博客。 关于 ASAN - 知乎 (zhihu.com)。 ASAN 问题总结-CSDN博客。 KASan介绍-CSDN博客。 C++(Qt)软件调试—GCC编译参数学习-程序检测（13）_gcc 编译-fsanitize=address-CSDN博客。 AddressSanitizer（ASan）是一种用于检测和调试内存错误的工具。它是由Google开发的，并内置于GNU编译器套件（GCC）和LLVM编译器中。 释放后使用（野指针） 堆缓冲区溢出 栈缓冲区溢出 全局缓冲区溢出 返回局部堆区地址后使用（经过测试没检测出来） 作用域外使用栈内存 初始化顺序错误（经过测试未检测出来） 内存泄漏 使用： 首先说结论：对于 linux，则 gcc 和 clang 均可（注意版本）。对于 win，则 则 mingw-w64 没有带 ASAN 库，所以 win 上只能用 clang（而且还是特定的出包，比如 MSYS2 的 clang 包可以用 ASAN） 来使用 ASAN。 先碎碎念一波，各种查找信息和试验搞了半天，这里记录下：mingw 版本的 gcc 没有集成 ASAN 这个库，c++ - MinGW-w64’s gcc and Address Sanitizer - Stack Overflow，并且 mingw 官网也说 win 上没有支持 ASAN Contribute - MinGW-w64。而 MSYS2 （使用其里面的 clang 工具链）是有的，如果你想使用 MSYS2 就可以配置环境直接用其工具链上手。要是非要用 mingw 环境，则要试着 自己编译 ASAN 库来使用，自己动手编译asan库 - 知乎 (zhihu.com)，或者自己编 asan 源码 AddressSanitizerHowToBuild · google/sanitizers Wiki (github.com)，自己编这个，这些我都暂没有在 win 上试成功，不推荐轻易尝试，MSYS2 和 Cygwin 等已经提供了比较好用的环境，自己编译的话用于研究和学习可以，但这个学习的路径比较陡峭所以不推荐轻易尝试，学习途径有很多（自己搭建开发环境，可以参考 TODO 放自己 cmake 模板工程 仓库），凡事讲究成本。 clang 在 win 上是支持 ASAN 的 AddressSanitizerWindowsPort · google/sanitizers Wiki (github.com)。clang 官方也说 AddressSanitizer 支持 win 但是 支持不太好 AddressSanitizer — Clang 20.0.0git documentation (llvm.org)。自己本地 win 上这种情况就可以换用 clang 编一编来跑一跑（编出来也是用于测试的，而非正式环境用），又发现，还需要依赖 compiler-rt 这个工具。这个 compiler-rt 可以用 MSYS2 安装。。折腾了一圈，还是拥抱 MSYS2 吧，用这个来管理所有编译相关工具链吧。。话又说回来，AddressSanitizer 在 win 上支持并不好，所以 win 上还是换用其它工具吧 比如 DrMemory（专用于 win 的），在 linux 下就可以愉快的使用 AddressSanitizer（gcc 和 clang 均可）。 win 上使用 ASAN 路径： MSYS2 安装指引 MSYS2 MSYS2-Installation - MSYS2 更新最新库，使用命令 pacman -Syuu 在 MSYS2 里的 CLANG64 环境下，执行：来安装 clang 工具链，以及 compiler-rt 库。 pacman -S mingw-w64-clang-x86_64-clang pacman -S mingw-w64-clang-x86_64-compiler-rt 在 MSYS2 目录下 .\\clang64\\bin 目录下可以搜索 ASAN 找到相应的库（不容易啊终于找到个win上能用的） 使用 clang/clang++ 就可以使用 ASAN 了（在mingw-w64 工具链的目录下就没有，是 MSYS2 也没有编译这个库） 把 MSYS2 目录下的 .\\clang64\\bin 目录添加到环境变量。 一个例子：使用 MSYS2 目录下的 .\\clang64\\bin 里面的 clang++ 来编译下面的程序例子，就有 ASAN 的检测和打印了。后续就可以方便的集成到 cmake 等工程里面，给自己工程定义个 DEBUG 模式，在该模式下使用选项 -fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer -g 等。 #include \u003ccstdint\u003e#include \u003ciostream\u003e /* env: 对于 linux，则 gcc 和 clang 均可，gcc 的信息如下。对于 win，则 mingw-w64 没有带 ASAN 库，所以 win 上只能用 clang 来使用 ASAN gcc/g++ -v: Target: x86_64-linux-gnu gcc/g++ -- version: gxx (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0 compile: clang++/g++ -fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer -g -O1 ./main.cpp -o main.exe run: ./main.exe */ int main(int argc, char* argv[]) { (void)argc; (void)argv; std::cout \u003c\u003c \" --- begin\" \u003c\u003c std::endl; int32_t* int_ptr; int_ptr = new int32_t(0); delete int_ptr; // int_ptr = nullptr; *int_ptr = 10; // int32_t num = *int_ptr; // std::cout \u003c\u003c \" --- *int_ptr: \" \u003c\u003c *int_ptr \u003c\u003c std::endl; std::cout \u003c\u003c \" --- end\" \u003c\u003c std::endl; } Undefined Behavior Sanitizer C++ UBSAN (Undefined Behavior Sanitizer) Introduction | hacking C++ (hackingcpp.com)。 detects many types of undefined behavior at runtime dereferencing null pointers reading from misaligned pointers integer overflow division by zero … instruments your code with additional instructions: runtime increase in debug build~25% -fsanitize=undefined：使用 UndefinedBehaviorSanitizer（UBSan）工具，它可以检测代码中的未定义行为，如空指针解引用、数组越界、变量溢出、除0 等等。 -fs","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:6","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"专用于 win 的工具 这里会罗列各种可能的方法，很多本文作者并没有试过。正如 unix 一个设计哲学——“提供机制，而不是提供策略”（实际采用的策略是因场景、需求选取使用一些机制来组合使用）。 一个综合贴：[QT编程系列-43]: Windows + QT软件内存泄露的检测方法_qt 内存泄露排查手段-CSDN博客。 2.1 内存监测工具 -Valgrind 2.2.1 Valgrind for Linux 2.2.2 Valgrind for Windows 2.2 内存监测工具-Dr. Memory 2.3 内存监测工具-Visual Leak Detector 2.4 内存监测工具-WinDbg 2.5 Windows进程内存监控工具——任务管理器 2.6 Windowx线程内存 监控工具——Windows性能工具集（Windows Performance Toolkit）——xperf 命令行工具 2.7 API函数获取线程级内存使用情况——Windows API中的GetProcessMemoryInfo函数 2.8 Windows性能监控——性能监视器 补充： Windows Sysinternals Suite DrMemory Home (drmemory.org)。下载后，drmemory 的 bin 目录添加环境变量，即可 shell 中运行 drmemory -version。 参考： Running Dr. Memory (drmemory.org)。 Dr. Memory 使用 - 简书 (jianshu.com)。 本地编译，使用 MinGW，用于 DrMemory g++ .\\main.cpp -g -static-libgcc -static-libstdc++ -ggdb -o main.exe 执行（但是没有一次正常过，试过各种选项） drmemory.exe -- .\\main.exe Visual Leak Detector 内存泄漏检测（win 上） 内存泄露检测工具VLD(Visual Leak Detector)使用说明-CSDN博客 Qt / MSVC 中使用内存泄露检测工具 VLD(Visual Leak Detector)_qt内存泄漏检测工具-CSDN博客 WinDbg Application Verifier 配置太复杂了..若长期专门开发 win 程序可以用 Windows Performance Toolkit Windows Sysinternals Suite Sysinternals Suite - Sysinternals | Microsoft Learn。 微软工具包Windows Sysinternals Suite简介-CSDN博客。 Sysinternals Suite免费的Windows系统工具集（系统管理良兵利器） - 知乎 (zhihu.com)。 Windows API Windows API 中的 GetProcessMemoryInfo 函数 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:6:7","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"静态检查 * 使用静态代码分析工具，来检测潜在的内存泄漏、不安全的内存操作，以及其它不合规范 等问题。这些工具可以帮助你发现代码中的潜在问题，提升程序健壮性，也可针对性减少内存占用。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:7:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"cppcheck 安装 bin 到系统并添加到环境变量后，VsCode 安装 cpp-check-lint 插件即可，可以对插件做进一步配置。 Cppcheck - A tool for static C/C++ code analysis。 vscode中嵌入cppcheck进行静态检查，包含插件使用方法_cppcheck集成到vscode-CSDN博客。设置插件，也可以通过 VsCode 可视化操作而不必直接修改 setting 的 json 文件。这个因人习惯而异吧。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:7:1","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"clangd / clang-tidy clangd clangd 提供的 LSP 服务 给 VsCode 日常开发的 跳转、补全 等用，见 cmake 模板工程 仓库（暂没有上）的具体使用。 clang-tidy clang-tidy拥有多种内置检查器，可用于检测性能问题、代码规范、可能的程序错误、可移植性问题等。此外，它允许用户自定义规则，可以非常灵活地适应不同的编程规范和需求。 Clang-Tidy — Extra Clang Tools documentation (llvm.org) 其中包含了 Clang Static Analyzer，以及更多检查项。 clang-tidy - Clang-Tidy Checks — Extra Clang Tools 20.0.0git documentation (llvm.org) 支持的检查类型。 clang-tidy 大致分类： boost 检测boost库API使用问题 cert 检测CERT的代码规范 cpp-core-guidelines 检测是否违反cpp-core-guidelines google 检测是否违反google code style llvm 检测是否违反llvm code style readability 检测代码上相关问题，但又不明确属于任何代码规范的 misc 其它一些零碎的check mpi 检测MPI API问题 modernize 把C++03代码转换成C++11代码，使用C++11新特性 performance 检测performance相关问题 clang-tidy 检查项各项更详细的说明：使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例_clang-tidy cmake-CSDN博客 开源C++静态代码检测工具clang-tidy、cppcheck和oclint的比较_clang-tidy cppcheck-CSDN博客。 这是 clang-tidy 介绍 和 命令行的使用，一般更好的使用方法是与 IDE 结合，比如 VsCode。 30.静态代码分析工具clang-tidy-CSDN博客。c++静态代码扫描工具clang-tidy详细介绍-CSDN博客。 vscode配置clang-tidy插件_vscode clang-tidy-CSDN博客。 实测发现，clang-tidy 有一些基础的问题查不出来，比如数组越界，等等（或许也是我配置有问题？）。这种意义上，cppcheck 还是 好用些。 关于 clangd、clang-tidy 的配置文件，可参考 TODO 放自己 cmake 模板工程 仓库。 scan-build scan-build是一个命令行工具，用于在编译时调用Clang静态分析器来分析C/C++代码。它的主要用途是识别程序中可能导致bug的构造。 scan-build在编译过程中拦截编译器的调用，插入静态分析过程。它会生成一份包含潜在错误和警告的报告，并可以通过生成的HTML报告详细查看问题所在及上下文。 scan-build通常在命令行环境中使用，可以轻松地与持续集成系统集成，作为项目构建过程的一部分自动运行。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:7:2","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"编译时提示 综合 C++ Diagnostic Basics: Warnings, Assertions, Testing | hacking C++ (hackingcpp.com)。 使用-Wall、-Wextra等标志打开所有警告。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:7:3","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"大型静态检查软件 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:8:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"SonarQube + sonar-cxx * 社区开源的。可以和 jenkins 结合。 SonarQube C++ 社区插件安装与配置指南-CSDN博客。 SonarQube 安装及使用 | Server 运维论坛 (learnku.com)。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:8:1","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"Black Duck / Coverity 商业级静态扫描服务，收费的。 SAST - 静态代码分析工具 | Black Duck。Coverity 静态分析软件 | Black Duck。 Black Duck 软件组件分析 (SCA) | Black Duck。帮助团队管理在应用和容器中使用开源和第三方代码所带来的安全、质量和许可证合规性风险。 Coverity 代码静态安全扫描工具 ： 认识Coverity-CSDN博客。 内存占用优化相关 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:8:2","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"初步检查 如果对程序熟悉，针对性的对占内存的地方 进行优化。 使用 上述 内存统计命令和工具，检查。 看大头： 最小工程放到机器上看内存占用，和正式的进程进行比较 一般 [heap]、[anon]、各种库、字体等 占了该进程的主要内存大头 程序中按各块功能逐个开启，看内存。 UI界面，逐个页面加载看内存增长变化。 看细节： 比如 perf mem 等工具分析每个函数申请内存的情况，找出大头。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:9:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"基本优化 这里以 qt 程序的内存占用优化为例。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:10:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"库编译精简 编译器选项：使用适当的编译器选项，例如优化标志，以提高生成的代码的效率和内存使用。 调试相关的有 -g -ggdb，优化相关的有 -O0 -O1 -O2 -Os，工程上经验建议最高允许也常常开到 -O2。 比如 qt库 有一些精简编译的选项可以用。 在 buildroot 的 qt 选项里面 添加 Custom configuration options，看 package 里面 qt 文件夹 里面的 .in 和 .mk 文件可见，最终传递给 buildroot/output/\u003cboard\u003e/build/qt5base-5.xx.x 下面的 configure（通过 ./configure -help 查看 所有配置选项） 添加选项 -optimize-size -release -strip -reduce-exports。 主要的核心库 libQt5Core.so.5.12.2 4.89MB libQt5Gui.so.5.12.2 3.71MB libQt5Widgets.so.5.12.2 5.64MB libQt5Qml.so.5.12.2 libQt5Quick.so.5.12.2 5.64MB libQt5Network.so.5.12.2 1.46MB libQt5VirtualKeyboard.so.5.12.2 qt 库 重编（这里是基于 buildroot 编译框架 来 编译 qt package） make qt5base-dirclean \u0026\u0026 make qt5base-configure \u0026\u0026 make qt5base ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:10:1","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"针对项 程序的内存优化。 UI 页面不缓存（但是 UI 理论上相对会变卡顿，具体看芯片性能）。精简 UI 页面。限制显示元素。 图片尽量不变形，图片变形会拷贝图片导致内存暴增（Qt）。批量显示图片的地方可以设置图片不缓存。 字体。 这里是针对性缩减字体文件的，如果 flash 或者 ram 充裕 则不推荐这么做，为了未来的可能出现的各种文本的正常显示，留一定较广泛的兼容性较好。 使用 fontcreator 挑出所用文字，缩小字体库，需要手动增减文字，对于后面增加文案来说不友好 https://blog.csdn.net/xiaohui_brook/article/details/51909612；一个提取给出文本中所有单独文字工具 https://gitee.com/Polarix/MinimumFontLib。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:10:2","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"chatGPT 给出 内存优化 基本经验 以下 chatGPT 给出。 Qt是一个流行的C++应用程序开发框架，可以用于创建跨平台的图形用户界面应用程序。要降低Qt应用程序的内存使用，可以考虑以下方法： 1.使用动态分配内存：避免在堆栈上创建大型对象，而是使用堆上的动态内存分配。使用new和delete或者更好的智能指针来管理对象的生命周期。 2.资源管理：确保及时释放不再需要的资源，如图像、字体、音频等。Qt提供了QResource类来管理应用程序的资源，确保在不需要时卸载它们。 3.使用精简的数据结构：选择最适合你的数据的数据结构。有时候，使用QVector比QList更高效，或者使用QHash而不是QMap，具体取决于你的需求。 4.避免不必要的复制：使用const引用来传递参数，以避免复制大型对象。使用move语义来移动对象，而不是复制它们。 5.使用局部变量：在可能的情况下，使用局部变量而不是全局变量或类成员变量。局部变量在超出其作用域后会自动释放内存。 6.定期清理内存：如果你的应用程序长时间运行，确保定期清理不再使用的内存。Qt的内存管理通常是自动的，但你可以显式地调用QCoreApplication::sendPostedEvents()来处理未处理的事件，这可以释放不再需要的内存。 7.使用Qt的容器类：Qt提供了一系列高效的容器类，如QList、QVector和QMap。使用这些容器类可以减少内存分配和释放的开销。 8.避免内存泄漏：定期检查应用程序以确保没有内存泄漏。你可以使用工具如Valgrind或Qt的内存分析工具来检测内存泄漏。 9.优化图形资源：如果你的应用程序涉及大量图形资源，确保这些资源被合理地加载和释放。使用Qt的图像和绘图类，如QImage和QPainter，来管理图形资源。 10.使用虚函数：如果你使用Qt中的继承体系，请合理使用虚函数。这可以减少对象的内存占用，并允许更高效的动态多态性。 11.精简Qt模块：如果你只需要Qt的特定功能，可以考虑只包含所需的模块，而不是整个Qt框架。这可以减小应用程序的二进制文件大小和内存占用。 12.使用Qt的资源系统：Qt的资源系统允许你将资源文件嵌入到二进制文件中，而不是在磁盘上存储它们，从而减少内存占用。 要降低Qt应用程序的内存使用，最重要的是了解你的应用程序的需求，以便选择合适的数据结构和内存管理策略，并进行适当的优化。 如果你的Qt程序已经开发完成，但你仍然想优化内存使用并减少不必要的模块占用内存，可以考虑以下方法： 1.静态分析工具：使用静态代码分析工具，如Clang Static Analyzer或Cppcheck，来检测潜在的内存泄漏、不安全的内存操作和其他潜在问题。这些工具可以帮助你发现代码中的潜在问题，从而减少内存占用。 2.动态分析工具：使用动态分析工具，如Valgrind（在Linux中）或Application Verifier（在Windows中），来检测运行时的内存错误和泄漏。这些工具可以帮助你找出程序中的内存问题，以便进行修复。 3.使用更轻量的替代品：如果你发现Qt模块占用了大量内存，考虑是否可以用更轻量的替代品替代它们。有时候，自定义的轻量级库可能比Qt更适合特定的任务，从而减少内存占用。 4.延迟加载模块：如果你的应用程序使用了多个Qt模块，但不是所有模块都在启动时立即需要，可以考虑延迟加载这些模块。这意味着只有在需要时才加载它们，而不是一开始就加载所有模块。 5.优化资源加载：如果你的应用程序使用大量图像、字体或其他资源，确保资源加载是延迟的，只在需要时加载，然后在不再需要时及时释放。 6.使用轻量级控件：如果你使用Qt的GUI模块，考虑使用轻量级的控件替代重型的控件。例如，可以使用QLabel替代QWebView来显示简单的HTML内容。 7.精简依赖项：如果你使用了第三方库或模块，确保只包括你实际需要的部分，避免引入不必要的依赖项。 8.内存池：实现自定义的内存池，以便更有效地分配和管理内存。这可以减少内存碎片和提高内存使用效率。 9.代码优化：审查代码并寻找可以优化的部分，例如减少不必要的对象复制、避免过度使用虚函数等。优化代码可能需要对性能和内存占用进行权衡。 10.使用Qt的资源系统：将应用程序中的资源文件合并到Qt的资源系统中，以减少磁盘上的文件访问，并降低内存占用。 11.动态链接：如果你的应用程序使用了大量的Qt模块，可以考虑将Qt库动态链接，以减小可执行文件的大小，因为它不会包含Qt库的副本。 12.编译器选项：使用适当的编译器选项，例如优化标志，以提高生成的代码的效率和内存使用。 在进行这些优化时，确保进行充分的测试，以确保你没有引入新的问题或破坏了应用程序的功能。内存优化通常需要权衡性能和内存使用，因此需要根据具体情况仔细评估每个优化步骤的效果。 程序中指针、抛异常地方检查 查看 bin 结构 / size 优化相关 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:11:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"elf 解析 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:12:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"查看各段 # 使用 readelf -S \u003cbin\u003e 查看段 # 使用 readelf -h 来查看用法 readelf -S \u003cbin\u003e # 也可以使用 objdump -x \u003cbin\u003e，注意要使用 bin 对应的编译器的 objdump objdump -x \u003cbin\u003e # 把段的原始二进制内容拷出来 objcopy --only-section=.rodata \u003cbin\u003e \u003coutput_file\u003e # 使用 strings 查看 \u003coutput_file\u003e 里面的字符串成分 strings \u003coutput_file\u003e \u003e \u003coutput_strings_file\u003e objdump命令的常见用法-CSDN博客。 基于GCC的工具objdump实现反汇编-CSDN博客。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:12:1","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"查看对象和函数 查看程序内各个对象和函数的大小并排序 readelf -s -W \u003cbin\u003e \u003e symbols.txt awk 'NR \u003e 5 {print $3, $4, $8}' symbols.txt | sort -nr \u003e temp1.txt 第一行的输出例子： Symbol table '.dynsym' contains 1917 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND __aeabi_unwind_cpp_pr1@GCC_3.5 (3) 2: 00000000 0 TLS GLOBAL DEFAULT UND _ZSt15__once_callable 3: 00000000 0 OBJECT GLOBAL DEFAULT UND _ZTISt12system_error 4: 00000000 0 NOTYPE WEAK DEFAULT UND _ZTHN6BGuiFe13ThreadPoolE 把第一行的输出喂给 AI工具来生成，指引其对这段输出进行排序，生成上面第二段命令，执行则排序并输出到 temp1.txt 文件里面 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:12:2","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"size 优化的点备忘 针对一些占 size 大头 的 东西 图片：使用优化工具，减 size；并且尽量使用 编码的数据，如直接存储文件，而不要存储图片数据数组（会膨胀很多，至少 5 倍以上）；可以的话还可以压缩处理。 以及其它素材文件。 库：编译的时候可以去掉一些选项，不编译一些组件，缩减库。 依照上面 readelf 读出的程序内各个对象和函数的大小，再针对大的项，进行缩减。 加 根据不同产品区分的 功能宏，不编译 不必要的部分。 ","date":"2024-12-22","objectID":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/:13:0","tags":["C++"],"title":"编程经验、调试、性能和内存检查工具集合","uri":"/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C%E8%B0%83%E8%AF%95%E6%80%A7%E8%83%BD%E5%92%8C%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"},{"categories":["EE-CS-Study"],"content":"C / C++ 实用库备查","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C / C++实用库备查 网络参考源： Your list / 实用库 / EE-CS (github.com)。 你工作中最推荐的 C/C++ 程序库有哪些，为什么？ - 知乎 (zhihu.com)。可以不时的更新收录到下面。 可以使用 C++ 的哪些库或函数来简化任务？ - 知乎 (zhihu.com)。可以不时的更新收录到下面。 开源 C++ 库列表 - cppreference.com。这里面有一些比较老的，有些经典的。 fffaraz/awesome-cpp: A curated list of awesome C++ (or C) frameworks, libraries, resources, and shiny things. Inspired by awesome-… stuff. (github.com)。超多，可以时不时看一看，更新收录到下面。 不容错过的 13 个顶级 C++ 程序库_c++库-CSDN博客。 分享给大家的c++常用库，建议收藏！ (baidu.com)。 以下是自总结的平时用到的、好用的库和一些网络上推荐的库的集合。基本上，每个领域只推荐一个 或 两个 相关领域 最常用的、最主流的。排序不分先后。 下面会尽量挑选协议商用友好的库，基本可以直接拿来用的那种，但是可能不是所有库都是，所以要注意下所用库的协议。 欢迎在原文 github / gitee 仓库 提 issue 指出错误，和 提 PR 来一同建设内容。 每个库会尽量有这几个部分：自写的一段话简介（库所提供的基础能力概括）、项目网址（官网 或者 github 仓库网址 等）、网友写的一些比较好的入门教程、win 以及 linux 上的安装（保证方法具有普适性，必能跑通）、几段使用例子（由简单到复杂，是自己本地跑起来的自写的例子，以及指明官方提供的较系统的 demo 所在）。 TODO：以下还缺少 ui、cv、ml 领域相关的库，好用的基本上也达成共识了，ui 框架的库可以看自己 git 收藏里面的；cv的 openCV 等等 看看还有什么；ml 的 无非 pytorch、tf、keras 等（这些有 C++ 接口，但最好还是 python 来开发） ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:0:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Misc 这里的几个库是综合性的，内涵丰富，但也比较重型，按需。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"glibc 即 GNU C Library，Linux 的标准 c 库（直接使用并编译，不用附带加载库），Linux 下原来的 标准 c 库 libc 逐渐不再被维护。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"boost c++ Boost C++ Libraries The Boost C++ Libraries (theboostcpplibraries.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"introduce_c-cpp_manual 本repo搜集全网适合C/C++新手学习的入门项目，整理收纳开发者开源的小项目、工具、框架、游戏等，帮助大家更好地学习c/c++。 0voice/introduce_c-cpp_manual: 一个收集C/C++新手学习的入门项目，整理收纳开发者开源的小项目、工具、框架、游戏等，视频，书籍，面试题/算法题，技术文章。 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"GLib GLib is the low-level core library that forms the basis for projects such as GTK and GNOME. It provides data structure handling for C, portability wrappers, and interfaces for such runtime functionality as an event loop, threads, dynamic loading, and an object system. GNOME/glib: Read-only mirror of https://gitlab.gnome.org/GNOME/glib (github.com) glib是GTK+的基础库，综合用途的实用的轻量级的C程序库 glib 相关，源码中有 docs 手册 GLib包含了字符串操作、文件操作、数据校验、编解码、字符集转换、随机数生成器、命令行解析器、xml解析器、正则表达式、单链表、双链表、 数组、指针数组、双端队列、哈希表、平衡二叉树、N维树、泛型、主循环、多线程、线程池、异步队列、内存分配、内存片段、错误系统、测试框架等等一系列功能，称得上是C语言开发人员的军刀，值得研究。 功能罗列 GLib2.0的一百个小知识点 - 知乎 (zhihu.com) 目录说明 1_02_GLib库入门与实践_GLib库源代码目录结构简介_glib-2.0 库源码-CSDN博客 系列文章 GLib库入门与实践_field1003的博客-CSDN博客 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:4","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"dlib Dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real world problems. See http://dlib.net for the main project documentation and API reference. davisking/dlib: A toolkit for making real world machine learning and data analysis applications in C++ (github.com) 推荐开源库：DLib - 解决C++编程中常见任务的实用工具集-CSDN博客。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:5","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"cpp-tbox C++ Treasure Box is a service-oriented development framework and component library based on the Reactor model, aim at make C++ development easy. cpp-main/cpp-tbox: A complete Linux application software development tool library and runtime framework, aim at make C++ development easy. (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:6","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"ffead-cpp ffead-cpp is a web-framework, application framework, utilities all bundled into one. It also provides an embedded HTTP/Web-Socket compliant high-performance server core. It is a collection of modules all geared towards performing individual roles which together form the cohesive back-bone of ffead-cpp. It provides a very simple to use and maintain web-framework library with advanced features like Reflection, Dependency Injection (IOC), Inbuilt REST/SOAP support, Security/Authentication features. Moreover implementation for interfacing to caching tools like Memcached/Redis are provided in-built. Database integration/ORM framework (SDORM) solves all major issues with respect to interfacing with SQL/No-SQL database alike. Multi-level serialization or template level serialization is a high point of ffead-cpp core serialization run-time. Any C++ POCO class can be marked as serializable and the run-time will take care of marshalling/un-marshalling the object to its intended serializable form and back(JSON/XML/BINARY). ffead-cpp can be easily driven by XML configuration, Services/Controllers/Filters/Interfaces/API(s) are all simple POCO classes without any need for them to extend any classes. The differentiating feature in ffead-cpp is the usage/implementation/support for markers (Annotations in java). Simple #pragma directives can now be used to drive the entire configuration in ffead-cpp, so you can just forget XML configuration. All in all ffead-cpp is the gap in the world of C++ web application or enterprise application development which I have tried to fill with my humble/honest effort. sumeetchhetri/ffead-cpp: Framework for Enterprise Application Development in c++, HTTP1/HTTP2/HTTP3 compliant, Supports multiple server backends (github.com) 企业应用程序开发框架，综合多种功能。github 仍在更新。这是一个 C++ 的 Web 框架，C++ 应用程序框架，C++ 的 REST 框架和 C++ 的 SOAP 框架，这些框架都内置其中。它包含 Linux/Windows（通过 Cygwin）的实现。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:7","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"KDUtils A set of C++ helpers and wrappers around the C++ standard library 内涵三个库： KDFoundation KDGui KDUtils MIT 协议的，可商用，但要遵守协议的一些要求。Where is the doc link? And is this lib free for commercial use or? · Issue #53 · KDAB/KDUtils (github.com)。 KDAB/KDUtils: A set of C++ helpers and wrappers around the C++ standard library (github.com)。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:8","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Misc JUCE：专注音频开发 LibU：C语言写的多平台工具库，可以看看。github 不怎么更新了 libPhenom：Facebook发布的C语言事件框架，用于构建高性能和高可扩展的系统。支持多线程、提供内存管理和常用数据结构，2019年停止维护，可以看看代码实现。替代品 folly。 LibSourcey：LGPL-2.1+，用于实时的视频流和高性能网络应用程序的C++11 evented IO，视作 libuv, FFmpeg, OpenCV and WebRTC 结合体。github 不怎么更新了 Ultimate++：C++跨平台快速应用程序开发框架，框架应该比较大，是个新领域，看需求吧 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:1:9","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Parallel / Async ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"parallel lib comparison table 这里需要再多一些信息来区分这些库 几个库的使用场景（使用 gpt） oneTBB 适合大规模并行计算和高效利用多核处理器的场景。 workflow 适合需要并行计算和异步网络处理的复杂应用，尤其在分布式和高性能环境中。 workspace 更加适用于轻量级异步任务调度和并发执行，尤其在需要精细控制优先级和任务管理时。 taskflow 适合高效的任务调度系统，特别是有异构计算需求的场景（例如同时使用 CPU 和 GPU）。 Asio 则专注于网络和 I/O 密集型任务，尤其是需要处理大量并发连接的应用。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"oneTBB oneAPI Threading Building Blocks (oneTBB) uxlfoundation/oneTBB: oneAPI Threading Building Blocks (oneTBB) (github.com) Intel Threading Building Blocks 之 并行循环_intel threading building blocks在哪里下载-CSDN博客 SSE_TBB加速编程_Belial_2010的博客-CSDN博客 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"workflow C++ Parallel Computing and Asynchronous Networking Framework sogou/workflow: C++ Parallel Computing and Asynchronous Networking Framework (github.com) workflow这个C++开源项目值得学习 - 知乎 (zhihu.com)。 workflow开源项目学习心得 - 知乎 (zhihu.com)。 开源项目Workflow中有一个非常重要的基础模块，代码仅300行的C语言线程池。 一个逻辑完备的线程池 - 知乎 (zhihu.com)。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"workspace * workspace是基于C++11的轻量级异步执行框架，支持：通用任务异步并发执行、优先级任务调度、自适应动态线程池、高效静态线程池、异常处理机制等。 CodingHanYa/workspace: workspace是基于C++11的轻量级异步执行框架，支持：通用任务异步并发执行、优先级任务调度、自适应动态线程池、高效静态线程池、异常处理机制等。 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:4","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"taskflow * A General-purpose Task-parallel Programming System using Modern C++ Taskflow helps you quickly write parallel and heterogeneous task programs in modern C++ taskflow/taskflow: A General-purpose Task-parallel Programming System using Modern C++ (github.com) Taskflow: A General-purpose Task-parallel Programming System。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:5","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Asio * Asio C++ Library Asio is a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach. chriskohlhoff/asio: Asio C++ Library (github.com) Folly.ThreadPoolExecutor folly/folly/executors/ThreadPoolExecutor.h at main · facebook/folly (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:6","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"ThreadPool * A simple C++11 Thread Pool implementation progschj/ThreadPool: A simple C++11 Thread Pool implementation (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:7","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"dpool 使用 C++11 实现的动态线程池，主要特性： 使用简单，不易出错。 支持线程复用，提升性能。 支持懒惰创建线程。 必要时自动回收空闲的线程。 senlinzhan/dpool: 使用 C++11 实现的动态线程池 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:8","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"CThreadPool CThreadPool 是一个跨平台的、无任何三方依赖的、高性能的C++11（含以上版本）版本的线程池，也是 CGraph 项目中使用的跨平台线程池组件功能的最小集。 经过CGraph和关联项目的长期迭代和验证，功能已经趋于稳定，且性能优异。因为咨询相关内容的朋友较多，故做为独立的仓库提供出来，方便大家使用。 由于是CGraph项目中的剥离出来的功能类，故在项目中保留了多处 CGRAPH_* 的命名方式，仅将 namespace 修改为 CTP，预计今后与CGraph相互独立更新。 本项目参考了《C++并发编程实战（第二版）》 中的部分内容，和github上的一些优秀实现。并在此基础上进行大量的改动、扩展和优化，在功能、性能和易用性上均有较大的提升。 ChunelFeng/CThreadPool: 【A simple used C++ threadpool】一个简单好用，性能优异的，跨平台的C++线程池。欢迎 star \u0026 fork (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:9","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"minicoro * Minicoro is single-file library for using asymmetric coroutines in C. The API is inspired by Lua coroutines but with C use in mind. The project is being developed mainly to be a coroutine backend for the Nelua programming language. edubart/minicoro: Single header stackful cross-platform coroutine library in pure C. (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:2:10","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Event ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:3:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"libsigc++ libsigc++ (a.k.a. libsigcplusplus) implements a typesafe callback system for standard C++. It allows you to define signals and to connect those signals to any callback function, either global or a member function, regardless of whether it is static or virtual. libsigc++ is used by gtkmm to wrap the GTK signal system. It does not depend on GTK or gtkmm. sigc++-2.0 and sigc++-3.0 are different parallel-installable ABIs. This file describes sigc++-3.0. libsigcplusplus/libsigcplusplus: libsigc++ implements a typesafe callback system for standard C++. It allows you to define signals and to connect those signals to any callback function, either global or a member function, regardless of whether it is static or virtual. (github.com) 官方手册 libsigc++: libsigc++ Reference Manual (libsigcplusplus.github.io)。 Unix/C++–信号与槽机制的理解_c++ libsigcplusplus库-CSDN博客 各种信号槽库的介绍 信号槽库：sigslot.h和sigc++使用 - DoubleLi - 博客园 (cnblogs.com) 好用而且也是业界推荐的，但是比较重的一个库。个人觉得可用下面 KDBindings 替代。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:3:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"KDBindings * Reactive programming \u0026 data binding in C++ From plain C++ you get: Signals + Slots. Properties templated on the contained type. Property bindings allowing reactive code to be written without having to do all the low-level, error prone plumbing by hand. Lazy evaluation of property bindings. No more broken bindings. Totally stand-alone “header-only” library. No heavy Qt dependency. Can still be used with Qt if you so wish. KDAB/KDBindings: Reactive programming \u0026 data binding in C++ (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:3:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Libevent libevent The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts. libevent is meant to replace the event loop found in event driven network servers. An application just needs to call event_dispatch() and then add or remove events dynamically without having to change the event loop. libevent/libevent: Event notification library (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:3:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"inotify-cpp Inotify-cpp is a C++ wrapper for linux inotify. It lets you watch for filesystem events on your filesystem tree. The following usage example shows the implementation of a simple filesystem event watcher for the commandline. erikzenker/inotify-cpp: A C++ interface for linux inotify (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:3:4","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Web / Net / Async ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"curl libcurl is the library curl is using to do its job. It is readily available to be used by your software. Read the libcurl manpage to learn how. curl/curl: A command line tool and library for transferring data with URL syntax, supporting DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS. libcurl offers a myriad of powerful features (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"async lib comparison table 对比表（GPT生成） 特性 glib libuv libevent libev libhv 开源协议 LGPL-2.1-or-later MIT 3-clause BSD BSD BSD 3-Clause 主要用途 全功能框架，适合 GUI 和服务程序。 提供了事件循环的支持，核心模块是 GMainLoop 和 GSource。 集成了多种高级工具：线程池、数据结构（如动态数组、链表、哈希表等）、消息队列和日志系统。 可与 GTK+ 完美结合，用于 GUI 应用的事件处理。 跨平台异步 IO 和事件驱动。 支持事件循环（基于多种底层实现，如 epoll、kqueue、IOCP 等）。 提供多种异步 IO 操作：文件系统、网络 IO、DNS 解析等。 内置线程池，用于执行耗时的任务（如文件操作）。 高效网络 IO。 支持高效的事件驱动模型，底层基于 epoll、kqueue、poll 等机制。 支持定时器、信号和缓存机制（例如 bufferevent）。 轻量化设计，但功能足够丰富。 极简事件驱动库。 提供极简的事件循环，支持底层 epoll、kqueue 等。 专注于高效、轻量的事件处理。 不包含复杂的附加功能，例如线程池或高级 IO 操作。 比libevent/libuv/asio更易用的网络库。 A c/c++ network library for developing TCP/UDP/SSL/HTTP/WebSocket/MQTT client/server. 跨平台支持 较好（Windows 支持有限） 非常好 好（支持 Windows） 较差（Windows 支持弱） 线程支持 多线程、线程池 多线程、线程池 不支持线程池 不支持线程池 轻量程度 较重 中等 轻量 极轻 性能 中等 较高 高 最高 复杂性 高 中等 中等 低 支持场景 过于庞大，可能会为轻量级项目引入不必要的复杂性。 性能相较其他轻量级库（如 libev）可能稍低。 更倾向于桌面环境的开发。 构建基于 GTK+ 的 GUI 应用程序。 GNOME 项目的插件开发或扩展。 需要丰富工具支持的非网络类应用程序。 跨平台支持好，代码高度一致（尤其适用于 Windows 和 Linux 的统一开发）。 提供内置的线程池支持，适合处理复杂异步操作（如文件 IO）。 构建跨平台的高性能网络服务或工具。 需要线程池支持的复杂 IO 操作场景（如文件操作、DNS 解析等）。 不支持线程池或高级异步操作，需要额外实现。 长期以来更新速度较慢，社区活跃度比 libuv 和 libev 稍低。 构建高性能的网络服务或服务器。 不需要线程池或其他附加功能的事件驱动应用。 专注于事件和 IO 模型的小型项目。 功能相对单一，仅适用于事件驱动。 Windows 支持不佳（虽然可以通过兼容层解决）。 需要开发者自行实现线程池或复杂操作的支持。 需要极高性能的事件驱动应用程序。 构建单线程、高效的网络服务器。 Linux 或 Unix 系统上的轻量级服务。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"libuv Cross-platform asynchronous I/O libuv is a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, uvloop, and others. Full-featured event loop backed by epoll, kqueue, IOCP, event ports. Asynchronous TCP and UDP sockets Asynchronous DNS resolution Asynchronous file and file system operations File system events ANSI escape code controlled TTY IPC with socket sharing, using Unix domain sockets or named pipes (Windows) Child processes Thread pool Signal handling High resolution clock Threading and synchronization primitives libuv/libuv: Cross-platform asynchronous I/O (github.com) 基于libuv实现的C++11风格网络库。接口简洁，性能优越，做过业务压测，稳定线上运行。 wlgq2/uv-cpp: libuv wrapper in C++11 /libuv C++11网络库 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"libhv * 比libevent/libuv/asio更易用的网络库。A c/c++ network library for developing TCP/UDP/SSL/HTTP/WebSocket/MQTT client/server. ithewei/libhv: 🔥 比libevent/libuv/asio更易用的网络库。A c/c++ network library for developing TCP/UDP/SSL/HTTP/WebSocket/MQTT client/server. (github.com) 协议 BSD 3-Clause。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:4","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Tinyhttpd Tinyhttpd 是J. David Blackstone在1999年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。官网:http://tinyhttpd.sourceforge.net EZLippi/Tinyhttpd: Tinyhttpd 是J. David Blackstone在1999年写的一个不到 500 行的超轻量型 Http Server，用来学习非常不错，可以帮助我们真正理解服务器程序的本质。官网:http://tinyhttpd.sourceforge.net (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:5","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"TinyWebServer Linux下C++轻量级WebServer服务器 qinguoyi/TinyWebServer: 🔥 Linux下C++轻量级WebServer服务器 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:6","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"cpp-httplib A C++ header-only HTTP/HTTPS server and client library yhirose/cpp-httplib: A C++ header-only HTTP/HTTPS server and client library (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:7","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Monkey HTTP Server Monkey HTTP Server monkey/monkey: Monkey HTTP Server (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:8","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"CppNet Cppnet is a proactor mode and multithreaded network with C++11 on tcp. Support Window, Linux and macOS. Simple: Only export a little interfaces, all net io insterface are asynchronous callbacks Insterface as much as possible like calling the socket API of the system There is only one additional buffer interface for the client Support both IPv4 and IPv6 Fast: Use epoll, wepoll and kqueue Multithreaded threads are handled by the kernel Each socket has a single memory pool object. All memory requested from the memory pool is managed by an intelligent pointer Using time wheel to realize timer Clear: Three layers: event-driven layer, session management layer and interface layer Upward notification through callbacks between layers. Clear division of responsibilities among modules, pay to Caesar what belongs to Caesar and God what belongs to God The interface decoupling module is used to meet the minimum interface principle and dependency inversion principle caozhiyi/CppNet: Cross platform network library with C++11 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:4:9","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Data / Log / Format ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:5:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Format / Protocol fmt {fmt} is an open-source formatting library providing a fast and safe alternative to C stdio and C++ iostreams. fmtlib/fmt: A modern formatting library (github.com) inja 看看例子就知道做什么的了，还是挺花里胡哨的，对于一些自定义格式的解析挺方便。 Inja is a template engine for modern C++, loosely inspired by jinja for python. It has an easy and yet powerful template syntax with all variables, loops, conditions, includes, callbacks, and comments you need, nested and combined as you like. Of course, everything is tested in CI on all relevant compilers. pantor/inja: A Template Engine for Modern C++ (github.com) Ada * ada_url Ada is a fast and spec-compliant URL parser written in C++. Specification for URL parser can be found from the WHATWG website. The Ada library passes the full range of tests from the specification, across a wide range of platforms (e.g., Windows, Linux, macOS). It fully supports the relevant Unicode Technical Standard. Introduction - Ada URL (ada-url.com)。 ada-url/ada: WHATWG-compliant and fast URL parser written in modern C++, part of Node.js, Clickhouse, Redpanda, Kong, Telegram and Cloudflare Workers. (github.com) MQTT-C * MQTT-C is an MQTT v3.1.1 client written in C. MQTT is a lightweight publisher-subscriber-based messaging protocol that is commonly used in IoT and networking applications where high-latency and low data-rate links are expected. The purpose of MQTT-C is to provide a portable MQTT client, written in C, for embedded systems and PC’s alike. MQTT-C does this by providing a transparent Platform Abstraction Layer (PAL) which makes porting to new platforms easy. MQTT-C is completely thread-safe but can also run perfectly fine on single-threaded systems making MQTT-C well-suited for embedded systems and microcontrollers. Finally, MQTT-C is small; there are only two source files totalling less than 2000 lines. LiamBindle/MQTT-C: A portable MQTT C client for embedded systems and PCs alike. (github.com) Eclipse Mosquitto eclipse-mosquitto/mosquitto: Eclipse Mosquitto - An open source MQTT broker (github.com) nlohmann/json * There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals: Intuitive syntax. In languages such as Python, JSON feels like a first class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the examples below and you’ll know what I mean. Trivial integration. Our whole code consists of a single header file json.hpp. That’s it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings. Serious testing. Our code is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative (CII) best practices. Other aspects were not so important to us: Memory efficiency. Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: std::string for strings, int64_t, uint64_t or double for numbers, std::map for objects, std::vector for arrays, and bool for Booleans. However, you can template the generalized class basic_json to your needs. Speed. There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a std::vector or std::map, you are already set. nlohmann/json: JSON for Modern C++ (github.com) cJSON Ultralightweight JSON parser in ANSI C. DaveGamble/cJSON: Ultralightweigh","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:5:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"database sqlite * Official Git mirror of the SQLite source tree sqlite/sqlite: Official Git mirror of the SQLite source tree (github.com) SQLiteCpp SQLiteC++ (SQLiteCpp) is a smart and easy to use C++ SQLite3 wrapper. SRombauts/SQLiteCpp: SQLiteC++ (SQLiteCpp) is a smart and easy to use C++ SQLite3 wrapper. (github.com) SRombauts/SQLiteCpp_Example: C++ Example project using SQLiteCpp as a Git submodule / CMake subdirectory (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:5:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Log log4cplus * log4cplus is a simple to use C++23 logging API providing thread–safe, flexible, and arbitrarily granular control over log management and configuration. It is modeled after the Java log4j API. log4cplus/log4cplus: log4cplus is a simple to use C++ logging API providing thread-safe, flexible, and arbitrarily granular control over log management and configuration. It is modelled after the Java log4j API. (github.com) EasyLogger An ultra-lightweight(ROM\u003c1.6K, RAM\u003c0.3k), high-performance C/C++ log library. | 一款超轻量级(ROM\u003c1.6K, RAM\u003c0.3k)、高性能的 C/C++ 日志库 armink/EasyLogger: An ultra-lightweight(ROM\u003c1.6K, RAM\u003c0.3k), high-performance C/C++ log library. | 一款超轻量级(ROM\u003c1.6K, RAM\u003c0.3k)、高性能的 C/C++ 日志库 (github.com) FlashDB An ultra-lightweight database that supports key-value and time series data | 一款支持 KV 数据和时序数据的超轻量级数据库 armink/FlashDB: An ultra-lightweight database that supports key-value and time series data | 一款支持 KV 数据和时序数据的超轻量级数据库 (github.com) https://github.com/storaged-project/udisks) spdlog Fast C++ logging library. gabime/spdlog: Fast C++ logging library. (github.com) pdf JagPDF JagPDF is a free, open source library for generating PDF documents. The goal of this project is to provide a fast and reliable library that is usable in both server and desktop environments. The library is written in C++ and provides bindings for other languages. It runs on x86/Linux, amd64/Linux and x86/Windows platforms. JagPDF aims to be easy to use, have a look at Hello World examples in C++, Python, Java or C. The library implements a fairly large subset of the PDF specification which enables creation of a broad range of document types. The library is distributed under the MIT license which encourages both commercial and non-commercial usage. JagPDF - PDF Generation Library libharu Haru is a free, cross platform, open-sourced software library for generating PDF. It supports the following features. Generating PDF files with lines, text, images. Outline, text annotation, link annotation. Compressing document with deflate-decode. Embedding PNG, Jpeg images. Embedding Type1 font and TrueType font. Creating encrypted PDF files. Using various character set (ISO8859-116, MSCP12508, KOI8-R). Supporting CJK fonts and encodings. You can add the feature of PDF creation by using Haru without understanding complicated internal structure of PDF. libharu/libharu: libharu - free PDF library (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:5:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Com ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:6:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"dbus-cxx * DBus-cxx is a C++ implementation for DBus. DBus is a Linux-specific RPC(remote procedure call) and IPC(inter-process communications) mechanism. DBus-cxx provides an object-oriented view of all programs on the DBus, and allows an object-oriented way of exporting methods onto the DBus. This new 2.0 version(that you are looking at now) is a complete ground-up implementation of the DBus protocol, without libdbus, in part to fix a number of known multithreading issues with libdbus. This also allows for templates to be used throughout the system, for methods, signals, and properties. dbus-cxx/dbus-cxx: DBus-cxx provides an object-oriented interface to DBus (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:6:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"protobuf * Protocol Buffers (a.k.a., protobuf) are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data. You can learn more about it in protobuf’s documentation. protocolbuffers/protobuf: Protocol Buffers - Google’s data interchange format (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:6:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"EmbeddedRPC Embedded RPC EmbeddedRPC/erpc: Embedded RPC (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:6:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Argo / Crypto ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:7:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"openssl * TLS/SSL and crypto library openssl/openssl: TLS/SSL and crypto library (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:7:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"tiny-AES-c Small portable AES128/192/256 in C This is a small and portable implementation of the AES ECB, CTR and CBC encryption algorithms written in C. You can override the default key-size of 128 bit with 192 or 256 bit by defining the symbols AES192 or AES256 in aes.h. kokke/tiny-AES-c: Small portable AES128/192/256 in C (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:7:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"crc-lib-c 基于C语言的CRC校验库，包括常用的21个CRC参数模型实现 whik/crc-lib-c: 基于C语言的CRC校验库，包括常用的21个CRC参数模型实现 (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:7:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"zip zlib zlib is a general purpose data compression library. All the code is thread safe. The data format used by the zlib library is described by RFCs (Request for Comments) madler/zlib: A massively spiffy yet delicately unobtrusive compression library. (github.com) zstr A C++ header-only ZLib wrapper mateidavid/zstr: A C++ header-only ZLib wrapper (github.com) libzip This is libzip, a C library for reading, creating, and modifying zip and zip64 archives. Files can be added from data buffers, files, or compressed data copied directly from other zip archives. Changes made without closing the archive can be reverted. Decryption and encryption of Winzip AES and legacy PKware encrypted files is supported. libzip is fully documented via man pages. HTML versions of the man pages are on libzip.org and in the man directory. You can start with libzip(3), which lists all others. Example source code is in the examples and src subdirectories. nih-at/libzip: A C library for reading, creating, and modifying zip archives. (github.com) LibZippp libzippp is a simple basic C++ wrapper around the libzip library. It is meant to be a portable and easy-to-use library for ZIP handling. Underlying libraries: ZLib 1.3.1 libzip 1.11.2 ctabin/libzippp: C++ wrapper for libzip (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:7:4","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"QR-Code-generator This project aims to be the best, clearest QR Code generator library in multiple languages. The primary goals are flexible options and absolute correctness. Secondary goals are compact implementation size and good documentation comments. nayuki/QR-Code-generator: High-quality QR Code generator library in Java, TypeScript/JavaScript, Python, Rust, C++, C. (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:7:5","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Scientific Computing ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:8:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Matrix mlcpp/Matrix: Easy-to-use Scientific Computing library in/for C++ available for Linux and Windows. (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:8:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"NumCpp A Templatized Header Only C++ Implementation of the Python NumPy Library。 dpilger26/NumCpp: C++ implementation of the Python Numpy library (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:8:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Matrix_hub A lib of Matrix operation for C language. (矩阵运算库–C语言) Amoiensis/Matrix_hub: A lib of Matrix operation for C language. (矩阵运算库–C语言) (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:8:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Language Bind ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:9:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Lua 一种轻量级多范式脚本语言，主要设计用于嵌入使用。C 库。 The Programming Language Lua ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:9:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"sol2 一个绑定 Lua 的现代 C++ 库。 sol2 is a C++ library binding to Lua. It currently supports all Lua versions 5.1+ (LuaJIT 2.0+ and MoonJIT included). sol2 aims to be easy to use and easy to add to a project. The library is header-only for easy integration with projects, and a single header can be used for drag-and-drop start up. ThePhD/sol2: Sol3 (sol2 v3.0) - a C++ \u003c-\u003e Lua API wrapper with advanced features and top notch performance - is here, and it’s great! Documentation: (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:9:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Device ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:10:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"UDisks The UDisks project provides a daemon, tools and libraries to access and manipulate disks, storage devices and technologies. For API stability and intended audience of UDisks, see the API STABILITY and AUDIENCE section of the udisks(8) man page (doc/man/udisks.xml in the tarball and git repository). [storaged-project/udisks: The UDisks project provides a daemon, tools and libraries to access and manipulate disks, storage devices and technologies. (github.com)]( ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:10:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"libusb libusb is a library for USB device access from Linux, macOS, Windows, OpenBSD/NetBSD, Haiku, Solaris userspace, and WebAssembly via WebUSB. It is written in C (Haiku backend in C++) and licensed under the GNU Lesser General Public License version 2.1 or, at your option, any later version (see COPYING). libusb is abstracted internally in such a way that it can hopefully be ported to other operating systems. Please see the PORTING file for more information. libusb homepage: https://libusb.info/ libusb/libusb: A cross-platform library to access USB devices (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:10:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Embedded ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:11:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"ETL 实现了资源节省的、固定内存分配的 C++ 的各种基本功能，采用回调函数的方式与 嵌入式 mcu 设备中的 各种 uart、timer 等中断回调进行连接，来使得能够用 c++ 来编写 mcu 代码。 C++ is a great language to use for embedded applications and templates are a powerful aspect. The standard library can offer a great deal of well tested functionality, but there are some parts of the standard library that do not fit well with deterministic behaviour and limited resource requirements. These limitations usually preclude the use of dynamically allocated memory and containers with open ended sizes. What is needed is a template library where the user can declare the size, or maximum size of any object upfront. Most embedded compilers do not currently support the standard beyond C++ 03, therefore excluding the programmer from using the enhanced features of the later library. This is what the ETL attempts to achieve. ETLCPP/etl: Embedded Template Library (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:11:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Unit testing ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:12:0","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Criterion http://criterion.readthedocs.org/ Most test frameworks for C require a lot of boilerplate code to set up tests and test suites – you need to create a main, then register new test suites, then register the tests within these suites, and finally call the right functions. This gives the user great control, at the unfortunate cost of simplicity. Criterion follows the KISS principle, while keeping the control the user would have with other frameworks: C99 and C++11 compatible. Tests are automatically registered when declared. Implements a xUnit framework structure. A default entry point is provided, no need to declare a main unless you want to do special handling. Test are isolated in their own process, crashes and signals can be reported and tested. Unified interface between C and C++: include the criterion header and it just works. Supports parameterized tests and theories. Progress and statistics can be followed in real time with report hooks. TAP output format can be enabled with an option. Runs on Linux, FreeBSD, macOS, and Windows (Compiling with MinGW GCC and Visual Studio 2015+). Snaipe/Criterion: A cross-platform C and C++ unit testing framework for the 21st century (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:12:1","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"googletest GoogleTest User’s Guide | GoogleTest GoogleTest - Google Testing and Mocking Framework google/googletest: GoogleTest - Google Testing and Mocking Framework (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:12:2","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"Catch2 Catch2 is mainly a unit testing framework for C++, but it also provides basic micro-benchmarking features, and simple BDD macros. Catch2’s main advantage is that using it is both simple and natural. Test names do not have to be valid identifiers, assertions look like normal C++ boolean expressions, and sections provide a nice and local way to share set-up and tear-down code in tests. catchorg/Catch2: A modern, C++-native, test framework for unit-tests, TDD and BDD - using C++14, C++17 and later (C++11 support is in v2.x branch, and C++03 on the Catch1.x branch) (github.com) C/C++生态工具链——单元测试工具Catch2简介-CSDN博客。 ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:12:3","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"ThrowTheSwitch/Unity Welcome to the Unity Test Project, one of the main projects of ThrowTheSwitch.org. Unity Test is a unit testing framework built for C, with a focus on working with embedded toolchains. This project is made to test code targetting microcontrollers big and small. The core project is a single C file and a pair of headers, allowing it to be added to your existing build setup without too much headache. You may use any compiler you wish, and may use most existing build systems including Make, CMake, etc. If you’d like to leave the hard work to us, you might be interested in Ceedling, a build tool also by ThrowTheSwitch.org. If you’re new to Unity, we encourage you to tour the getting started guide. ThrowTheSwitch/Unity: Simple Unit Testing for C (github.com) ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:12:4","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"cppunit CPlusPlusUnit | cppunit CPlusPlusUnit - Tiny single source file C++ Unit testing TDD framework with the output message format like Python unittest. No installation is required, just copy Cppunit class definition form cppunit.h into your source file and you are all set. cppunit/cppunit: CPlusPlusUnit - Tiny single source file C++ Unit Testing TDD framework with the output message format like Python unittest http://cppunit.github.io ","date":"2024-09-15","objectID":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/:12:5","tags":["C++"],"title":"C / C++ 实用库备查","uri":"/c-cpp%E5%AE%9E%E7%94%A8%E5%BA%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C++11 / 14 / 17 常用语法大总结；C++ 类 / 泛型模板 / 高并发 等高价值课题 最佳实践的总结；C++ 常用库大收集；C++ debug / 动态 \u0026 静态检查 技术 大整理。等等","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C++ 学习总结 本文非基础教学文，而是在有 C 语言的基础上对 C++ 学习的总结记录，长期积累\u0026更新。 欢迎在原文 github / gitee 仓库 提 issue 指出错误，和 提 PR 来一同建设内容。 本文的 Github 仓库地址 内文章会不断更新，而发在其它位置的不会跟进了，本文的 Gitee 仓库地址 访问更流畅。 p.s 本文为个人对 C++ 学习的总结，本人习惯性把一块领域的内容用一篇大文章（万字为单位计）来汇聚（而非分了很多个小文章），说白了是主要用于个人总结和备查，而非做教程，因而会有个人对内容的挑选，而非照搬该领域的大部分内容（因此本文会遗漏一些过于基础的东西），以及使用的最佳实践，后二点，可以通过多看一些最佳实践的文章和工程来对自己进行提高（下面也会给出很多推荐看的链接）；本文会给出大量的参考链接，绝大多数都是漫长时间里面发现、挑选、整理出来的精品，也就是个人把本文当字典来用；因为非教程，而是面向有一定基础的人，而且一个文章的体量相比于大多数网络文章显得 “过于巨大”，看的人少也是应该的。 尚有 一些 标记了 TODO 的地方 有待施工。没有三头六臂，很多资料 手头和脑里 都有 只是尚未没有整理出来。 虽抱文章，开口谁亲。且陶陶、乐尽天真。几时归去，作个闲人。对一张琴，一壶酒，一溪云。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:0:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C/C++ 有迹可循 / 汇总 下面的教程会列举很多，选择合适自己的去看即可。 C 语言入门 菜鸟教程 C 语言教程 | 菜鸟教程 (runoob.com)。 C语言中文网 网站地图 (biancheng.net)，个别小节需要 RMB。 B站搜“C语言学习” C语言学习 _ 搜索结果_ 哔哩哔哩 _Bilibili，随便一搜一大把，其它语言同理。 对于 C 语言特性的精品汇总 [Knowledge-Notes/2 - C语言笔记 at master · wuxiaolie/Knowledge-Notes (github.com)](https://github.com/wuxiaolie/Knowledge-Notes/tree/master/2 - C语言笔记)。 embedded/01_C at master · kuraxii/embedded (github.com)。 lh233/C-knowledge: 关于C语言的基础知识 (github.com)。 C 语言提高 C 语言三剑客：《C和指针》、《C陷阱与缺陷》和《C专家编程》，经典永流传。 《嵌入式C语言的自我修养》 从沙子讲到CPU，从编辑器讲到编译器，从高阶C语言讲到内存管理，从GNU讲到多任务编程。《嵌入式C语言自我修养》勘误 - 公众号文章汇总 | 宅学部落 (zhaixue.cc)。 列一些提高的书：（有的书可以网上找到电子版（只提醒一下）） 让你不再害怕指针——C指针详解(经典,非常详细) - 简书 (jianshu.com)，让你不再害怕指针——C指针详解(经典,非常详细)_程序老兵的博客-CSDN博客_指针。 你必须知道的495个C语言问题 (豆瓣) (douban.com)，你必须知道的495个C语言问题_benpaobagzb的博客-CSDN博客_你必须知道的495个c语言问题，《你必须知道的495个C语言问题》知识笔记及补充 - Alexia(minmin) - 博客园 (cnblogs.com)。 C语言深度解剖 (豆瓣) (douban.com)。 C语言的底层操作_zhongjie的专栏-CSDN博客_c语言底层架构。 深入理解C指针 (豆瓣) (douban.com)。 嵌入式学习网]嵌入式C精华.pdf 免费在线阅读 (book118.com)，嵌入式C语言精华文章集锦.pdf_嵌入式c-C文档类资源-CSDN文库。 本文作者的 “C 规范”： Gitee：[C \u0026 MCU编写规范和其他.md · 瞰百/coding-style-and-more - Gitee.com](https://gitee.com/staok/coding-style-and-more/blob/main/C \u0026 MCU编写规范和其他.md)。 Github：[coding-style-and-more/C \u0026 MCU编写规范和其他.md at main · Staok/coding-style-and-more (github.com)](https://github.com/Staok/coding-style-and-more/blob/main/C %26 MCU编写规范和其他.md)。 学完一门语言要赶紧去看该语言的 数据结构与算法。C 语言的数据结构与算法，网搜教程。 本文作者的 （大集合）数据结构与算法简述和CS综合 - 欢迎来到 Staok - 瞰百易 (github.io) / CSDN。 这个文章属于早期整理，正式的、内容更丰富的 github 仓库为 Staok/C-Cpp-data-struct-algo: C-C++-数据结构与算法相关优秀资料集子 (github.com)。 C++ 教程 B站大学 玄马教育 C++40个知识点带你入门_哔哩哔哩_bilibili。 简明教程（推荐） C++ Beginner’s Guide for Python/Java/… Programmers | hacking C++ (hackingcpp.com)。 介绍 论C++教程就属HackingCpp简洁优雅,C++ Primer,cppreference_哔哩哔哩_bilibili。 《C++ Primer Plus（第六版 ）》中文版，大厚书，适合用于复习和课余补充。 菜鸟教程（推挤） C++ 教程 | 菜鸟教程 (runoob.com)。 C语言中文网 C++入门教程，C++基础教程（更新完毕） (biancheng.net)，STL教程：C++ STL快速入门（非常详细） (biancheng.net)。 干货推荐 ：五万字长文总结 C/C++ 知识 - 知乎 (zhihu.com)。 C++ 标准库简介 - OI Wiki (oi-wiki.org)，类 - OI Wiki (oi-wiki.org)。 学习C++这一篇就够了（基础篇）-CSDN博客，学习C++这一篇就够了（提升篇）_c++提升学习-CSDN博客，学习C++这一篇就够了（进阶篇）_c++ 进阶csdn-CSDN博客。 C++ 快速复习 都是些应试用的时代废品 这可能是史上最快学习C++的课程，期末考前复习冲刺的宝典_哔哩哔哩_bilibili。 复习100分钟拿下100分，你能做得到吗？【C++】(面向对象程序设计)（总复习）_哔哩哔哩_bilibili。 对于 C++ 语言特性的精品汇总 [Knowledge-Notes/2 - C++笔记 at master · wuxiaolie/Knowledge-Notes (github.com)](https://github.com/wuxiaolie/Knowledge-Notes/tree/master/2 - C%2B%2B笔记)。 embedded/02_CPP at master · kuraxii/embedded (github.com)。 EmbeddedSystem/Language at master · SummerGift/EmbeddedSystem (github.com)。 chengxumiaodaren/cpp-learning (github.com)。 C++11/14/17/20/23新特性，哪些是必须掌握的，哪些基本用得不多？ - 知乎 (zhihu.com)。 C++ 精品仓库 下面这些 C++ 笔记 / 仓库可牛了（这些仓库大部已离线到 C++学习相关Github仓库收集 文件夹下！） chengxumiaodaren/cpp-learning (github.com)。好内容非常多。这个没有离线到本地。 linux-cpp-tutorial: 基于Linux的C++ 教程合集， 包括C++基础， C++服务器， C++专题 - Gitee.com。 czs108/Cpp-Primer-5th-Notes-CN: 📚 《C++ Primer中文版（第5版）》笔记 (github.com)。 demon90s/CppStudy: My study notes for c/cpp language (github.com)。 Light-City/CPlusPlusThings: C++那些事 (github.com)。 0voice/introduce_c-cpp_manual: 一个收集C/C++新手学习的入门项目，整理收纳开发者开源的小项目、工具、框架、游戏等，视频，书籍，面试题/算法题，技术文章。 (github.com)。 0voice/cpp_new_features: 2021年最新整理， C++ 学习资料，含C++ 11 / 14 / 17 / 20 / 23 新特性、入门教程、推荐书籍、优质文章、学习笔记、教学视频等 (github.com)。 FunctionDou/STL: STL源码分析 (github.com)。 推荐源码库可读 1：你读过的最好的 C++ 开源代码是什么？ - 知乎 (zhihu.com)。 推荐源码库可读 2：你读过的最好的 C++ 开源代码是什么？ - 知乎 (zhihu.com)。 推荐源码库可读 3：chenshuo/muduo: Event-driven network library for multi-threaded Linux server in C++11 (github.com)。 C++ 参考 / 字典 / 特性快速索引 首推 cppreference。这个网站里面的描述可能大多 “比较官话”，相关的关键字可以网搜文章来学，这个网站对于广大应用者来说可以认为是比较全的列出来 “都有什么”。 离线查看的归档 - cppreference.com。cppreference离线文档下载 - 知乎 (zhihu.com)。 C++ 标准库标头 - cppreference.com。 hackingcpp，容器 \u0026 argo库 等 图形化展示 C++ Cheat Sheets \u0026 Infographics | hacking C++ (hackingcpp.com)。 mortennobel/cpp-cheatsheet: Modern C++ Cheatsheet (github.com)。 C++ 有用的资源 | 菜鸟教程 (runoob.com)。 以下挑出上面没有的做补充 以下资源包含了 C++ 有关的网站、书籍和文章。请使用它们来进一步学习 C++ 的知识。 C++ 有用的网站： C++ Programming − 这本书涵盖","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:1:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C/C++ 精品库 看到的小巧精良的小型 c/cpp 库/项目列举。 C 精品仓库 jobbole/awesome-c-cn: C 资源大全中文版，包括了：构建系统、编译器、数据库、加密、初中高的教程/指南、书籍、库等。 (github.com)。 C++ 精品仓库 同目录的 C-C++实用库备查.md 文章 Your list / 实用库 / EE-CS (github.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:2:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"编程提高杂文 C/C++ 编程技术 - 知乎 (zhihu.com)。 C/C++ Linux 软件开发模拟面试 - 知乎 (zhihu.com)。 Linux 开发 - 知乎 (zhihu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:3:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"编程经验、调试、性能和内存检查工具集合 见同目录的 编程经验、调试、性能和内存检查工具集合 文章。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C/C++ 数据结构与算法 / 设计模式 学习一些设计模式和实践经验，写更健壮和好维护的程序。 总结整理仓库： C-C++-数据结构与算法简述 Staok/C-Cpp-data-struct-algo: C-C++-数据结构与算法相关优秀资料集子 (github.com)。 C-C++-设计模式综合 Staok/C-Cpp-design-patterns: C/C++设计模式相关优秀资料集子 (github.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C++ (11 / 14 / 17 / 20) 基础 主要围绕 C++ 11 / 14 / 17 / 20 以及以上 的 各版本特性 展开 下面各小节的顺序没有处理。 下面给出的基础语法和例子，实践的时候可举一反三使用，写东西时候先多思考架构，不必一上来就写 等 情况的出现，减少后面 debug 和 重构的时间。 TODO: 《C++ Primer Plus（第六版 ）》书 已经看完 4、5、6、7（7章最后还差一点）章节，开始弄c++总结时候，先将前面这些 书上 画线、笔记 总结到这里； 当Linux应用完之后，接着看完C加加书的第7章，然后将4 5 6 7章的所有划线部分都零散的总结进去，然后再接着看后面的计划的章节：10、13章，还有 16.1、16.3、16.7。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C++ 各版本优质参考 C++11 - cppreference.com，C++14 - cppreference.com，C++17 - cppreference.com，C++20 - cppreference.com。 c++14新特性总结 - 知乎 (zhihu.com)。 当面试官问我C++ 11新特性的时候，应该怎样回答？ - 知乎 (zhihu.com)。 chengxumiaodaren/cpp-learning (github.com)。 C++11/14/17/20/23新特性，哪些是必须掌握的，哪些基本用得不多？ - 知乎 (zhihu.com)。 c++11 新特性总结（一）——关键字篇 - 知乎 (zhihu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:1","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"基础 p.s 与 C 大同小异的部分不做展开。 变量与作用域 变量 补充参考 C++ 数据类型 | 菜鸟教程 (runoob.com)、C++ 变量类型 | 菜鸟教程 (runoob.com)、C++ 变量作用域 | 菜鸟教程 (runoob.com)；C++ 常量 | 菜鸟教程 (runoob.com)、C++ 修饰符类型 | 菜鸟教程 (runoob.com)。C++变量的定义位置 (biancheng.net)，C++布尔类型（bool） (biancheng.net)。 void bool（true/false） char、wchar_t、short、int、long float、double // c++11 新增了几种数据类型: nullptr(在 c++ 中替代 NULL，专用于 表示 空指针；NULL 本质上是个 int 型的 0，不是个指针) long long char16_t、char32_t (Unicode 字符) --- signed、unsigned --- struct // 结构体 c++的结构体里面可以写函数，通过 “结构体.函数名(..)” 来调用 enum // 枚举 c++ enum的新特性之enum class enum struct：https://blog.csdn.net/qq_32348883/article/details/122866241 union // 联合 --- const、static、volatile typedef // 类型定义 extern // 对其它文件可见 作用域 全局作用域（全局变量）。 局部作用域 / 块作用域（语句块 {...} 内的变量，局部变量）。 类域（class），命名空间作用域（namespace）。 块的内外部均定义有同名变量情况下，在运行到块内部时，仅使用块内部的同名变量而隐藏掉块外部的同名变量。 关于 auto、static、thread_local、extern、mutable 这些 存储类 说明符 / 修饰符 的 说明 和 使用范围： 存储类说明符 - cppreference.com。 预处理 补充参考 C++ 预处理器 | 菜鸟教程 (runoob.com)。 #include #if、#ifdef、#ifndef、#elif、#else、#endif #define # 后文转字符串 ## 左右文拼接 __func__、__LINE__、__FILE__、__DATE__、__TIME__ __has_include 预处理 表达式 #if defined __has_include #if __has_include(\u003ccharconv\u003e) #define has_charconv 1 #include \u003ccharconv\u003e #endif #endif std::optional\u003cint\u003e ConvertToInt(const std::string\u0026 str) { int value{}; #ifdef has_charconv // 判断是否有包含某个头文件 或 库，根据实际 include 的东西 选择处理方式 const auto last = str.data() + str.size(); const auto res = std::from_chars(str.data(), last, value); if (res.ec == std::errc{} \u0026\u0026 res.ptr == last) return value; #else // alternative implementation... // 其它方式实现 #endif return std::nullopt; } 循环和分支结构 循环：for、while、do{ }while + continue、break 分支：if、if-else、if-else if-...-else、switch ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:2","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"命名空间 补充参考 C++ 命名空间 | 菜鸟教程 (runoob.com)、C++命名空间（名字空间）详解 (biancheng.net)。 本意即 区分不同库中相同名称的函数、类、变量等。本质上，命名空间就是定义了一个范围。 是一种作用域的划分，通常用于区分项目中的模块或组件，其中可定义变量、函数等。 可分布式定义，可嵌套，可取别名。推荐使用::来引用命名空间里的对象。 下面简单例子说明 命名空间的定义（新定义或多次定义增加内容）、引用（使用 using 或 :: 直接引用）和 保证元素名称的唯一性。 #include \u003ciostream\u003eusing namespace std; /* 使用 iostream 库中 std 命名空间 的内容 */ /* using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句： using std::cout; */ // 定义第一个命名空间 // 一个命名空间的各个组成部分可以分散在多个文件中，下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素 namespace first_space // 该 命名空间 的 名字 first_space { // 这里是代码声明 void func() { cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } namespace first_space // 分布式定义，为 命名空间 first_space 添加成员 { int a; } // 定义第二个命名空间 namespace second_space { int b; void func() { cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } int cc1 = 10; namespace cd { int c = ::cc1; // 引用全局变量 cc1 namespace d // 命名空间 嵌套 { int d; } } // using namespace cd; // 访问 cd 中的成员 // using namespace cd::d; // 访问 d 中的成员 /* 使用 :: 运算符来访问嵌套的命名空间中的成员： 使用 using 引用（不推荐常用在命名空间）：using namespace cd::d::d; 或者直接引用（推荐）：cd::d::d 要保证同名的函数、变量等的唯一性，不能同时： using namespace first_space; 和 using second_space ; */ namespace n = cd; // 给 命名空间 cd 取别名为 n namespace dd = cd::d; // 给 命名空间 d 取别名为 dd using namespace first_space; int main () { // 上面 using 表明 其后面的程序使用 first_space 命名空间的内容，这里直接调用第一个命名空间中的函数 func(); // 使用 :: 调用第二个命名空间中的函数 second_space::func(); return 0; } // namespace 嵌套，C++ 17 起 // 多层的命名空间可以这么定义 namespace A::B::C { void func();) } 下面开始介绍 c++ STL 标准库里的 常用数据结构实现，常用的有 string、vector、list、hash 等。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:3","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"string 参考：C++ string类型理解_xuewu0zhijing的博客-CSDN博客。c++ string常见用法汇总_路过的小熊~的博客-CSDN博客_c++ string 使用。 各种方法，用时可以在 cppreference 里现找即可。 下面的就是看着玩的。 各种基本方法 #include \u003cstring\u003e string str1 = \"runoob\"; string str2 = \"google\"; string str3; /* 运算符重载 “+”、“+=”：连接多个字符串； “=”：给字符串赋值；如 str3 = str1; // 复制 str1 到 str3 str3 = “aaa”; str3 = str1 + str2; // 连接 str1 和 str2 “\u003c”、“\u003c=”、“\u003e”、“\u003e=”：字符串的比较； “==”、“！=”：判断字符串是否相等； */ /* string 类的方法，每个方法 都是 “string对象.方法;” 来用 size(); // 返回字符串长度，int len = str3.size(); // str3 的总长度 length(); // 返回字符串长度 empty(); // 检查 str 是否为空，为空返回 1，否则返回 0 at(n); // 同 str[n]; 作用，存取 str 第 n + 1 个字符（如果溢出会抛出异常） append(“abc”); // 作用同 + 运算符重载，在字符串末尾添加字符串\"abc\"，并返回形成的新字符串 insert(x, “hello”); // 从 [x] 位置开始添加字符串 “hello”，并返回形成的新字符串 insert(x, “hello”, y); // 从 [x] 位置开始添加字符串 “hello” 的前 y个字符，并返回形成的新字符串 insert(x, “hello”, y, z); // 从 [x] 位置开始添加字符串 “hijklmn” 的 [y]位置开始的 z 个连续字符 （包括 [y] 在内），并返回形成的新字符串 erase(x); // 删除 [x] 及其以后的字符，并返回形成的新字符串 erase(x, y); // 删除从 [x] 开始的 y 个字符，并返回形成的新字符串 查找 find(\" \"); // 返回字符串 \" \" 在 str 的位置； find(\" \", x); // 在 str[x] ~ str[n - 1] **(x\u003cn，下同)**范围内查找并返回字符串 \" \" 在 str 的位置； rfind(\" \", x); // 在 str[0] ~ str[x] 范围内查找并返回字符串 \" \" 在 str 的位置； string 与 char* 相互拷贝 char * 转成 string，直接赋值 string s1 = \"aaa\"; string 转成 char *，调用类方法 法一：只需调用 c_str() 方法 printf(\"%s\\n\", s1.c_str()); 法二：调用 copy() 方法 char buf[128]; s1.copy(buf, 3 ,0); // 把string中的内容copy到char *类型的buf中，从位置0开始拷贝3个到buf中 first 类方法 find_first_of(\" \"); // 返回 \" \" 中任何一个字符首次在 str 中出现的位置； find_first_of(\" \", x); // 返回 \" \" 中任何一个字符首次在 str[x]~str[n-1] 范围中出现的位置； find_first_not_of(\" \"); // 返回除 \" \" 以外的任何一个字符在 str 中首次出现的位置； find_first_not_of(\" \", x);// 返回除 \" \" 以外的任何一个字符在 str[x]~str[n-1] 范围中首次出现的位置； last 类方法 find_last_of(\" \"); // 返回 \" \" 中任何一个字符最后一次在 str 中出现的位置； find_last_of(\" \", x); // 返回 \" \" 中任何一个字符最后一次在 str[0]~str[x] 范围中出现的位置； find_last_not_of(\" \"); // 返回除 \" \" 以外的任何一个字符在 str 中最后一次出现的位置； find_last_not_of(\" \", x); // 返回除 \" \" 以外的任何一个字符在 str[0]~str[x] 范围中最后一次出现的位置； 以上如果没有找到相对应的字符，均返回string::npos 替换 replace(x,y,“hello”)； // 返回把 [x]~[x+(y-1)] 的内容替换为 “hello” 后的新字符串 replace(x, y, “abcd”, z); // 返回把 [x]~[x+(y-1)] 的内容替换为 “abcd” 的前z个字符后的新字符串 子串 substr(x)； // 返回[x]及以后的子字符串 substr(x,y)；// 返回[x]~[x+(y-1)]的子字符串（即从[x]开始的y个连续字符组成的字符串） */ 理解： C++初阶：String类_AKA你的闺蜜的博客-CSDN博客。 C++ String类的理解_一只名叫二毛的猫的博客-CSDN博客。 String类的理解_mm1296939448的博客-CSDN博客。 流的格式控制 这里面方法很多，难全记，所以实际常问 AI 工具去写。 参考 C++输出流格式控制_iomanip_51CTO博客_c++ 输出格式控制，C++输入输出流格式控制_c++输入输出格式控制_GNG的博客-CSDN博客。 两种方式：具体写发看参考即可。 使用控制符：引用头文件 iomanip，使用方式 cout \u003c\u003c 控制符 \u003c\u003c 数据 \u003c\u003c endl;。 使用 cout 成员函数：例如 cout.setf(ios::left);// 设置左对齐，cout.width(4);// 宽度为4，cout.precision(2);// 设置浮点数精度为2 等等。 std::string_view 通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。 void func(std::string_view stv) { cout \u003c\u003c stv \u003c\u003c endl; } int main(void) { std::string str = \"Hello World\"; std::cout \u003c\u003c str \u003c\u003c std::endl; std::string_view stv(str.c_str(), str.size()); cout \u003c\u003c stv \u003c\u003c endl; func(stv); return 0; } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:4","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"容器 首要说明，以下列出常用容器，有的可组合使用。各容器的方法，可以在 cppreference 里现找，或者 C++ Standard Library Containers | hacking C++ (hackingcpp.com)。 注意所有容器使用 at() 方法 等的时候，若没有项 则会抛异常，要处理！ 参考： 都有什么 容器库 - cppreference.com。 c++容器–vector deque list set map stack queue特性及其选取准则_路过的小熊~的博客-CSDN博客。 常用的： vector，动态数组，内存连续，增删 O(n)，改查 O(1) list，链表结构，内存不连续，增删 O(1)，改查 O(n) set，平衡二叉搜索树（红黑树），有序的、不重复的元素集合，创建时可指定自定义排序 插入时即排好序，查找、插入和删除 O(logn) map，红黑树，只可对 key 排序，插入的时间是O(logn),查询时间是O(logn)，不允许重复 key，若有重复 key 则用 mutilmap 注意：set 和 map 定义好排序规则后 新插入数据 就排序好（遍历出来），这种数据结构不建议中途改排序规则，因为需要全清 若要 插入和搜索 均为 O(1) 且又能随时排序 的 数据结构，参考使用 结合 list + unordered_map 的 LRU unordered_map，哈希，不可排序，插入的时间是 O(logn)，查询时间是 O(1)，其它基本同 map 这些容器常用的操作要熟悉：插入（push_back()、[]、insert()）、查找（find()）、遍历（熟悉迭代器使用），还有排序（std提供的排序，自定义排序） 删除节点，遍历删除节点等。 遍历，一般用 for (it = myMap.begin(); it != myMap.end(); it++) 和 for (const auto\u0026 elem : myMap) 这两种 基础类型 vector / list / stack / queue … vector C++Vector使用方法 - mengfanrong - 博客园 (cnblogs.com)。 #include \u003cvector\u003e vector\u003c typeName \u003e v4(n); // v4含有n个值为0的元素 vector\u003c typeName \u003e v3(n,i); // v3包括n个值为i的typeName类型元素 vector\u003c typeName \u003e v1; // 默认v1为空，故以下的赋值是错误的v1[0]=5; vector\u003c typeName \u003e v2(v1); // v2是v1的一个副本，若v1.size（）\u003ev2.size()则赋值后v2.size()被扩充为v1.size() // 或 v2 = v1; // 或 vector\u003ctypeName\u003e v2(v1.begin(), v1.end()); // 或 int a[4]={0,1,2,3,3}; vector\u003cint\u003e v5(a,a+5); // v5的size为5，v5被初始化为a的5个值。后一个指针要指向将被拷贝的末元素的下一位置 /* vector对象最重要的几种操作 v.push_back(t) 在容器的最后加入一个值为t的数据，容器的size变大 v.pop_back() 删除容器的末元素，并不返回该元素 v.insert(pointer,number, content) 向v中pointer指向的位置插入number个content的内容 v.insert(pointer, content) 或 v.insert(pointer,a[2],a[4]) 将a[2]到a[4]三个元素插入 v.size() 返回容器中数据的个数，size返回对应vector类定义的size_type的值。 v.resize(2*v.size) 或 v.resize(2*v.size, 99) 将v的容量翻倍(并把新元素的值初始化为99) v.empty() 判断vector是否为空 v.clear() 删除容器中的全部元素 v[n] 读写v中位置为n的元素，下标仅仅能用于读写已存在的元素 v1 == v2 判断v1与v2是否相等 !=、\u003c、\u003c=、\u003e、\u003e= 保持这些操作符惯有含义 */ // 遍历所有项 void print(const std::vector\u003cint\u003e\u0026 vec) { for (const auto\u0026 i : vec) { std::cout \u003c\u003c i \u003c\u003c ' '; } std::cout \u003c\u003c std::endl; } // 删除某个项的方法 void erase(std::vector\u003cint\u003e\u0026 vec, int a) { for (auto iter = vec.begin(); iter != vec.end();) { if (*iter == a) { iter = vec.erase(iter); // erase 返回 当前项的下一项的迭代器 } else { ++iter; } } } vector 迭代器用法： C++ STL vector容器迭代器用法详解 (biancheng.net)。 真正可以释放内存的方法是同时调用 clear() 与 shrink_to_fit() 函数，其它 容器 同理。对于内存并不紧张的场景，这个并不常用。 C++ STL标准库容器真正减少空间的方法_vs中的std::list怎么强制清空内存-CSDN博客。 C++11中的emplace_back与push_back区别 C++11中的emplace_back与push_back区别_emplaceback和pushback-CSDN博客 emplace、emplace_back等_emplace()函数的用法-CSDN博客 从结果可以看出，在对vector的插入过程中，push_back方法构造了一次，移动了两次；使用emplace_back只进行了一次构造，没有进行内存的移动。 对于把较复杂的类（C++ 容器如 vector / list / map 等）作为容器的基本单位，向容器添加元素的时候建议 emplace_back()，其它原生类型（char / int 等）等建议用 push_back()， 自己定义类的构造函数，可以提供全：一般构造函数、拷贝构造函数（className\u0026）、移动构造函数（\u0026\u0026 和 std::move()）。 list 链表。用法与 std::vector 大同小异。 ＜C++＞ list容器本质|常用接口|自定义排序规则_c++ list 排序-CSDN博客。 对于list，遍历，把符合某个条件的项删掉给另一个list std::list\u003cstd::string\u003e dirs; std::list\u003cstd::string\u003e filesDirs_; for(std::list\u003cstd::string\u003e::iterator it = filesDirs_.begin() ; it != filesDirs_.end() ; ) { if(it-\u003eisDir ...) { dirs.push_back((*it)); // Accept the iterator returned by \"erase\", it point to next node it = filesDirs_.erase(it); continue; } it++; } forward_list 单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能 array 参考：C++ array_星空那么亮的博客-CSDN博客_c++array。C++基础之容器——array详解_helpburn的博客-CSDN博客_array c++。 array 是序列式容器，类似于 C 语言的数组，是固定大小的，一旦定义完成后就无法进行扩容或收缩。 #include \u003carray\u003e std::array\u003cint, 4\u003e arr = { 1, 3, 2, 4 }; for (auto it = arr.begin(); it != arr.end(); it++) { std::cout \u003c\u003c *it \u003c\u003c \" \"; } 有方法：begin（返回一个指向array容器第一个元素的迭代器，迭代器可以随机移动和访问元素），end，size，max_size，empty，at，front（返回第一个元素的引用），back，data，fill，swap 等。 deque 参考： C++——deque的了解和使用_c++ deque-CSDN博客。 std::deque - cppreference.com。 Deque是一种线性数据结构，它允许在两端进行插入和删除操作。这两端通常被称为前端（front）和后端（rear），或者端点1和端点2。Deque的灵活性在于，它既可以用作队列（FIFO，先进先出），也可以用作栈（LIFO，后进先出），具体取决于元素的插入和删除操作是在哪一端进行的。deque是C++STL（标准模板库）中的一种容器，可以用于存储各种类型的元素。deque的特点是可以在队列的两端进行元素的操作，并且可以高效地在队列的任意位置进行元素的插入和删除操作。 stack 参考：c++ stack用法详解_斯文～的博客-CSDN博客_c++ stack。C++中stack使用详细说明_","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:5","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"lambda 参考 lambda 表达式 (C++11 起) - cppreference.com。 [C++]lambda_c++ lamda-CSDN博客 Lambda 表达式 - OI Wiki (oi-wiki.org) 完整格式： auto fun_xxx = [ 捕获变量 ] ( 形参 ) mutable -\u003e void { 函数内容 }; []：捕捉列表，捕捉上下文中的变量，然后用于lambda使用。 ()：参数列表，与函数的参数列表类似，如果不需要传递参数 可以不写 ()。 mutable：默认条件下，lambda总是有一个const特性，即捕获的变量不能修改，我们可以通过mutable取消掉它的这个特，加上mutable时，()不能省略。 -\u003e returntype：返回值类型，当没有返回值可以不写，当返回值类型非常明确，也可以不写，编译器会推导。 {}：函数体，也就是我们写函数时需要用{}包起来的部分。 可以将 lambda 函数 赋值给 某个变量，可以在后面调用 auto getUrl = [archive, \u0026rels, this](ByteArray const \u0026 type, String \u0026 result) { ...} getUrl(\"xxx1\", xxx1); getUrl(\"xxx2\", xxx2_); 说明，即便是相同参数和返回值的 lambda 和 函数指针，二者的类型也不同； 使用 std::function::target_type().name() 看出，而且如果 std::function 存一个 lambda，用 std::function::target\u003c函数指针类型\u003e() 会返回 null，使用 std::function::target\u003clambda 类型\u003e() 才会返回填入的 lambda；一个 c 函数如果接收 函数指针 那么不能接受 同类型的参数和返回值的 存于 std::function 的 lambda。为了 c/c++ 同时的可移植性，还是多考虑下 软件分层的 哪一层 用哪个，一般 高层次的应用层 c++ 多一些，偏底层的 就是 c 的写法。 // 判断的写法： typedef void(*lv_btn_cb_fun)(lv_event_t*); const std::function\u003cvoid(lv_event_t*)\u003e _fun = ... if(!_fun) { LV_LOG_ERROR(\"empty _fun\"); return -1; } const lv_btn_cb_fun* callBackFun = _fun.target\u003clv_btn_cb_fun\u003e(); // if the fun in \"_fun\" is not \"lv_btn_cb_fun\" type, \"_fun.target\u003c\u003e()\" will return null, // use lambda fun storage in \"_fun\", the target_type is not \"lv_btn_cb_fun\", and it can't pass to \"lv_obj_add_event_cb\", so no use of it if(!callBackFun) { LV_LOG_ERROR(\"null _fun\"); return -1; } constexpr lambda 表达式 C++ 17 起。 使得 lambda 在编译期计算。 constexpr auto lamb = [] (int n) { return n * n; }; static_assert(lamb(3) == 9, \"a\"); 注意：constexpr函数有如下限制： 函数体不能包含汇编语句、goto语句 / label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:6","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类型别名 using 参考 类型别名，别名模板 (C++11 起) - cppreference.com。 例子： template\u003cclass T\u003e using Vec = vector\u003cT, Alloc\u003cT\u003e\u003e; // 类型标识为 vector\u003cT, Alloc\u003cT\u003e\u003e Vec\u003cint\u003e v; // Vec\u003cint\u003e 等同于 vector\u003cint, Alloc\u003cint\u003e\u003e ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:7","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类型推导 auto \u0026 decltype 基本用法： auto 用于推导变量类型，decltype 用于推导表达式返回值类型 int main() { auto a = 10; // 10是int型，可以自动推导出a是int int x = 0; decltype(x) y; // y是int类型 decltype(x + y) z; // z是int类型 return 0; } 引自 这些知识点你都知道吗，测试你的C++入门程度 (qq.com)。 更详细的： 可参考 C++11的类型推导详解 - 知乎 (zhihu.com)，有很多例子，举例了各种情况。 C++14， auto 可用于 函数返回值 类型推导，模板函数返回值 类型推导，lambda 函数的形参 类型推导。 但是感觉这些并不常用，返回值什么的，若不是在写模板，还是标好一些地方的类型吧，少做谜语人。 #include \u003ciostream\u003eusing namespace std; // --- auto func(int i) { return i; } // --- template\u003ctypename T\u003e auto func(T t) { return t; } cout \u003c\u003c func(4) \u003c\u003c endl; cout \u003c\u003c func(3.4) \u003c\u003c endl; // --- auto f = [] (auto a) { return a; }; cout \u003c\u003c f(1) \u003c\u003c endl; cout \u003c\u003c f(2.3f) \u003c\u003c endl; 引自 C++14新特性的所有知识点全在这儿啦！ - 知乎 (zhihu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:8","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"枚举类 enum class 枚举类 为 带有作用域的枚举类型，可在 C++ 环境中 完全替代 enum，使用类似 命名空间的方式用 各个枚举变量，防止原来 enum 的 全局重名 和 不同 enum 类型的变量可互相直接赋值 等问题。 enum class AColor { kRed, kGreen, kBlue }; enum class BColor { kWhite, kBlack, kYellow }; int main() { if (AColor::kRed == BColor::kWhite) { // 编译失败 cout \u003c\u003c \"red == white\" \u003c\u003c endl; } return 0; } 引自 这些知识点你都知道吗，测试你的C++入门程度 (qq.com)、 c++11 的 union 中 允许数据成员类型有 非POD类型。 POD类型 大体上可以理解为对象可以直接memcpy的类型。 C++ POD与非POD类型的区别 - 问答 - 亿速云 (yisu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:9","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"编译期计算 constexpr constexpr：修饰 常量 和 函数，由编译期来完成 计算 和 函数\"内敛功能\"（特别是在定义小的、编译时可计算的函数时） 等。 constexpr 保证的是编译时的常量性，而 inline 则是建议编译器进行内联展开以优化性能。 constexpr int32_t constNum = 1 + 2 + 3; constexpr int func(int i) { return i + 1; } C++14中可以使用局部变量和循环。C++11中constexpr函数必须必须把所有东西都放在一个单独的return语句中，而 C++14 的 constexpr则无此限制。 constexpr int factorial(int n) { // C++11中不可，C++14中可以 int ret = 0; for (int i = 0; i \u003c n; ++i) { ret += i; } return ret; } constexpr int func(bool flag) { // C++11中不可，C++14中可以 if (flag) return 1; else return 0; } 引自 C++14新特性的所有知识点全在这儿啦！ - 知乎 (zhihu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:10","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"编译期检查 static_assert 参考 static_assert 声明 (C++11 起) - cppreference.com。 c++11 引入，用于编译期进行检查，若第一个参数值为 false，则打印 message，报编译失败错误。 例子： static_assert(true/false, message); ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:11","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"二进制字面量 参考 整数字面量 - cppreference.com。 int a = 0b0001'0011'1010; double b = 3.14'1234'1234'1234; 二进制字面量与整形字面量分隔符，C++14新特性的所有知识点全在这儿啦！ - 知乎 (zhihu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:12","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"字符字面量 参考 字符字面量 - cppreference.com，这里面有例子。 u8'.'：UTF-8 字符字面量，例如 u8’a'。这种字面量具有 char(C++20 前)char8_t(C++20 起) 类型，且它的值等于c字符 ﻿的。 u'.'：UTF-16 字符字面量，例如 u’猫'，但不是 u'🍌'（u'\\U0001f34c'）。这种字面量具有 char16_t 类型。只要该值能以单个 UTF-16 代码单元表示（即c字符 ﻿处于范围 0x0-0xFFFF（含边界）内）。 U'.'：UTF-32 字符字面量，例如 U’猫' 或 U'🍌'。这种字面量具有 char32_t 类型。 L'.'：宽字符字面量，例如 L’β' 或 L’猫'。这种字面量具有 wchar_t 类型。 参考 字符串字面量 - cppreference.com，这里面有例子。 一些修饰字符串的符号，下面，不带 R 的 为 s字符序列：就是基本字符串，带 R 的 为 d字符序列：不包括括号、反斜杠和空格。 参考 字符集与编码 - cppreference.com。 \"...\"，R\"...\"：普通字符串字面量 const char[N]。 L\"...\"，LR\"...\"：宽字符串字面量 const wchar_t[N]。 u8\"...\"，u8R\"...\"：UTF-8 字符串字面量 const char[N] (C++20 前)，const char8_t[N] (C++20 起)。 u\"...\"，uR\"...\"：UTF-16 字符串字面量 const char16_t[N]。 U\"...\"，UR\"...\"：UTF-32 字符串字面量 const char32_t[N]。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:13","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"自定义字面量 个人觉得还是少用，太谜语人了，写完后也许自己很清楚，但是别人看着会比较绕。 constexpr long double operator\"\" _d2r( long double deg ) { long double radians = deg * std::numbers::pi_v\u003clong double\u003e / 180; return radians; } double x_rad = 90.0_d2r; //x_rad = 1.570796 引自 C++ 的用户自定义字面量_c++ 自定义字面量-CSDN博客。 struct mytype { unsigned long long value; }; constexpr mytype operator\"\" _mytype ( unsigned long long n ) { return mytype{n}; } mytype mm = 123_mytype; cout \u003c\u003c mm.value \u003c\u003c endl; 引自 c++11新特性，所有知识点都在这了！ - 知乎 (zhihu.com) 里面 自定义字面量 一节。 参考 用户定义字面量 (C++11 起) - cppreference.com。 支持的种类： 用户定义整数字面量，例如 12_km 用户定义浮点字面量，例如 0.5_Pa 用户定义字符字面量，例如 'c'_X 用户定义字符串字面量，例如 \"abd\"_L 或 u\"xyz\"_M ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:14","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"动态创建内存对齐的对象 参考 内存对齐 - 知乎 (zhihu.com)。 结构体和类的基本内存对齐规则 很基础可网搜。 什么是内存对齐 理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数N的倍数，这就是内存对齐。 为什么要内存对齐 硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。 提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。 内存对齐规则 数据成员对齐规则：struct或者union的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员都按照#pragma pack数值和这个数据成员自身大小中更小的那个进行对齐。 整体对齐规则：struct或者union的首地址按照内部最大数据成员的大小和#pragma pack数值较小的那个N进行对齐，并且结构体的总大小为N的整数倍，如有必要编译器也会在最后一个成员后面填充一些字节用于对齐。 静态自定义内存对齐的数据结构：声明自定义内存对齐的结构体或类 // c 语言标准关键字：#pragma pack // pragma pack(n) alignment must be a power of two #pragma pack(2) //指定按两字节对齐 ... #pragma pack() // 取消指定对齐 // --- // gcc 编译器扩展关键字 __attribute__((aligned)) struct A { char a; ... } __attribute__((aligned)) / __attribute__((aligned(1))) / __attribute__((packed)); // __attribute__((packed))告诉编译器取消编译中的内存对齐优化，采用实际占用的字节数进行对齐 // __attribute__((aligned(N))) 告诉编译器在编译过程中按照N字节对齐，经过测试这个N只有大于结构体中最大的变量的大小才有用 // __attribute__((aligned)) 后面不接数字，告诉编译器根据目标机制采用最大最有益的方式对齐，基本上就是16字节对齐 // alignof(X) 返回某类型的对齐大小，与std::alignment_of类似，这两个功能完全相同，但是std::alignment_of可以用于模板元编程 动态创建自定义内存对齐的对象： class A { int a; char d; }; // 创建给定类型对象大小满足对齐要求的未初始化内存块，在一个内存对齐的缓冲区上创建对象 // C++11后可以这样操作 void align_cpp11_after() { static std::aligned_storage\u003csizeof(A), alignof(A)\u003e::type data; A *attr = new (\u0026data) A; } // C++11之前 void align_cpp11_before() { static char data[sizeof(void *) + sizeof(A)]; const uintptr_t kAlign = sizeof(void *) - 1; char *align_ptr = reinterpret_cast\u003cchar *\u003e(reinterpret_cast\u003cuintptr_t\u003e(data + kAlign) \u0026 ~kAlign); A *attr = new (align_ptr) A; } 关于 alignof 和 alignas： alignof 运算符(C++11 起) - cppreference.com。 alignas 说明符 (C++11 起) - cppreference.com。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:15","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"内存申请和释放 new \u0026 delete 补充参考和引用： C++ 动态内存 | 菜鸟教程 (runoob.com)、C++ new和delete运算符简介 (biancheng.net)。new、new()和new 三者的区别_西雅图_Seattle的博客-CSDN博客_new()。 new[]和delete[]为何要配对使用？ 为了自定义类型（如类）的正确 释放 / 析构。 /* 获取数组的成员个数 */ #define ARR_SIZE(arr) sizeof(arr)/sizeof((arr)[0]) /* 打印数组 */ #define PRINT_ARR(arr) \\ for(i = 0;i \u003c ARR_SIZE(arr);i++) \\ cout \u003c\u003c arr[i] \u003c\u003c ' '; \\ cout \u003c\u003c endl; /* ———————— 申请 变量 和 数组 ———————— */ double* pvalue = new double; if(NULL == pvalue) exit(-1); /* new 后跟 类型名，也可以是类 */ int* arr_ptr = new int(10); // 开辟 1 个 int 空间，并赋初值为 10 if(NULL == arr_ptr) exit(-1); cout \u003c\u003c *arr_ptr \u003c\u003c endl; cin \u003e\u003e n; int* arr = new int[n]; // 开辟 n 个 int 空间 的数组，地址连续 if(NULL == arr) exit(-1); for(i = 0;i \u003c ARR_SIZE(arr);i++) // 挨个填充值，可以空格隔开，如输入 -1 2 6 cin \u003e\u003e arr[i]; PRINT_ARR(arr); delete[] arr; // 释放 new 申请的数组空间 delete arr_ptr; // 释放 new 申请的变量空间 delete pvalue; /* ———————— 申请 m 行 n 列 的 二维数组 ———————— */ cin \u003e\u003e m \u003e\u003e n; int** array = new int* [m]; // 分配 m 个指针空间（指针数组） for(unsigned int i = 0; i \u003c m; i++) { array[i] = new int [n]; // 对指针数组每一个指针所指地址再申请 n 个 int 空间 } // 释放 for(unsigned int i = 0; i \u003c m; i++) { delete [] array[i]; } delete [] array; struct 里面有 std::string，申请和释放这个 struct 内存用 new 和 delete 在为string分配空间时需要调用string的构造方法，而malloc无法调用，故程序会报错，而new拥有调用构造函数的功能 c++链表/结构体中含有string类型使用malloc分配内存失败/报错_结构体内部有c++类型却使用了malloc-CSDN博客 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:16","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"智能指针 参考 C++ 智能指针_TABE_的博客-CSDN博客_c++智能指针。c++智能指针详解_bitcarmanlee的博客-CSDN博客_c++ 智能指针。c++ 智能指针_lucky九年的博客-CSDN博客_c++智能指针。 c++11新特性之智能指针 - 知乎 (zhihu.com)。 内存管理库 - cppreference.com. 推荐多用智能指针管理内存，可一定程度防止内存泄漏等。 推荐多做 RAII（利用对象生命周期管理资源）风格编码，如 使用 智能指针。 unique_ptr，拥有独有对象所有权的智能指针。 推荐使用 std::make_unique （C++14）创建。 shared_ptr，拥有共享对象所有权的智能指针。 推荐使用 std::make_shared 创建。 自定义类 继承 enable_shared_from_this，则允许 类 创建 并 通过 shared_from_this() 来获得 指向 this 的 shared_ptr。 对于上两点，unique_ptr 和 weak_ptr 同理。 weak_ptr，使用 std::shared_ptr 所管理对象的弱引用，可解决 std::shared_ptr 中出现 互相引用 导致资源永不释放 的 问题。 可看链接里面，有多种基础例子。 shared_ptr： 当一个 shared_ptr 实例对象超出作用域 就会释放其包含的指针对应的内存，或者调用 .reset()，推荐使用 make_shared() 创建 shared_ptr 对象 C++:共享指针shared_ptr的理解与应用_shareptr-CSDN博客 有很多好例子 智能指针——shared_ptr_sharedptr-CSDN博客 原理和注意事项 各个智能指针 std::auto_ptr、std::unique_ptr、std::shared_ptr 的设计思路和模拟实现，逐个进化，并且存在的特定环境下出现的问题 智能指针 smart_ptr_smartptr-CSDN博客 [【C++修炼之路】32.智能指针_ptradc-\u003eptrmaxch] = (ptradc-\u003eptrdata[ch] \u003e ptradc-CSDN博客 好处：不需要显式地释放资源。采用这种方式，对象所需的资源在其生命期内始终保持有效。 // 简单测试：创建 std::shared_ptr 指针的几种写法，但推荐 std::make_shared std::shared_ptr\u003cint\u003e p0 = std::make_shared\u003cint\u003e(); std::shared_ptr\u003cint\u003e p00 = std::make_shared\u003cint\u003e(5); std::shared_ptr\u003cint\u003e p1 = std::shared_ptr\u003cint\u003e(new int(10)); // 由 new int(10) 分配的内存的地址用std::shared_ptr类型构造 再赋值给 p1 std::shared_ptr\u003cint\u003e p2(new int(15)); std::shared_ptr\u003cint\u003e p22(nullptr); std::shared_ptr\u003cint\u003e p222 = nullptr; std::shared_ptr\u003cint\u003e p222_(p00); std::shared_ptr\u003cint\u003e p222__ = p1; std::cout \u003c\u003c \" -- 1 p0 -- \" \u003c\u003c p0.use_count() \u003c\u003c \" -- \" \u003c\u003c *p0 \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p00 -- \" \u003c\u003c p00.use_count() \u003c\u003c \" -- \" \u003c\u003c *p00 \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p1 -- \" \u003c\u003c p1.use_count() \u003c\u003c \" -- \" \u003c\u003c *p1 \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p2 -- \" \u003c\u003c p2.use_count() \u003c\u003c \" -- \" \u003c\u003c *p2 \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p22 -- \" \u003c\u003c p22.use_count() \u003c\u003c \" -- \" \u003c\u003c \"no *p22\" \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p222 -- \" \u003c\u003c p222.use_count() \u003c\u003c \" -- \" \u003c\u003c \"no *p222\" \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p222_ -- \" \u003c\u003c p222_.use_count() \u003c\u003c \" -- \" \u003c\u003c *p222_ \u003c\u003c std::endl; std::cout \u003c\u003c \" -- 1 p222__ -- \" \u003c\u003c p222__.use_count() \u003c\u003c \" -- \" \u003c\u003c *p222__ \u003c\u003c std::endl; *p1 = 99; std::cout \u003c\u003c \" -- 2 -- \" \u003c\u003c p1.use_count() \u003c\u003c \" -- \" \u003c\u003c *p1 \u003c\u003c std::endl; { std::shared_ptr\u003cint\u003e ppp1 = p1; *ppp1 = 11; std::cout \u003c\u003c \" -- 3 -- \" \u003c\u003c p1.use_count() \u003c\u003c \" -- \" \u003c\u003c *p1 \u003c\u003c std::endl; } std::cout \u003c\u003c \" -- 4 -- \" \u003c\u003c p1.use_count() \u003c\u003c \" -- \" \u003c\u003c *p1 \u003c\u003c std::endl; p1.reset(); // set nullptr, free mem std::cout \u003c\u003c \" -- 5 -- \" \u003c\u003c p1.use_count() \u003c\u003c std::endl; // 再使用 *p1 就会报错 // 打印：引用计数的变化，若 p1 出了生命周期 或者 其计数 为 0，就自动释放内存 -- 1 p0 -- 1 -- 0 -- 1 p00 -- 2 -- 5 -- 1 p1 -- 2 -- 10 -- 1 p2 -- 1 -- 15 -- 1 p22 -- 0 -- no *p22 -- 1 p222 -- 0 -- no *p222 -- 1 p222_ -- 2 -- 5 -- 1 p222__ -- 2 -- 10 -- 2 -- 2 -- 99 -- 3 -- 3 -- 11 -- 4 -- 2 -- 11 -- 5 -- 0 shared_ptr 存在的一些潜在的内存泄漏的场景 shared_ptr产生内存泄漏的场景_shared指针泄漏-CSDN博客 std::shared_ptr 用于 多个对象共享同一资源，当不再需要资源时会自动销毁资源。 weak_ptr 的主要作用是 避免循环引用，即当两个 shared_ptr 互相引用对方时，会导致引用计数无法归零，从而内存无法释放。 std::weak_ptr 用于避免 循环引用，允许对对象进行观察，但不会增加引用计数，通常与 shared_ptr 配合使用。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:17","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类型转换 cast 可参考 这个链接里面的 类型转换 一节，各种类型转换的情况一看便知：这些知识点你都知道吗，测试你的C++入门程度 (qq.com)。 // static_cast，通常用于 c/c++ 基础类型相互之间的转换 float f = 1.0f; int a = static_cast\u003cint\u003e(f); // const_cast，解 const 指针的，不推荐用 const char* cc = \"hello world\\n\"; char* c = const_cast\u003cchar*\u003e(cc); // dynamic_cast，基类指针 转 子类指针。反过来，则 子类指针变量 可以直接 通过 等号 赋值 给 基类指针变量 struct Base {}; struct Derive : public Base {}; void func() { Base* base = new Derive; Derive* derive = dynamic_cast\u003cDerive*\u003e(base); } // reinterpret_cast，void* 和 类指针之间 相互转 A *a = new A; void* d = reinterpret_cast\u003cvoid*\u003e(a); 对于 std::shared_ptr 的 基类指针 转 子类指针，使用 std::dynamic_pointer_cast()。 C++四种cast的详细介绍_c++ cast-CSDN博客。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:18","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"引用 补充参考 C++引用精讲，C++ \u0026用法全面剖析 (biancheng.net)。c++引用_路过的小熊~的博客-CSDN博客。 引用 - OI Wiki (oi-wiki.org)。 作用： 给变量起别名。 语法： 数据类型\u0026 别名 = 原名。本质：引用的本质在c++内部实现是一个常量指针 特点： 引用必须初始化。 引用在初始化后，不可以改变。 函数传参时，可以利用 “引用” 让修饰形参（等效于传入指针可以变量修改），也可以修饰 返回值（函数内不要返回局部变量的引用）。通过引用参数产生的效果同按 地址/指针 传递是一样的，引用的语法更清楚简单。 在函数形参列表中，可以加 const 修饰形参 ，防止形参改变实参，增加引用的安全性。 不能建立数组的引用。 // 引用修饰 形参 和 返回值。传入 a b 进行交换，再返回 静态变量 c。 int\u0026 test02(int\u0026 a, int\u0026 b, const int\u0026 v) { /* v 只能读，不能改 */ // v += 10; int temp = a; a = b; b = temp; static int c = 30; return c; } int\u0026 test01() { static int a = 20; return a; // 函数内返回引用变量必须为 static 修饰 或 全局变量 } int main() { int a1; const int\u0026 ra=a1; // ra = 1; // 错误 a1 = 1; // 正确 int temp_a = 10, temp_b = 20; int\u0026 ref2 = test02(temp_a, temp_b, temp_a + temp_b); /* int\u0026 ref2 = xxx; 编译器认为为 int* const ref = \u0026xxx */ cout \u003c\u003c \"temp_a = \" \u003c\u003c temp_a \u003c\u003c \" \" \u003c\u003c \"temp_b = \" \u003c\u003c temp_b \u003c\u003c endl; cout \u003c\u003c \"ref2 = \" \u003c\u003c ref2 \u003c\u003c endl; int\u0026 ref1 = test01(); cout \u003c\u003c \"ref1 = \" \u003c\u003c ref1 \u003c\u003c endl; test01() = 1000; /* 这样等效于修改 变量 ref1 */ /* 编译器发现 ref1 是引用，自动帮我们转换为: *ref1 = 1000; */ cout \u003c\u003c \"ref1 = \" \u003c\u003c ref1 \u003c\u003c endl; system(\"pause\"); return 0; } /* 打印信息 temp_a = 20 temp_b = 10 ref2 = 30 ref1 = 20 ref1 = 1000 */ std::ref、std::cref 参考： C++库std::ref-CSDN博客。 C++11的std::ref、std::cref源码解析 - 知乎 (zhihu.com)。 遇到 std::bind 或者 给函数传入变量的时候，为了确保是传入 的 引用 而不是 拷贝，使用 std::ref、std::cref 给 实参 套上。 在实际应用中，能用 直接引用 就使用 直接引用。 当： 使用 标准库算法。 函数对象、回调。 使用 std::bind 或其他类似工具。 多线程编程中将引用传递给线程函数。 直接传引用不适用，使用 std：：ref。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:19","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"右值引用 \u0026 移动语义 \u0026 完美转发 参考 左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里 - 知乎 (zhihu.com)。 c++11 新特性总结（三）——右值引用和完美转发 - 知乎 (zhihu.com)。TODO 待看下 右值 下面任意一个条件成立即算： 不可以放到等号左边的东西。 不能取地址的没有名字的东西。 不可访问内存地址的值。 运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值 将亡值（临时产生的，不打算再用了，要把资源搬运给别的变量，自己不再 hold 一份） 将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T\u0026\u0026函数的返回值、std::move函数的返回值、转换为T\u0026\u0026类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。 我理解 右值引用（T\u0026\u0026）、移动语义（std::move），在实践意义上，即主要用于 转移所有权，省去拷贝负担；就是这个资源，要 转移 / 搬运 到别的地方（而不是拷贝一份，是内存上这块资源所处变量 的 换主），就转为右值引用 然后用 移动语义 送出去，送走资源后的变量，就当作亡值不要用了，资源转移出去了，由接着资源的变量来替代了。 T\u0026\u0026 t = std::move(...); // 这个，一般用于 函数形参 和 实参 对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的 移动构造函数。 C++所有的STL都实现了移动语义。 右值变量 给 右值 取别名。右值：不能取地址的值、将亡值。 用于构造函数：移动构造（减少拷贝）（编译器会生成浅拷贝的移动构造，类里面没有涉及到内存申请释放的可以直接用默认的，否则需要自己实现深拷贝的移动构造） 用于模板函数：万能引用（T\u0026\u0026 t）+ 完美转发（std::forward\u003cT\u003e()） C++右值引用与左值详解：移动语义、完美转发的应用-CSDN博客 【C++】右值引用和移动语义（带你理解C++为何如此高效）_c++右值引用和移动语义-CSDN博客 完美转发 / 转发右值引用 写一个 接受任意实参 的 函数模板 A，并 调用 其它函数 B 和 直接传入参数，目标函数 B 会收到 与 转发函数 A 完全相同的实参。 TODO：参考 上面 链接 里面的。还需要自己相关的，总结下放这里 返回值优化 返回值优化(RVO)是一种C++编译优化技术。当函数需要返回一个对象实例时候，就会创建一个临时对象并通过 复制构造函数 将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。 触发编译器的返回值优化，同时满足如下： return的值类型与函数的返回值类型相同 return的是一个局部对象 下面这段代码会触发RVO，不拷贝也不移动，不生成临时对象： std::vector\u003cint\u003e return_vector(void) { std::vector\u003cint\u003e tmp {1,2,3,4,5}; return tmp; } std::vector\u003cint\u003e rval_ref = return_vector(); 值类别 - 复制消除 - OI Wiki (oi-wiki.org)。值类别 - 常见误区 - OI Wiki (oi-wiki.org)。 复制消除中的返回值优化（Return Value Optimization，RVO）。 在 f1 中返回 std::move(x) 是多余的，并不会带来性能上的提升，反而会干扰编译器进行 NRVO 优化。 在 f2 中返回 std::move(x) 是危险的，函数返回右值引用指向了已被销毁的局部变量 s，出现了悬空引用问题。 std::string f1() { std::string s = \"123\"; // 等价于 return std::string(std::move(s)) return std::move(s); } std::string\u0026\u0026 f2() { std::string s = \"123\"; return std::move(s); } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:20","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"函数默认值 \u0026 占位参数 \u0026 重载 函数默认值 函数的形参列表中的形参是可以有默认值的。 注意点： 从带有默认参数的形参开始，右面所有的形参都要带默认参数。 如果函数声明有默认值，函数实现的时候就不能有默认参数。 // 从带有默认参数的形参开始，右面所有的形参都要带默认参数 int func(int a, int b = 10, int c = 10) { return a + b + c; } // 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a = 10, int b = 10); int func2(int a, int b) { return a + b; } int main() { cout \u003c\u003c \"ret = \" \u003c\u003c func(20, 20) \u003c\u003c endl; cout \u003c\u003c \"ret = \" \u003c\u003c func(100) \u003c\u003c endl; system(\"pause\"); return 0; } /* 打印信息 ret = 50 ret = 120 */ 函数占位参数 函数的形参列表里可以有占位参数（但只写变量类型不用写变量名），用来做占位，调用函数时必须填补该位置。在个别高级编程场景里面会用到。 // 函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) { cout \u003c\u003c \"this is func\" \u003c\u003c endl; } int main() { func(10,10); // 占位参数必须填补 system(\"pause\"); return 0; } 函数重载 函数名相同但参数列表不同的多个函数共存，调用时通过传入不同参数形式来区分调用哪一个。 函数重载满足条件 和 例子： 同一个作用域下。 函数名称相同。 函数参数类型不同 或者 个数不同 或者 顺序不同。函数的返回值不作为函数重载的条件。 引用也算，带不带 const 修饰的形参 也算不同（传入参数也根据是不是常量来区分调用哪一个函数）。 函数默认参数 也算不同，但要注意调用时候不要产生歧义。 void func() {} // 调用例子：func(); void func(int a) {} // 调用例子：func(10); void func(double a) {} // 调用例子：func(3.14); void func(int a ,double b) {} // 调用例子：func(10, 3.14); void func(double a ,int b) {} // 调用例子：func(3.14, 10); void func(int \u0026a) {} // 调用例子：int a = 10; func(a); 即 调用无 const 的 void func(const int \u0026a) {} // 调用例子： func(10); 即 调用有 const 的 void func2(int a, int b = 10) // 这样调用会产生歧义：func2(10); 碰到默认参数产生歧义，需要避免 void func2(int a) ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:21","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"异常处理 参考 C++ 异常处理 | 菜鸟教程 (runoob.com)。C++异常处理（try catch）从入门到精通 (biancheng.net)。 参考视频 shellmad-c++_57 异常处理_哔哩哔哩_bilibili。 C++异常处理详解-CSDN博客。 基本的异常处理写法：可以写成一个宏，后面调用宏来包裹起来会抛异常的代码段 try { // run something } catch (const std::exception\u0026 e) { std::cout \u003c\u003c \" catch exception: %s\" \u003c\u003c e.what() \u003c\u003c std::endl; } catch (...) { std::cout \u003c\u003c \" catch exception\" \u003c\u003c std::endl; } 抛异常相关： 1. 直接使用 std::runtime_error、std::invalid_argument 等标准异常类，这些类都允许传递错误消息。例如： try { throw std::runtime_error(\"Something went wrong during execution!\"); } catch (const std::exception\u0026 e) { std::cout \u003c\u003c \"Caught an exception: \" \u003c\u003c e.what() \u003c\u003c std::endl; // 打印异常信息 } C++ 标准库中有很多内置的异常类型，它们都继承自 std::exception，并且允许你传递一个错误消息。比如其它的标准异常类： std::invalid_argument：表示无效参数的异常。 std::out_of_range：表示超出范围的异常。 std::logic_error：表示程序逻辑错误的异常。 std::domain_error：表示非法域的异常。 std::length_error：表示容器的大小超过允许范围。 2. 可以创建一个继承自 std::exception 的类。这个类需要重载 what() 方法来返回异常信息。 自己的习惯： 1、自己写的程序，尽量不主动抛异常（代码一复杂、层次一多，就麻了）。 2、写 C++ 的代码中，所有可能抛异常的地方均用 try catch 处理并打印 log（用上面的宏 TRY_CATCH(_exec) 套上即可），防止此类的 crash。 从机制上，c++做不到可能抛异常的API没有加try catch就编译给警告或报错；而且也不推荐强制做。 异常是动态的，抛出的异常类型是在运行时确定的，而不是在编译时可以精确推断的。C++ 并没有强制要求所有可能抛出异常的代码都必须被 try-catch 包围。相反，C++ 的异常处理设计允许开发者灵活地选择是否处理异常，这样可以根据具体的应用需求和性能考虑来决定是否使用异常机制。 如果编译器强制要求捕获所有可能抛出的异常，可能会导致额外的性能开销和代码复杂性，这违背了 C++ 作为一门高效编程语言的设计理念。 你的c++团队还在禁用异常处理吗？ (qq.com) 虽然链接中文章表示异常是比返回值更好的处理错误的方式，但是本文作者个人表示自己写的程序还是尽量不抛出异常，程序一大不好控制，得总是分出点注意力来处理异常（且容易忘），一旦函数嵌套层数一多就容易乱且难维护，使用库的方法可能抛出异常则必须要写上 catch 异常，除非能够保证输入参数等一定正确使用使得方法不抛异常。但是也不要过度是使用返回值的判断（一串 if else 的判断）和层层返回传递，某一层出错，视情况严重性，是直接终止程序（后面依靠比较完备的测试来逐渐收敛程序 bug 来提高程序健壮性），还是及时在当下来处理错误（如给个默认值等）。 下面是链接文章中的一些精华，也可以参考： 异常处理对于错误的处理更简洁，可以更方便的把错误信息反馈给调用者，同时不需要调用者使用额外的ifelse分支来处理成功或者不成功的情况。如果不是特别特别注重实时性能或者特别在乎程序的体积我们完全可以使用异常处理替代我们平时使用的c语言中的那种错误码处理方式。 如果有更多的运算，或者有更多的错误码，异常处理的优势会更明显。 使用异常可以使得代码逻辑更清晰，将代码按正确的逻辑列出来，逻辑更紧密代码更容易读懂，而错误处理可以单独放到最后做处理。 异常可以选择自己处理或者传递给上层处理 异常处理的关键点 不应该使用异常处理做什么？ throw仅用于抛出一个错误，标识函数没有按设想的方式去执行 只有在知道可以处理错误时，才使用catch来捕获错误，例如转换类型或者内存分配失败 不要使用throw来抛出编码错误，应该使用assert或者其它方法告诉编译器或者崩溃进程收集debug信息 如果有必须要崩溃的事件，或者无法恢复的问题，不应该使用throw抛出，因为抛出来外部也无法处理，就应该让程序崩溃 try、catch不应该简单的用于函数返回值，函数的返回值应该使用return操作，不应该使用catch，这会给编程人员带来误解，同时也不应该用异常来跳出循环 异常处理看似简单好用，但它需要项目成员严格遵守开发规范，定好什么时候使用异常，什么时候不使用，而不是既使用异常又使用错误码方式。 构造函数可以抛出异常吗？可以而且建议使用异常，因为构造函数没有返回值，所以只能抛出异常，也有另一种办法就是添加一个成员变量标识对象是否构造成功，这种方法那就会额外添加一个返回该返回值的函数，如果定义一个对象数组那就需要对数组每个对象都判断是否构造成功，这种代码不太好。 构造函数抛出异常会产生内存泄漏吗？不会，构造函数抛出异常产生内存泄漏那是编译器的bug，已经在21世纪修复，不要听信谣言。 void f() { X x; // If X::X() throws, the memory for x itself will not leak Y* p = new Y(); // If Y::Y() throws, the memory for *p itself will not leak } 永远不要在析构函数中把异常抛出，还是拿对象数组举例，数组里有多个对象，如果其中一个对象析构过程中抛出异常，会导致剩余的对象都无法被析构，析构函数应该捕获异常并把他们吞下或者终止程序，而不是抛出。 构造函数内申请完资源后抛出异常怎么办？使用智能指针，关于char*也可以使用std::string代替。 #include \u003cmemory\u003e using namespace std; class SPResourceClass { private: shared_ptr\u003cint\u003e m_p; shared_ptr\u003cfloat\u003e m_q; public: SPResourceClass() : m_p(new int), m_q(new float) { } // Implicitly defined dtor is OK for these members, // shared_ptr will clean up and avoid leaks regardless. }; 永远通过值传递方式用throw抛出异常，通过引用传递用catch来捕获异常。 可以抛出基本类型也可以抛出对象，啥都可以 catch(…)可以捕获所有异常 catch过程中不会触发隐式类型转换 异常被抛出，但是直到main函数也没有被catch，就会std::terminate() c++不像java，不会强制检查异常，throw了外层即使没有catch也会编译通过 异常被抛出时，在catch之前，try和throw之间的所有局部对象都会被析构 如果一个成员函数不会产生任何异常，可以使用noexcept关键字修饰 通过throw可以重新抛出异常 指定函数不会抛出异常 以及验证 函数是否会抛异常 noexcept： 参考 noexcept 说明符 (C++11 起) - cppreference.com。noexcept 运算符 (C++11 起) - cppreference.com void f() noexcept; // 函数 f() 不会抛出 void (*fp)() noexcept(false); // fp 指向可能会抛出的函数 void may_throw(); void no_throw() noexcept; // !noexcept(may_throw()) 为 true， 即 可能会 抛异常 // !noexcept(no_throw()) 为 false，即 不会 抛异常 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:22","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"属性 参考： 属性说明符序列 (C++11 起) - cppreference.com。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:23","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"标准属性 C++ 标准定义了下列属性。 标准属性不能在语法上被忽略：它们不能包含语法错误，必须应用到正确的目标，并且实参中的实体都会被 ODR 使用。 标准属性也不能在语义上被忽略：程序在去掉某个标准属性的所有实例的情况下的行为必须是该程序在保留该属性的情况下遵守标准要求的行为。 属性 释义 [[noreturn]](C++11) 指示函数不返回 (属性指示符) [[carries_dependency]](C++11) 指示在函数内外传播“释放-消费”std::memory_order 中的依赖链 [[deprecated]](C++14) [[deprecated(\"*原因*\")]](C++14) 指示以此属性声明的名字或实体，允许使用但因某种 原因 而不鼓励使用 [[fallthrough]](C++17) 指示从前一 case 标号的直落是故意的，且会警告直落的编译器不应当对此诊断 [[maybe_unused]](C++17) 抑制对于未使用实体的编译器警告，如果有 [[nodiscard]](C++17) [[nodiscard(\"*原因*\")]](C++20) 鼓励编译器在返回值被丢弃时发出警告 [[likely]](C++20) [[unlikely]](C++20) 指示编译器应当针对此种情况进行优化：通过某条语句的执行路径比其他任何执行路径更可能或不可能发生 [[no_unique_address]](C++20) 指示一个非静态数据成员不必具有与类中的其他所有非静态数据成员都不同的地址 [[assume(*表达式*)]](C++23) 指示 表达式 在给定的位置永远为 true [[indeterminate]](C++26) 指示对象在未初始化时具有不确定值 [[optimize_for_synchronized]](TM TS) 指示函数定义应当为从同步语句中调用的情况优化 常用的： C++ 属性： maybe_unused (C++17 起) - cppreference.com。 C++ 属性： fallthrough (C++17 起) - cppreference.com。 C++ 属性： noreturn (C++11 起) - cppreference.com。 C++ 属性： likely, unlikely (C++20 起) - cppreference.com。这个 C++ 属性 太新了，慎用。可以用 gcc 的扩展关键字： #define likely(x) __builtin_expect(!!(x), 1) #define unlikely(x) __builtin_expect(!!(x), 0) ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:24","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"结构化绑定 参考 https://zh.cppreference.com/w/cpp/language/structured_binding。C++ 17 起。 auto[i, d] = std::tuple(1, 2.2); cout \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c d \u003c\u003c endl; // --- std::pair a(1, 2.3f); auto[i, f] = a; // 拷贝赋值 // 对于 std::array 也中 // --- map\u003cint, string\u003e m = { {0, \"a\"}, {1, \"b\"}, }; for (const auto \u0026[i, s] : m) { cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c s \u003c\u003c endl; } // --- // 也可以通过结构化绑定改变对象的值 std::pair a(1, 2.3f); auto\u0026 [i, f] = a; i = 2; cout \u003c\u003c a.first \u003c\u003c endl; // 2 // --- constexpr auto[x, y] = std::pair(1, 2.3f); // C++20 可以 // --- // 对于结构体 struct Point { int x; int y; }; Point func() { return {1, 2}; } const auto [x, y] = func(); 实现自定义类的结构化绑定： // 需要实现相关的tuple_size和tuple_element和get\u003cN\u003e方法。 class Entry { public: void Init() { name_ = \"name\"; age_ = 10; } std::string GetName() const { return name_; } int GetAge() const { return age_; } private: std::string name_; int age_; }; template \u003csize_t I\u003e auto get(const Entry\u0026 e) { if constexpr (I == 0) return e.GetName(); else if constexpr (I == 1) return e.GetAge(); } namespace std { template\u003c\u003e struct tuple_size\u003cEntry\u003e : integral_constant\u003csize_t, 2\u003e {}; template\u003c\u003e struct tuple_element\u003c0, Entry\u003e { using type = std::string; }; template\u003c\u003e struct tuple_element\u003c1, Entry\u003e { using type = int; }; } int main() { Entry e; e.Init(); auto [name, age] = e; cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c age \u003c\u003c endl; // name 10 return 0; } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:25","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"if 语句初始化 // if (init; condition) if (int a = GetValue()); a \u003c 101) { cout \u003c\u003c a; } string str = \"Hi World\"; if (auto [pos, size] = pair(str.find(\"Hi\"), str.size()); pos != string::npos) { std::cout \u003c\u003c pos \u003c\u003c \" Hello, size is \" \u003c\u003c size; } 使用这种方式可以约束作用域，可读性可能略有下降但还好 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:26","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类封装 参考 C++ 类 \u0026 对象 | 菜鸟教程 (runoob.com)、C++类和对象（class和object） (biancheng.net)。复习100分钟拿下100分，你能做得到吗？【C++】(面向对象程序设计)（总复习）_哔哩哔哩_bilibili。C++ 数据抽象 | 菜鸟教程 (runoob.com) 介绍将数据封装为类的一些概念。 参考 类 - cppreference.com。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"封装概念 p.s 首先说，类内的 变量 和 函数，在这里统一叫 成员变量 和 成员函数。 类定义的一般做法，写成 .c 与 .h 的库形式： 类内编写 私有数据（变量） + 公有方法（函数的声明），然后放到 .h 里面。即 成员变量/类属性 和 成员函数/类方法 声明在 类 里面。 类中函数的定义 在 .c 文件中，形式为：函数返回值类型 类名::函数名(...)。使用双冒号:: 在 类的 外面 进行定义等 成员变量 和 成员函数。 三种访问权限（public/private/protected 关键字，如不定义则默认为 private）。类内可以访问到所有成员，但类外要看这三种权限。 公共权限 public：类内可以访问 类外可以访问。 私有权限 private：类内可以访问 类外不可以访问，包括 子类/孩子类 也不能访问；但可以通过 在 public 下定义 set/get 操作 的 函数 来专门访问到 这些 private 变量 而间接对外开放，函数内可以做一些 检查/合法化 等操作，如果是设置 set 或 get 操作 的 函数 就让这些 私有变量 变成 只写 或 只读。 保护权限 protected：类内可以访问 类外不可以访问，但是 子类 进行 公有或保护继承 后，子类内部可以访问 到 基类 的 protected 成员。 c++11 中 sizeof 可以直接用在类的数据成员上。 例子：cout \u003c\u003c \"size \" \u003c\u003c sizeof(A::data) \u003c\u003c endl;，其中 A 可以是 结构体 或 类。 实例见后面。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:1","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"特殊修饰 const / static 补充参考： C++ const成员变量和成员函数（常成员函数） (biancheng.net)，C++ const对象（常对象） (biancheng.net)；C++ static静态成员变量详解 (biancheng.net)，C++ static静态成员函数详解 (biancheng.net)。 shellmad-c++_40 常成员函数_哔哩哔哩_bilibili，shellmad-c++_41 常成员变量及初始化列表_哔哩哔哩_bilibili；shellmad-c++_42 静态成员变量_哔哩哔哩_bilibili，shellmad-c++_43 静态成员函数_哔哩哔哩_bilibili。 const 类内的 成员变量 和 成员函数 可以加 const 修饰，对于 常成员变量（在变量声明的最左边加），则初始化后（可以在声明/定义时候初始化值，也可以在构造函数的初始化列表上加）不允许修改，对于 常成员函数（在函数声明的函数名的右边加，类外定义函数的地方不用再加），是下面的情况： const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值。 常对象（在最前面 用 const 修饰 来 创建新对象，如 const A a;），此时，常对象 只能 调用其 常成员函数。 必须在成员函数的声明和定义处同时加上 const 关键字。 static 可参考 static 成员 - cppreference.com。 类内的 成员变量 加 static 修饰，则为 类的对象们共享的变量。 类内 静态的（static 修饰的）成员变量 和 静态或非静态的 成员函数 这三者 均不占 对象空间，即 只有一份/一个实例，所有成员都用这一份/一个实例；而对于 非静态的 成员变量 占用 对象空间，每次例化 新的 对象，都会对 这些 变量 新申请空间。 静态成员函数（在函数声明的最左边加，类外定义函数的地方不用再加）只能访问（包括读写） 类内的静态成员。 例子： class A { private: int class_a_num; public: static unsigned int class_a_count; A() { class_a_count++; cout \u003c\u003c \"A() class_a_count:\" \u003c\u003c class_a_count \u003c\u003c endl; } ~A() { class_a_count--; cout \u003c\u003c \"A() class_a_count:\" \u003c\u003c class_a_count \u003c\u003c endl; } static void class_a_count_show() // 静态函数成员，可以用 A::class_a_count_show() 来全局访问；所有类的实例都用这一份 { cout \u003c\u003c \"static void class_a_count_show():\" \u003c\u003c class_a_count \u003c\u003c endl; // class_a_count = class_a_num; 静态成员函数 只能访问 静态成员变量 } }; unsigned int A::class_a_count = 0; // 静态变量成员 的 初始化必须写到类的外面 int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; A a[5]; cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } 内联变量 C++ 17 起。可在头文件中，初始化类的静态变量成员。 C++类的静态成员变量在头文件中是不能初始化的，但是有了内联变量，就可以达到此目的。 // header file struct A { static const int value; }; inline int const A::value = 10; // ==========或者======== struct A { inline static const int value = 10; } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:2","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"构造 \u0026 析构函数 构造函数 和 析构函数 的 作用 分别为 对 对象 的 初始化 和 清理，定义好之后 分别 由 对象创造 和 销毁 的时候自动调用。 构造函数 三种：无参数、有参数（新对象的某些参数的初始化，即传入变量参数） 和 拷贝构造函数（用于对新对象的成员变量用老对象的成员变量赋值，即传入类的引用，理解为构造函数的函数重载）。 构造函数在对象被定义的时候 自动被调用，析构函数在对象 出作用域 时候 自动被调用。如果 类B 中嵌套了定义 类A 的对象（类A 为 类B 的成员类），那么 类B 在例化对象的时候，先调用 类A 的构造，再调用 类B 的构造，析构顺序与之相反；子类 继承 基类，那么先调用 基类 构造，再 子类 构造；如果 子类 中 继承 和 成员类 均有的情况，那么先 基类 再 成员类 再 子类自己，析构顺序与之相反。 类的构造函数，类例化一个对象时可传参用于对象内 成员变量 的初始化，且可写成函数重载。 类例化时候传参（或者 new 的时候，或者 make_shared() 的 时候，这些均同理）：类名 对象名(参数);。 类内编写构造函数：有几种情况，根据实际需求来 下面是抽象的总结，用于复习，新学习可以看视频，讲的比较清楚 C++40个入门知识点_24_ 浅拷贝与深拷贝_哔哩哔哩_bilibili。 如果不写（则均不用编写构造和析构函数），则编译器生成一个默认的无参的构造函数。或可以显式的指示：类名() = default;（显示的标记，使用编译器生成的无参构造函数）；显式的指示不用构造函数：类名() = delete;。 如果类内不需要申请内存空间，只给一些变量赋值（这是也不需要显式的编写析构函数），可以直接写带传参参数的构造函数：类名(传参){...进行类内变量赋值初始化...}。可以写不同的几个带参数构造函数进行函数重载。或者使用编译器生成的浅拷贝构造函数： 浅拷贝构造函数编译器可以帮着生成，即可以不写，也可以显式的写 ：类名(类名\u0026 obj) = default;，写为 =delete; 即不用拷贝构造函数 / 不许对象进行拷贝构造。类例化时候这样写：类名 对象2 = 对象1; 或 类名 对象2(对象1);，浅拷贝构造函数即：将 对象1 中所有变量拷贝给 对象2（如果类中有承载申请内存空间的指针变量，那么也包括申请了内存的指针地址拷贝过去，这样新对象中这个指针地址空间也使用了和老对象一块内存空间，使用时候会冲突，而且析构时候会多次释放会出错，因此除了特殊用途，类内有申请内存的指针变量的时候就只用浅拷贝）。 如果类内需要申请内存空间（比如给 char* 变量 申请字符串内存空间，给数组、结构体等等申请内存），构造函数就成为拷贝构造函数，即构造函数的传参为类的引用，个人理解为构造函数的一种函数重载。 每次类例化的对象都重新申请属于自己的内存空间，这里就是深拷贝构造函数，需要手写，在拷贝构造函数 类名(类名\u0026 obj){...} 里面，重新申请内存 给 this-\u003e承载申请的内存空间的指针，将obj下的内存数据复制到 this-\u003e承载申请的内存空间的指针 里即可完成深拷贝构造。此时的析构函数：每次对象销毁（出作用域）的时候自动调用析构函数，在里面要进行内存释放。 例子：在 main() 里面两次以不同方式例化对象（两次构造），再两次释放（两次析构）。 class test1 { private: unsigned int test1_a = 10; unsigned int * test1_b_ptr; char* test1_str; unsigned int test1_str_len; #define MAX_STR_LEN 10 public: /* 带参数 构造函数，给类的成员变量进行初始化 */ test1(unsigned int test1_a_in, unsigned int test1_b_in, char* test1_str_in, unsigned int test1_str_in_len) { test1_a = test1_a_in; /* 初始化 test1_a */ test1_b_ptr = new unsigned int(10); /* 初始化 test1_b （先申请空间） */ *test1_b_ptr = test1_b_in; if(test1_str_in_len \u003eMAX_STR_LEN) /* 初始化 test1_str （先申请空间） */ { delete test1_b_ptr; return; } test1_str_len = test1_str_in_len; test1_str = new char[test1_str_len]; memset(test1_str, '\\0', test1_str_len); memcpy(test1_str, test1_str_in, test1_str_len); cout \u003c\u003c \"class test1 init with parameter in\" \u003c\u003c endl; } // test1(const test1\u0026 obj) = default; // 这一句就是 使用默认的浅拷贝，由编译器自动生成 // test1(const test1\u0026 obj) = delete; // 这一句就是 不允许使用拷贝构造来初始化新对象 /* 使用自写的深拷贝 */ test1(const test1\u0026 obj) { this-\u003etest1_a = obj.test1_a; /* 初始化 test1_a */ test1_b_ptr = new unsigned int(10); /* 初始化 test1_b （先申请空间） */ *this-\u003etest1_b_ptr = *obj.test1_b_ptr; this-\u003etest1_str_len = obj.test1_str_len; /* 初始化 test1_str （先申请空间） */ this-\u003etest1_str = new char[this-\u003etest1_str_len]; memset(this-\u003etest1_str, '\\0', this-\u003etest1_str_len); memcpy(this-\u003etest1_str, obj.test1_str, this-\u003etest1_str_len); cout \u003c\u003c \"class test1 init with obj\" \u003c\u003c endl; } // 并且要实现 operate= 操作符， 当使用 test1 b = a; 的时候也许是调用浅拷贝构造函数 // 一般不建议允许使用 类之间的 直接等于号来 赋值 / 复制拷贝，就用 explicit 来修饰构造函数。 ~test1() { test1_a = 0; delete test1_b_ptr; delete[] test1_str; cout \u003c\u003c \"class test1 release\" \u003c\u003c endl; } }; int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; char* temp_str = \"AbCd.!\"; { /* 例化 类 test1 对象 带 参数 进行初始化 */ test1 test1_obj1(5, 10, temp_str, sizeof(temp_str)); /* 使用拷贝构造函数，具体使用深或者浅的，看类里面的拷贝构造函数实现 */ test1 test1_obj2(test1_obj1); // 或写为 test1 test1_obj2 = test1_obj1; 效果一样，这么写也是 调用拷贝构造函数， // 如果 先例化对象 test1_obj2，再单独写一句 test1_obj2 = test1_obj1; 这就是运算符重载，不再调用拷贝构造函数了 system(\"pause\"); } cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } 关于类里面使用 this 指针，其指向 当前所在 / 所处的类。若 函数 的形参 和 类内的 成员变量 名字一致，则用 this-\u003e成员变量 来专门表示 类内的那个成员 而不是 形参，用于区分，这只是一种情况，可灵活运行。 各个默认构造函数 struct trivial { trivial() = default; // 默认构造 trivial(const trivial\u0026) = default; // 默认拷贝（通过引用传入）构造 trivial(trivial\u0026\u0026) = default; // 默认移动（通过右值引用传入）构造 trivial\u0026 operator=(const trivial\u0026) = default; // 默认 赋值 拷贝（通过引用传入）构造 trivial\u0026 operator=(trivial\u0026\u0026) = default; // 默认 赋值 移动构造 ~trivial() = default; // 默认析构 }; 引自 函数声明 - cppreference.com。 关于各种 拷贝（或引用） / 移动 构造函数（构造的实现又分 浅拷贝、深拷贝）、赋值拷贝（或赋值引用） / 赋值移动 构造函数的比较全的例子，可见下面链接中 class \u0026 struct 一节： 参考 这些知识点你都知道吗，测试你的C++入门程度 (qq.com) 里","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:3","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类的构造和析构时刻 关于c++一些类的构造和析构时刻的试验 // 实验用的类： class TestClass { public: explicit TestClass() = default; explicit TestClass(const int32_t\u0026 _priv) : mPriv(_priv) { GUIFE_LOGI(\" --\u003e construct TestClass, mPriv: %d\", mPriv); } virtual ~TestClass(void) { GUIFE_LOGI(\" \u003c-- de-construct TestClass\"); } private: int32_t mPriv; }; // 执行： for(uint32_t i = 0; i \u003c 3; i++) { TestClass testClassInst(i); GUIFE_LOGI(\" ------ i: %d\", i); } // 打印： [User] (0.520, +0) testClass: --\u003e construct testClass, mPriv: 0 (in Test.cpp line #596) [User] (0.520, +0) test: ------ i: 0 (in Test.cpp line #624) [User] (0.520, +0) ~testClass: \u003c-- de-construct testClass (in Test.cpp line #600) [User] (0.520, +0) testClass: --\u003e construct testClass, mPriv: 1 (in Test.cpp line #596) [User] (0.520, +0) test: ------ i: 1 (in Test.cpp line #624) [User] (0.520, +0) ~testClass: \u003c-- de-construct testClass (in Test.cpp line #600) [User] (0.520, +0) testClass: --\u003e construct testClass, mPriv: 2 (in Test.cpp line #596) [User] (0.520, +0) test: ------ i: 2 (in Test.cpp line #624) [User] (0.520, +0) ~testClass: \u003c-- de-construct testClass (in Test.cpp line #600) // 结论：每次 for 的循环，开始会构造，结束会析构 // 执行：结论在注释 TestClass TestClassInst(1); TestClass TestClassInst2(10); TestClass TestClassInst3(20); std::list\u003cTestClass\u003e tests; GUIFE_LOGI(\"复制\"); tests.push_back(TestClassInst); // TestClassInst 只在上面构造一次，在这里直接复制进 tests，没有新构造发生, TestClassInst 不析构 GUIFE_LOGI(\"原位构造 再 push_back\"); tests.push_back(TestClass(2)); // 构造一个新的 TestClass(2) 再复制进 tests GUIFE_LOGI(\"原位构造 再 直接 emplace_back\"); tests.emplace_back(TestClass(3)); // 同上，emplace_back 是 使用引用 传入，即 构造一个新的 TestClass(3) 通过引用给到 tests GUIFE_LOGI(\"变量直接 emplace_back\"); tests.emplace_back(TestClassInst2); // emplace_back 是 使用引用 传入 GUIFE_LOGI(\"TestClassInst2.getPriv(): %d\", TestClassInst2.getPriv()); GUIFE_LOGI(\"直接移动\"); tests.emplace_back(std::move(TestClassInst3)); // emplace_back 使用移动（右值引用）传入 GUIFE_LOGI(\"TestClassInst3.getPriv(): %d\", TestClassInst3.getPriv()); GUIFE_LOGI(\"start clear~\"); tests.clear(); // 析构顺序： // tests 里面的所有 类 成员的 析构，tests 里面的 项 从前往后的顺序 挨个 析构 // TestClassInst3, TestClassInst2, TestClassInst // 执行：结论在注释 std::list\u003cTestClass*\u003e testPtrs; GUIFE_LOGI(\"new 之后 用 push_back\"); testPtrs.push_back(new TestClass(1)); // 执行一次构造 GUIFE_LOGI(\"new 之后 用 emplace_back\"); testPtrs.emplace_back(new TestClass(2)); // 同上 GUIFE_LOGI(\"start clear~\"); testPtrs.clear(); // 调用 存储 类指针 的 容器的 clear 并不会调用 其 项 的 析构，所以这种情况，需要 clear 之前，对其每一项先用 delete !! // 执行：结论在注释 std::list\u003cstd::shared_ptr\u003cTestClass\u003e\u003e testPtrs; GUIFE_LOGI(\"new 之后 用 push_back\"); testPtrs.push_back(std::make_shared\u003cTestClass\u003e(1)); // 执行一次构造 GUIFE_LOGI(\"new 之后 用 emplace_back\"); testPtrs.emplace_back(std::make_shared\u003cTestClass\u003e(2)); // 同上 GUIFE_LOGI(\"用个变量引用 testPtrs.front()\"); auto it = testPtrs.front(); GUIFE_LOGI(\"start clear~\"); testPtrs.clear(); // 调用 存储 shared_ptr 类型 类指针 的 容器的 clear 后，其中 若项 的 shared_ptr 的引用次数会归为 0 因而会被析构 // 用 vector 效果也一样 // 但是 testPtrs.front() 不会析构 因为 指针被 it 用走了一份 GUIFE_LOGI(\"it.use_count(): %ld\", it.use_count()); GUIFE_LOGI(\"it = nullptr;\"); it = nullptr; // 这里就会析构 it 指向的 类实例 GUIFE_LOGI(\"it.use_count(): %ld\", it.use_count()); // 对于放到一个结构体里面，如下 struct TestStruct { std::string str; uint32_t num; TestClassSharedPtr testClassPtr; }; std::vector\u003cTestStruct\u003e testPtrs; // 进行相同的操作，结果也一样 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:4","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"友元 使用 friend 关键字 在左边 修饰 在 类A 内 声明的 但定义在外面的 函数 或 类B内的函数 或 类B，则在外面定义的 函数 或 类B内的函数 可以访问到 类A 的 私有变量。缺点是破坏了类的封装性和私有性，不推荐用，但是某些运算符重载和特殊情况可以酌情用。 例子：在 类A 中设置一些友元，在 main() 里面用这些函数操作 类A 的私有变量。 /* 首先声明 类 A 和 B */ /* 因为后面 类B 里面 void set_class_A_obj_private_a(A\u0026 obj, int a); 里面有 A，不提前声明则编译会提示不存在 */ class A; class B; class B { private: public: B() = default; ~B() = default; /* 声明在这里，定义在外面 */ void set_class_A_obj_private_a(A\u0026 obj, int a); void set_class_A_obj_private_b(A\u0026 obj, int b); }; /* 声明一个全局函数，定义在后面 */ void set_class_A_obj_private_a(A\u0026 obj, int a); class A { private: int private_a; int private_b; public: A() = default; ~A() = default; /* 声明友元 */ friend void set_class_A_obj_private_a(A\u0026 obj, int a); /* 把一个 全局函数当作友元*/ friend void B::set_class_A_obj_private_a(A\u0026 obj, int a); /* 把一个 类B 的函数当作友元*/ friend B; /* 把 类B 当作友元 */ }; void set_class_A_obj_private_a(A\u0026 obj, int a) { obj.private_a = a; } void B::set_class_A_obj_private_a(A\u0026 obj, int a) { obj.private_a = a; } void B::set_class_A_obj_private_b(A\u0026 obj, int b) { obj.private_b = b; } int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; A class_a_obj1; B class_b_obj1; set_class_A_obj_private_a(class_a_obj1, 10); class_b_obj1.set_class_A_obj_private_a(class_a_obj1, 20); class_b_obj1.set_class_A_obj_private_b(class_a_obj1, 20); cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:5","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"单例模式 即类的对象只有一个的情况，补充参考视频 shellmad-c++_44 单例模式的原理及实现_哔哩哔哩_bilibili。 一个简单例子： class ClassASolo { // 这个类目的是只有全局一个实例，只能用 \"ClassASolo::inst()\" 来访问 public: explicit ClassASolo() = default; virtual ~ClassASolo() = default; static ClassASolo* inst(void) { // 关键方法 std::lock_guard\u003cstd::mutex\u003e lock(mMutex); // 防止多个线程都第一次调用从而创建多次 static ClassASolo inst; return \u0026inst; } int32_t setVar(const int32_t\u0026 _var) { if(mVar != _var) { mVar = _var; return 0; } else { return EIO; } } int32_t getVar(void) const { return mVar; } private: int32_t mVar = 0; static std::mutex mMutex; }; int main(void) { ClassASolo::inst()-\u003esetVar(1); int32_t var = ClassASolo::inst()-\u003egetVar(); ... } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:6","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"初始化列表实现 std::initializer_list 不同于 类构造函数的初始化列表，那个也有叫 委托构造函数，这里是 自写类实现 = { ..., ...} 形式的初始化。 参考 std::initializer_list - cppreference.com。 c++11新特性之列表初始化 - 知乎 (zhihu.com)。 TODO: 这里还需要补充 并可使用 基于范围的for循环，实现如下的效果：TODO：再查下自写的类，怎么写实现这种用法 for (int i : vec) { // c++11基于范围的for循环 cout \u003c\u003c \"i\" \u003c\u003c endl; } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:7","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"各类型初始化写法 初始化 - cppreference.com。 不完全列举，其中包括： 默认初始化。 值初始化。 引用初始化。 复制初始化。 聚合初始化。 列表初始化。 直接初始化。 例子： #include \u003cstring\u003e std::string s1; // 默认初始化 // 值初始化 char\u0026 c = a[0]; // 引用初始化 std::string s3 = \"hello\"; // 复制初始化 char a[3] = {'a', 'b'}; // 聚合初始化（C++11 起是列表初始化的一部分） std::string s4(\"hello\"); // 直接初始化 std::string s5{'a'}; // 列表初始化（C++11 起） // 直接初始化 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:8","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"杂项 在 lambda 表达式 用 *this 捕获对象副本 正常情况下，lambda表达式中访问类的对象成员变量需要捕获this，但是这里捕获的是this指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题。 C++17增加了新特性，捕获*this，不持有this指针，而是持有对象的拷贝，这样生命周期就与对象的生命周期不相关啦。 struct A { int a; void func() { auto f = [*this] { // 这里 cout \u003c\u003c a \u003c\u003c endl; }; f(); } }; int main() { A a; a.func(); return 0; } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:9","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类继承 补充参考 C++ 继承 | 菜鸟教程 (runoob.com)、C++继承和派生简明教程 (biancheng.net)。 子类/派生类 继承于 父类/基类（后面以 子类 和 基类 来叫）。子类 从基类继承过来的 表现共性，子类 再自己增加的成员 体现个性。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:8:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"继承 三种继承/派生（继承和派生这里一个意思）：公共继承、保护继承、私有继承。 写法例子：class B : public A, protected AO {...};，即 类B 公有继承 类A 且 类B 保护继承 类AO。 基类 中 a 权限的成员 被以 b 权限 继承到子类，那么子类中该成员的权限为 取 a 和 b 中较低的那一个；基类的 私有成员，无论什么类型的继承，子类都不能访问到。子类 继承 基类 后，基类 所有 成员变量 均添加到 子类 的头部，子类 创建对象后，在对象的内存上，首先是 基类 所有 成员变量 的内存空间，然后再是 子类 新添加的 成员变量 的内存空间，虽然 子类 中 基类的 私有成员 看不见（编译器在编译的时候使其这样的），但内存上可以操作到 基类 的所有成员变量。 子类继承基类后，当创建子类对象，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。 初始化列表：例化 子类 对象的时候 不能给 基类 的构造函数 传参，那么就给 子类的构造函数 后面 添加 初始化列表，里面的语句会逐个执行，在里面可以添加 调用基类的带参数的构造函数的语句，这是一种写法，也可以添加 子类 成员变量赋值的语句，此乃 初始化列表。 补充参考 C++40个入门知识点_31 派生类中的函数隐藏_哔哩哔哩_bilibili，P2继承_哔哩哔哩_bilibili 的4分半的地方。 子类的构造函数中对类成员变量进行初始化，要先用 初始化列表 来初始化 基类 的 成员变量，再去在函数内初始化 子类的 成员变量，比较规范。包括 const 修饰的变量也可以写在初始化列表里面。 写法例子： class A { private: int class_a_num; public: A() { cout \u003c\u003c \"A()\" \u003c\u003c endl; } A(int class_a_num_in) { class_a_num = class_a_num_in; cout \u003c\u003c \"A(int class_a_num_in)\" \u003c\u003c endl; } ~A() = default; }; class B : public A // 类B 公有继承 类A { private: int class_b_num; public: B() : A(1), class_b_num(2) // 初始化列表，调用 类A 的带参数构造函数，给自己 成员变量初始化值 { cout \u003c\u003c \"B()\" \u003c\u003c endl; } ~B() = default; }; int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; B b; cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } 继承 的时候 如果 是修饰为 类指针 或者 引用 类型（而且不使用 new / malloc 创建空间），则不为其分配内存，只是继承过来一个类的对象的指针。 c++ explicit 修饰只有一个参数的构造函数，即取消隐式转换，在例化对象时候只能用函数的方式，不能用赋值的方式，赋值 = 用操作符重载去做。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:8:1","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"虚继承 / 菱形继承 一个类（孙子类）继承多个类（子类），而这多个类中至少有两个类（子类） 又 继承自 同一个类（父类/基类），从而导致 孙辈的类 会包含 多个来自 父辈类的副本成员，因此要使用 虚继承。多个子类（至少两个） 继承 基类 时候使用 virtual 修饰，这样 孙子类 继承多个 子类 后，只有一个 基类 的副本。 例子： class A { protected: int class_a_num; public: A() { cout \u003c\u003c \"A()\" \u003c\u003c endl; } ~A() { cout \u003c\u003c \"~A()\" \u003c\u003c endl; } }; class B1 : virtual public A { protected: int class_b1_num; public: B1() { cout \u003c\u003c \"B1()\" \u003c\u003c endl; } ~B1() { cout \u003c\u003c \"~B1()\" \u003c\u003c endl; } }; class B2 : virtual public A { protected: int class_b2_num; public: B2() { cout \u003c\u003c \"B2()\" \u003c\u003c endl; } ~B2() { cout \u003c\u003c \"~B2()\" \u003c\u003c endl; } }; class C : public B1, public B2 { private: int class_c_num; public: C() { cout \u003c\u003c \"C()\" \u003c\u003c endl; } ~C() { cout \u003c\u003c \"~C()\" \u003c\u003c endl; } void class_c_set_and_show(int class_a_num, int class_b1_num, int class_b2_num, int class_c_num) { this-\u003eclass_a_num = class_a_num; this-\u003eclass_b1_num = class_b1_num; this-\u003eclass_b2_num = class_b2_num; this-\u003eclass_c_num = class_c_num; cout \u003c\u003c class_a_num \u003c\u003c '\\t' \u003c\u003c class_b1_num \u003c\u003c '\\t' \\ \u003c\u003c class_b2_num \u003c\u003c '\\t' \u003c\u003c class_c_num \u003c\u003c '\\t' \u003c\u003c endl; } }; int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; { C c; c.class_c_set_and_show(1, 2, 3 ,4); } cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } /* 打印信息： ----- start ----- A() B1() B2() C() 1 2 3 4 ~C() ~B2() ~B1() ~A() ----- end ----- */ ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:8:2","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"类多态 补充参考：C++ 多态 | 菜鸟教程 (runoob.com)，C++多态与虚函数 (biancheng.net)。 调用基类的虚函数（表共性的），就调用了子类中同名函数（表特点的），达到这样一个效果。 基类中定义虚函数，函数前面添加 virtual 修饰，就成了虚函数（可以直接调用，写为 对象名.虚函数名();），因基类虚函数一般为实现类多态，子类会覆写同名函数带有具体内容，因此基类这里的虚函数可写为空（花括号里面为空）；基类中虚函数也可以写为 virtual 函数返回值 函数名() = 0;，则成为纯虚函数，有纯虚函数的类是抽象类，抽象类不允许创建对象（抽象类一般是基础的、提供接口规范的，不提供实际具体功用，是用来被继承的，因此就不允许创建对象了）。子类继承抽象类后，子类里面必须实现有同名函数（函数名、返回值、函数参数必须一致）（至少写成 函数返回值 函数名(){...}，而且仍为虚函数）（若函数不完全同名，比如参数有区别，那就不覆盖，而且基类继承过来并且和子类的都存在，属于函数重载了），子类才能创建对象，否则子类也是抽象类就不能创建对象。 子类的地址可以 赋值给 基类的指针 或 基类的引用，这是安全的（子类空间比基类相等或更大，基类指针操作时候不会越界）。 关于虚函数的直接调用（就是调用谁就运行谁，没有多态性）（基类对象名.虚函数名()； 和 子类对象指针.基类类名::虚函数名();（这是明确类域范围的用指针调用，用引用同理））和间接调用（有了多态性）（用指针或引用去调用，但不明确写出类域范围），编译时期会有区别，间接调用的话调用虚函数时候会有一个查找虚函数表里面到底要调用哪一个的过程（除了直接调用和明确类域范围的用指针调用），具体可看一下 shellmad-c++_37 虚函数的直接调用与间接调用_哔哩哔哩_bilibili 和 shellmad-c++_47 虚函数的多态性_哔哩哔哩_bilibili。 例子： class shape { public: virtual void area() { cout \u003c\u003c \"shape area()\" \u003c\u003c endl; } // virtual void area() = 0; 这么写就是纯虚函数，则 类 shape 变为抽象类，则不允许定义对象 /* 基类的普通成员函数中调用多态函数，也具有多态性 但是在构造和析构函数中调用 多态函数，就不具备多态了（就是调用基类自己的那个虚函数了） */ void shape_area() { cout \u003c\u003c \"shape shape_area()\" \u003c\u003c endl; area(); // 本质上是 this-\u003earea(); 是具有多态性的，就是看是哪个子类的指针，去调用那个子类的 area() } }; class circle : public shape { public: virtual void area() { cout \u003c\u003c \"circle area()\" \u003c\u003c endl; } }; class rectangle : public shape { public: virtual void area() { cout \u003c\u003c \"rectangle area()\" \u003c\u003c endl; } }; void show_shape_area(shape\u0026 s) { s.area(); } int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; shape sh; circle c; rectangle r; shape* s[2] = {\u0026c, \u0026r}; /* 直接调用，没有多态性，调用谁直接运行谁 */ sh.area(); c.shape::area(); cout \u003c\u003c \"-------------\" \u003c\u003c endl; /* 间接调用，具有多态性：两种写法，一个是指针直接用，一个是写个函数用引用 */ s[0]-\u003earea(); show_shape_area(c); s[1]-\u003earea(); show_shape_area(r); cout \u003c\u003c \"-------------\" \u003c\u003c endl; /* 基类的普通成员函数中调用多态函数，也具有多态性 */ s[0]-\u003eshape_area(); cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } /* 打印内容： ----- start ----- shape area() shape area() ------------- circle area() circle area() rectangle area() rectangle area() ------------- shape shape_area() circle area() ----- end ----- */ 类的（尤其是抽象类（基类））的析构函数最好定义为虚函数（子类继承后，子类里的析构函数也都成为虚函数），具体可看 shellmad-c++_46 虚析构函数的作用_哔哩哔哩_bilibili。一个小的点，虚析构函数 可以写为 纯虚析构，那么必须要有实现（有花括号），例 virtual ~类名() = 0 { }。例子： class base { public: base() { cout \u003c\u003c \"base()\" \u003c\u003c endl; } virtual ~base() // 基类 且要被继承的基类 的虚构函数 最好写为 虚函数 { cout \u003c\u003c \"~base()\" \u003c\u003c endl; } }; class child : public base { public: child() { cout \u003c\u003c \"child()\" \u003c\u003c endl; } virtual ~child() // 也可以修饰为虚函数（也可以不，除非被别的类再继承） { cout \u003c\u003c \"~child()\" \u003c\u003c endl; } }; int main() { cout \u003c\u003c \" ----- start ----- \" \u003c\u003c endl; /* 在使用这种方式 来使用 基类的时候，释放 对象指针 b 时候， 若基类的析构函数 修饰为虚函数，则会调用 基类 和 父类的 析构函数 若基类的析构函数不修饰为虚函数，则释放 对象指针 b 时候，只会调用 子类的虚构函数，基类的虚构函数没有调用到，就不安全 */ base* b = new child; delete b; cout \u003c\u003c \" ----- end ----- \" \u003c\u003c endl; system(\"pause\"); return 0; } 更多的多态的基础例子，还可以参考这个链接里面 多态 一节：这些知识点你都知道吗，测试你的C++入门程度 (qq.com)。 (05)重学C++：多态 - 知乎 (zhihu.com)。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:9:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"运算符重载 或叫 重载运算符。 参考 C++ 重载运算符和重载函数 | 菜鸟教程 (runoob.com)、C++函数重载详解 (biancheng.net)、C++运算符重载基础教程 (biancheng.net)。 参考视频：shellmad-c++_51 运算符重载_哔哩哔哩_bilibili，shellmad-c++_52 cin\u0026cout的奥秘_哔哩哔哩_bilibili，shellmad-c++_53 自己动手编写字符串类_哔哩哔哩_bilibili，shellmad-c++_54 转换运算符_哔哩哔哩_bilibili。 C++类和对象(4):运算符重载——=、==、()函数调用运算符_重载操作符=和()-CSDN博客。 TODO: 这里还需要补充例子 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:10:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"模板 / 泛型 模板是泛型编程的基础。C++ 用 模板 来支持 泛型编程，即 一种 类 或 函数 支持多种数据类型，关注算法实现。 模板一节，会包含一些较新的 c++ 版本 的 模板特性。 基础参考： C++ 模板 | 菜鸟教程 (runoob.com)，C++模板和泛型程序设计 (biancheng.net)，c++高效编程之模板函数、模板结构体、模板类的使用_路过的小熊~的博客-CSDN博客_c++ 结构体模板。 c++11新特性之模板的改进 - 知乎 (zhihu.com)。 C++函数模板5分钟入门教程 (biancheng.net)，shellmad-c++_55 函数模板_哔哩哔哩_bilibili。中文语境下 也叫 “模板函数”。 C++类模板5分钟入门教程 (biancheng.net)，shellmad-c++_56 类模板_哔哩哔哩_bilibili。中文语境下 也叫 “模板类”。 大话C++模板编程的来龙去脉 (biancheng.net)，STL（Standard Template Library，标准模板库）就是 C++ 模板实现库。 C++模板-CSDN博客。 指定调用模板函数： c++模板:调用模板成员函数需不需要加template关键字?_调用类模板的特化函数,需要带template关键字吗?-CSDN博客。 可变参数模板类和函数： 可变参数模板 - OI Wiki (oi-wiki.org)。 包 (C++11 起) - cppreference.com。 精品参考： Mq-b/Modern-Cpp-templates-tutorial: 现代C++模板教程 (github.com)。 wuye9036/CppTemplateTutorial: 中文的C++ Template的教学指南。与知名书籍C++ Templates不同，该系列教程将C++ Templates作为一门图灵完备的语言来讲授，以求帮助读者对Meta-Programming融会贯通。(正在施工中) (github.com)。 [STL/6 模板中class与typename区别.md at master · FunctionDou/STL (github.com)](https://github.com/FunctionDou/STL/blob/master/6 模板中class与typename区别.md)。 STL/template之模板注意事项.md at master · FunctionDou/STL (github.com)。 STL/template之类相关.md at master · FunctionDou/STL (github.com)。 STL/template之非类型模板参数.md at master · FunctionDou/STL (github.com)。 TODO: 这里还需要补充 变量模板 变量模板 (C++14 起) - cppreference.com。 template\u003cclass T\u003e constexpr T pi = T(3.1415926535897932385L); int main() { cout \u003c\u003c pi\u003cint\u003e \u003c\u003c endl; // 3 cout \u003c\u003c pi\u003cdouble\u003e \u003c\u003c endl; // 3.14159 return 0; } 别名模板 C++ 14 起。 template\u003ctypename T, typename U\u003e struct A { T t; U u; }; template\u003ctypename T\u003e using B = A\u003cT, int\u003e; int main() { B\u003cdouble\u003e b; b.t = 10; b.u = 20; cout \u003c\u003c b.t \u003c\u003c endl; cout \u003c\u003c b.u \u003c\u003c endl; return 0; } 折叠表达式 参考 折叠表达式(C++17 起) - cppreference.com。 C++ 17 起。 template \u003ctypename ... Ts\u003e auto sum(Ts ... ts) { return (ts + ...); } int a {sum(1, 2, 3, 4, 5)}; // 15 std::string a{\"hello \"}; std::string b{\"world\"}; cout \u003c\u003c sum(a, b) \u003c\u003c endl; // hello world // --- template\u003ctypename... Args\u003e bool all(Args... args) { return (... \u0026\u0026 args); } bool b = all(true, true, true, false); // 在 all() 中，一元左折叠展开成 // return ((true \u0026\u0026 true) \u0026\u0026 true) \u0026\u0026 false; // b 是 false ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:11:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"多线程编程基础 参考 和 引用： 并发支持库 (C++11 起) - cppreference.com。 很清楚的总结 C++ 中，std::async 可以完全替代 std::thread 来开启异步的多线程操作吗？ - 知乎 (zhihu.com)。 【C++11多线程】异步任务：async、packaged_task、promise_c++ async-CSDN博客。 async的两个坑 - 知乎 (zhihu.com)。 关于多线程的一些心得 - 知乎 (zhihu.com)。 c++11新特性之线程相关所有知识点 - 知乎 (zhihu.com)。 c++11 新特性总结（二）——多线程篇 - 知乎 (zhihu.com)。 Mq-b/ModernCpp-ConcurrentProgramming-Tutorial: 现代C++并发编程教程 (github.com)。 比较全面的总结 C++多线程+线程池（全详解） - 知乎 (zhihu.com)。 用法归纳 C++中的thread最全用法归纳_c++ thread用法-CSDN博客。 std::thread（线程）-CSDN博客。 C++：std::thread：线程用法_std::thread用法-CSDN博客。 C++ std::thread调用类成员函数_std::thread 类成员函数-CSDN博客。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:12:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"创建线程 相关方法：过于基础的暂不提供例子。 thread 创建线程 ... std::thread t(func, funcPara); // 可传入 lambda、函数指针等等，并后跟着函数入参；也可传入 std::packaged_task 变量 if (t.joinable()) { t.detach(); } ... 更多线程相关 API 例子： std::thread t(func); cout \u003c\u003c \"当前线程ID \" \u003c\u003c t.get_id() \u003c\u003c endl; cout \u003c\u003c \"当前cpu个数 \" \u003c\u003c std:🧵:hardware_concurrency() \u003c\u003c endl; auto handle = t.native_handle();// handle可用于pthread相关操作 std::this_thread::sleep_for(std::chrono::seconds(1)); std::call_once ... for(uint32_t i = 0; i \u003c 5; i++) { std::thread t( []() -\u003e void { static auto func = []() -\u003e void { std::cout \u003c\u003c \" --- just run once\" \u003c\u003c std::endl; }; static std::once_flag onceflag; std::call_once(onceflag,func); } ); if(t.joinable()) { t.detach(); } } std::this_thread::sleep_for(std::chrono::seconds(3)); ... ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:12:1","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"线程间同步机制 互斥锁：mutex 注意先的各种锁的种类，来自于不同的 C++ 版本，可参考 锁（mutex）使用（c++11、c++14、c++17）_c++11、c++14、c++17多线程读写锁的区别-CSDN博客。 mutex 种类： 互斥 - cppreference.com。 std::mutex：独占的互斥量，不能递归使用，不带超时功能 shared_mutex (C++17) 可实现读写锁 shared_timed_mutex (C++14)，同上，带等待超时功能。 std::recursive_mutex：递归互斥量，可重入，不带超时功能 std::timed_mutex：带等待超时的互斥量，不能递归 std::recursive_timed_mutex：带等待超时的互斥量，可以递归使用 在 C++ 中通常不直接使用 std::mutex 来进行锁定，而是使用 std::unique_lock、std::lock_guard 或 std::scoped_lock（从 C++17 起可用）等类，以更加安全地管理锁定。这些类提供了更好的异常安全性，在临界区中的代码发生异常，std::unique_lock 也会在超出作用域时自动释放锁定，确保资源被正确地释放，从而提供更好的异常安全性。 unique_lock 和 lock_guard：如果需要更多的灵活性、手动控制锁定或支持移动语义，则选择 std::unique_lock。而如果只需要简单的自动锁定和释放，且不需要额外的功能，则选择 轻量级 std::lock_guard 更为合适。二者默认 创建时候 加锁，超出作用域时 自动解锁 和 释放。 通过 try_lock 方法，可以在多次执行一个 函数的时候，判断是否有其它线程已经在执行了，若不需要同时执行（比如按键的回调函数，当按键多次点击，不需要并行执行的时候），就可以用 try_lock 方法来判断，选择要不要 return。灵活去用 锁 的 各种方法。 有 try_to_lock、defer_lock 等更灵活的用法。例如，如果一个线程函数不希望在其它线程正在运行这个函数还没有结束的时候再执行，就可以用 try_to_lock 方法，如果 lock.owns_lock() 返回 false 是没有锁上就表明其它线程正在占用 所以直接 return 即可。 上锁： 锁变量直接调用其方法来上锁 (lock() / try_lock())。 RAII 风格（利用对象生命周期管理资源） 通用互斥体管理 - cppreference.com。 unique_lock（有 try_lock 等方法） shared_lock (C++14) lock_guard scoped_lock (C++17)（TODO: 有待补充） 指定锁定策略 std::defer_lock, std::try_to_lock, std::adopt_lock, std::defer_lock_t, std::try_to_lock_t, std::adopt_lock_t - cppreference.com。 实现读写锁，可用 shared_mutex 或 shared_timed_mutex（相较 前者多了超时功能），可参考： C++多线程——读写锁shared_lock/shared_mutex_princeteng-GitCode 开源社区 (csdn.net)。 多线程同步原语std::shared_timed_mutex 和 std::shared_lock_std shared lock-CSDN博客。 条件变量：condition_variable，参考 std::condition_variable - cppreference.com。 看例子即可，使用与 ptherad 中的都比较类似。 其中 wait(m, pred) 的 pred 可以认为是其它线程发送的条件变量到底是不是给我听的（返回 false 指示不是给自己的，反之则是），参考 std::condition_variable::wait - cppreference.com。 atomic，可用时现查。 std::atomic - cppreference.com。 C++并发编程 | 原子操作std::atomic-CSDN博客。 互斥量锁保护的数据范围比较大，我们期望更小范围的保护。并且当共享数据为一个变量时，使用 std::atomic 建立原子变量 效率更高。 并提供了原子操作的 读写、加减 等 API。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:12:2","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"future / packaged_task promise / future / shared_future std::promise - cppreference.com。std::future - cppreference.com。std::shared_future - cppreference.com. std::promise 用于生成值或异常，并将其与 std::future 关联起来，而 std::future 则用于获取异步操作的结果或状态。它们通常一起使用，实现线程间的协作和通信，以便在异步环境中进行数据共享和控制流管理。 // future from a promise std::promise\u003cint\u003e p; std::future\u003cint\u003e f3 = p.get_future(); std::thread p([\u0026p]{ p.set_value_at_thread_exit(9); }); p.detach(); ... C++11中std::future的具体使用方法_C/C++_服务器之家 (zzvips.com)。 std::future 是独占的，即它只能与一个 std::promise 对象关联，并且不能被复制或共享；一旦与 std::promise 关联的值被设置，std::future 就无法再次与其他 std::promise 关联；std::future 对象是一次性的，一旦获取了异步操作的结果，就不能再次获取。 std::shared_future 可以与多个 std::promise 对象关联，并且可以被多个线程同时访问；std::shared_future 允许多个线程同时等待异步操作的完成，并且可以多次获取相同的结果。 当需要允许多个线程同时等待相同的异步操作结果时，也可以使用 std::shared_future；在某些情况下，使用 std::shared_future 可以减少资源的重复计算，因为多个线程可以共享相同的结果，而不是每个线程都需要独立计算一次。 packaged_task 用于更灵活的线程返回值控制。 std::packaged_task 承载一个将要 异步执行 的可调用对象（函数、函数对象或 Lambda 表达式），然后可以获得其 std::future 或 std::shared_future 对象，自己手动创建个 thread 并将 std::packaged_task 对象移入 来异步执行函数，然后 通过 future 对象 获取 异步执行的返回结果。 相比较 std::async 更灵活，可操作性大。 #include \u003cfuture\u003e#include \u003ciostream\u003e#include \u003cthread\u003eint main() { std::packaged_task\u003cint(int, int)\u003e task([](int a, int b) { return a + b; }); auto f = task.get_future(); std::thread t(std::move(task), 1, 2); std::cout \u003c\u003c f.get() \u003c\u003c std::endl; if (t.joinable()) t.join(); } ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:12:3","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"async std::async 是一个函数模板，用于启动一个异步任务，并返回一个与该任务关联的 std::future 或 std::shared_future 对象，用于获取任务的结果，可以选择其内部自动创建个新的 thread 来执行（选择策略为 std::launch::async，即创建新线程并立即执行） 或 在调用线程中执行任务（选择策略为 std::launch::deferred，即在调用 std::future::get() 或 std::future::wait() 的线程中执行，即 延迟执行任务）。简化了代码编写。 // future from an async() std::future\u003cint\u003ef2= std::async(std::launch::async, []{ return 8;}}; auto f = std::async( std::launch::async, [](void) mutable -\u003e uint32_t { std::this_thread::sleep_for(std::chrono::seconds(3)); return 0; } ); f.get(); // will block until thread of async exit, for \"f.wait();\" too // f.wait(); // 关于 std::chrono，可以用时现查，其方法比较多，也可以问 AI。 // wait_for // auto f_state = f.wait_for(std::chrono::milliseconds(100)); // if(f_state == std::future_status::ready) { // // ... // } // wait_until // std::chrono::system_clock::time_point two_seconds_passed // = std::chrono::system_clock::now() + std::chrono::seconds(2); // auto f_state = f.wait_until(two_seconds_passed); // if(f_state == std::future_status::timeout) { // // ... // } 关于 async 返回 future 在析构的时候会阻塞直到线程函数执行完毕，为了不阻塞 async 后面的执行，两种写法来解： 1、搞个 全局的 future 变量来承接 async 的返回，在需要的地方对其 get 或 wait_for； 2、把 async 返回的 future 局部变量 用 std::thread t(…); t.detach(); 创建个专门线程，用 右值引用（std::move）的传参方式 传进去（future 生命周期就转移到 t 的线程函数里面），在里面对其 get 或 wait_for。 1 例程： #include \u003cchrono\u003e#include \u003ccstdint\u003e#include \u003cfuture\u003e#include \u003ciostream\u003e#include \u003cthread\u003e void test(void); void test2(void); static std::future\u003cuint32_t\u003e f_async; int main(void) { std::cout \u003c\u003c \" -------- main begin\" \u003c\u003c std::endl; test(); test2(); std::cout \u003c\u003c \" -------- main end\" \u003c\u003c std::endl; } void test(void) { std::cout \u003c\u003c \" ------------------ test begin\" \u003c\u003c std::endl; f_async = std::async( std::launch::async, [](void) mutable -\u003e uint32_t { std::this_thread::sleep_for(std::chrono::milliseconds(300)); return 0; } ); std::cout \u003c\u003c \" ------------------ test end\" \u003c\u003c std::endl; return; } void test2(void) { std::cout \u003c\u003c \" ------------------ test2 begin\" \u003c\u003c std::endl; for(;;) { auto f_async_state = f_async.wait_for(std::chrono::milliseconds(100)); if(f_async_state == std::future_status::timeout) { std::cout \u003c\u003c \" ... f_async wait_for 100 ms\" \u003c\u003c std::endl; } else if (f_async_state == std::future_status::ready) { std::cout \u003c\u003c \" ... f_async ready\" \u003c\u003c std::endl; break; } } std::cout \u003c\u003c \" ------------------ test2 end\" \u003c\u003c std::endl; return; } /* print: -------- main begin ------------------ test begin ------------------ test end ------------------ test2 begin ... f_async wait_for 100 ms ... f_async wait_for 100 ms ... f_async ready ------------------ test2 end -------- main end */ 2 例程： #include \u003cchrono\u003e#include \u003ccstdint\u003e#include \u003cfuture\u003e#include \u003ciostream\u003e#include \u003cthread\u003e void test(void); int main(void) { std::cout \u003c\u003c \" -------- main begin\" \u003c\u003c std::endl; test(); std::cout \u003c\u003c \" -------- main end\" \u003c\u003c std::endl; } void test(void) { std::cout \u003c\u003c \" ------------------ test begin\" \u003c\u003c std::endl; std::future\u003cuint32_t\u003e f_async = std::async( std::launch::async, [](void) mutable -\u003e uint32_t { std::this_thread::sleep_for(std::chrono::milliseconds(300)); return 0; } ); bool is_f_async_done = false; std::thread t_process_f_async( [\u0026is_f_async_done](std::future\u003cuint32_t\u003e\u0026\u0026 f_async) mutable -\u003e void { for(;;) { auto f_async_state = f_async.wait_for(std::chrono::milliseconds(100)); if(f_async_state == std::future_status::timeout) { std::cout \u003c\u003c \" ... f_async wait_for 100 ms\" \u003c\u003c std::endl; } else if (f_async_state == std::future_status::ready) { std::cout \u003c\u003c \" ... f_async ready\" \u003c\u003c std::endl; is_f_async_done = true; // or call a callback fun break; } } }, std::move(f_async) ); t_process_f_async.detach(); for(;;){ if(is_f_async_done) { std::cout \u003c\u003c \" ... is_f_async_done\" \u003c\u003c std::endl; break; } }; std::cout \u003c\u003c \" ------------------ test end\" \u003c\u003c std::endl; return; } /* print: -------- main begin ------------------ test begin ... f_async wait_for 100 ms ... f_async wait_for 100 ms ... f_async ready ... is_f_async_done ------------------ test end -------- main end */ 当然这两种可能不规范，还是软件工程要提前划分好子任务，线程间","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:12:4","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"thread_local 参考 c++11新特性，所有知识点都在这了！ - 知乎 (zhihu.com) 里面 thread_local 一节。 c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。 一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。 #include \u003ciostream\u003e#include \u003cthread\u003e class A { public: A() {} ~A() {} void test(const std::string \u0026name) { thread_local int count = 0; ++count; std::cout \u003c\u003c name \u003c\u003c \": \" \u003c\u003c count \u003c\u003c std::endl; } }; void func(const std::string \u0026name) { A a1; a1.test(name); a1.test(name); A a2; a2.test(name); a2.test(name); } int main() { std::thread(func, \"thread1\").join(); std::thread(func, \"thread2\").join(); return 0; } /* 输出 thread1: 1 thread1: 2 thread1: 3 thread1: 4 thread2: 1 thread2: 2 thread2: 3 thread2: 4 */ ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:12:5","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"现代高性能并发编程 parallel101/course: 高性能并行编程与优化 - 课件 (github.com)。 更多可参考 C-C++实用库备查 里面的线程池等相关的 github 实现。 更多可参考 C-C++实用库备查 里面的 高并发 处理库，会用，善用。 深入理解C11/C++11内存模型(白嫖新知识~) - 知乎 (zhihu.com)。 TODO 有待补充 event epoll 一些 并发库，从 C-C++实用库备查 里面拿出来，写几个用例。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:13:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C++ 标准库 / STL 参考 菜鸟教程、C 语言中文网等。这里只是罗列库函数，解决“都有什么”的问题，每一个 API 的具体用法需要用时现查。 很多可以用时现查，或者问 AI 工具，但是，知道 都有什么 很重要。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:14:0","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C++ 的 以及参考 cpp 标准库 参考：这里是全的，可以时不时的刷刷看看。 里面的各种方法太多，所以实际常问 AI 工具去写，但是，还是要看一下 都有什么，知道用什么才更好，有方向性的去问 AI。 std 提供了很多实用 API 可以不必自己实现。 TODO：这里面的库的罗列，可以复制出来放下面 C++ 标准库 - cppreference.com。 C++ 标准库标头 - cppreference.com。 C++ STL 教程 | 菜鸟教程 (runoob.com)。 STL教程：C++ STL快速入门（非常详细） (biancheng.net)。 C++ Cheat Sheets \u0026 Infographics | hacking C++ (hackingcpp.com)。 库： – 下面只是之前零碎整理，不全，但是删了又暂时不想删，先放着。 fstream：文件操作库，用时现查即可。 可参考 C++ 文件和流 | 菜鸟教程 (runoob.com)。C++文件操作 (biancheng.net)。 文件系统库 - cppreference.com。 fstream / ifstream / ofstream 的用法，各种方法 和 控制符。 regex 可参考 正则表达式库 (C++11 起) - cppreference.com。 一般，可以由 GPT 等工具生成来写。但是最好，正则表达式要懂一些。 chrono duration time_point clocks steady_clock system_clock high_resolution_clock std::function 类似于定义函数指针，但写法简单，用于承接 普通函数、模板函数、lambda、仿函数（类或结构图实现“()”的操作符重载）等 c++11新特性之std::function和lambda表达式 - 知乎 (zhihu.com)。 std::function详解-CSDN博客 丰富用法例子 std::function简介与使用 | 码农家园 (codenong.com) std::function 变量 比较 和 类的变量成员 std::function对象比较的问题_std::function 比较-CSDN博客 std::bind std::bind - cppreference.com 【C++】C++11的std::function和std::bind用法详解_c++11 新增了 std::function、std::bind-CSDN博客。 https://zh.cppreference.com/w/cpp/utility/functional/bind C++11中的std::bind 简单易懂-CSDN博客 random 可以选择概率分布类型。 整数均匀分布和浮点数均匀分布： ... std::default_random_engine random(time(nullptr)); std::uniform_int_distribution\u003cint\u003e int_dis(0, 100); // 整数均匀分布 std::uniform_real_distribution\u003cfloat\u003e real_dis(0.0, 1.0); // 浮点数均匀分布 for (int i = 0; i \u003c 10; ++i) { cout \u003c\u003c int_dis(random) \u003c\u003c ' '; } cout \u003c\u003c endl; for (int i = 0; i \u003c 10; ++i) { cout \u003c\u003c real_dis(random) \u003c\u003c ' '; } cout \u003c\u003c endl; ... c++11 提供的概率分布类型还有好多，例如伯努利分布、正态分布等。 algorithm 参考 算法库 - cppreference.com。 参考 C++ Standard Library Algorithms Visual Overview | hacking C++ (hackingcpp.com)。 搜索算法：find() 、search() 、count() 、find_if() 、find_if_not() 、search_if() 、count_if() 分类排序：sort() 、merge() 删除算法：unique() 、remove() 生成和变异：generate() 、fill() 、transformation() 、copy() 、copy_if() 关系算法：equal() 、min() 、max() 条件：all_of()、any_of()、none_of() minmax_element() 返回容器内 最大元素 和 最小元素 的 迭代器 itoa() 对容器内的元素 逐个 递增 赋值 is_sorted() 、is_sorted_until() 返回容器内元素是否已经排好序 等等 IO 参考 输入/输出库 - cppreference.com。 iostream 该文件定义了 cin、cout、cerr 和 clog 对象（iostream 类的实例），分别对应于标准输入流、标准输出流、非缓冲标准错误流 和 缓冲标准日志流。 使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 一些设置输出模式的 API（比如 设置/清除 左/右对齐、保留几位小数、科学计数法、16禁止输出，还有 iostream 中定义的操作符 等）： 参考 C++ 基本的输入输出 | 菜鸟教程 (runoob.com)，C++ cout格式化输出（超级详细） (biancheng.net)。 也可以用 c 的标准输入输出 API 如 scanf()、printf()、getchar()、putchar() 等等。 sstream 各种类型和字符串类型的互转，以及逐个提取字符串（默认空格、回车分割） std::basic_stringstream - cppreference.com C++之stringstream类-基本用法详解-CSDN博客 fstream 文件的流式访问 std::basic_fstream - cppreference.com std::quoted C++14。std::quoted - cppreference.com。 对字符串做转义，同时也支持自定义的转义符。 个人觉得不常用。 utility 参考 工具库 - cppreference.com。 参考 标准库标头 - cppreference.com。 std::bitset std::bitset - cppreference.com 可以替代所有 C 原生的 位运算操作，不容易出错 std::exchange C++14。std::exchange - cppreference.com。 作用是把第二个值赋值给第一个值，同时返回第一个值的旧值。 exchange 的第二个值是 完美转发，是既可以接收左值，也可以接收右值。 std::integer_sequence C++14。std::integer_sequence - cppreference.com。 人话参考： 【模板进阶】std::integer_sequence_integer sequence-CSDN博客。 【C++ 14 新特性 std__integer_sequence 】了解 std__integer_sequence 的使用 - 知乎 (zhihu.com)。 Math 参考 数值库 - cppreference.com。 Complex 复数库 标准库标头 - cppreference.com Memory 参考 内存管理库 - cppreference.com。 参考 低层内存管理 - cppreference.com。 std::launder 参考 std::launder - cppreference.com。 可参考 C++笔记：尝试用人话解释std::launder - 知乎 (zhihu.com)。 std::launder‌ 用于处理指针的生命周期和编译器优化问题。其主要作用是防止编译器对通过特定指针进行的操作进行优化，确保程序的运行结果符合预期。 ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:14:1","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["EE-CS-Study"],"content":"C 带来的 可以参考这里比较全的总结： coding-style-and-more/额外文档/各种C标准库详解和用例 at main · Staok/coding-style-and-more (github.com)。 – 下面只是之前零碎整理，不全，但是删了又暂时不想删，先放着。 cmath：常用数学函数。 cmath 库函数 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 ctime：时间和日期。 有四个与时间相关的类型：clock_t、time_t、size_t（这三个能够把系统时间和日期表示为某种整数） 和 tm。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时 }; ctime 库函数 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 使用例子参考 C++ 日期 \u0026 时间 | 菜鸟教程 (runoob.com)。 cstdlib： rand() 这个头文件里面还有很多方法 cstring：与 c 的 string.h 大同小异。 cstring 库函数 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串（string 类型的）也可以用 + 号，例如: string str1 = \"runoob\"; string str2 = \"google\"; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回值小于 0；如果 s1\u003es2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 …. ","date":"2023-07-29","objectID":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:14:2","tags":["C++"],"title":"C++ 学习总结备查","uri":"/cpp%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【规范】系列"],"content":"硕士实验室嵌入式学习路线参考清单","date":"2023-04-11","objectID":"/%E7%A1%95%E5%A3%AB%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%8F%82%E8%80%83%E6%B8%85%E5%8D%95/","tags":["规范","软件","硬件"],"title":"【目录贴】硕士实验室嵌入式学习路线参考清单","uri":"/%E7%A1%95%E5%A3%AB%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%8F%82%E8%80%83%E6%B8%85%E5%8D%95/"},{"categories":["【规范】系列"],"content":"下面是对我在硕士期间边学边实践所写的部分文章，挑选整理出一个 “学习清单”。 其实我写到目前为止，如果你看进去了这些东西 可以说各种东西达到了熟悉/熟练的状态 可不敢说精通（面试官会出手） 如果看到这篇路线总结，无论你是本科还是硕士 你也别太感觉东西太多了 那可能是应试教育、考试的惯性思维在作祟 如果自始至终没有这种惯性思维，而是联系实际、独立思考、实事求是的，是出于好奇和兴趣，是处于饥渴和想要去“探险”，是自信又理智 那特别好，特别特别 理智分析、精明能干是对勇气的画龙点睛，实事求是、谨慎计划、利索实施是对希望和乐观的点石成金 可以按照我排的顺序和文中珠玑总结的思路与要点 并且看那些我推荐的系统教程，尤其推荐是pdf文本的（视频啰嗦），一会一个内容，一会一章，很快 只要开始，就不晚 刷起来，做起来，持续起来之后，这是会上瘾的 希望你能、你会进入这种状态 硕士实验室嵌入式学习路线参考清单 ⚑ 老师日常语录，师之传达：【杂谈】师之传达 - 欢迎来到 Staok - 瞰百易 (github.io)，定总基调的。 ⚑ 具体学习路线：实验室的嵌入式方向的学习路线，可以借鉴： 总览软硬件规范化的意义和内容-学习路径。 ⚑ 硬件电路设计 学习 \u0026 规范： 介绍和罗列关于硬件设计所需要考虑的各个方面。纯个人经验总结，非科班念经。 【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用 / Github 仓库 / Gitee 仓库。 ⚑ C 编程学习 \u0026 规范： C 语言学前班。 【规范】C \u0026 MCU 编写规范和技巧 / Github 仓库 / Gitee 仓库。 数据结构与算法 总结。 ⚑ STM32 学习： 超快 STM32 系统入门指南。 外设编程 实例 Github 仓库 / Gitee 仓库。 ⚑ FPGA 学习 \u0026 规范： 【规范】HDL \u0026 FPGA 学习、规范和技巧 / Github 仓库 / Gitee 仓库。 ⚑ Linux 学习： 【主线剧情】Linux 系列 / Github 仓库 / Gitee 仓库。 本文引自 批判与扶正歪气 - 欢迎来到 Staok - 瞰百易 (github.io)。 ","date":"2023-04-11","objectID":"/%E7%A1%95%E5%A3%AB%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%8F%82%E8%80%83%E6%B8%85%E5%8D%95/:0:0","tags":["规范","软件","硬件"],"title":"【目录贴】硕士实验室嵌入式学习路线参考清单","uri":"/%E7%A1%95%E5%A3%AB%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%8F%82%E8%80%83%E6%B8%85%E5%8D%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"主线剧情 系列 的循序渐进的查看顺序","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"必先看：主线剧情 系列 的循序渐进的查看顺序 【主线剧情】Linux 系列，为嵌入式 Linux 的学习记录。 每一篇文章的内容、以及仓库的内容都极其丰富~ 仓库地址： Github Staok/ARM-Linux-Study: ARM Linux 的学习历程，文章遵守 CC BY NC SA 4.0 协议。 (github.com)。 Gitee ARM-Linux-Study: ARM Linux 的学习历程，文章遵守 CC BY NC SA 4.0 协议。 (gitee.com)。 小站文章 【主线剧情】Linux 系列 - 分类 - 欢迎来到 Staok - 瞰百易 (github.io)。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:0:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"负责声明 本 ARM-Linux-Study 仓库是个人学习之后的总结，是稍微系统性的整理备查，不适合用来初学 Linux，初学 嵌入式 Linux 强推 去看 主线剧情0.0-Linux学习资源大综合 这个文章里 !学习来源! 一节总结的，主要是 入手开发板，跟着教程学！ !学习来源! 下面仅为个人见到的选择的推荐，欢迎补充！ 最推荐的就是 “入手开发板，跟着教程学” 的方式即可~ 韦东山 的 系列教程，靠谱而较全面，跟着走就成。 Linux 学习 B 站视频。 百问网 资源下载站。推荐 跟着这个开发板学 🎫100ASK_IMX6ULL_PRO开发板。 百问网论坛。 正点原子/野火 的 Linux 系列教程，靠谱而较全面，跟着走就成。 正点原子 Linux 学习 B 站视频，正点原子 资源下载站，论坛。 野火 Linux 学习 B站视频，野火 资源下载站，论坛。 买书（驱动和应用），参考 下面 “书籍推荐” 一节。 其它 嵌入式 Linux 开发板 和 资料 的提供商，他们都提供了开发板配套的较完整的 SDK 和 硬件方案，对于开发的参考价值极大。 百问网 Linux 板 产品页 \u0026 米尔 Linux 板 产品页。 Firefly | 让科技更简单，让生活更智能 (t-firefly.com)。 Orange Pi PC - 香橙派。 看官方 doc：怎样成为一名优秀的Linux驱动设备工程师？ - 知乎 (zhihu.com)。 Linux内核文档：The Linux Kernel documentation — The Linux Kernel documentation。 Linux设备驱动程序开发指南：Driver implementer’s API guide — The Linux Kernel documentation。 Linux内核api：Core API Documentation — The Linux Kernel documentation。 非官方的推荐\u003cLinux 内核模块编程指南\u003e：The Linux Kernel Module Programming Guide (sysprog21.github.io)。 就这些，我不会列成吨的资料骑脸。。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:1:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"一开始可以鸟瞰一下 ARM 系列处理器的当前局面 主线剧情-番外01-ARM系列快速鸟瞰（在 【0 ARM \u0026 Linux 主线剧情系列文章】 文件夹里面）。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:2:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"首先是基础 主线剧情0.0-Linux学习资源大综合（在 【0 ARM \u0026 Linux 主线剧情系列文章】 文件夹里面，下同）。 主线剧情01-ARM-IMX6ULL基础学习记录。 主线剧情02-ARM-Linux基础学习记录。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:3:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"然后是应用编程 主线剧情08-Linux应用编程-学习总结备查（在 【Linux 通用应用开发】/主线剧情08-Linux应用编程-学习总结备查 文件夹里面）。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:4:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"然后是驱动编程 主线剧情07.1-Linux驱动编程-基本字符设备和设备树维护（在 【Linux 通用驱动开发】/基本字符设备驱动程序-输出 文件夹里面）。 主线剧情07.2-Linux驱动编程-各种内核机制总结（将长期建设，用到的时候才会慢慢补充）（在 【Linux 通用驱动开发】/基本字符设备驱动程序-输入 文件夹里面）。 主线剧情07.3-Linux驱动编程-内核态API总结备查（在 【Linux 通用驱动开发】 文件夹里面）。 主线剧情07.4-Linux驱动编程-内核线程相关API（在 【Linux 通用驱动开发】 文件夹里面）（尚无）。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:5:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"可以系统看一下 设备树 主线剧情-番外02-设备树详解（在 【0 ARM \u0026 Linux 主线剧情系列文章】 文件夹里面）。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:6:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"然后是移植相关 （有兴趣则去学习，这部分将长期建设，用到的时候才会慢慢补充） 主线剧情03-NXP-i.MX系列的u-boot移植基础详解（在 【0 ARM \u0026 Linux 主线剧情系列文章】 文件夹里面）。 主线剧情04——计划为Linux内核配置与移植（尚无）。 主线剧情05——计划为Buildroot构建文件系统（尚无）。 主线剧情06——计划为ubuntu的移植（尚无）。 ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:7:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["【主线剧情】Linux 系列"],"content":"优化相关 主线剧情09-Linux性能优化相关总结（尚无） ","date":"2022-06-04","objectID":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/:8:0","tags":["ARM","Linux"],"title":"必先看：主线剧情系列的循序渐进的查看顺序","uri":"/%E5%BF%85%E5%85%88%E7%9C%8B%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85%E7%B3%BB%E5%88%97%E7%9A%84%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E7%9A%84%E6%9F%A5%E7%9C%8B%E9%A1%BA%E5%BA%8F/"},{"categories":["随机技术情报"],"content":"IEEE 1451 智能传感器接口标准介绍","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"IEEE 1451 智能传感器接口标准介绍 本文的 Github/Gitee 仓库：Github仓库，Gitee仓库。 简单地说，IEEE 1451 标准是为了统一传感器的“接口”的标准，使其网络化、智能化和标准化，让相互不同的、陌生的传感器接入系统后可以“自发现”、“自识别”和“自组网”，并自动的开始进行数据和命令的上下传递，使传感器具有“即插即用”性、兼容性、互操作性与相互独立的解耦性（与 USB 等规范不同，此标准专门适应了 智能传感器的弱处理能力、低功耗、设备信息标准格式定义与传输、特有功能等独特性需求）。 记录经过阅读十几篇介绍文章、PPT和论文后的一点粗浅的感悟（发现）。标准的初心是大家都遵守的规范，用得越多越好，这样大家都能互识、互联和互通。本文中许多中文名词为作者本人翻译自英文源文，非官方。成文辛苦，图片高达 44 张。本文所用到的图片侵删。如有没看懂的地方可在评论区留言，帮助进行通俗化改进；如有错误也请直言不讳。 写标准就是画饼，画饼是快乐的，读起来就能感觉到；技术路线确定后，实现就是个稍显无趣的体力活了。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:0:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"名词/概念释义 一个传感器（或叫变送器，Transducer）主动或者被动的采集数据并以一定格式上传到中控参与控制或以图表形式显示，这是采集系统最简单的形式的表述。 一个传感器称得上为智能，有以下特征（标准 1451.0 定义的）：1、以数字的形式传递数据和命令，2、有统一的协议，3、提供触发、状态切换等可控制的功能；在作者看来，即传感器端加上一个微控制器（MCU，即漫威宇宙，啊不，即单片机）或者传感器端加上一个较复杂的 ASIC 专用逻辑芯片，实现以上功能，就算“智能”了。题外话，若更进一步，如果传感器的数据比较珍贵而且处理的计算量很大，传感器端可以上微处理器（MPU，或唤作 SoC），运行 Linux，该 SoC 带 GPU 等，再跑一些人工智能、深度学习算法，这算“边缘计算”的概念了。 下图为一种“智能传感器”的释义。 更多的，智能传感器具有的特征如下（实际无必要全囊括）： 自描述；自识别； 自诊断；自校准； 定位信息，时间信息； 数据聚合、处理和提取特征进行推理； 报警通知； 标准通讯接口和标准通讯协议。 下图为工业现场背景下的一个智能传感器的示例（此图是通过无线的方式将数据发送出去），传感器会有成百上千个，而且类型也很多。 现在 处理器平台 和 通讯/数据传输的接口 的繁多性，如下图。 现在要很多个各式各样的智能传感器都可以连接到中控，要考虑两个方面： 指定标准的数据和命令的上下传输的协议； 指定一个标准的传感器“身份证”，让一个传感器接入系统后先发送这个亮明自己身份的“身份证”，上面有我是谁（传感器 ID、类型等）、我有啥、我能干啥等等信息。 第一个问题，标准的数据和命令上下传输协议，在1451标准中，数据和命令的传输都属于消息传输范畴，数据消息只有指定以字节形式高位先传（MSB），用户自定协议，命令消息有严格的发送和接收格式； 第二个中所讲的传感器的“身份证”，在1451标准中唤作 传感器电子数据表格（Transducer Electronic Data Sheet，TEDS）（源文翻译怪怪的），有严格的格式。这些协议或者叫格式的具体定义下文会引用标准源文讲到。下图为智能传感器带着TEDS的示例。 连接传感器（也叫变送器）的模块，与传感器通讯拿到其数据，并以1451标准定义的协议上传这些数据的模块，这里叫做传感器接口模块（源文翻译）（Transducer Interface Module，TIM）。TEDS 存在于 TIM 中，实现自描述。 上文的传感器接口模块（TIM）通过有线或者无线的形式以1451标准定义的协议上传上来的数据会首先送到一个应用处理模块，该模块经过分析处理这些数据再通过网络发出去，这个应用处理模块当作中间件起到中间转发和管理的作用，在这里叫做联网应用处理器（源文翻译）（Network Capable Application Processor，NCAP）。NCAP 接收 TIM 发送上来的 TEDS 并作解析，实现自识别，还有控制/管理各个 TIM 的用处。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:1:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"标准簇/标准模型 IEEE 1451 标准制定了 TEDS 的格式以及 联网应用处理器端（NCAP） 和 智能传感器端（TIM） 之间的通讯规范等。1451 协议簇： 下图可以让系统的结构清晰起来，一个 1451 模型的简略示意图，各个子标准分别描述了该模型各个部分的规范。 简单描述各个子标准： 1451.0 描述 NCAP 和 TIM 包含的必要和可选的功能、通讯协议（数据/命令 的 请求/响应 的协议）以及 TEDS 的格式等（Common functions, communication protocols, and TEDS formats），这个要在 TIM 和 NCAP 中实现，TIM 中主要实现 TEDS 用于自描述，NCAP 中主要实现 TEDS 的解析，这样才能发现新设备的接入，即自识别，另外还有管理和控制手底下这些 TIM 的实现，如通知/数据/命令的上下传输。 1451.2 描述 NCAP 和 TIM 之间以点对点（point-to-point）方式通讯（如串口的TTL/232/485、TII（该标准新定义的，类 SPI 的 10 线接口）、SPI 等）时候的相关标准，此时的 TIM 唤作 STIM（Smart Transducer Interface Module）。 1451.3 描述分布式多点总线（Multidrop）的总线方式通讯（各种 Bus，多个设备共享物理总线），此时的 TIM 唤作 TBIM（Transducer Bus Interface Modules）。 1451.4 描述数模混合接口的方式通讯，为传统的模拟传感器增加支持，传感器上电后先通过一根数字先发送 TEDS 给 NCAP，然后传感器用模拟线传递数据信息，此时与传统模拟传感器无异。 1451.5 描述无线（Wireless）的方式通讯（如 WLAN、BT、ZigBee 等），此时的 TIM 唤作 WTIM（Wireless Transducer Interface Module）。 1451.6 描述在 CAN 总线物理层上利用 CANopen 协议进行通讯。 1451.7 描述利用 FRID 进行，扩展 RFID 系统的应用。 1451.1 描述 NCAP 与上面网络（Network）部分通讯的一种规范，是可选项，NCAP 入网的协议可以采用其它如 Web/HTTPS/MQTT 等。 于是一张细节丰富一点的 1451 整体模型逐渐清晰，如下图。可以发现，1451.4 接口的智能传感器 通常挂在 TIM 之下。 ![1451整体模型 1](assets/1451整体模型 1.png) 举一个例子，此时如果要根据这个图的架构搭建一个简易的测试用的 传感器采集并上传 的系统，如下图所示。橘色和绿色的部分是采用 1451.2 点对点的方式使 TIM 和 NCAP 通讯，这里使用 串口（UART），右边浅靛色部分是采用 1451.5 无线的方式实现 TIM 与 NCAP 通讯，多对一，各个 NCAP 上面都通过有线（网线）或者无线（WLAN）入网，下面的 TIM 可以实现灵活的接入自识别/自组网。 最后，1451 标准给出完整的整体模型，如下图。 可以看出 NCAP 与 TIM 之 间的接口被定义为 IEEE 1451.X 物理接口规范，根据不同的应用需求选择不同的子标准接口规范。1451.x 主要做数据中转，1451.0 主要做信息（message）和 TEDS 服务，上图中标注 Optional 的部分为可选的。 由标准给出的架构图可知，NCAP 和 TIM 之间通过 1451.x（x = 2、3、5、6 等）进行交互，在 1451.x（做数据中转） 之外再加一层 1451.0（做信息（message）和 TEDS 服务） 。若 1451.0 种提供的功能等足够系统，可以只用 1451.0，即直接用于 NCAP 和 TIM 之间的交互，如下图所示（引自论文《IEEE_1451网络化智能传感器接口技术_王石记》）。 另外，一个 TIM 下面可以挂接多个 传感器，每一个传感器称为 一个传感器通道（Transducer Channel），一个 TIM 也可以挂接多个 执行器（Actuator，比如电机等），一个 TIM 下面也可以 连接多个 TIM，形成总分结构。 NCAP 对多个 TIM 的动态管理需要用户根据具体应用场景考虑，TIM 的接入、移出、命令/信息的收发等等。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:2:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"NCAP 与 TIM 通讯标准 **这里为 1451.0 标准，其他标准如 1451.2、1451.3、1451.4、1451.5 等 在 消息（message）和 TEDS 的定义上会有出入（各自有适应性改造），按需选择其中一个即可。**比如智能传感器系统中 NCAP 和 TIM 的通讯为 点对点的 有线的形式，则对于 消息（message）和 TEDS 的定义 看 1451.2 标准，如果为无线通讯形式，则对于 消息（message）和 TEDS 的定义 看 1451.5 标准。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:3:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"通讯要素 模型 梳理好了，架构 在大脑中也形成了，就差它们中间流动的数字的通讯协议的规范。1451标准描述它们的通讯要素有以下方面： TEDS 的传递（递名片），TIM 自己的 TEDS 描述自己的信息（自描述），TIM 给 NCAP 发送自己的 TEDS（自识别），NCAP 可以发命令/数据来控制/读/写 TIM 的 TEDS。传感器自识别是 IEEE 1451 智能传感器的主要特点之一，TEDS 定义与配置是实现传感器自描述、自识别（即插即用）的核心技术。 数据的传递（干正事），以字节形式，高位先传（MSB），格式为用户自定（推荐使用“响应（Peply or Response）”的格式回传数据）；传输模式被定义为以下几种：1、NCAP 要时再给，2、TIM 缓存满时再给，3、TIM 固定周期性给，4、用户自定其它传输模式。 控制命令的传递（管一管），NCAP 和 TIM 可以相互发 控制命令消息（Command message）做请求（Request），接收方收到后必须予以响应（Response）。 除了数据传递，TEDS 和控制命令的发送都需要等待 响应/回复/应答，若超过 1s 不响应则以 1s 周期循环发送和等待，直到收到正常响应，如果超过一定次数还未收到响应则断连。 1451.0 标准主要针对自描述名片和消息（TEDS and message）的具体规范，以下开始具体介绍。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:3:1","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"消息 的格式 TIM、NCAP 任一方接收到对方消息帧后须返回应答/响应/回复帧，若发送方在规定时间内没接收到对方确认应答帧则重新发送数据，直至发送成功或发送次数达到最大值。 刨除数据的传递，消息（message）分为以下三种类型： 命令（command）； 响应/回复（Peply or Response）； TIM 初始化完毕（TIM initiated）。 命令消息 命令消息（Command message）一般为 NCAP 向 目标 TIM 的特定 通道（Destination TransducerChannel）发送一帧数据来请求（Request）TEDS（就是问，你谁啊？） 或者控制命令（就是下达命令）。TIM 接收到后予以响应（Response），响应的格式详见“响应/回复消息”一节。 Command message 格式如下表所示。 具体释义如下： 前两个字节（Dest Channel Number）指示 目标 TIM 的 目标 通道标号（具体如何分配标号 在 1451.0 标准的 “5.3 Addresses” 一节给出）；或者第一个字节表示目标 TIM 编号，第二个字节表示 传感器通道编号； 第三个字节（Command class）指示命令类别（Command class），具体值如下表，按需填入； ![命令类别（Command class）表](assets/命令类别（Command class）表.png) 第四个字节（Command function）指示具体的命令是什么，根据第三个字节的命令类别分为几大类。 当第三个字节的命令类别（Command class）为 1，为通用命令（CommonCmd），则第四个字节填入下表中的标号以表示想要发送的具体命令。 发送编号为 1 的 Query TEDS command（请求 TEDS 信息表命令） 命令，该命令带一个参数，即请求的 TEDS 的类型编号，详见下文 “TEDS 的格式” 一节的 Table-17。需要 TIM 响应/回应自己的 TEDS 的信息表，详见下表。响应/回复格式按照 “响应/回复消息” 一节描述的格式，下表为响应信息格式中 回复附带参数（Reply-dependent）部分的具体格式。 该表具体释义如下： 第一个字节 为自己的 TEDS 属性，详见 “TEDS 属性” 一节； 第二个字节 为 TEDS 状态，详见下表； 第三、四、五、六个字节指示目前 TEDS 的字节数； 第七、八个字节为 TEDS 的校验值； 最后四个字节为 TEDS 的最大字节数。 发送编号为 2 的 Read TEDS segment command（读 TEDS 命令）命令，参数为 Table-21 所示，如下图。需要 TIM 回应自己的 TEDS，具体格式为：按照 “响应/回复消息” 一节描述的格式，其第 4 个字节开始的 附带信息 的格式为 Table-22 定义，如下图。TEDS 的格式具体见 “TEDS 的格式” 一节。 上表中， TEDSOffset 为 TIM 传回信息中 TEDS 数据开始的偏移量，如果 TIM 回应 纯的 TEDS 数据，那么该值为 0 即可。 发送编号为 3 的 Write TEDS segment command（写 TEDS 命令） 命令，可以用于改写 目标 TIM 的 TEDS 的 某个部分。具体见标准 1451.0 的 7.1.1.3 一节。（太多了不想翻了，搞的那么繁杂）。 编号 4 的 Update TEDS command（更新 TEDS 命令），即使用 Write TEDS segment command（写 TEDS 命令）命令之后，再用该命令让 TIM 保存其刚接收到的新的 TEDS 到其非易失存储器（FLASH 或 EEPROM 等）内。命令参数为 TEDS 类型编号（Table-17），TIM 响应信息格式同Query TEDS command（请求 TEDS 信息表命令） 命令的回复格式。 下面不一个一个细说了。 编号 5 的 Run self-test command（运行自测命令）。 编号 6 的 Write service request mask（写 NCAP 请求目标地址的掩码）。 编号 7 的 Read service request mask（有写就有读…）。以下编号依次类推。 Read status-event register（读目标 TIM 或者 TIM 的传感器通道（Transducer Channel）的状态码）。 Read status-condition register。 Clear status-event register。 Write status-event protocol state。 Read status-event protocol state。 编号 128~255 的命令为用户保留，用户可自定义。 前置定义，TIM 和传感器通道 的状态分类以及状态图定义，详见 “TIM/传感器 的状态图” 一节。当第三个字节的命令类别（Command class）为 2，即 传感器 空闲状态命令（XdcrIdle，Transducer idle state commands），该命令在 传感器 为 空闲状态（Idle）时才有效，其他状态无效。此时，第四个字节填入下表中的标号以表示想要发送的具体命令： 不一一详细介绍了，具体看 1451.0 标准源文的 7.1.2 一节。 编号 1 为设置 TIM 的传感器通道的数量。 编号 2 为 设置 TIM 的某一个传感器通道能否在 free-running 状态下被设置为 pre-trigger 模式（关于 TIM 和 传感器通道的 状态和模式 定义详见 1451.0 标注源文的 5.10 一节）。 编号 3 This command assigns a TransducerChannel to an AddressGroup. 编号 4 设置 TIM 的某一个传感器通道的采集模式。 编号 5 设置 TIM 数据传输模式。 等等，太繁琐了。 当第三个字节的命令类别（Command class）为 3，即 传感器 空闲状态命令（XdcrOperate，Transducer operating state commands），该命令在 传感器 为 工作状态（operational state）时才有效，其他状态无效。此时，第四个字节填入下表中的标号以表示想要发送的具体命令： 编号 1 为 Read TransducerChannel data-set segment（读传感器通道数据集）命令，带一个命令参数为返回的数据集中读数据起始位置的偏移，TIM 回应数据以 “响应/回复消息” 一节描述的格式，响应/回复参数为 1451.0 标准 Table-32 指定。 后面略。 当第三个字节的命令类别（Command class）为 4，即 传感器 空闲状态或工作状态命令（XdcrEither，Transducer either idle or operating state commands），此命令类下的具体命令见 1451.0 标注源文的 Table-34。 当第三个字节的命令类别（Command class）为 5，即 TIM 睡眠状态命令（TIM sleep state commands），该命令只在 TIM 睡眠状态下有效，此命令类下的具体命令见 1451.0 标注源文的 Table-35，用于唤醒，目前只此一个命令，其他均作保留。 当第三个字节的命令类别（Command class）为 6，即 TIM 激活状态命令（TIM active state commands），该命令只在 TIM 激活状态下有效，此命令类下的具体命令见 1451.0 标注源文的 Table-36。 当第三个字节的命令类别（Command class）为 7，即 TIM 任何状态命令（TIM any state commands），此命令类下的具体命令见 1451.0 标注源文的 Table-37，用于复位 TIM，目前只此一个命令，其他均作保留。 第五、六个字节（Length）指示 附带的命令参数的字节数，接收方可据此判断何时接收完毕从而得到完整数据； 往后（Command dependent）为根据具体的附带的命令的参数。 响应/回复消息 一方接收到消息（Message）后予以响应/回应/回复（Peply or Response），其具体的的消息格式如下表所示。 具体释义如下： 第一个字节（Flag）：0 表示失败，其它值 表示成功； 第二、三个字节（Length）：指示 Reply-dependent 部分的字节数，接收方可据此判断何时接收完毕从而得到完整数据； 往后为 Reply-dependent 内容，根据收到的特定命令回应相应的信息。 初始化完毕消息 TIM 初始化完毕后给 NCAP 发送一个 初始化完毕信息（TIM initiated message），其具体的的消息格式如下表所示。 具体释义如下： 前两个字节指示 本 TIM 的哪个通道 在发 此信息，即指示哪个通道初始化完毕了； 其他格式 同 “命令消息”，具体详看同名小节。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:3:2","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"TEDS 的格式 TEDS 包含一个仪器设备或测量系统，可对传感器进行识别、校正、连接及传感器数据信息的正确使用。具体信息有：厂商信息、模块编号、版本信息、产品序列号、灵敏度、测量范围、电气输出范围、功率要求、物理单位、校准信息、维护信息、位置信息以及用户数据等。 TIM 一旦上电或接受了 请求 TEDS 的命令，TEDS 信息就上传到 NCAP。TEDS 简化了传感器的安装/部署，一个被损坏的传感器可以直接被替换而不需要更改任何设置。 TEDS 的所有类型如下图，第三列是该类型的名称。第一列的代号为 10 进制表示。 一个 TIM 必要有的四个 TEDS 类型如下，其他 TEDS 为可选。 Meta-TEDS（描述所在 TIM 的基本信息、，传感器通道数、分组情况，详见 1451.0 标准的 8.4 小节）； TransducerChannel TEDS（描述 TIM 中特定传感器通道的详细信息，比如物理上实际的采集量、被控量，工作模式等，详见 1451.0 标准的 8.5 小节）； User’s Transducer Name TEDS（存储所在智能传感器的名称用于系统识别，用于，详见 1451.0 标准的 5.5.1.3 小节和 8.11 小节）； PHY TEDS（描述 TIM 与 NCAP 之间的物理连接的媒介，格式无标准定义，可用户自定）。 所有 TEDS 类型的格式如下（General format for TEDS）。 如上图所示，一帧数据的构建： TED 长度（TED Length），包括 DATA BLOCK 和 CHECKSUM，字节为单位 （占 4 个字节）； 数据区（DATA BLOCK）： 第一个域类（Field type）（占 1 个字节）； 第一个域类的 值的长度（Length of Value），字节为单位（占一个字节）； 第一个域类的值（Value）（占 值的长度 个字节）； 第二个域类（占 1 个字节）； 第二个域类的 值的长度，字节为单位（占一个字节）； 第二个域类的值（占 值的长度 个字节）； … 以此类推。 校验值（CHECKSUM），从 TED Length 到 DATA BLOCK 的最后一个字节加和，再用 0xFFF 减去该加和值（占两个字节）。 TEDS 的一些注意的点： TEDS 有 实TEDS 和 虚TEDS 之分，对于那些不能包含非易失存储器器件来保存 TEDS 的 TIM 就是用 虚TEDS，虚TEDS 保存在某个网络节点上，NCAP 索要 TEDS 的时候由该节点提供 TIM 的 TEDS ，实 TEDS 即 TEDS 信息真实的保存在 TIM 内部的非易失存储器。 TEDS 的内容 在 TIM 执行器件可以根据传感器通道等的变化进行改动，或者接收到 NCAP 的改动 TEDS 的控制命令消息进行改动。 可以根据应用场景和开发限制来适当删减 TEDS 中一些冗长繁杂的格式。 Meta-TEDS 格式 描述所在 TIM 的基本信息、，传感器通道数、分组情况，详见 1451.0 标准的 8.4 小节。 该 TEDS 可以如何访问到：The Meta-TEDS is accessed using a Query TEDS command, a Read TEDS segment command, a write TEDS segment command, or an Update TEDS command.从 Table-17 可知该 TEDS 代号 01（10 进制）。该表的第一列 域类 号均为 10 进制表示。 上表的各个域类不必全部给出，标好域类好就行。其具体说明如下： 开头为 TED 长度（TED Length），包括 DATA BLOCK 和 CHECKSUM，字节为单位，占 4 个字节； 数据区（DATA BLOCK）的第一个域类为 TEDSID，即 TEDS identification header，详见 本文 “TEDS 头” 一节； 第二个域类 UUID，全局独特身份码（名片上的大名），举例（16 进制）：04 0a 8d 4d 9d a6 52 81 f7 00 00 00，释义如下。 UUID 的定义如下。 紧跟着三个域类分别是 操作超时时间、低速访问超时时间和自测试时间，举例如下。 Float32 占用四个字节，具体编码描述： A single-precision real number is a 32 bit binary sequence that encodes real numbers as specified in IEEE Std 754-1985. 来到域类13，MaxChan，本智能传感器 TIM 下边连着几个 传感器通道（“传感器通道（Transducer Channel）” 这里英文缩写表示为 TCH）（比如采集三路模拟量），举例（16 进制）：0d 02 00 03，表示本 TIM 有 三个传感器通道。 其他域类… 最后两个字节做校验位，从 TED Length（最开头） 到 DATA BLOCK 的最后一个字节（本域类的上一个字节） 的加和，再用 0xFFF 减去该加和值。 上面的进行组合，这就是一帧 Meta-TEDS。 再举一个具体的例子（已经保姆级详尽了），如下图所示一个完整 Meta-TEDS。 TransducerChannel TEDS 格式 该 TEDS 是为了确保 TIM 的所有 传感器通道（TCH）有必要信息从而可以被寻址和被操作。该 TEDS 描述 TIM 中特定传感器通道的详细信息，比如物理上实际的采集量、被控量，工作模式等，详见 1451.0 标准的 8.5 小节。 该 TEDS 可以如何访问到：The TransducerChannel TEDS is accessed using a Query TEDS command, a Read TEDS segment command, a write TEDS segment command, or an Update TEDS command.从 Table-17 可知该 TEDS 代号 03（10 进制）。该表的第一列 域类 号均为 10 进制表示。域类3 TEDSID 详见 “TEDS 头” 一节。 信息特别多了，以上每项的具体说明见 1451.0 标准的 “8.5.2 Data block” 章节。 User’s Transducer Name TEDS 格式 存储所在智能传感器的名称用于系统识别，用于，详见 1451.0 标准的 5.5.1.3 小节和 8.11 小节。 The User’s Transducer Name TEDS may be associated with the TIM or a TransducerChannel. It is accessed using a Query TEDS command, a Read TEDS segment command, a write TEDS segment command, or an Update TEDS command.从 Table-17 可知该 TEDS 代号 12。该表的第一列 域类 号均为 10 进制表示。域类3 TEDSID 详见 “TEDS 头” 一节。 上表中域类4，即 format 详见下表（下表中 Field Name 一栏为 16 进制的 10，即 十进制的 4）。 域类5，即 content，详见下表，内容用户自定， TIM 的名字，规范根据 域类 4 的 format 的值（0 为用户自定，1 为按照 标准中 8.9 Text-based TEDS 的规范来（又是一大堆））。 PHY TEDS 格式 1451.0 的一页源文。 PHY TEDS 的具体格式定义在 1451.x（x = 2,3,4,5…）标准里，比如对于 1451.5 无线方式通讯，PHY TEDS 格式定义在其 5.3 一节。 TEDS 头 即 TEDS identification header，这是一个域类，定位于 Meta-TEDS 格式表中的 域类3 中，具体定义详见 1451.0 标准 8.3 小节，格式如下表所示。 上表具体说明如下： 前面三个一般不变，为 03 04 00；需要说明，Family 域的值随着 使用 1451.x（x = 0,2,3,4,5…）标准而变，比如使用 1451.5，Family 域的值变为 05； 第四个域（Class 那里）为当前 TEDS 的类型编号，其具体值见上面 “TEDS 的所有类型” 的表（Table 17）； 第五个域（Version 那里）的具体值见下表（Table 42）； 第六个域（Tuple Length 那里）的具体值，即上面所说的“数据区（DATA BLOCK）”里面的“第 x 个域类的 值的长度（Length of Value）”这个域类所占几个字节，一般为 1。 则 TEDS identification header 这个域类的最终合成如右（举例，十六进制）：03 04 00 01 01 01，具体释义如下。 TEDS 属性 每个 TEDS 都有属性，在 请求 TEDS 命令（Query TEDS command）之后 TIM 响应 TEDS 时带着 该 TEDS 的属性信息。 TEDS 的属性可以设置为 只读，这样 NCAP 的修改 TEDS 的命令不会起作用。源文：TEDS may be implemented as a r","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:3:3","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"TIM/传感器 的状态图 根据 1451.0，TIM 的状态分为两个部分，TIM 自己的状态以及 TIM 下面接的每一个传感器通道的模式状态，TIM 讲模式，传感器讲模式。 智能传感器的 TIM 状态转换图。 智能传感器 TIM 每一个传感器通道（TCH）的状态转换图（模式转换图）。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:4:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"1451.5 标准 1451.5 标准中对于 1451.0 标准的一些新增/兼容部分，参考于 1451.5 标准源文。 1451.5 标准的变化之处举例： TIM 与 NCAP 的连接拓扑关系有新定义（5.1、5.2 小节）； NCAP 和 TIM 状态图新定义（5.4、5.5 小节）； 服务质量定义（5.6 小节）； 错误代号定义（5.7 小节）； message 不变； TEDS 除了 PHY TEDS，其他一样（5.3 小节）； WLAN 章节的一些特别定义（第 9 章）。 关于具体的 1451.5 标准的情况的介绍会在下一篇【读标准02】文章。 ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:5:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"1451标准的局限性 以下记录一些推广上的局限性 和 一些疑问。 把网络化智能传感器系统分为 NCAP 和 TIM 两个模块，而这两个模块都需要有微控制器（或微处理器），增加上手门槛和使用的复杂性。 1451.x 标准 只能放在一起使用，与现有其他标准或者协议差异巨大，需要全新的重新开发。 一个 NCAP 连接多个 TIM ，NCAP 该如何区分不同的 TIM，1451.5 定义吗？，还是用户自定？ 连续发了三个命令，陆续收到三个响应，三个收到的响应如何与三个命令一一对应起来？作者在此认为，响应/回复信息中的回复附带参数部分（Reply-dependent）首先填入接收到的命令的类（class）和具体命令这两个编号，然后才是真正的附带参数，这样 NCAP 可以区分该 回复是针对哪个命令的，NCAP 可以据此差异性解析，提高交互并发性，而不用发出一个命令后只能先等。不过标准也许有对这一块的定义，可能源文几百页太长了作者没注意到。 TEDS 在尽量包含所有传感器类型的描述信息，但不可能穷举所有传感器类型；对于应用层没有对数据格式做规范。简而言之，本文作者认为综合性、一般性模型的目标不算尽善尽美的达到。 与一般标准的一样，体系庞大，内容非常复杂 ，人们理解起来非常费时费力；如今嵌入式处理器应用越来越广，低成本和低功耗的考虑越来越多，因此人们可能只能执行标准的一部分。 制定标准时不容易或者没有处理好与已有标准协议的关系。（6、7 条引自论文《海洋观测网络化智能接口标准的研究_张帅》） ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:6:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"参考 \u0026 引用 [0] IEEE 1451 协议培训，IEEE-1451-介绍 - 百度文库 (baidu.com)，IEEE 1451 介绍ppt课件 - 百度文库 (baidu.com)，IEEE 1451 介绍课件 (renrendoc.com)。 [1] 孔勇,杨志强,张溪溪,杨吉宇,李继明,程学珍.基于IEEE1451标准的称重传感器实验系统设计ADXL355加速度计在强振动环境中的应用[J].电子测试,2020(15):11-13+42.DOI:10.16520/j.cnki.1000-8519.2020.15.003. [2] 解宇. 海洋仪器网络化平台智能船载终端研发[D].济南大学,2019.DOI:10.27166/d.cnki.gsdcc.2019.000446. [3] 杨吉语. 基于IEEE1451.5标准网络传感器的研发[D].山东科技大学,2018.DOI:10.27275/d.cnki.gsdku.2018.000570. [4] 陈耿新,黄锦胜.基于IEEE 1451.5的高精度智能称重传感器系统[J].自动化与信息工程,2017,38(05):5-11. [5] 赵常. 基于IEEE1451标准的加速度智能传感器的研究[D].沈阳理工大学,2016. [6] 陶星珍,蒋廷彪,崔更申.基于IEEE 1451.5标准的物联网体系结构设计[J].计算机测量与控制,2014,22(09):2960-2961+2966.DOI:10.16526/j.cnki.11-4762/tp.2014.09.039. [7] 朱志伟.遵循IEEE1451标准的传感器即插即用研究[J].单片机与嵌入式系统应用,2014,14(09):3-6. [8] 张小廷. 基于IEEE1451标准的无线智能传感网的设计与实现[D].哈尔滨工业大学,2014. [9] 张帅,张锁平,齐占辉.海洋观测网络化智能接口标准的研究[J].电子设计工程,2013,21(09):183-187.DOI:10.14022/j.cnki.dzsjgc.2013.09.003. [10] 王石记,周庆飞,安佰岳.IEEE 1451网络化智能传感器接口技术[J].计算机测量与控制,2012,20(10):2600-2602+2616.DOI:10.16526/j.cnki.11-4762/tp.2012.10.076. [11] 郑培亮. 基于ARM的IEEE 1451智能称重传感器设计[D].华南理工大学,2011. [12] 张韵. 基于IEEE1451标准中间件的研究和实现[D].大连理工大学,2007. [13] 黄永忠,李正晓.IEEE 1451标准族智能传感器技术发展浅析[J].仪器仪表标准化与计量,2005(04):24-27. [14] 童利标,徐科军,梅涛.IEEE1451网络化智能传感器标准的发展及应用探讨[J].传感器世界,2002(06):25-32. ","date":"2021-07-14","objectID":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:7:0","tags":["IEEE 1451","标准","1451.0"],"title":"【读标准01】IEEE1451 智能传感器接口标准介绍","uri":"/10.1%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["【主线剧情】Linux 系列"],"content":"介绍 ARM 和 i.MX6ULL SoC 的基本内容，以及GCC、Makefile等","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM \u0026 i.MX6ULL 基础学习记录 编辑整理 by Staok。 本文大部分内容摘自“100ask imx6ull”开发板的配套资料（如《IMX6ULL裸机开发完全手册》等等），侵删。进行了精髓提取，方便日后查阅。过于基础的内容不会在此提及。如有错误恭谢指出！ 注：在 Github 上的原版文章日后可能会更新，在其它位置发的不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"目录 [TOC] ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM \u0026 Linux 相关 p.s 汇编基本指令和 ARM 的汇编启动代码看 “ARM异常处理 及其模板” 文件夹里的 startup.s 文件。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"cpsr 寄存器详情 运行模式 Cortex-A7架构的运行模式有9种。运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的，用户模式下需要借助异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换。 模式 描述 User 用户模式，非特权模式，大部分程序运行的时候就处于此模式 Sys(System) 系统模式，用于运行特权级的操作系统任务 FIQ 快速中断模式，进入 FIQ 中断异常 IRQ 一般中断模式 ABT(Abort) 数据访问终止模式，用于虚拟存储以及存储保护 SVC(Supervisor) 超级管理员模式，供操作系统使用 UND(Undef) 未定义指令终止模式 MON(Monitor) 用于安全扩展模式 Hyp 用于虚拟化扩展 几点说明： 板子上电时，CPU处于SVC模式，它用的是SVC模式下的寄存器。 程序运行时发生了中断，CPU进入IRQ模式，它用的IRQ模式下的寄存器。 CPU发生某种异常时，比如读取内存出错，它会进入ABT模式，使用ABT模式下的寄存器来处理错误。 每一种模式对应使用的寄存器 几点说明： 如果某个程序处于 FIQ 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_fiq。 如果某个程序处于 SVC 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_svc。 除了 FIQ 模式，寄存器 R0~R12 都是通用的，即模式之间切换前这些寄存器的值应该保存。 假如某个ARM处理器是三级流水线：取指-\u003e译码-\u003e执行，循环执行，那么程序计数器 R15(PC) = 当前执行指令地址 + 4 * 2 个字节。 未定义指令异常的个别用法：在某些系统中，代码可能包含用于协处理器（例如VFP协处理器）的指令，但是系统中不存在相应的VFP硬件。另外，VFP硬件有可能无法处理特定指令，而是想调用软件来对其进行模拟。或者，可能会禁用VFP硬件，采用异常处理，以便可以启用它，然后重新执行指令。使用未定义的指令，可以实现一些仿真器（软件模拟硬件的实现）。比如在你的芯片中，它并未支持某条硬件除法指令，但是你还可以在代码中使用它。当CPU执行这条指令时会发生异常，在异常处理函数中，你用软件来实现该指令的功能。对于不是特别设置的未定义指令，在异常处理函数中不能处理它时，通常做法是记录适当的调试信息，并关掉（kill）对应的应用程序。在某些情况下，未定义指令异常的另一个用途是实现用户断点：调试器（如gdb）去修改代码，替换断点位置的指令为一条未定义指令。 SVC异常的个别用法：软中断 swi 指令可以触发此异常，获得 SVC 权限。在Linux中对文件的open/read/write等APP层的系统函数，它的本质都是执行SVC指令，从而进入Linux内核中预设的SVC异常处理函数，在内核里操作文件。可以使用寄存器或者操作码中某个字段将参数传递给SVC处理程序。 程序状态寄存器 cpsr 所有运行模式都共用一个 CPSR 物理存在的寄存器叫 程序状态寄存器，CPSR 可以在任何模式下被访问。当特定异常中断发生时，备份程序状态寄存器 SPSR 用来保存 CPSR 的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。 各个位的说明： N(bit31)：当两个有符号整数(补码表示)运算时，结果用N表示，N=1/0 表示 负数/正数。 Z(bit30)：对于 CMP 指令，Z=1 表示进行比较的两个数大小相等。 C(bit29)： 在加法指令中，当结果产生了进位，则C=1，表示无符号数运算发生上溢，其它情况下 C=0； 在减法指令中，当运算中发生借位，则C=0，表示无符号数运算发生下溢，其它情况下 C=1； 对于包含移位操作的非加/减法运算指令，C 中包含最后一次溢出的位的数值； 对于其它非加/减运算指令，C 位的值通常不受影响。 V(bit28)：对于加/减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V=1 表示符号位溢出，通常其他位不影响 V 位。 Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q=1/0 表示累积饱和/累积不饱和。 IT[1:0] (bit26:25) 和 IT[7:2] (bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。 J(bit24) 和 T(bit5)：控制指令执行状态，表明本指令是ARM指令还是Thumb指令。{J,T} = b00 为 ARM；= b01 为 Thumb；= b11 为 ThumbEE；= b10 为 Jazelle。 GE[3:0] (bit19:16)：SIMD（单指令多数据，处理器为提升并行操作的一种功能） 指令有效，大于或等于。 E(bit9)：大小端控制位，E=1/0 表示大/小端模式。 A(bit8)：禁止异步中断位，A=1 表示禁止异步中断。 I(bit7)：I=1/0 代表 禁止/使能 IRQ。 F(bit6)：F=1/0 代表 禁止/使能 FIQ。 M[4:0]：运行模式控制位，如表 M[4:0] 运行模式 10000 User 模式 10001 FIQ 模式 10010 IRQ 模式 10011 Supervisor(SVC)模式 10110 Monitor(MON)模式 10111 Abort(ABT)模式 11010 Hyp(HYP)模式 11011 Undef(UND)模式 11111 System(SYS)模式 在用户模式下，无法改变处理器模式的M位[4：0]来切换模式和A，I和F位来使能或者禁止异步中止、IRQ和FIQ。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:1","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"大小端模式 大端模式（Big-endian），是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:2","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"汇编程序调用 C 程序详情 在 C 程序和 ARM 汇编程序之间相互调用时必须遵守 ATPCS 规则，其是基于 ARM 指令集和 THUMB 指令集过程调用的规范，规定了调用函数如何传递参数，被调用函数如何获取参数，以何种方式传递函数返回值。 寄存器 R0~R15 在 ATPCS 规则的使用 在函数中，通过寄存器 R0~R3 来传递参数，被调用的函数在返回前无需恢复寄存器 R0~R3 的内容。 在函数中，通过寄存器 R4~R11 来保存局部变量。 寄存器 R12 用作函数间 scratch 寄存器。 寄存器 R13 用作栈指针，记作 SP ，在函数中寄存器 R13 不能用做其他用途，寄存器 SP 在进入函数时的值和退出函数时的值必须相等。 寄存器 R14 用作链接寄存器，记作 LR ，它用于保存函数的返回地址，如果在函数中保存了返回地址，则 R14 可用作其它的用途。 寄存器 R15 是程序计数器，记作 PC ，它不能用作其他用途。 汇编程序向 C 程序函数传递参数 当参数小于等于 4 个时，使用寄存器 R0~R3 来进行参数传递。 当参数大于 4 个时，前四个参数按照上面方法传递，剩余参数传送到栈中，入栈的顺序与参数顺序相反，即最后一个参数先入栈。 C 程序函数返回结果给汇编程序 结果为一个 32 位的整数时，通过寄存器 R0 返回。 结果为一个 64 位整数时，通过 R0 和 R1 返回，依此类推。 结果为一个浮点数时，通过浮点运算部件的寄存器 f0，d0 或 s0 返回。 结果为一个复合的浮点数时，通过寄存器 f0-fN 或者 d0~dN 返回。 对于位数更多的结果，通过调用内存来传递。 当 C 程序从一个函数跳转到另一个函数时，会先把源函数的 CPU 的寄存器和函数内的局部变量都入栈，当跳回时再出栈，这一过程的汇编代码是当 C 程序编译成汇编时被编译器自动添加。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:3","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"imx6ull 裸机编程相关 这里是处理器启动流程等的介绍，属于科普环节，有个印象，会加深对于处理器如何运行的理解，非必要记住，而是为以后的操作说明每一个步骤都在做什么事情。此部分理解为主。 ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"裸机映像文件合成详情 先说原理，看 imx6ull 芯片手册可知，芯片上电时内部的 boot ROM 固化的程序会通过外部引脚确定启动方式（USB\\NAND\\EMMC\\SD等），将应用的二进制数据（app.bin）从存储区（NAND\\EMMC\\SD等）搬运到内存区（DDR2\\3等），然后跳转到内存区的程序处开始执行程序。这个过程是这个芯片自动完成的，但是需要根据规定合成烧录到存储区的映像文件， 在编译得到应用的二进制文件 app.bin（这个就是比如 裸机应用固件 或 Linux 固件等）之后，再用 mkimage 工具（gcc-arm-linux-gnueabihf-6.2.1 编译器自带的）根据 imximage.cfg.cfgtmp 这个文件的信息，合成头部信息，再与 app.bin 组合生成 .imx 文件， .imx 的头部再添加 1KB 的数据（可以全为0，也可包含分区表等数据） 组合生成 .img 文件，具体如下： .imx 文件 = 头部信息（ IVT + Boot data + DCD） + app.bin -\u003e 用于在烧写工具中烧写到 EMMC 中，烧写工具会自动将其烧写到 1KB 偏移处。 .img 文件 = 1k.bin + .imx 文件 = 1k.bin + 头部信息（ IVT + Boot data + DCD） + app.bin -\u003e 用于在烧写工具中烧写到 SD 中，烧写工具会将其烧写到 0 位置处（对与 SD 的烧写，此工具不会自动加 1KB 偏移…）。 头部信息包含了指示 boot ROM 程序要把 app.bin 数据搬运到内存的何处，其大小，以及包含了配置 DDR 的寄存器、引脚等数据等待，具体如下： IVT：Image vector table，含 header（含 tag、length、version，这 3 项，length 表示 IVT 的大小）、entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）、dcd（指示 DCD 数据 在内存中的位置）、boot_data（指示 Boot data 在内存中的位置）、self（指示 IVT 在内存中的位置）等，共占 32*8bit 大小，entry 为 app.bin 要在内存中的目的地址。 Boot data：start（映像文件在内存中的地址，为 IVT 在内存中的绝对地址减去 1024 偏移）、length（整个映像文件的长度，含 1k.bin）、plugin，共占 32*3bit 大小。 DCD：配 imx6ull 芯片的寄存器，如 DDR 的配置等，可自定，复杂，mkimage 根据 imximage.cfg.cfgtmp 这个文件的信息合成。 其中，entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）的地址在 Makefile 中调用 mkimage 工具时是可以指定的，在\"重定位\"章节会细说。 具体分布： 头部数据和偏移区使用 mkimage 工具生成，官方都会提供的。 最前面的灰色部分就是偏移数据区，对于EMMC/SD存储区设备是 1KB，对于 NAND 是256B，具体看手册。 最终生成的 .img 文件结构： imx6ull 上电启动过程分析： boot Rom 会把 EMMC 或 SD 卡的前 4K 数据（涵盖了头部信息（ IVT + Boot data + DCD）这些等）读入到芯片内部 RAM 运行。 boot Rom 根据 DCD 进行初始化 DDR。 boot Rom 根据 IVT，从 EMMC 或 SD 卡中将 app.bin 读到 DDR 的 0x80100000 地址（IVT 的 entry，如上图所示）。 跳转到 DDR 的 0x80100000 地址执行，即 CPU 开始从内存 0x80100000 地址开始执行机器码。 以上步骤执行完之后的 DDR 内存图示：（这是反汇编 应用固件 产生的 机器码-汇编码 相互对应的内容） ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:1","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"重定位、启动和编译 各段数据重排序 每一个汇编成机器码的 .o 文件都会分为这几个数据段： 代码段(.text)：存放代码指令； 只读数据段(.rodata)：存放有初始值并且 const 修饰的全局类变量； 数据段(.data)：存放有初始值的全局类变量（有非零初始值的变量，如 char A = 'A';）； 零初始化段(.bss)：存放没有初始值或初始值为0的全局类变量（如 int g_intA = 0;int g_intB;，这些存放在 .bss 段）； 注释段(.comment)：存放注释。 在 Makefile 文件中，在链接步骤，通过 LD 工具，把各个 .o 文件的各个数据段，按照 imx6ull.lds 定义的顺序安放，即各段数据重排序，最后合成一个二进制文件 app.bin，其中的代码段(.text)、只读数据段(.rodata)和数据段(.data)等都来自于前面各个 .o 文件，每个段 的顺序按照 imx6ull.lds 安放。 链接脚本 imx6ull.lds 解析（一体式链接脚本格式）： SECTIONS { . = 0x80100000; //设定链接地址为0x80100000 . = ALIGN(4); //将当前地址以4字节为标准对齐 .text : //创建段，其名称为 .text { //.text包含的内容为所有链接文件的数据段 *(.text) // *：表示所有文件 } . = ALIGN(4); //将当前地址以4字节为标准对齐 .rodata : { *(.rodata) } //.rodata存放在.text之后,包含所有链接文件的只读数据段 . = ALIGN(4); .data : { *(.data) } //.data存放在.rodata之后，包含所有链接文件的只读数据段 . = ALIGN(4); __bss_start = .; //将当前地址的值存储为变量__bss_start .bss : { *(.bss) *(.COMMON) } //.bss存放在.data段之后, 包含所有文件的bss段和注释段 __bss_end = .; //将当前地址的值存储为变量__bss_end } 可见 imx6ull.lds 文件给出 .bss 段的头、尾地址标识：__ bss_start 和 __ bss_end。 启动文件程序 以最简单的裸机点灯程序的启动文件 start.S 为例。仅为示例，过于简单，完整示例可看 下面 “ARM异常处理 \u0026 启动文件的示例” 一节。 .text .global _start _start: /* 设置栈地址 */ ldr sp,=0x80200000 bl main halt: b halt Makefile 文件解析 以最简单的裸机点灯程序的 makefile 为例。 PREFIX=arm-linux-gnueabihf- CC=$(PREFIX)gcc LD=$(PREFIX)ld AR=$(PREFIX)ar OBJCOPY=$(PREFIX)objcopy OBJDUMP=$(PREFIX)objdump led.img : start.S led.c main.c $(CC) -nostdlib -g -c -o start.o start.S # 把启动文件 .s 和各个 .c 文件都汇编为机器码文件 .o $(CC) -nostdlib -g -c -o led.o led.c $(CC) -nostdlib -g -c -o main.o main.c $(LD) -T imx6ull.lds -g start.o led.o main.o -o led.elf # 链接，按照 imx6ull.lds 定义的格式，各段数据重排序，把各个 .o 文件组成 .elf 文件 $(OBJCOPY) -O binary -S led.elf led.bin # .elf 转为 .bin 二进制文件，应用二进制文件 $(OBJDUMP) -D -m arm led.elf \u003e led.dis mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80100000 -d led.bin led.imx # 使用 mkimage 生成 头部数据，并与 .bin 组合，产生 .imx 文件 dd if=/dev/zero of=1k.bin bs=1024 count=1 # 创建一个 1KB 的空文件 1k.bin cat 1k.bin led.imx \u003e led.img # 把 1k.bin 放在 .imx 前头，组合成 .img 文件 clean: rm -f led.dis led.bin led.elf led.imx led.img *.o 清零 bss 段 在 启动文件 汇编程序中，根据 .bss 段的头、尾地址（__ bss_start、__ bss_end）来对此区域清零，让 C 程序中未定义初始值或零初始值的变量在初始化时都为零值，而非随机值。 附程序： clean_bss: ldr r1, =__bss_start @ 将链接脚本变量__bss_start变量保存于r1 ldr r2, =__bss_end @ 将链接脚本变量__bss_end变量保存于r2 mov r3, #0 clean: strb r3, [r1] @ 将当前地址下的数据清零 add r1, r1, #1 @ 将r1内存储的地址+1 cmp r1, r2 @ 相等：清零操作结束；否则继续执行clean函数清零bss段 bne clean mov pc, lr 并在进入主函数前调用 bl clean_bss /* 清零bss段 */。 数据段再单独重定位 事出有因，想要把 .data 段的数据放到 片内内存中以加快访问速度，参考芯片手册得到片内RAM的地址为：0x900000 ~ 0x91FFFF，共128KB（当然不会很大，也就裸机下的编一编、学一学行，Linux 系统等的大型工程就不适合了），所以我们将 .data 段重定位后的地址设置为0x900000。 第一步：把链接脚本 imx6ull.lds 中的 .data : { *(.data) }换成下面的： data_load_addr = .; .data 0x900000 : AT(data_load_addr) { data_start = . ; //addr = 0x900000 *(.data) data_end = . ; //addr = 0x900000 + SIZEOF(.data) } 第二步：在启动文件中，复制 data 段数据到片内内存 data_start copy_data: /* 重定位data段 */ ldr r1, =data_load_addr /* data段的加载地址, 从链接脚本中得到, 0x8010xxxx */ ldr r2, =data_start /* data段重定位地址, 从链接脚本中得到, 0x900000 */ ldr r3, =data_end /* data段结束地址, 从链接脚本中得到,0x90xxxx */ cpy: ldr r4, [r1] /* 从r1读到r4 */ str r4, [r2] /* r4存放到r2 */ add r1, r1, #4 /* r1+1 */ add r2, r2, #4 /* r2+1 */ cmp r2, r3 /* r2 r3比较 */ bne cpy /* 如果不等则继续拷贝 */ mov pc, lr /* 跳转回调用copy_data函数之前的地址 */ 并在进入主函数前调用 bl copy_data /* 复制 data 段数据到片内内存 data_start */ 100ask imx6ull 的 《IMX6ULL裸机开发完全手册》中的 “第13篇 IMX6ULL裸机开发 - 9.4.3 总结:如何在C函数中使用链接脚本变量” 章节讲了如何在 C 程序中调用链接脚本中的表示地址的变量，从而可以在 C 程序中实现 “清零 bss 段\"和\"数据段搬运到片内内存”，而不用在启动代码里完成这些操作。 100ask imx6ull 的 《IMX6ULL裸机开发完全手册》中的 “第13篇 IMX6ULL裸机开发 - 9.5 重定位全部代码” 章节讲了将全部应用的二进制数据搬到芯片的内部内存（128KB），并在其内运行，并且使用 C 程序实现 bss 段清零。其步骤是：第一步，修改链接脚本，段顶位置加上 . = 0x900000;，并加上头、尾的地址标识字符；第二步，在 C 程序中利用头、尾的地址标识字符将其间的数据搬运到芯片内部内存地址；第三步，修改启动文件汇编程序，跳转到内部内存的应用数据处执行。 修改应用在内存中的存放地址 IVT 中的 entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）的地址在 Makefile 中调用 mkimage 工具时是可以指定，需要改相关联的几个地方如下： 假设应用的二进制数据（app.bin）原来是要存放在内存的 0x80100000 位置，现在要改为 app_address 处。 Makefile 文件中修改 -e 选项后的地址 mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80100000 -d relocate.bin r","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:2","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"100ASK IMX6ULL Flashing Tool 工具使用 通过 USB 运行裸机程序（不需要烧写，通过u-boot直接在内存中运行）： 板子设到 USB 启动，在 100ask_imx6ull_flashing_tool 工具中的“专业版”界面，打开 .imx 文件，直接点运行。 通过 USB 烧写裸机程序： 板子设到 USB 启动，在 Tool 中的“基础版”界面，若选 EMMC ，则用 .imx 文件，若选 SD ，则用 .img 文件。成功后，断电，切到 EMMC 或 SD 启动模式，再上电。 或者在 win 上，用 win disk imager 工具，把 .img 文件写到 SD 卡。 基础版界面详情： 按钮 作用 烧写整个系统 “选择设备”为EMMC时，把emmc.img烧到EMMC上； “选择设备”为SD/TF时，把sdcard.img烧到SD/TF卡上； “选择设备”为NAND时，把rootfs.ubi烧到Nand Flash上； 并且会烧写对应的U-Boot，请看下面的“更新Uboot”按钮说明。 更新内核 把zImage上传到根文件系统的/boot目录 (对于Nand，是直接烧到内核分区) 更新设备树 把100ask_imx6ull-14x14.dtb上传到根文件系统的/boot目录 (对于Nand，是直接烧到设备树分区) 更新Uboot 对于IMX6ULL全功能版： ①“选择设备”为EMMC时，把u-boot-dtb.imx烧写到EMMC ②“选择设备”为SD/TF时，把u-boot-dtb.imx烧写到SD/TF卡 对于IMX6ULL mini nand版： ①“选择设备”为NAND时，把u-boot-dtb_nand.imx烧写到Nand Flash ②“选择设备”为SD/TF时，把u-boot-dtb_nandsd.imx烧写到SD/TF卡 烧写裸机 把所选裸机文件，烧写到EMMC、SD/TF卡或Nand Flash 上传文件 把所选用户文件，上传到根文件系统的/目录 对于imx6ull mini nand版，无法上传文件(只支持ext4文件系统，而它不是) ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:3","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"异常与GIC介绍 GIC概念 念课本（以下内容都是针对\"通用中断控制器（GIC）“而言，直接摘录的，有的地方可能不符人类的理解方式）： 通用中断控制器（GIC）架构提供了严格的规范，不同厂商的中断控制器之间具有很高的一致性；该控制器包括一组用于管理单核或多核系统中的中断的硬件资源。GIC提供了内存映射寄存器，可用于管理中断源和行为，以及（在多核系统中）用于将中断路由到各个CPU核。它使软件能够屏蔽、启用和禁用来自各个中断源的中断，以（在硬件中）对各个中断源进行优先级排序和生成软件触发中断。它还提供对TrustZone安全性扩展的支持。GIC接受系统级别中断的产生，并可以发信号通知给它所连接的每个内核，从而有可能导致IRQ或FIQ异常发生。 通用中断控制器的工作流程。GIC分为两部分：分发器（Distributor）和CPU接口（CPU interface）。系统中的所有中断源都连接到分发器。可以通过仲裁单元的寄存器来控制各个中断源的属性，例如优先级、状态、安全性、触发方式和使能状态。中断的优先级和可接收中断的核都在分发器中配置。分发器把中断输出到“CPU接口单元”，后者决定将哪个中断转发给CPU核。CPU接口单元寄存器用于屏蔽、识别和控制转发到CPU核的中断的状态。系统中的每个CPU核心都有一个单独的CPU接口，一个CPU核不可能访问另一个CPU核的CPU接口。中断处理详情请看下面的\"处理中断\"部分。 GIC作为内存映射的外围设备，被软件访问。所有内核都可以访问公共的 GIC的分发器 单元。 中断在软件中由一个称为中断ID的数字标识。中断ID唯一对应于一个中断源。软件可以使用中断ID来识别中断源并调用相应的处理程序来处理中断。呈现给软件的中断ID由系统设计确定，一般在SOC的数据手册有记录。 中断可以有多种不同的类型： 软件触发中断（SGI，Software Generated Interrupt）。这是由软件通过写入专用仲裁单元的寄存器即软件触发中断寄存器（ICDSGIR）显式生成的。它最常用于CPU核间通信。SGI既可以发给所有的核，也可以发送给系统中选定的一组核心。中断号0-15保留用于SGI的中断号。用于通信的确切中断号由软件决定。 私有外设中断（PPI，Private Peripheral Interrupt）这是由单个CPU核私有的外设生成的。PPI的中断号为16-31。它们标识CPU核私有的中断源，并且独立于另一个内核上的相同中断源，比如，每个核的计时器。 共享外设中断（SPI，Shared Peripheral Interrupt）。这是由外设生成的，中断控制器可以将其路由到多个核。中断号为32-1020。SPI用于从整个系统可访问的各种外围设备发出中断信号。 GIC分发器 拥有许多寄存器，可以通过它们配置各个中断的属性。这些可配置属性是： 中断优先级：GIC分发器使用它来确定接下来将哪个中断转发到CPU接口。 中断配置：这确定中断是对电平触发还是边沿触发。 中断目标：这确定了可以将中断发给哪些CPU核。 中断启用或禁用状态：只有GIC分发器中启用的那些中断变为挂起状态时，才有资格转发。 中断安全性：确定将中断分配给Secure还是Normal world软件。 中断状态。中断标志位需要软件清除。 GIC分发器还提供优先级屏蔽，可防止低于某个优先级的中断发送给CPU核。 处理流程 众多的中断源，汇集于中断管理器，由中断管理器选择优先级最高的中断并通知CPU。CPU会根据中断的类型到跳转到不同的地址处理中断。当CPU核接收到中断时，它会跳转到异常向量表执行。顶层中断处理程序读取CPU接口模块的Interrupt Acknowledge Register，以获取中断ID。除了返回中断ID之外，读取操作还会使该中断在GIC分发器中标记为active状态。一旦知道了中断ID（标识中断源），顶层处理程序就可以根据中断ID来执行相应的处理任务。 当特定于设备的处理程序完成执行时，顶级处理程序将相同的中断ID写入CPU interface模块中的End of Interrupt register中断结束寄存器，指示中断处理结束。除了把当前中断移除active状态之外，这将使最终中断状态变为inactive或pending（如果状态为inactive and pending），这将使CPU interface能够将更多待处理pending的中断转发给CPU核。这样就结束了单个中断的处理。 同一CPU核上可能有多个中断等待服务，但是CPU interface一次只能发出一个中断信号。顶层中断处理程序重复上述顺序，直到读取特殊的中断ID值1023，表明该内核不再有任何待处理的中断。这个特殊的中断ID被称为伪中断ID（spurious interrupt ID），伪中断ID是保留值，不能分配给系统中的任何设备。 再讲一遍，中断信号先到达分发器，分发器根据该中断所设定的CPU，把中断发送到CPU对应的CPU interface上；在CPU interface里判断该中断的优先级是否足够高，能否抢断或打断当前的中断处理，如果可以，CPU interface就会发送一个物理的信号到CPU的IRQ（或FIQ）线上；CPU接收到中断信号，转到中断处理地址进行处理。 初始化流程 复位后，必须初始化GIC，中断才能生效。在初始化中断时，要初始化这4部分：产生中断的源头(GPIO模块或UART模块等)、GIC(内部有Distributor或CPU interface)、CPU本身(设置CPSR寄存器)。 最后提一句，相关的初始化和处理的代码，芯片官方会提供裸机编程的框架，提供基本的所有寄存器及其结构体的 .h 文件，以及相关使用例程代码，用时看懂就行。 前文根据 100ask的《imx6ull裸机编程》部分的 第十章 “异常与中断” 一节 进行简单总结，后面再看100ask的《imx6ull裸机编程》部分的 第十一章 “GPIO中断” 内容可了解裸机编程中的中断部分。 更多内容 中断管理_lgjjeff的博客-CSDN博客。 … ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:4","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM异常处理 \u0026 启动文件的示例 这里根据 100ask的《imx6ull裸机编程》部分的介绍内容，给出一个 比较丰富的、删去无关代码保留中断处理的、注释丰富的一个 启动文件 汇编程序示例。 @ 本程序仅仅是一个示例 @ 不同ARM内核的中断向量表不同，具体看手册 @ 现在的微处理器寄存器结构非常复杂，不建议硬刚芯片手册手写配置代码，直接参考厂家和网络高手的例子特别省事 @ 一些基础的、不变的、规律性的则必须要会 @ 中断的保存、恢复现场，以及分辨中断号和调用相应中断函数，Cortex M3/M4 是硬件完成的， Cortex A7 是软件实现的 .text @ 代码段(.text)，表示代码段 @ 其他段介绍： @ 只读数据段(.rodata)：存放有初始值并且const修饰的全局类变量（全局变量或static修饰的局部变量） @ 数据段(.data)：存放有初始值的全局类变量 @ 注释段(.comment)：存放注释，注释段里面的机器码是用来表示文字的 @ 零初始化段(.bss)：存放没有初始值或初始值为0的全局类变量 @ 注：bss段和注释段不保存在bin/elf文件中， @ 所以如果bss段的数据没有清0的话，没有初始值的变量在初始化时会是随机的，但个人觉得清不清0不是特别重要。 .global start @ .global 表示 start 是一个全局符号 start: @ 程序入口 @异常向量表 b reset @ 0x00 reset ldr pc,=_undef @ 0x04 undef 未定义指令异常 ldr pc,=_swi_handler @ 0x08 swi 软中断入口 （如果用 mov 指令有32M地址大小限制） ldr pc,=_pre_fetch @ 0x0c prefetch abort ldr pc,=_data_abort @ 0x10 data abort nop @ 0x14 reserved ldr pc,=_irq @ 0x18 irq ldr pc,=_fiq @ 0x1c fiq _undef: .word _undef _swi_handler: .word _swi_handler _pre_fetch: .word _pre_fetch _data_abort: .word _data_abort _irq: .word _irq _fiq: .word _fiq _swi_handler: stmfd sp!,{r0-r12,lr} @ 把 r0-r12 和 lr 寄存器内容进栈，即保护现场 sub r0,lr,#4 @ 软中断号被保存到 lr 寄存器的上一个指令地址，将其临时保存到 r0 ldr r0,[r0] @ 取 r0 保存的地址所指向的值 bic r0,#0xff000000 @ 根据手册，软中断号被保存在低 24 位，则把高八位内容清 0 bl swi_user_handle @ 跳转到 swi_user_handle 软中断用户处理程序，并把下一指令的地址保存到 lr 中 ldmfd sp!,{r0-r12,pc}^ @ 从栈恢复 r0-r12 寄存器内容，并把原来的 lr 内容 恢复到 pc 中， @ 并从 spsr（cpsr的影子寄存器）恢复到 cpsr，即恢复现场 swi_user_handle: @... 软中断的用户应用程序，可以调用 c 函数 cmp r0,#2 @ 判断软中断号是否为2，是则执行后面尾缀带eq的指令 moveq r7,#2 cmp r0,#5 @ 判断软中断号是否为5，是则执行后面尾缀带eq的指令 moveq r7,#5 cmp r0,#7 @ 判断软中断号是否为7，是则执行后面尾缀带eq的指令 moveq r7,#7 ldr pc,lr @ 跳回 _irq: sub lr,lr,#4 stmfd sp!,{r0-r12,lr} bl irq_user_handle ldmfd sp!,{r0-r12,pc}^ irq_user_handle: @... 外中断的用户应用程序，可以调用 c 函数 @并在用户程序中，从中断控制器的寄存器中读出当前的中断号，做相应的相应，然后清中断标志位 @现在的微处理器寄存器结构非常复杂，不建议硬刚芯片手册手写配置代码，直接参考厂家和网络高手的例子特别省事 ldr pc,lr reset: ldr sp,=stack_base @ 分配栈地址到 sp 寄存器 msr cpsr,#0x10 @ 切换到 user 模式 @... 用户应用程序，可以调用 c 函数 swi 2 @ 触发软中断，自动跳转到软中断程序入口 @ 并自动把返回地址（下一个指令的地址）保存到 LR 寄存器 @ 并自动切换到 SVC（超级用户） 模式 nop nop swi 5 nop nop swi 7 nop nop /* @ 这一段是调用 c 程序里面的 void print_test_string(unsigned int cpsr, char *str) 函数 @ 给它传入的两个实参为 r0 和 r1 @ 这时 ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）所规定的 mrs r0, cpsr ldr r1, =test_string bl print_test_string */ b reset @ 返回 reset 地址，大循环 /* test_string: .string \"test_string\" */ @ 定义栈空间和地址，buf 为栈的开头地址，stack_base 为栈的尾地址，中间有 32 个 word 空间 @ 我们使用进出栈的指令是 stmfd 和 ldmfd @ 这两个指令，为从 stack_base 开始向上递进存，向下递进取的顺序，与这里定义的顺序一致 /* ldr sp,=0x80200000 stmfd sp!, {r0-r2} @ 入栈 ldmfd sp!, {r0-r2} @ 出栈 结果： 0x00000000 ... 0x801FFFF4 -\u003e R0 R1 0x80200000 -\u003e R2 sp指针的移动方向：存向上，取向下 也可以用下面指令，效果一样 push {r0-r2} @ 入栈 pop {r0-r2} @ 出栈 */ /* 栈的存取方式 栈的存取方式，为后进先出（LIFO），是由于进出栈指令的作用方式决定的，数据在栈指针处入栈时， 如 stmfd sp!,{r0-r12,lr}，根据这个指令的含义，栈指针sp会根据数据存放的方向自增或自减，出栈的时候过程相反， 在外界看来，这种方式就是只能在头部进出数据的线性表，从算法上来说是一种特殊的线性表，这种 方式是由汇编指令和硬件的易实现性所决定的。 堆是一块空闲空间，使用 malloc 函数来管理它，malloc 函数可以自己写 \"stack_base:\" 这种带冒号的标签表示地址位置，通过其得到指令/数据地址 */ .data buf: .space 32 stack_base: .end ","date":"2021-04-02","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["ARM","Linux"],"title":"【主线剧情01】ARM IMX6ULL 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["人与世人的关系"],"content":"科幻小说《请留在未来》，Science-fiction 《please stay in the future》","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":" 科幻小说《请留在未来》 Science-fiction 《Please Stay in The Future》 本文发在 Github、知乎、BiliBili、小站。 按： 有时真的非常想写一些东西，写一些不一样的东西，这个小文费了不多也不少力气。 星空对于我小时候来说是理想国，做梦会梦到的存在。看火箭发射真的会落泪，不过是想起了多少前辈的努力，看到往天上飞行的火箭，心里一直在呐喊“飞啊，向上!向上冲啊。”对于闲笔碎言的写一些这样的文字，我记得过去的一些，小学应要求写过一篇描述未来学校的，初中写过两个一共几万字的科学幻想小作品，高中又写了几篇小短篇。直到现在这篇，更长，篇幅更丰富。 最初的最初，是在知乎上，抖机灵写了一个描述“实现了共产主义的外星文明”的基本设定的回答，觉得这些设定挺有意思，也有一些想批判性写的东西，由此展开写了此小说。我承认我并没有在认真写科幻文，只是不间断批判性的夹带一些私货。这是一个“后现代魔幻现实赛博朋克文艺和共产红星高照的硬科幻时政”小说。 始写于约2019.7的人生困难时期，有时在路上想到一个点子记下来，有时在睡前隐隐约约想到一种场景记录下来，就这样断断续续积攒灵感，最后在几天里收集整理，成文于2020.6.1的阳光时期，困难终会过去。 注：《请留在未来-注解篇》为对正文中的彩蛋和致敬的部分内容做注解。 版本历史： 2020.6.1 v0.1 第一次成稿； 2020.6.17 v0.3 补充细节，补充《幕后篇》； 2021.9.11 v1.0 为投稿补充更多细节内容，修正一些Bugs使文章更合理，将结局修改为开放结局版本。 2021.9.13 v2.0 半补全结局。 简短介绍： 悠久的人类史诗，在一次次技术革命中重塑，但从二项玻诞生的那一天，我们才真正突破了自身的屏障，而由此展开汹涌澎湃、星辰大海般的第五次、第六次工业革命。如果你来到了这样的未来，一路上，一人向你介绍这里过去几百年的历史，和在这个科幻般的、处于共产主义社会的世界里的奇特事物，你会留在这个未来吗…… ","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:0","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":"概率跳动 我倚石迷花，云跃上翘枝。我观天测物，天斗转星移。 悠久的人类史诗，在一次次技术革命中重塑，但从二项玻诞生的那一天，人类才真正突破了自身的屏障，想象一个与地球相仿的平行地球，但她，随着出现这样的转变，而离我们所熟知的模样远去，快速地变得不可观测，不可理解，不可叙述，是结束，也是开始。 “文明，让宇宙在静默运转中绽放意义之花，从远古第一堆篝火的摇曳微光到新世纪航天器的赤涌尾焰，而这仅是人类文明滔滔麦田中的零星穗谷。 …… 让偏见化作带有人情的想象，让想象缓解带有无知的挫败，哲学总是后知后觉的在事后阐述其道理，我们一直以‘反馈’来认识和改造这个世界，这一次，我们有了‘前馈’。当一个人站在人生十字路口时，如何能够预测每一条分支的未来，可能需要有足够量的信息和得当的想象上的发挥，如果‘想象’从不遵从一定的规律，那么预测未来就不能方法论化；创新属于想象的范畴，创新是否遵从一定的标准和规范，从而实现创新的工业化、流水线化。一个思考者认为‘有用的组合’和‘有意义的简化’是否算作‘创新’的哲学观念。二项玻所引发的认知革命使得人类可以预测近未来，我想这是该变革所引发的最具价值的事情，这是一种几百年来呼之欲出，而又是最重要的一个技术革命，使得并且值得之前的认知逻辑一律推倒重来，这一次的工业革命，竟是回到人类认识这个世界的方式上，意料之外，情理之中，她因简约而美”。——选自《二项玻传》。 透过图书馆的巨型窗，阳光下一切熠熠生辉，夏叶正在看一本书，上面介绍着，“目前的观测表明，我们的宇宙在大尺度结构上曲率接近于——零，这意味着，即在距此大约460亿光年的位置，在可观测宇宙的边缘，以那里作为新的观察点，看上去依旧是漫天的繁星，似曾相识燕归来。与此同时的另一件事，在圆周率无限并且不循环的数字中，理论上包含着所有序列组合，包括每一个人的电话号码，车牌号和身份证，比如笔者的生日出现在第45,561,304位；其可以包含着汤显祖戏剧的GB2312编码，包含着DNA编码，包含着可以描述地球的数字串，也可能包含着另一个无限不循环小数”。 人和桌椅错落的影子渐渐拉长，阳光留在墙壁上的光斑悄悄上升。图书馆证是夏叶所在的一家知名的有着四十多年悠久历史的计算机公司发的，想鼓励员工没事的话多看一点书，这家公司有运营一个百科知识库，夏叶经常要去运维服务器。今天是一个周末，夏叶拿起手机约了公司同事晚上在公园对面的餐馆吃饭。天还没黑，月亮已见，斑驳街景中多了一个看起来正在想事的人。 “最近几天我做了一些奇怪的梦”，夏叶和同事在餐厅一偶闲聊。 “就是那种，很少见的那种，我感觉自己漂浮在宇宙中，很奇怪啊”，夏叶疑惑的说道。 同事来了兴趣，紧接着说，“你不要担心，我不会怕。你也不怎么看关于宇宙的东西啊，怎么会梦见这类东西？” “对啊，最近才想了解一下看看，哈哈之前我连地球外面长什么样子都不晓得，但不瞒你说，那梦相当真实，我梦到我在一个巨大星球的环上，那叫什么来着，土星是吗，各种小山一样的碎冰、碎石还有我都漂浮在那一望无垠的环上，围绕着那个巨物土星旋转，我的天，那土星贼大。然后，某个方向有一个光点慢慢亮起，突然，我周围的物体全部向光点相反方向无声地快速移动并消失，周围的点点星光却几乎一动不动，我感觉我是在向光点的方向移动”。 “挺有意思啊，不过你梦到这种东西正常吗，是不是最近精神压力有些大”。 “就太真实了，好像是什么预兆之类的，但有时候就没有了，昨天就没有”。 “也许又是外星人绑架地球人了呢，哈哈，清醒梦之类的罢了吧，吃饭吃饭”。 又过了不慌不忙的几天工作，梦算是又正常了。 一天晚上，夏叶吃过晚饭，戴上耳机听几首歌，一首流行英文乐，一首中文情歌，再出去压马路，到公园稍微活动一下，同时还听了一首摇滚，一首民谣，一首说唱，一首future bass风格的电音，一首Vocaloid，一首日系轻音乐和一首古典交响乐曲，回到家，刷了几下朋友圈，聊聊天，对明天的日程做一个规划，查一下长期任务的完成情况，再洗漱完毕，便关灯睡去。 这个星空，点点起伏，好像那深邃的远方，也充满故事。 在42光年之外，一个市郊，一个人正在思考，“这个项目最近很难维持了”，大潭结束了一天的工作，疲劳的坐在记录仪前讲述着，“这个机器我已经维持了十年，马上就要成功了”。 大潭继续说道，“大约150年以前，星球共同体第一次接收到了外星文明信号，但是奇怪的是那个文明所在的行星乃至上面的文明种群与我们相当类似。从概率上讲啊，在距离我们足够多的可观测宇宙距离之外，微观粒子的特定排序有可能重现，但是在42光年外这么近的距离便出现了镜像星球，至今都不可理解，我是无神论者，我可不相信这是什么造物，只能说这种情况科学不是不允许。在那个时代我们和他们经过了一来一回的交流，估算他们的科技水平大概落后我们200年，可是由于无线电信号传输的数据太少，并且来回一次交流的时间需要84年！这堪比彗星的漫长周期，有一次我们截获的信号中有记录一个保存了他们大部分文明成果的服务器的所在坐标，于是共星球同体决议研制了这个‘远距离取物’的传送机器，在遥远的两个星球之间传输数据，直接送硬盘比用微弱的无线电信号传输更高效，这个过程预计要进行约150年，相比于84年也只能传相当少的信息来说，这个计划相当可行”。 “当上这个项目的主管，接手这个项目是我年轻时的一个理想。马上就要完成这个已经进行了几代人的实验了，感觉近在咫尺，现在……” 大潭停顿了一下，想了想继续说道，“这个项目已经持续了太久太久，人在历史中学到的之一就是历史会重演。热情消磨在时间中，有人说这个时代的奇迹太多，谁会关心那个落后的处于‘手工业’阶段的文明。在最后的十年里，绝大部分人相继开始认为这个项目是个吸金的无底洞，也有人认为运送过来的可能是核弹，各种声音此起彼伏，人们纷纷反对，我接手这个项目的时候将实验室搬到了丛林大自然中，我喜欢这个环境，但这使得更多的人开始离开，这几年只剩下我一个人在维持实验室的运转。如果有人以后能看到这段，我想说，拜托各位，几百年前的人多么有梦想，他们如此远见的制定了远长于他们寿命的百年计划，这种高瞻远瞩、言而必达的比比皆是。现在这个项目很难维持，我不得不计划铤而走险一出”。 大潭关掉了记录仪，才突然想到，“忘了把机器现在缺少钯元素这个状况记录进去了，说着说着又跑偏。机器大概明后天结束，150年了，星际‘快递’要来了，千万不能在最后一刻掉链子”。 “不录了困了”，大潭心想，“明天去弄来42克钯”。 大潭躺在床上，看着天花板上的几行诗逐渐进入梦乡： “美丽的宇宙太空， 以它的神秘和绚丽， 召唤我们踏过平庸， 进入它无垠的广袤。①” 窗外远处的巨型荧幕上正在播放着画面，其中正播到“……一个人能熟练掌握的知识是有限的，而且在某一刻的思考所能涉及到的方面更是有限的，就像计算机内存一样有限，即便感觉所有的可能性都思考过了，但是仍感觉还有没有思考到的地方。随着知识爆炸的压迫，这种不安全感促使人们制定了名为‘天下大同’的人类学习加速计划，在这个时代里，所有知识和经验都要进行精简化和步骤化，一个人要进入一个领域时，能够用最小的时间迅速了解到这个领域80%的东西，每一个学科的学习路线是经过机器学习、优化理论、教育学、心理学等的精密研究、处理、计算和沉淀过的，并通过计算机辅助启发和自动演化推理的帮助，使得学习变得更加符合人类的认知逻辑并且全面而简洁，知识的学会过程就像锻炼肌肉一样直白且管用，其初心是能够使人快速在一个领域登堂。进而同时，学科交叉得到空前发展，引起了一场又一场的技术革命，人类学习加速也是认知革命的有力成果之一……直到今天，我们仍在二项玻所引领的认知革命上获取新鲜、创新和有效的想法，这一切都要感谢玻柏先生的开创性设想。明天还会和今天一样吗……” 第二天，大潭开始了炫技。大潭已经提前了解到某研究所的无人卡车今日会运进一些钯元素，现在，大潭给该研究所的服务器挂一个“肉机”自动化扫描和尝试进入该服务器，该行为必会引起服务器的自动化反病毒攻击程序，而这正是大谭想要的，大潭在几年前设计该服务器的电路时留了一个后门，当自动化反病毒攻击程序启动时，该物理后门会检测其服务器内存里的指令流，从而找到该反攻击程序的地址，这是软件所检查不到的，然后大潭远程控制后门发送关掉该程序的指令流，从而相当于拿到了该服务器的管理员权限，在服务器上定位到该无人卡车，控制其开到一个桥底下，然后拿到了一些关键的钯元素。 传送机器得以继续运转。 《平行地球漫游指南》词条： ①几行诗：对于地球来说，为南仁东先生作。 第二天，机器指示的进度达到了99.999%，最后就剩半天的时间！ 大潭提前架好了记录仪等待着这历史性的一刻，只是这一刻没有第二个人在。这个时代的奇迹太多，人们关心不过来。 突然电脑中的危险感知响起警报，“这个时候来这个”，大潭无趣的看过去，另一侧的屏幕上提示“警侦即将锁定昨天无人卡车失窃的幕后玩家”，大潭心想，“不好，快找上门了，反侦察能力还是欠佳啊”。 大潭焦急的等待着机器的结果，等待那从外星文明传送来的服务器和硬盘。 滋滋声时时作响，命令框内哔哔的更新着运行状况，电脑AI温馨的提醒着“一会要有光，小心眩光”，在机器的容器内渐渐有了光，可是在下一刻，一个人形的黑影出现在容器中，大潭眉头一皱，看向斜上方，转回头又露出无奈的眉目。 不多久，夏叶出现在机器中，急促的呼吸一口空气而后醒来。 大潭还是诧异的心想，“难道传送的那一刻把硬盘和一个人同时扫描了？那硬盘应该就在其旁边啊，但硬盘没有出现”。 大潭去将容器打开，夏叶惊慌的问道，“这是哪里！你是谁？”，大潭低头紧张的喃喃道，“我想这里有些错误，这个实验进行的有错误”，然后立马抬起头，才去面对这","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:1","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":"孪生往事 夏叶和大潭为了交流的区分，把夏叶所在的星球共同称为“地球”，把大潭的这个二人所在的星球共同称为“平行地球”，显然，这是按照夏叶的意志分的。 大潭讲得先离开这里，同时看了看屏幕上的危险感知信息，警侦定位自己的进度已经到了42%。大潭所在的楼层里另一个屋子有一个关系不错的老友，在做强人工智能方面的科研和私人侦探的工作。大潭说先去那里想想计划。 夏叶问大潭因为什么被追捕，大潭将机器缺少材料和铤而走险的事情讲了一下，夏叶又问道，“这么大一辆卡车都开走了，这之间全程都没有人发现异常吗？”，大潭回答，“那里具体有多少人在管理我不清楚，但那种研究所中人类和AI总共不超过五个人，一般情况是两个休假，一个在路上，两个在做实验，哈哈我就知道，AI像人了之后，也会犯不少人类的错”。 夏叶接着问，“怎么这么少的人？啊对，还有那个什么自动化反攻击程序这么不堪一击吗，你们这个时代怎么计算机安全这么差劲”，夏叶流露出不屑的表情，大潭看着夏叶说，“安全性极佳，那个安全机制是由一个公司，上百个人和AI们共同维护的，但只管软件层面，我是通过电路级别的物理介入，属于那个古词怎么说来着，降维打击，还有关于为什么科研机构人少，我一会给你讲讲强AI，我一直觉得老有意思了，有的人管他们叫铳人，那是些无法接受AI变为人的人”。 两人在这栋只有三层但很长的楼内通过电梯墙②，来到了老友门前，这间屋子的门自己开了，大潭唤醒了屋内的电脑。这台电脑与大潭屋内的很像，都是只有一个薄玻璃般的屏幕立在桌子上，别无其它。屏幕里出现了老友的声音，大潭讲了事情的经过，老友表示可以帮助大潭和夏叶获取到一个交通工具送到城市边缘的离他们最近的空地上。大潭表示感谢，“谢了，华和洁”。 《平行地球漫游指南》词条： ②电梯墙：楼内任意两点快速直达的机动装置，原理为在一栋大楼的外面增加一个二维运动电梯，电梯在大楼的外平面上移动。部分高层建筑没有安装此装置。 已经下午六七点，出现灿烂的夕阳，蓝色的背景穿过淡红的光再经过丝丝白云的点缀好似画家的调色板。夏叶站在干净、洁白的楼道里，透过窗，可以感觉到这是一个坐落在半山腰上的研究所，到一层邻近门的地方，可以听到不远处潺潺溪水的声音，出了门，看到道路两旁长满了开着粉红花的树，松鼠和飞鸟有恃无恐。这份与地球无异的场景令夏叶恍如隔世，但又格外的适应。二人相与步出建筑。 夏叶说，“我想在这里种一棵树”。 大谭回应到，“啊，我这几天正想呢，拿到了树苗一直没种下，这太好了，我就去取”。 二人在不远的空地一同种下有一人高的小树，夏叶觉得就像地球人类登月时候插旗一样，这是在外星文明中种下的一个象征，而大谭则体会着这份奇妙，这是另一个文明在他的文明栽下的一个希望。 大潭和夏叶继续向山下走去，准备到城市边上获取到交通工具然后立马去华和洁的另一个住处，那是在海里，有另外一个传送机器，当时建造的传送机器不只一台。 山下的丛林中，距离二人远处坐落着一架巨大的机械臂，在林中尚可窥见其巨大的体型，大到唯有周围的山体可以与之相称，大潭向夏叶解释着：这个用于大型工程建设，可以把几十吨的整屋当成积木搬来搬去，还全是自动化运行，所以科研院可以轻松建在半山腰上，我喜欢这大自然的环境。 “天呐，我是在科幻小说里吗？”夏叶惊呼。 “不，因为这里没有宇宙飞船、全息投影和机器人！” “为什么这么说？” “因为，呃…科幻作品里面不都得有宇宙飞船、全息投影和机器人这‘老三样’吗。只是现在平行地球的自然环境比你们那好了太多…” “等等，你们怎么知道我们地球的这么多情况？” “你们地球的‘大喇叭’在最初的50年里一直介绍着你们的境况，我们也一直聆听着。平行地球这里的高层了解到地球的自然环境没有改善的迹象，极端天气对于你们就像温水煮青蛙，平行地球虽然科技领先，但高层还是引以为戒，大力改善自然环境，平行地球这里的外星移民进度被放缓，所以恒星际宇宙飞船、人体冷冻休眠、全息投影现在还是属于‘科幻’的范畴，不是说科技发展的慢哈，而是这些确实很难，看以后吧”。 大潭和夏叶相互搀扶的穿越茂密的森林，天将黑时两人戴上了具有彩色视觉的红外眼镜，使周围便又变得像白天一样。 “那么，这么巨大的东西都是你们设计的吗，我看这巨型机械臂别的地方估计也少有吧”。 “国际设计分享。我来讲讲星球共同体吧，星球共同体管理整个星球的事务，前身是联合国。很久之前这里干了第三场全球战争，比不上前两次残忍，为的是军事对抗而不是消耗人，只是相互的摧毁军事设施，前前后后比二战东线还要复杂很多，当各国国武库的最后私货悉数搬出来的时候大家就都懵了，人类终于整体性意识到对立、隔阂和动态的制衡并不是出路和真正的稳定，星球共同体成立③。但是离现在已经很远啦差不多有300年了，之前还有人说历史课本的内容太多了，现代化之后的历史非常长。所以，这个巨型机械臂是别的院做的，通过国际方案共享平台提供给全人类，建造实施时候也没需要多少人，从零开始的原料采集加工，装配到测试都是机器自动化完成。这个机械臂底座的钢我听说好像是从海底矿场采出来的。所以你又可以想到，星球共同体那里其实除了处理人类重大决策外，已知的绝大部分事务，都早被调优和自动化了，比如医院，全球所有地方都一致性的接受着最高规格的装备和最先进的管理与治疗方案，新治疗手段和科技一经验证便通过信息网络全球同步，新设备就地全自动化制造和补充。事实上许多设备的一半部分都是AI设计的，AI的许多在我们看来很‘聪明’的创新举动，可能是AI们自己试出来的，也可能有一定的“思考”，因为他们还是讲不清楚自己，AI会输出一些结构化的知识和经验，但是具体运作过程还是有点难搞明白，就算我们在电脑里全模拟两个一样的AI并且给相同的输入，两个AI的输出还会是不一样的东西，真有意思，我不是搞强人工智能的，不是很明白，但是听说第一个强AI是像小孩一样，会对这个世界好奇，一群科学家围着他拿着各种颜色的积木告诉他这是红色、绿色，这是圆形等等，让他触摸、发音、识字、写字、手脚协调、被教授课本等等，所有人类成长的必要过程都给予一遍，不同的是每个步骤只需要‘教’一次，当他依据经验理从条件反射的角度学会人类的情感，并且对学习感兴趣之后，取出其网络的所有数据，开始大批量试产，这就是现在这个社会中AI人的诞生之初”。 “仿生人会梦见电子羊吗？” “会，不但会梦见，在其数字世界中，仿生人还会涮电子羊，就像人在精神世界构建想象物”。 “等等，你刚才又说道300年之类的，能说一下时间线吗？” “约150年前，平行地球2220年左右第一次接收到了外星文明信号，就是你们，非常丰富的信息，我们了解到你们那时候大概处于1980年，也就是你们地球向宇宙‘喊麦’的开始，信号经过了42年到达我们这里，所以大概可以得知地球落后于平行地球200年左右。平行地球2220年，对应地球的2022年，那时我们紧接着回复了信号，这个信号故意设置的微弱而且就像激光一样是高度聚焦的，只针对你们的方向，地球在21世纪六十年代年接收到了我们平行地球的信号，在那之后我们再也没有接收到来自地球的信号。平行地球今年是2372年”。 “你说你们这里一百五十年前第一次收到来自我们星球的信号还给予了回应，我过来之前怎么我们的历史并没有说有收到外星信号，是不是我们的上层隐瞒了下来，等等……” “不是”，大潭缓缓说道，“你来的时候信号还没传到地球。而且你不是瞬间传送过来的……我很抱歉，也就是说，由于‘光速叠加不变定理’的影响（地球上叫“狭义相对论”），你的时间相对被拉长，也就是说，你的传送过程其实持续了约150年！我们维持了这个设备150年”。 夏叶停了下来想：2372-150-200．．．．．．对，这就是我来的那个地球年．．．．．． 《平行地球漫游指南》词条： ③：平行地球的往事，不一定是地球的未来之事。大潭只是讲讲平行地球过去的历史。 “先快点走吧，别停下”，大潭说。夏叶没有好脸色的挪动着。 大潭话锋一转，“在我们截获了一份成建制的外星文明信号的那时，还有一点小插曲，那是我们文明第一次真正意义上接触到外星文明信息，其实之前这种信号已经存在大十几年了，但是时断时续，遥远的星际空间和来自各处的电磁波干扰造成的，但当局和科学家都还很负责，在确认了那就是如假包换的外星文明后，官方并不直接承认事实，而是在全世界的首脑中达成了这样的共识，即先渐渐的增加外星文明的小道消息，因为凡事都有第一次，用‘议程设置’先让民众习惯习惯，然后政府和科学家再出面封锁消息制造神秘感，当一些无线电爱好者捕获了一点点前面说的信号然后大张旗鼓的宣传时，政府雇佣一些傀儡自称那些信号是他们做某某项目发出的与外星文明无关，在众目睽睽下，傀儡被媒体要求复现信号，这时人们就会发现傀儡制造的信号的与观测的太空信号大差不差，虽然猜疑并不能消除，但是经过类似的运作，这就在一部分民众间产生了一种貌似可解释的印象，一种谈资或者说安慰，在另一部分民众中依然保持神秘，其实这就是要达到的效果，有的科幻电影和科幻小说也是这种让民众提前适应适应外星文明出现的运作，官方被逼出面解释一些意外流出的影像资料，有的会承认那便就是不明现象。官方当然也有可能永远不会承认，除非出现瞒不住的情况，但那时至少前戏已经做足了”。 在四维时空中能量是信息唯一的屏障，远方的声音虽然无形，但是具体的编码无时不刻证明着那里真实的存在，如此慷慨、礼貌而又孤单的的广播着着他们的文化和文明。 “从信息大概了解到你们地球的文明等级约在0.82，快要能利用整个行星能量的水平；从发展时间来说，大概处于第四次工业革命的前期，遇到了很多困难，再进行一次比较难；从认知能力上来说的话，也就是比动物社会高级一点，处于辨识的水平，离实现‘认知’的水平就差一个哲学家","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:2","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":"大谭夏叶 大潭说了那么多，夏叶依然板着脸。在静静的走了一会后，夏叶说明，“对你们的好奇增加了，但是还是不敢相信自己被一个外星人绑架”。 大潭，“我再次表达歉意，我给你个‘万物体验’玩玩吧”。 “哼，什么东西，给我看看”，但夏叶眼里来了光，貌似她对新奇玩意儿的好奇没有受到任何影响。 “难能可贵的是保持好奇，一个善于好奇的人不会迷茫，他们会转化要做的事为快乐，探索的快乐，新奇的快乐，好奇会引领跳出圈子，而看到更真实的，啊，一点感慨”，大谭说道。 万物体验，感知世界上任何事物，原理说白了就是对生物感官的特定输入；对于类似‘上瘾物’的东西，就是找到生物的一些正反馈然后疯狂给定，必须节制或者拒绝。 大潭从随身的肩包中翻出一个小立方体，举在夏叶的面前并说“万物体验”，空明洁净的立方体在月光下闪闪发光如夏叶发光的眼。把这个立方体展开，变成了一副面具，像VR一样戴上，“往往，生活会待你如泥潭，社会会待你如杂质，人际会待你如透明，焦虑不可怕，到这时候还不思进取就沉迷在虚幻之中了。这装置，通过声、光、风、化学等给定的手段，让人可以真实体验各种感觉和情感，比如感动的哭，体验针对特定的人最易感触的情景而制造旷世感动，最顽固、高冷或者迟钝不敏感的人都能在里面感动的稀里哗啦，或者体验古代君王的忧思，或者体验电影里的情节。虽然人各不同，但是接受的感受都是一样的”。 夏叶体验到了从来没有体验过的情感，就好像梦见一场精心安排的天作合拍的两个人在最完美浪漫情景中相遇相知，营造一种恰当地击中测试者最易感的情景，感觉人都升华了，说不出的感觉。一瞬可当永远，人生好似无限。 同时也可以让夏叶感觉变成一只小鸟、鱼、鹿等等，在翱翔蓝天、在畅游堡礁、在漫步山林，也可以是一条河流，汇聚成海，是一棵在斗转星移之下的树，周围快速闪过日出日落，突然停下，又能感觉到被轻风吹拂。 忽然夏叶的视角移出星球看到一个星系，奇怪的可以说出每个星球的名称，看到每个星球的样貌，其中的恒星正处于红巨星阶段，轨道上有五颗行星，其中的一颗行星正处于生命宜居带，但是其公转周期极其长，相当于42个地球年，不但如此，自转周期也极其长，上面演化出了生命，其生命周期也极其长，是因为这种环境让它们演化出极其缓慢的新陈代谢，在缓慢移动，生命的外形就好像是巨大的粉色水母，它们时而仰望天空．．．．．． 大潭拿下了夏叶的面具，发现她留下了两行泪，“我看到了所有的一切，太美了”。 大潭说，“很多人用一次后都会变的有些迷恋这东西”，大谭继续说，“就在你刚才体验的时候，根据给人喂感受的这个方向，我想了点东西，就是不要太相信你感受，有的人因为气质或者语气上的习惯容易让人相信，而有的人或许更正确却不被人信任，很多平淡和鸡汤换个新的包装就有人觉得又有道理了，甚至被奉为真理；这是我个人观点，万物皆有其适用范围，事物值得批判，以发展、辩证的眼光去看问题。可能视野和格局打开之后，无知便会令人感到生厌”。 二人爬上了另一座小山头，这里有一个很简单的木架结构，二人便上去歇脚，不远处就是繁华诺大的城市光影。 这时，城市中大屏幕上的一段对话吸引了二人的注意。一位科研所的人被当作嘉宾请到了电视节目现场，有一段话二人看的格外认真，那位嘉宾微笑但泪似乎要溢出，“离子推进器的慢加速效果经过长时间的积累后也能达到可观的速度，核聚变解决电的问题，再加上冷冻休眠，组合为一套‘星际流浪’的‘三大件’。人类仰望星空一万年，怀揣一个星辰大海的梦五百年了，我相信这三件会有凑齐的一天！” 二人都还不知道这是谁，在这个时代，有成就的科学家如漫天繁星，他们满怀远景，而有的说着说着就热泪盈眶，也是“返璞归真”罢。 终于，夏叶看清了城市的面貌，夜晚的黑似乎很符合幻想般的情景，眼前是古代楼桥装点在各种现代高楼大厦和立体交通轨道中，眼前是如翻山越海，却故人相逢，眼前是如魂归故里，但焕然一新。这个时代，如大谭所描述的科幻，如夏叶所看到的未来，但令夏叶想不到的是啊，在漫长的时间流淌过后，历经道不尽的坎坷，这片土地，这个星球终于来到了共产主义纪元。这里是平行地球。 “这个时代的电，几乎全由核聚变电厂提供，电能极大丰富。电能替代了以往的大部分靠化学能量的设备，比如工厂的切割和电焊操作全替换为高能激光，因为有的是电，汽车和轮船全电推进，发射的火箭如果是常规小型运载任务还用化学燃料，不过化学燃料大部分是用电能合成，大型火箭引擎由可控核聚变提供能量；天上还飞着很多可控核裂变供能的导弹，可以几乎永远的在天上飞，哪里有问题就去哪里瞧瞧，没事了再飞走，大部分时间都在超高速滑翔，所以你看这个时代也不是那么美好；电池发展的迟滞导致电池逐步被忽略或当作应急用，小型设备由无线输电提供电能，家庭和街道上到处都有无线输电，就像无线蜂窝网络一样密集，电池做的很小或者没有，设备进一步变的便携，只要民众接受，这些前沿的事就有研究机构和技术公司去尝试”。说着，大潭从肩包里拿出另一个小黑方块，如果六面再涂上红点就是一个稍大的骰子，这个“骰子”不断以对折方式展开，一块长方形的薄薄的小镜子呈现出来，“镜子”亮屏了，这就是手机，电能由周围的无线输电提供，其组成元件只是一块芯片、一个屏幕和一个综合传感器⑤而已。这个“镜子”还可以继续展开，形成一面很大很薄的屏幕。 《平行地球漫游指南》词条： ⑤综合传感器：它的出现，标志着硬件工艺进入新的时代，这个器件的核心是种新材料，像膜，同时对声音、气体成分、压力和电磁波敏感，并且分别有不同的输出，可以同时测量如人的听觉、嗅觉、触觉和视觉所感受的外界量；在通上特定规则的电后会发出声音，音质很好。 夏叶拿过手机，大潭帮夏叶架好以让夏叶看屏幕时不至于太近或者低着头，夏叶职业习惯般的搜索着这个世界的百科资料，感觉这个‘卡片’的操作如行云流水。 “欸，那你们这里，军事科技都发展到什么程度了？航空母舰是不是大到跟小岛一样了？”夏叶继续提问。“在这里，航空母舰被淘汰掉了，因为能源极大富裕，连酒店都在天上飞着不下来，最长的都连续几十年了。1.42型文明当然会让自己的主行星在保持生态的同时，到处流动着巨大的能量，现在想的主要是怎么合理开发好太阳系剩下的这几个有意思的行星。星球命运体不允许大规模纷争，无期徒刑的重大罪犯或者战争犯将被流放到遥远冰冷的柯伊伯带，不过大多在路上就老死了”。 大潭说，“你们有“印象效率”这个词吗？”，夏叶目不转睛的看着屏幕回了一句，“没，那是啥”，“我们这经常说这个词。就是一个人和另一个人初次见面，要相互了解的时候，一个人以较为客观而有特点的方式表达自己，并共事一段时间，能够让另一个人在较短时间内较为客观的对这个人有一个三观人品上的判断和过去、现在、将来的发展轨迹与本质动机的了解，所用的时间越短，印象越为深刻，我们就说这个人给别人留下印象的效率比较高，用印象效率这个量去衡量，现已成为每个人自带的基础属性之一。印象效率用与这个人接触过的人和AI的平均感受打分，在生产生活发展至今天，这种评价的进行并不是难事，现在小学生都可以在像我们以前古时的‘电子积木’类似的平台上搭建小的机器学习系统。印象效率的用处随处可见诶，清楚表达自己的观点和思想是人与人打交道和交流中最重要的事情之一，面试的时候，面试官可以参考这个属性，就像银行借贷时候会看一下个人征信一样，搞对象的时候，也会有参考，‘日久见人心’的效率还是太低而且缺乏安全感。而且这套系统如果收集的信息再多一些，比如一个人面对不同场合的表现、日常的脾气秉性、日常所做的选择等等比较私人的信息，其实就可以预测这个人在特定场合倾向于做出什么选择，这个机器感知到你有可能接下来会做某某事，会提醒你，如果你去做将会以怎样的概率发生什么结果。预测近未来和辅助人们做选择也是认知革命所引发的成果之一，鉴于篇幅我就不举例了”。 “xxxx图书馆，进去看看”，夏叶在手机上找到了一个小资料库。 随着夏叶心里想的，屏幕里打开了一个名叫“科幻/科普区”的目录。 扫了一眼书目，夏叶看到这些书名觉得蛮有意思的，有《陨石降临时一条恐龙的自救历程》、《从小约翰的三个苹果到五阶偏微分方程的近似解》等等。 正看到此，耳边又响起大潭的声音，大潭又要表达一番个人观点了，“我给你解构一下科幻小说。我看过的许多科幻小说，他们都挺有想象力的，写出的是一些震撼的感觉，或是讽刺的效果，抑或是对人类局限性的发问，或者就单纯是有趣的文学故事。科幻作品会带来很多科学上的新想法，甚至在一定程度上有助于科学技术的发展和科学思想的传播，同时也为没时间学高深的科学知识但又对科学超级感冒的人提供了精神食粮。 但是套路泛滥的科幻小说我不感冒。写科幻作品构建世界观很重要，这块也容易崩掉。比如说，你描绘的世界，生产力和科技水平已经极其高了，为什么联络、观测和决策的水平还和现在一样呢，那感觉就像，你把高深的科技和装备给一群小动物来玩耍一般，并不合理。退一步讲，把那些未曾有过的设想和设定，套入当下的人而展开考虑，即把先进的事物或者未知的事物摆在现在人的面前，看看会发生什么反应，不谈笔法技巧性的东西，剧情的发展还是多少沾一点独裁、自私、对立、报仇等的兽性的东西的边。就觉得，一些科幻作品只提供震撼的想象，但对一些情节操弄、高科技的使用的描述觉得比较随意，些都是作者的一己之见罢了，与现实会发生的事情相比，是一种可能，但显得不成熟。 看透来说，大部分作品套用伟大的二项玻定则来解释就再简单不过了。比如你看，人类在地球上种土豆，改成‘在火星上种’；人们发现了一篇日记，改成‘发现一篇外星人的日记’等等之类的，变一变。总之就是要么把一个概念强化，比如光滑的表面无限光滑，结实的琴弦加强等等；要么把不同概念混拼，比如在强引力场中的星球种产生文明会怎么样，在地核中产生的文明会面","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:3","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":"人在共产 转过头，“书架”随着夏叶的思索还自动的呈现了一些别的书。 工程类：《星环矿场建设标准》、《失重环境过山车建设及作业标准》等等。 设计史类：《能源决定了设计》、《设计的变迁——不是源于想象而是发现》等等。 到了仙侠小说类，夏叶：“你这里现在也有古侠小说？我们的古侠啊，达官仕途之子上山苦练，见高人比划比划，行江湖有勇有谋，侠胆义张，人情交错，时景变迁，促成的一段往事，如有为天下之大义”。大潭：“但终将不过是小农经济社会的极致手工业，过往云烟尔尔”。夏叶哭笑不得：“你将此评价为小农经济社会的‘手工业’啊，噗”。 来到考古类，都是三百多年前的书了，随便展开一本，此时屏幕自动的从中间弯曲，像一本展开的书一样，呈现在夏叶的正前方，显然这才是真正的“阅读模式”。 翻阅中，其中一页写道： “鉴于本书本意随笔、记思和记趣的属性，最近我写了一个SCP文档，挑出部分列下： SCP-201904 面试官，相关文章及其演绎内容已经过O5-█同意，在CC BY-NC-SA 4.0协议下进行发布，简单描述为一个永远不会让面试者通过的面试官，外貌为一位德高望重的成年人，会自觉的留在位于██地区的地下二层020房间，除非每天必须有一个人员进入房间被其面试，否则其会动用某种能力强行让一个人去接受面试，目前没有表现出任何伤人行为，因而现被列为safe级。根据目前的保密级别，可以公开的SCP-201904-3中部分面试笔录如下： SCP-201904：‘呦来了个搞图像算法的，问个简单的，简单描述一下stm32程序中RTOS的时间片轮巡、任务调度算法和任务通知的概念，不会？刷掉刷掉！’ SCP-201904：‘来了个搞嵌入式的，问个简单的，简单描述PLC支持的总线通讯都有哪几种，不会？这都…刷掉。’ SCP-201904：‘来了个搞机械的，我就问个简单的啊，简述BP神经网络的优缺点，不会？刷掉。’ 又来了一个面试的，得到同样的结果。这个面试者在结束时要给这次面试写点意见，这是SCP-201904要求的，这个面试者随即写了点东西，SCP-201904拿来一看，上面写着，‘在候选者中选拔时，建议用骰子，节省时间。’SCP-201904并没有表现出任何危险的恶意，只是流露出不屑的表情。” 夏叶说，“哈哈哈，笑死我了，这是编的俗烂笑话吧？”夏叶又胡乱翻了几页，文中写道： “学习能够得到什么？1、建设祖国的崇高荣耀；2、早日实现财务自由的重要途径；3、一种喜悦内心的兴趣爱好，杜绝千篇一律，过有灵魂、内涵丰富的生活。 为如何培养、衡量学习兴趣和创新能力的问题而挠头抓耳，此情此景也许会令高阶文明发笑吧。一个范式被重复个十亿次，即便它是平庸的，也会变成难以动摇的；所以尽可能多的考虑巧妙的制度和策略，避免出现“以后再慢慢修补”的懒惰思维，辩证是看到本质，而不是不断粗暴的一刀一刀“剪枝”。现在培养的成材率（同时具有优良的功底和与之匹配的热爱）现在是1%左右，因为有人口基数在所以问题不显得严重，期待一个政策让学习的过程切实提高兴趣培养、实践培养和成才效率，由此会改善青年人的整体学习心态，培养出更多的大师。 …… 很多事情我已经习惯了两面去看，说完了踩再说说捧，在面对锡方世界鄙夷态度的时候，底牌我们总是有的，只是有时候我们得巧妙的宣传，讲一个小故事： 诗教授与一位国外科学家聊天，谈到本国的科技发展，对方很不屑，诗教授便说：‘不管怎么样，我们已经实现探测器登月了，你们的在哪呢’，对方答道：‘诗教授，我很尊重你，但是如果我们有你们的经济体量，我们能把五百人送上月球并安全回来’。 诗教授突然停顿哑口无言，没错，在效率上我们好像很不自信，更不要说被点出来。 这时，一个全程旁听的小伙子开腔道：‘好，如果我们有你们锡方的科学科技水平、文化中心，我们能把地球管理的歌舞升平、安居乐业，并已经在月球和火星上建立永久基地，并快要实现共产主义了。但看看你们现在是什么样子，我们在带着全人类的火车前进，你们就像在车厢里有文化的流氓。’ 年轻一代光有能力不够，光有清醒也不够，二者兼有便是光。 …… 有一次爆发人传人的病毒，国外的杂志《竹叶刀》仅一期就有国内一群专家的16篇文章，把很多信号送到了国外，国内决策者没有及时拿到，可能也因此，后来减弱了用外刊文章来评价人的占比，如果没有这次集群式的往外发文而没有给国内足够的信号，是不是这个决策还不一定来的那么急。如果改变是从跌倒中得到的，那为什么先只等着跌倒”。 “乱语胡言”，夏叶心想，回到介绍界面，看到书名《湖畔随记》。 大潭说，“差不多该继续走了，前面有一个湖泊，过了湖便是华和洁在等着我们”。 大潭继续说道，“你最后看的这本，应该是兴晨世纪的。哦，给你补充一下，我们这里对近代历史按照一百年一个叫法划分，从十九世纪开始分别为中兴世纪，骤暗世纪，兴晨世纪，华彩世纪和灼阳世纪等。平行地球第一次接收到地球的信号就在灼阳世纪”。 夏叶讲，“对，这书写各种批判，笔锋好像在模仿‘鲁迅体’，从这个方面来说其实马马虎虎。开头那段挺有意思”。 大潭说，“平行地球现在的社会特别重视教育。我记得一位曾经也在兴晨世纪的作者，那是在改革初期，曾经做过大概这么个意思的表述‘在已知框架之内，用标准化测试来测验具有多变灵性的个体的机械化问题处理能力，其实是在做不同问题与不同工具的连线问题，在本质上约等于是在考记忆力，创新能力不足是本来就可预料的事情’，还句名人名言是这么说的，‘有人说原创力和科学氛围不如强国，主张需改革教育，大家一定是不允许的，很多人一定说领先的人才就是刻苦学习出来的（这话没错，但这是转移主题的话），而我觉得是他们想保持现在这种‘因为没有尝试其他策略而自然而然成为最公平的’和‘目前最优’制度。但如果你主张那就实行精英教育，也许出人才出的更多，他们就会来调和，愿意想办法了’ ”，很多名人名言跟教育有关，现在全社会特别重视教育，这也是这里能够进行这么多科技革命和文化百花齐放的一个根因吧。 “你们的名人名言可真长，都快成小故事了”夏叶说，“但我觉得这和我们地球上鲁迅先生曾经说过的有几分异曲同工之妙，即‘性情是总喜欢调和，折中的。譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶，他们就会来调和，愿意开窗了’ ”。 大潭说，“这又让我想到了一句话‘马克沁机枪发明之后，凶猛好斗的草原民族就变得能歌善舞起来’，好像不太恰当，哈哈”。有着一点严肃的空气，好像热力熵增一般变得欢快起来。 在森林的尽头，有一湖泊挡住了去路，不知道大潭是不是故意咳嗽了一声，水中渐渐浮出一个栈道，旁边也有一个小屋子升了上来，从小屋中走出一个身穿发光线条的黑大衣的人，大潭对夏叶说，“这不是要过路费的摆渡人，这是‘牧人’ ”。 夏叶没有说话只是看着。大潭与其进行了简单交谈后，栈道便发了光，在湖面上形成一面发光的路。走上去后，牧人便回到小屋沉入了水中。 大潭饶有兴趣的向夏叶讲，“在这个人、机共存的社会，不是所有人都习惯身边有太多机器。极左人士总想要从人机共处的社会分裂出去，还说在人机共处的社会中自己自由选择的权利都被机器给的种种建议给‘控制’住了，虽然机器给出的建议往往都更好。他们管AI人叫为‘铳人’，那是种具有生厌性的蔑称。实际上我觉得AI人很友好。说个题外话，现在不管什么黑、白、蓝、绿色人和AI人都是平等的，不但法律规定了，而且是百年前研发出了一种化学试剂，当作疫苗一样注射，可以消除人的种族主义心理，无副作用，之后星球共同体的人决定全球免费供应，自愿注射。那些牧人并不太歧视AI人，也是不服不行，他们只是怀念人和人共处的日子，他们共同组成了一个小城，拿着AI也有功劳开发的科技，过着悠哉的生活”。 “那”，夏叶想问，像是个“十万个为什么”的读者，“你们有那么先进的AI都能帮助设计了，为什么还有人在自己设计和生产呢？不嫌累？要是我们那里有这个轻松的社会，早躺平了”。 大潭不慌不忙的回答道，“我先说我自己，我现在只做组织设计、项目管理、看行业报告、画方案框图和规划技术路线等事，综合来看就是做大框架设计和往无人区前进，这还是蛮快乐的，现在这个阶段的我不必也不喜欢去做具体的实现了，后者在深入了解之后大抵只是消耗时间去具体实现而没什么难度罢了，具体的活儿让AI人或其他学习过程中的人去做就成，AI人他们没有因重复而乏味的概念。然后对于其他人，因为绝大部分工作都被自动化机器和AI人替代了，AI人比人类好的就是对待时间问题上没有人脆弱，他们重复一个行为20年也就一眨眼，让人这样，从生下来就是这样，万物极大丰富，再加上远方理想、乐趣、体验万物的教育理念，就算还是闲或者玩20年，受不了得，也不可能，因为接触万物的教育深植人心，娱乐在万物面前不值一提，本性使然，就想要一些才艺活动以弥补空虚，比如研究大自然的规律…人总要有一些才艺嘛，也可以是住在大自然里，然后过‘上午钓鱼，下午打猎，晚上写写批判理论’的日子也挺好，虽然钓的鱼和打的猎物可能是某AI人养的哈哈”。 夏叶继续问道，“但是…噗哈哈，等一下，为什么搞科研成才艺了。难道你这里的才艺表演是这样的‘我来给大家表演一个发射火箭吧’”。 大潭回答道，“不是的，我是说比如，传统兴趣爱好当然都还是有的。机器大量替代人类工作不代表人就不会工作了，大量的必要信息及时快速的给定而替代慢节奏的思考和唠嗑后也不代表人丧失了思考的能力。我实验室里以前的电子仪器设备几乎每一个都被小年轻拆散过，我问过他们，是因为闲和好奇。你看，虽然知识爆炸已经炸了上百年了，但是现在又好像九百多年前达芬奇时代那样，一些人掌握学科的门类相当广泛”。 时间在缓缓流逝，全宇宙在无时不刻的运动着。二人拿到了华和洁的交通工具，华和洁告诉二人现在","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:4","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":"二项玻 阿西莫夫机器人三定律，是用提出者的名字命名；二项玻，也含有提出者的名字。玻柏，灼阳世纪的认知学家、计算机学者、DJ和大自然爱好者。这种倾向于和大自然站到一边的人可能更能洞察人类，也很放松。玻柏提出了著名的两项创新纲领，简称“二项玻”。 其第一项：简化之合理的简化；第二项：组合之有意义的组合。 社会进步的一个特征就在于，过去专家才能做到的事，如今普通人就能做到。在历史上来说，搞新文化、新方法和新理论的一方会胜利。 在说完二项玻的内容后，大潭继续讲着，“我觉得提出这两条真的好似摸清了人类创造文明的本质，要理解一个事物，先拆解简化，逐个理解，这是向下，要创造一个事物，然后就换一些组合方式，产生新事物，这是向上，这一下一上的反复进行，就是人类认识和改造自然的车轮。在两条创新纲领的指导下，加上从上到下的大力宣传和学习，行业大整合出现的大标准和高效的管理策略层出不穷，不断在验证着二项玻的正确性和优越性。比如拿‘简化之能够简化’来说，现在我们都相信，声音和视觉上的语言，要归向简明扼要和有条有理，而做事，要想的全面、考虑机制的复杂性、考虑可升级性和可重组性、考虑人际关系复杂性等等等等，这就是所谓的‘言归简，行致繁’，如果反过来就是言语复杂但做事蜻蜓点水，具体就是语言总倾向于大论长篇或者只有一大堆细枝末节但没讲好主干意义，同时行动却浮于表面，总倾向于照例重复，所以说，‘言归简，行致繁’的正确性，就来源于二项玻的预验性和正确性，尽人皆知，生活简单而美好。但是如果你说做事总趋于冗杂庞大也不对啊，别忘了还有第二项，‘组合有意义组合’，能动的进行事物的各种组合，然后观察其发生的反应，如果有更好的组合，当然要选更好的，时常会发生新的组合比旧的组合更加简单和高效的情况，新事物一定打败旧事物，这便是有意义的，行致繁的繁不是真把事情做的冗杂，而是做事想到的方面要繁多，进而可以组合，再配合上强人工智能的辅助判断和选择，如虎添翼。 如果仅仅在这个层面就说二项玻加速了平行地球的科技革命，还早一步。 历史的车轮永远在转。 社会的损失函数评价了实际现状与目标福祉的差别的程度，其优化方法正是谁能更好解决一个个具体问题。高效的解决问题，二项玻就是方法论，重要的是参与的人越多，社会整体效率越高。慢的、懒的、投机的和不产出的就要自觉的认清自己。要促使社会进化，进而带动整个社会群体提升生活水平和素质，形成良性循环”。 大潭继续说到，“在二项玻创新思潮之前，便已经有了这样的全民大讨论，‘认知能不能进行工业革命？’，那时候经常听到‘如果学习和研究的过程能进行‘工业革命’的话，人类是否已经成为星际文明了？’ 这种趋势，这个时代问号，在二项玻出现时看到了曙光。 转而代之，人们常问，这个领域‘二项玻’了吗？那个领域‘二项玻’了吗？一系列的新思想和新行动百花齐放。 其中最重要和最有启发性的一支认为，对于任何东西，拆解成可理解的最大公约单元，当所有的知识全部变成高度结构化和步骤化之后，那么高度的可自学性便水到渠成，教育资源不均的状况瞬间消失，再加上实践占比的大力提升，人民尤其是青年人便可浪潮般的真正变得为了兴趣和解决问题而习得知识，在以指数为量纲的科技进步速度上再添一个指数。让知识在脑中存取自如，知识质量不降反增的同时，摆脱学习不人性化的苦，不用什么奇技淫巧。在有终端的地方，所有的知识经过了符合心理学、教育学、AI优化、反复验证和沉淀之后的结构，都是以直达本质和所见即所得的方式呈现在每一个想学的人面前的，人人都可以脑袋跟开了光似的，从本质出发直接理解和解决问题。不同地方的人的理论掌握情况和实践能力变得势均力敌，从前不必要的冗余规则和政策都变成尴尬的存在。 真应了那句话，‘人民群众的创造力是无穷的’，我再加一句，‘如果把这种无限的创造力加以精巧的理念、政策和教育上的引导，就是无限光明的未来。’” 夏叶紧接着长叹一声，“哇喔”。大潭心想，“一定是被这美好的社会佩服的五体投地而发出的感叹声”。而夏叶心里想的是，“一定是民科无疑了”。 大潭收尾道，“这些也是不久之前才开始的。那时看到这种趋势并且积极去做的人和公司功不可没。由此引发了下一次科技革命，是第四次工业革命⑥之后的智能革命⑦，再之后的终极——认知革命⑧，已经有学者认为有了苗头。我跟你讲了大概三百多年的平行地球简史”。 《平行地球漫游指南》词条： ⑥第四次工业革命：众所周知，是继蒸汽技术革命（第一次工业革命），电力技术革命（第二次工业革命），计算机及信息技术革命（第三次工业革命）的又一次科技革命，是以石墨烯，基因，虚拟现实，量子信息技术，可控核聚变、清洁能源以及生物技术为技术突破口的工业革命。 ⑦智能革命：第五次工业革命，按照平行地球世界的历史，以及基于目前对平行地球残缺的信息，为智能革命，即强人工智能革命。仅可以了解到，那是以零点时刻诞生的第一个具有自由意识的“机器”为开始，“它”最基本的能力是理解对话，通过了图灵测试，具有类似人的学习能力却有更快的学习速度，经过从基本的颜色、立体结构到复杂图像的“认知”过程后可以具备类似于人的视觉能力，给予某领域的大量课本和课题，可快速成长为这个领域的“专家”，帮助人类专家共同做设计；另一个特点是“它们”虽然没有主动要求公民权利，但是科学界和伦理界一致认为政府应该从法律上把“它们”当做公民，法律又要变厚了？不用担心，那时AI人已经在帮助人类高效准确的处理法律案件；关于AI人的另一个特点，AI人丰富的知识和经验是任何人类个体无法企及的，你莫要企图竞争的过AI人，请认识到人类个体头脑的发散思维是有限的。每一个独立的AI人都被其旁边的人类取了人类名字。一部分人仍然认为，感情仍是人类的专利，强人工智能所做出的人类反应仅为在数学和概率的计算下的模仿。 ⑧认知革命：第六次工业革命，按照平行地球的历史，以及基于目前对平行地球残缺的信息，为认知革命。革命的起因是当强人工智能在所有已知领域在知识和经验上完胜人类之后，也随着知识爆炸的压迫，人类注定不甘于此，想要有办法更高效的汲取知识和经验，过去的学习方式再一次落伍了，这一次是落伍于强人工智能，于是，结构化一切知识、清单化一切事务运动轰轰烈烈的展开，在全民大讨论的‘认知是否可以工业革命’的命题下，诞生了里程碑“二项玻”，此后有了借助强人工智能的辅助学习、辅助工作和辅助判断，人类的学习速度、学习质量、判断能力和经验运用等直线加强，整个人类社会一年中在改造自然、改造科技等上的进展比得上过去十年甚至百年的进展。星球共同体内，强人工智能占有多数席位。在一部分人眼中，这次革命本质其实是人类用一个强人工智能的辅助来与另一个强人工智能竞争而已，但这种良心竞争意料之外、情理之中的引发了巨大的进步。历史进程急速加快，平行地球的人类同样的，随即进入隐匿状态，外人无法观测、无法理解和无法叙述。 ","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:5","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["人与世人的关系"],"content":"重逢 奔途进行了很长时间，已经走出去了很远，天际线的颜色在慢慢温暖起来。 森林的尽头是海边的海滩，三个颜色组成了此刻的画面，金黄的天际线，蓝色的海面和棕色的沙滩。交通工具径直的冲入海里，一段游走，来到一处断崖，进入一个入口。 在大潭进入房间后，径直的冲向传送机器，让夏叶进入相应的容器，等待被传送回地球。 大潭突然停下了工作，“不能走，你还没想好”。 “为什么，不能走”。 “把你传送回去仍然需要你来的那么长时间，你回去之后，你所熟知的一切已经变了”。 夏叶诧异的呆在原地，随后立马走出容器来到大潭的身边，“……”。 夏叶突然坚定的说，“那我也回去，我带上你这里的一个资料库什么的，带给我们的地球，完成大容量数据的传递，你不是说星际之间的大数据传硬盘比无线快吗，让地球知道这里和平而美妙的存在，我就担起这个任务了！” 大潭看了看夏叶又低下头看着控制面板。并不是一开始注定夏叶要留在平行地球，一路上的经历、景光和对话，在这个文化、科技和社会如此进步的未来世界，可是此刻，再深介绍下去好像也无意义。 这一刻二人和这样的世界似乎又无关。大潭想起在海边的那短暂的一刻，在金黄的光芒中，夏叶在大潭视角里超过了浩瀚的星空，多想留住这一瞬啊。“荣风起戎发，众星渺繁华。在这么短的时间里，我觉得特别开心”大潭对夏叶说，“一起经历了一些事情，又有默契”，大潭看着夏叶继续说：“请留在未来，好吗？”，大潭说完脸上又挂起了笑容。 “缘君共途，心绽有余”，夏叶道。 “如果我说我是AI人，你会信吗？” “啊！真的吗”，夏叶拿过大谭的手，捏一捏。 “我是如假包换的人啦”。 “啊哈哈，吓我一跳”。 “以前我常说，周折绘龙，谁点晴睛。现在我会说……” “说什么呀”。 “周折绘龙，你点晴睛！” 夏叶低下头，想了一番，“我想留在这个未来，大谭”。 大谭又惊又喜，“太好了，我是说…” 夏叶继续说道，“这个平行地球无限吸引我，不过…我想先回到地球，再看看那我生长的地方”。 夏叶补充到，“我回到地球再过上一段时间，然后我再咻的一下，回到未来，回到这里，如何？有什么办法吗？” 但是夏叶明白，这一来一回，哪里是什么咻的一下，而是两个150年，不过是对于夏叶自己而言只在须臾之间罢了。 大谭的笑容凝固了，轻轻的“嗯”了一声，陷入了思索。 短暂的片刻之后，“检测到你因信息和手段不足而思考，对你如何跳跃到300年后并且保持现在的状态而思考，何不去给华和洁打个电话？”电脑中的AI突然发出此段话，立即引起大谭的注意，“多谢”，大谭抱着试一试的心态，拿出圆角的立方块，在左手里一挤便形成了扁平的长方体，用另一只手掰下一角，揉一揉放在耳朵上，当作无线耳机，并用剩下的部分当作手机拨打华和的洁电话。 夏叶一开始被吓了一跳，以为这个房间里有第三个“人”，随即心想这个AI也太会了，与大谭所描述的无二。 不过奇怪的是，夏叶只看到讲电话中的大潭的嘴在动，没有听到任何说话的声音。 电脑里的AI察觉到了夏叶的疑惑，就跟夏叶解释道，他耳朵上的那个耳机，可以向外发出与他说话声音的声波相反的声音，实现对其他人的主动消音，从而不会干扰到他人。AI最后嬉笑地补充到，这时只有贴身靠近，才可以听到他的声音。 在另一边。“大谭，太好了，正想跟你联系，你已经到达我的海崖实验室了吧”，华和洁在电话的另一头欣喜的说到。 “是的是的，有什么好消息？” “我在你走之后，联系了以前在你实验室的同事，他们知道传输实验成功后纷纷表示祝贺，并在这时表达愿意提供更多的支持。我又告诉他们警方正在追查你们，很快啊，有一个同事讲可以从自己的库存中如数归还失窃的钯元素，并说愿为你当辩护人并请一些AI律师”。 “太感谢你们了，我欠你们的”。 “这几天你先忙你的事情吧，被追查这件事有人先替你收集信息和准备辩词，你的事情事出有因，而且在共产主义世界里，一般物品的缺失立马就补上了，这类非高价值物品的缺失也不算什么，不会很严重的。不过我想给你打电话不是因为这个，我和几个同事刚刚侦破了一起诈骗案”。 “诈骗案？你又发现了什么新玩意儿？” “比较高端，我们处理不了。事情是这样的，有个由几个人组成的团伙，在黑市声称他们已经发明了人体冷冻休眠技术，用特效做的复活冷冻休眠中的小动物的视频，以这个作为幌子，吸引很多想用这个高科技来休眠自己一下到达未来、留在未来的人，由此，该团伙非法骗取了很多财款和高价值物品。但是事情还没完，刚才我们进入了他们深藏地下的小‘作坊’，没想到的是这里真有一个人体冷冻休眠装置，但是半成品。所有的证据和线人作证表明啊，他们一开始就是在行骗，但是随着事情的热度越来越高，他们害怕了，后来开始通过赚来的财款和高价值物品吸引和资助一些科学家来真的研制这个装置。但是他们咬死不承认自己是在行骗，而是在‘众筹’，真是一群貌似有志向的团伙。但是他们的真实想法不只是他们自己清楚”。 “这整个事情和我窃取钯的事情有点像啊，虽然我和那个团伙所作所为的结果貌似都指向这是好事，但从当事人的心理来说，都是在投机取巧，法律的惩罚肯定是会吃的。另外，有了半个休眠装置，你们是打算怎么接着处理？” “是的是的，我们商量了一下，还是那些科学家，请到更好的实验室，想让他们继续研制，再叫上一些工程人员继续完善这个冷冻技术装置，所以过几天你来一下？” “求之不得”。 电话另一头说继续处理事情便结束了通话。大谭欣喜的想，我可以休眠到300年后等到夏叶的回来了，但突然又陷入短暂的迷茫，离别大谭现在的世人，包括亲朋好友，就像夏叶一样，决心的下定，需要一些时间，但是也绝不想错过和辜负夏叶的回来啊。另外，装置研发出来之后的试验，一次长达几十年的休眠试验来验证装置的可行性，大谭是熬不了那么久的，只有首次使用时候就是自己亲自进入这个参与研制的装置。 大谭跟夏叶说明了这些情况，似乎一切又有了希望，那个未来可期，那个未来可留，那个未来可以再次相遇。 “对了，你有我平生的所有数据吗？包括所有说的话，所有经历的事，我的行为、我的思考、我的资料库等等”，大谭向房间里的那个电脑AI问到。 “你是知道我的，你信任我，大哥，是的，我有几乎所有关于你的资料……”，该AI随即回应道，“难道真的要创造一个AI副本的你？” “不是创造，是学习啊大聪明”。 “哦”，AI冷冷的回应到。 夏叶在中间诧异的看着眼前大谭与AI之间敏捷且流程对话的场景，但不知道是在聊什么。 “那么就开始吧，这得有一阵子”，大谭最后对AI说到。回过头，大谭对夏叶讲，是做两手准备，就是叫一个AI学习自己，如果研制不出来冷冻休眠装置，那么会有一个与自己相似度高达99%的“AI我”来继续自己的意志活在这个世上，那个“AI我”的行为、言语等与我高度相似，可能也具有另外一个“我”的意识。但是为了达到这种程度的相似度，在这个时代的较高算力下，也需要反复迭代许多年，但是肯定远远到不了300年就是了。 大谭心里清楚，这个“AI我”，可以有新的名字，喜欢新的东西，过着新的生活，但是是我的数字孪生，与我的所思所想高度类似，所以在我万一无法冷冻休眠而老去之后，“AI我”才有资格被承认是我的意识的延续。只是这个“AI我”的所思所想，他在未来与夏叶的重逢，我再也感受不到罢了。 “不过”，夏叶问到，“最重要的一件事，这个‘如果’成真了呢？” 这是一个严肃的提问，夏叶继续说，“我再次回来的时候，是不是就只剩下‘AI你’了呢”，夏叶眼里闪了泪花。大谭透过那双晶莹、空明的眼睛，似乎看到了夏叶想象的一个场景，在夏叶回来之后，大谭的第一句就是“如果我是AI人，你会信吗？”夏叶是害怕信的。 大谭知道，平行地球这里认为“AI人”就是人，但来自地球的夏叶不一定。 大谭自信而安慰的说，“这里是平行地球啊，这里的奇迹太多，这里的科学家如满天繁星，咋不会成功呢，一定会的！” 电脑AI突然在一旁幽静的发出说话声，“我尝试计算和预测了一下，成功概率为…极有可能”。 “你看，大聪明都发话了…不，信息充足而且高度智能的AI都说了”，大谭和夏叶一同走入传送机器的容器，轻轻拭去夏叶眼角的水滴，继续与夏叶说，“这个传送机器会由华和洁保管的很好，我设定了155年后开始传送你回来，好吗？”说罢亲吻了夏叶的脸颊。 大谭走出容器，门被合上，模糊了的视线已经看不清操作台上的细节，大谭让AI开动机器。二人相视已久，容器内渐渐只剩如初那般人形的黑影。 不知过去了多久。在忙碌的房间里，AI不停的迭代学习建立大谭的“AI我”，大谭与一群计算机学家、生物学家、医生、工程师等各司其职于冷冻休眠装置。 在空闲的时候，大谭会走出半山腰上的研院楼，找那一片常去的空地，在那一颗不大的树下，倚在一块石头上，看那云儿好似跃上了枝头，想象透过大气层望向深邃的空间，渐渐进入温柔的梦乡，在那个世界里面，大谭每次都会与夏叶相逢，“别担心，我们地球的光会到达遥远的星系，在每个太阳系中，我们都重生，所以我们会永远在一起。” ","date":"2020-06-01","objectID":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/:0:6","tags":["科幻小说"],"title":"科幻小说《请留在未来》","uri":"/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/"},{"categories":["随机技术情报"],"content":"1451.5 智能无线传感器标准介绍","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"IEEE 1451.5 智能无线传感器标准介绍 本文的 Github/Gitee 仓库：Github仓库，Gitee仓库。 这里介绍 1451.5 标准中对于 1451.0 标准的一些新增/兼容部分的介绍，参考于 1451.5 标准源文。图片侵删。对于个人，如果业余时间想玩玩，把这个标准用起来，实现并且体验一下各个组件神奇的“自识别、自组网”、“即插即用”的话，主要在于实现 【读标准01】那篇文章里介绍的 1451.0 标准定义的 消息（message）和电子数据表格（TEDS）这两大功能，并且不用把标准所描述的都实现，实现其中自认为关键的/不可或缺的一部分即可。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:0:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"1451.5 的基本拓扑 图源：论文《基于IEEE_1451.5标准的物联网体系结构设计_陶星珍》 网关与传感器节点通讯流程图如图 5 所示。当传感器节点上电后，自动向网关广播一条消息，然后等待网关回应；网关收到来自传感器节点的消息后，对其进行解析，分析出命令的类号和功能号，然后做出应答，比如读取传感器的数据、读取传感器的 TEDS 或者写传感器的 TEDS等；当床啊七年节点收到后，将根据 1451.0 格式生成应答消息发回网关。 1451.5 拓扑 协议栈如下图所示。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:1:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"一个实例 1451.5 智能称重传感器系统架构如下图所示。图源：论文《基于IEEE_1451.5的高精度智能称重传感器系统_陈耿新》 上面实例中，1451.5 智能称重传感器系统传感器自识别流程如下图所示。 WTIM 在成功接入 ZigBee 网络后，向 NCAP 发送自识别中断请求开始自识别操作； WTIM、NCAP 任一方接收到对方消息帧后须返回确认应答 帧，若发送方在规定时间内没接收到对方确认应答帧则重新发送数据，直至发送成功或发送次数达到最大值。 TEDS 配置是 IEEE 1451 智能传感器自识别的关键环节。TEDS 配置流程包括： NCAP 接收到各TEDS 后，需通过校验和字段验证其完整性、正确性；对通过验证的 TEDS 进行解析、翻译，获取WTIM 及其通道相关信息、 参数， 再根据这些信息、参数配置相关资源以完成后续功能，如 NCAP 配置校正引擎相关参数实现数据解耦、校正。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:1:1","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"即插即用性能测试 引用：论文《基于IEEE_1451.5的高精度智能称重传感器系统_陈耿新》 以平均初次入网时间 tf、平均重新入网时间 tr、平均断网识别时间 tc作为评价指标。 平均初次入网时间 tf 定义为从 WTIM 首次向 NCAP 发送入网请求，直至其收到 NCAP 入网确认所需的平均时间； 平均重新入网时间 tr 定义为已加入网络的 WTIM 断开连接后， 从WTIM 再次发送入网请求， 直至其收到 NCAP 入网确认所需的平均时间； 平均断网识别时间 tc 定义为从WTIM 发生故障或断电开始，到 NCAP 识别 WTIM 断网所用的平均时间。 tf， tr， tc 越小，智能称重传感器 ZigBee 接口即插即用性能越好。 智能传感器系统 ZigBee 接口即插即用测试结果如下表所示。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:1:2","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"1451.5 标准的变化之处举例 1451.5 标准参考模型、物理层 TEDS（PHY TEDS） 和命令遵循 1451.0 标准。但是变化之处举例如下。 TIM 与 NCAP 的连接拓扑关系有新定义（5.1、5.2 小节）； NCAP 和 TIM 状态图新定义（5.4、5.5 小节）； 服务质量定义（5.6 小节）； 错误代号定义（5.7 小节）； 命令集； TEDS 除了 PHY TEDS，其他一样（5.3 小节）； WLAN 章节的一些特别定义（第 9 章）。 以下 TIM 都叫做 WTIM（Wireless Transducer Interface Module）。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:2:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"连接拓扑 NCAP 和 WTIM 的连接拓扑基本与 1451.0 中定义的 NCAP 和 TIM 一致，但 NCAP 与 WTIM 的通讯按照 1451.5 标准来。 以下是 1451.5 定义的 NCAP 与 WTIM 的角色关系。 An NCAP may route commands and data from an external network to/from a transducer connected to a WTIM. An NCAP may register multiple WTIMs. A WTIM shall only be registered with a single NCAP. A WTIM may interface to multiple transducers. WTIM-to-WTIM communication is allowed. ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:3:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"状态图 对于 NCAP 只是上电后有两个状态，一个是未连接 WTIM ，一个是连接了，对于 WTIM 状态有三个，前两个一样，在脸上之后，WTIM 给 NCAP 发送自己的 TEDS，告知自己的处于开放（Open）状态的传感器通道，并切到 开放状态，若 NCAP 回应则切回连接状态开始正常工作。具体 参考 1451.5 标准源文 5.4、5.5 小节。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:4:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"服务质量定义 服务质量（Quality of service，QoS）用于描述 NCAP 的服务质量，主要表现在 WTIM 对 NCAP 的请求或者传输命令/信息时候 NCAP 的回应延迟时间，举例来说，若前者时间超过 2 秒，或者后者时间超过 20ms，那么 WTIM 可以认为该 NCAP 的服务质量比较次，可以主动断开无线连接。具体 参考 1451.5 标准源文 5.6 小节。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:5:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"错误代号定义 用于标记 NCAP 或者 WTIM 在 1451 标准定义的协议的范畴上出现失败的情况的类型，比如标记了是 NCAP 或者 WTIM 的错误位置（位于 1451.0 还是 1451.5 层），以及在这一层，是目标地址错了、操作超时了、网络 下线了、TEDS 的格式错了等等等等。具体 参考 1451.5 标准源文 5.7 小节。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:6:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"命令集 NVAP 与 WTIM 通讯的信息协议格式与 1451.0 是一样的，只是改成借 1451.5 这一层当作中间原样传输层，这里定义了 1451.0 层调用 1451.5 层的中间的要有的一些 API。具体 参考 1451.5 标准源文 5.7 / 9.2 小节。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:7:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"PHY TEDS TEDS 的格式为 1451.0 定义的，如下： TED 长度（TED Length），包括 DATA BLOCK 和 CHECKSUM，字节为单位 （占 4 个字节）； 数据区（DATA BLOCK）： 第一个域类（Field type）（占 1 个字节）； 第一个域类的 值的长度（Length of Value），字节为单位（占一个字节）； 第一个域类的值（Value）（占 值的长度 个字节）； 第二个域类（占 1 个字节）； 第二个域类的 值的长度，字节为单位（占一个字节）； 第二个域类的值（占 值的长度 个字节）； … 以此类推。 校验值（CHECKSUM），从 TED Length 到 DATA BLOCK 的最后一个字节加和，再用 0xFFF 减去该加和值（占两个字节）。 其中 数据区（DATA BLOCK）各个域类的具体定义如下表所示。 释义如下： 域类 3，TEDS 头，值占四个字节，具体定义如下； 域类 10，无线类型，值占一个字节，具体定义如下； 域类 11，速度（bit / s），值占四个字节； 域类 12，与此设备的最大连接的可操作设备数，值占两个字节； 域类 13，与此节点的最大无线连接数，值占两个字节； 域类 14，加密特性，值占两个字节，第一个字节指示加密算法，第二个字节指示加密长度（单位：bit）； 等等等等，后面的具体看源文。授人以渔了已经。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:8:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"NCAP 和 WTIM 流程图 一下内容引自论文《基于IEEE1451.5标准网络传感器的研发_杨吉语》。 WTIM 程序流程图。 NCAP 程序流程图。 传感器即插即用功能实现流程图。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:9:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"一些注意事项 为了减少多个 TIM 上电后同时给 NCAP 发送 TEDS 信息而造成数据量突增，TIM 应该等待 NCAP 的发送 TEDS 的命令，然后再发送，而不是一上电就主动发送。TIM 都听从 NCAP 来指挥调度，遵守“交通”规则。 TIM、NCAP 任一方接收到对方消息帧后须返回应答/响应/回复帧，若发送方在规定时间内没接收到对方确认应答帧则重新发送数据，直至发送成功或发送次数达到最大值。 NCAP 与 TIM 建立连接后，在空闲时，与 TIM 心跳通讯，若有连续一定次数的不回应则断连。 使用 WLAN 时候，TIM 将自己的 IP 地址、端口等也存储在 PHY-TEDS 中。 实现的时候要充分考虑系统的扩展性、模块独立性和可移植性，比如还有 NCAP 适应 TIM 的增加入网，TIM 适应多个传感器通道的增加等，还要保持处理算法的小运算量，时间和空间复杂度控制住。 其他【读标准01】文章中提到的注意点。 ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:10:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["随机技术情报"],"content":"参考 \u0026 引用 [0] IEEE 1451 协议培训，IEEE-1451-介绍 - 百度文库 (baidu.com)，IEEE 1451 介绍ppt课件 - 百度文库 (baidu.com)，IEEE 1451 介绍课件 (renrendoc.com)。 [1] 孔勇,杨志强,张溪溪,杨吉宇,李继明,程学珍.基于IEEE1451标准的称重传感器实验系统设计ADXL355加速度计在强振动环境中的应用[J].电子测试,2020(15):11-13+42.DOI:10.16520/j.cnki.1000-8519.2020.15.003. [2] 解宇. 海洋仪器网络化平台智能船载终端研发[D].济南大学,2019.DOI:10.27166/d.cnki.gsdcc.2019.000446. [3] 杨吉语. 基于IEEE1451.5标准网络传感器的研发[D].山东科技大学,2018.DOI:10.27275/d.cnki.gsdku.2018.000570. [4] 陈耿新,黄锦胜.基于IEEE 1451.5的高精度智能称重传感器系统[J].自动化与信息工程,2017,38(05):5-11. [5] 赵常. 基于IEEE1451标准的加速度智能传感器的研究[D].沈阳理工大学,2016. [6] 陶星珍,蒋廷彪,崔更申.基于IEEE 1451.5标准的物联网体系结构设计[J].计算机测量与控制,2014,22(09):2960-2961+2966.DOI:10.16526/j.cnki.11-4762/tp.2014.09.039. [7] 朱志伟.遵循IEEE1451标准的传感器即插即用研究[J].单片机与嵌入式系统应用,2014,14(09):3-6. [8] 张小廷. 基于IEEE1451标准的无线智能传感网的设计与实现[D].哈尔滨工业大学,2014. [9] 张帅,张锁平,齐占辉.海洋观测网络化智能接口标准的研究[J].电子设计工程,2013,21(09):183-187.DOI:10.14022/j.cnki.dzsjgc.2013.09.003. [10] 王石记,周庆飞,安佰岳.IEEE 1451网络化智能传感器接口技术[J].计算机测量与控制,2012,20(10):2600-2602+2616.DOI:10.16526/j.cnki.11-4762/tp.2012.10.076. [11] 郑培亮. 基于ARM的IEEE 1451智能称重传感器设计[D].华南理工大学,2011. [12] 张韵. 基于IEEE1451标准中间件的研究和实现[D].大连理工大学,2007. [13] 黄永忠,李正晓.IEEE 1451标准族智能传感器技术发展浅析[J].仪器仪表标准化与计量,2005(04):24-27. [14] 童利标,徐科军,梅涛.IEEE1451网络化智能传感器标准的发展及应用探讨[J].传感器世界,2002(06):25-32. ","date":"2021-07-16","objectID":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/:11:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准02】IEEE 1451.5 智能无线传感器标准介绍","uri":"/10.2%E8%AF%BB%E6%A0%87%E5%87%8602-ieee1451.5-%E6%99%BA%E8%83%BD%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/"},{"categories":["【主线剧情】Linux 系列"],"content":"介绍 Linux 基本使用和对 ARM SoC 的基本编译流程","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM \u0026 Linux 基础学习记录 编辑整理 by Staok。 本文部分内容摘自 “100ask imx6ull” 开发板的配套资料（如 百问网的《嵌入式Linux应用开发完全手册》，在 百问网 imx6ull pro 开发板 页面 中的《2.1 100ASK_IMX6ULL_PRO：开发板资料》或《2.2 全系列Linux教程：在线视频与配套资料》里面可以下载到），还有参考 菜鸟教程、C语言中文网、红联的等等等等，比较广泛，侵删。进行了精髓提取，方便日后查阅。过于基础的内容不会在此提及。如有错误恭谢指出！ 注：在 Github 上的原版文章日后可能会更新，在其它位置发的不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"目录 [TOC] ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 一般开发步骤 p.s 本应放在最后，刻意写在前头。 Bootloader、Linux 内核、根文件系统、APP 等等软件，需要在 Ubuntu 中编译；但是阅读、修改这些源码时，在 Windows 下会比较方便。 所以工作日常开发流程如下： PC 端，使用 Source insight 编、改源码 —\u003e传—\u003e Ubuntu 端（通过 SSH 打开），对修改好的源码进行编译、制作 —\u003e下载—\u003e 嵌入式板端，在 Linux 板子上运行、测试。 分步来说就是： 在 Windows 上（Source insight）阅读、研究、修改，修改后，上传（推荐 FileZilla）到 Ubuntu； 在 Ubuntu 上编译、制作（推荐使用 MobaXterm 通过 SSH 远程登陆 Ubuntu）； 把制作好的可执行程序下载到 嵌入式开发板 上运行、测试。 u-boot、Linux内核，在 Windows 和 Ubuntu 各存一份。根文件系统使用 buildroot （或 Busybox 或 Yocto）制作，它无需放在 Windows 上。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux OS 相关 p.s 关于在 VM 虚拟机中安装 Linux 发行版系统和在 PC上安装 Linux 发行版系统，用时再在网上随用随查。 p.s 若仅用于开发或者只使用命令行的形式，一般在 MobaXterm 或者 Xshell 中使用 SSH 连接 Linux 系统（如 Ubuntu）来进行系统操作。 p.s 鼠标退出 VM ，按 ctrl + alt。 参考网搜教程的总目录 Linux 教程 | 菜鸟教程 (runoob.com)，Linux学习教程，Linux入门教程（超详细） (biancheng.net)。Linux 系统启动过程 | 菜鸟教程 (runoob.com)。 VM 虚拟机推荐安装 Ubuntu-18.04，网搜教程很多，安装好之后，要再执行结果必要的步骤： # 安装 vim sudo apt-get install vim # 换源 # 参考本文 “Ubuntu 下的包管理” 一节 # 安装 net-tools，可以使用 ifconfig 命令来查看 本机 ip 地址 sudo apt-get install net-tools # 安装 SSH 服务 sudo apt-get install openssh-server # 推荐使用 MobaXterm 通过 SSH 远程登陆 虚拟机里面的 Ubuntu-18.04 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 文件系统 文件目录 Ubuntu 中的目录遵循 FHS 标准(Filesystem Hierarchy Standard， 文件系统层次标准)。它定义了文件系统中目录、文件分类存放的原则、定义了系统运行所需的最小文件、目录的集合，并列举了不遵循这些原则的例外情况及其原因。 FHS 并不是一个强制的标准，但是大多的 Linux、 Unix 发行版本遵循 FHS。 这些目录简单介绍如下。 Linux 系统目录结构 | 菜鸟教程 (runoob.com)。Linux文件系统的层次结构 (biancheng.net)。 Linux绝对路径和相对路径详解 (biancheng.net)，Linux文件（目录）命名规则 (biancheng.net)。 文件属性 终端中执行 “ls -al” 命令则给出每个文件完整属性信息。文件属性示意图如下 。 第一个字符表示“文件类型”，文件类型可以是目录、文件或链接文件等。如下表所示。 d 目录 - 文件 l 链接文件 b 设备文件里的可供存储的接口设备 c 设备文件里的串行端口设备，如鼠标、键盘等 文件类型后面的 9 个字符以 3 个为一组： 第一组表示 “文件所有者的权限”； 第二组表示 “用户组的权限”； 第三组表示 “其他非本用户组的权限”，即其它所有人的权限。 每组都是 rwx 的组合， 其中 r 代表可读， w 代表可写， x 代表可执行； 如果没有对应的权限，就会出现减号-。 连接数： 表示有多少文件名连接到此节点。 文件所有者：表示这个文件的 “所有者的账号”。 文件所属用户组。 文件大小：表示这个文件的大小，默认单位是 B(字节)。 文件最后被修改的时间： 这个文件的创建文件日期或者是最近的修改日期。 文件名：对应文件的文件名。 文件/目录管理 和 更改文件属性/权限 等 参看文件/目录 \u0026 文件权限 \u0026 用户管理一节。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 系统相关概念 Linux 系统启动过程 | 菜鸟教程 (runoob.com)。 Linux系统相关的基础问题（空间、内存、库、链接、环境变量）_~青萍之末~的博客-CSDN博客。 Linux系统调用_~青萍之末~的博客-CSDN博客_linux系统调用。【第4篇】嵌入式Linux应用开发基础知识_哔哩哔哩_bilibili，其中 4-2_ 文件IO _系统接口 这一个节讲解 系统调用怎么进入内核。 Linux内核的五大模块_~青萍之末~的博客-CSDN博客_linux内核模块，进程调度，进程间通信模块（包括管道、命名管道、消息队列、信号量和共享内存等），内存管理模块，文件系统模块，网络接口模块。 etc. ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"terminal / console / tty / shell 一文搞懂~ 终端、Shell、tty 和控制台（console）有什么区别？ - 知乎 (zhihu.com)。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux Shell 概况 Shell 的意思是“外壳”，在 Linux 中它是一个程序，比如 /bin/sh、 /bin/bash 等。它负责接收用户的输入，根据用户的输入找到其他程序并运行。比如我们输入“ ls”并回车时， shell 程序找到“ ls”程序并运行，再把结果打印出来。Shell 有很多种实现，我们常用 bash。 命令提示符如下图。 根目录： “/” ；家目录： “~” ；上一级目录： “..” ；当前目录： “.” ；上一次目录：\"-\"。执行当前目录的 “app” 应用程序： “./app” 。 绝对路径从 根目录 “/” 开始写起，相对目录从当前所在目录 “.” 开始写起。 常用命令 Linux 命令查询，当字典用。 Linux 命令大全 - 菜鸟教程。 即用网页：Linux命令搜索引擎 命令，Linux Linux命令搜索引擎 命令详解：最专业的Linux命令大全，内容包含Linux命令手册、详解、学习，值得收藏的Linux命令速查手册。 - Linux 命令搜索引擎 (wangchujiang.com)，开源地址 jaywcjlove/linux-command: Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集。https://git.io/linux (github.com)。 即用网页：Linux工具快速教程 — Linux Tools Quick Tutorial (linuxtools-rst.readthedocs.io)，开源地址 me115/linuxtools_rst: Linux工具快速教程 (github.com)。 本地离线文档资料 Linux 命令速查：【1 Linux 命令速查 \u0026 Shell \u0026 Vim】\\Linux 命令速查-快速定位查询\\。 100ask 手册《嵌入式Linux应用开发完全手册》的 “第2章 开发板板载系统应用、库、工具、使用”。 Linux大神都是怎么记住这么多命令的？ - 知乎 (zhihu.com)。 20个提高生产力的 Linux 命令与技巧，用完带你起飞_布道者-瞎子的博客-CSDN博客. Shell 教程 - 菜鸟教程，Shell脚本：Linux Shell脚本学习指南（超详细） (biancheng.net)。 添加环境变量：具体步骤在 “换源 和 添加系统变量” 一节 里面的 “添加系统变量” 处。 快捷键 / 通配符 / 流重定向 / 管道 Linux 图形界面中（比如 Ubuntu 图形界面中），按下 Ctrl + Alt + t 打开终端。 命令的 惯例选项 的含义：以下命令的多个选项可以任意按需组合。 -a 表含隐藏文件； -r 表文件夹内遍历所有文件； -h 容量以方便识别的形式打印（如容量大小以 K/M/G 单位显示）； -i 执行例外操作前会询问，加上比较保险； -v 显示版本； –help 显示帮助； 等等。 快捷键： 结束当前进程：ctrl + c。 暂停当前进程：ctrl + z，可使用 fg 命令 恢复，详见 任务后台执行 / 任务\u0026进程查看 一节。 使光标移动到命令行的最前：ctrl + a，对于长命令可以快速定位到最前。 使光标移动到命令行的最后：ctrl + e。 退出当前终端：ctrl + d，关闭，作用与 exit 一样。 暂停终端的快速滚动（冻结）：ctrl + s；解冻终端是用 ctrl + q。 一行多个命令逐个执行：命令之间加 \u0026\u0026 符号。 一次运行多个命令：命令之间加上 ; 分号，即 command_1; command_2; command_3 形式。 将命令放到后台执行：命令结尾加一个 \u0026 符号，更多信息见 任务后台执行 / 任务\u0026进程查看 一节。 自动补全：tab 键自动补全命令和文件或目录的全名。输入路径全名的中途，按两下 tab 键显示当前目录下的内容。 shell 中 !! 代表上一个命令，原样替换，比如执行 command_1 后发现需要 root 权限，只需再执行 sudo !! 即可 带上 sudo 前缀执行上一次命令。 shell 中 !$ 代表 上一个命令的最后一项，比如 ls ~ 和 cd !$ 就是接连查看家目录和打开家目录。 设置命令别名：设置 linux 命令别名_清泉影月的博客-CSDN博客。 基本命令 alias ll=ls -l。删除别名 unalias [别名]。 直接执行 alias 命令后别名立马生效，只是临时生效，退出 shell 窗口就没了。 永久生效方法：上述命令写到 /root/.bashrc 文件，用 source 命令让 .bashrc 文件生效。 各种通配符： *：任何字符和字符串。 ?：一个任意字符。 [abc…]： 内的任意一个字符。 [abc]表示 a、 b、 c 任一个字符；有时候也表示范围，如 [a-x] ，表示 a 到 x 的任一个字符； [1-9] 表示 1 到 9 的任一数字。 [!abc…]：和上面的相反，表示除 内的字符外的任意一个字符。 例 rm -f 1[!1]*.txt 删除名字中第一个字符是 “1” 而第二个字符不是为 “1” 的所有文件。 流控制，输入 和 输出 重定向（\u003e / », \u003c）：Shell 输入/输出重定向 | 菜鸟教程 (runoob.com)。 command \u003e file，将 command 的 输出 重定向到 file（一个文件），即将 command 的输出流 stdout 重定向到 file，将 command 的打印内容覆盖输出到文件 file 里；command \u003e\u003e file，将输出以追加的方式重定向到 file，追加输入到文件 file。 command \u003c file，将 command 的 输入 重定向到 file，即将 command 的输入流 stdin 重定向到 file，本来需要从键盘获取输入的命令会转移到读取文件内容。 注意 输出重定向是大于号(\u003e)，输入重定向是小于号(\u003c)。 清空文本文件的内容而不删除文件本身：\u003e 文件名。 错误信息重定向： 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin 的文件描述符为 0，Unix 程序默认从 stdin 读取数据。 标准输出文件(stdout)：stdout 的文件描述符为 1，Unix 程序默认向 stdout 输出数据。 标准错误文件(stderr)：stderr 的文件描述符为 2，Unix 程序会向 stderr 流中写入错误信息。 command 2 \u003e\u003e file 让执行命令后的错误信息 stderr 追加到 file 文件末尾。 管道（ | ）： command1 | command2，当在两个 命令/应用/进程 之间设置管道时，管道符|左边命令的输出就变成了右边命令的输入（管道 即进程间通讯的一种）。 这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command1 的输出结果； command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。 例：查看指定程序的进程运行状态，并将输出重定向到文件中。 ps aux | grep httpd \u003e /tmp/ps.output \u0026\u0026 cat /tmp/ps.output 基本命令 / 文件\u0026目录管理 基本命令 pwd、cd、mkdir（-p 选项指示连续创建目录及其子目录，如mkdir -p test1/test2/test3/test4）、rmdir（不能删除非空目录，-p 选项可以一次删除多级空目录）、touch、clear、echo（往文件写内容 echo none \u003e /sys/class/leds/cpu/trigger）。 文件与目录管理 Linux 文件与目录管理 | 菜鸟教程 (runoob.com)。 ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称 显示目录文件和文件夹：ls -l 显示完整属性信息；-a 显示隐藏文件；-h 文件和文件夹大小以 K/M/G 单位显示；-i参数显示文件的inode节点信息。一个例子如图。 统计目录每个文件大小：du 统计指定目录内每个文件和文件夹大小：du -ah ~/Videos。-a 表显示隐藏文件，-h 表大小以 K/M/G 单位显示。 显示指定文件所占空间： # du log2012.log 300 log2012.log 复制 文件或文件夹：cp -r 表示递归目录下所有文件。 -d 如果源文件为链接文件，只复制链接文件而不是实际文件。 -i 增加特殊情况的讯问，如同名时会询问是否覆盖等（个人建议常用）。 -f 强制覆盖。 额外选项： -l：进行硬连结(hard link)的连结档创建，而非复制文件本身。 -s：复制成为符号连结档 (symbolic link)，亦即 快捷方式文件。 -p","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:4","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 下的开发 代码编辑：Vim、gedit（ubuntu 下）。 编译工具：gcc，make，cmake（生成 makefile，网搜教程，本篇不涉及）。 项目管理：git（网搜教程，本篇不涉及）。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"详细资料-重要 关于 Linux Shell 命令、GCC、Makefile/CMake、GDB/GDBServer、Vim 等工具的详细使用教程和使用经验， 可见 本系类文章对应 仓库 Github 仓库 或 Gitee 仓库 中： 【1 GCC \u0026 GDB \u0026 GDBServer】； 【1 Linux 命令速查 \u0026 Shell \u0026 Vim】； 【1 Makefile \u0026 CMake 教程及模板】。 这几个文件夹内！ ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Vim 编辑器 功能：打开、新建和保存文件；文本编辑；多行、列间复制、粘贴和删除；查找和替换。 意义：开发中，尤其对于大型项目并不常用，但是在需要临时修改、现场调试和没有 GUI 形式的编辑器等等的时候，可以快速进行一些简单文本编辑。 Linux vi/vim | 菜鸟教程 (runoob.com)。 一图以蔽之 一般模式/普通模式：用于按各种快捷键进行光标移动、复制、粘贴和删除等。 编辑模式/插入模式：用于敲字符输入/编辑。 命令行模式：用于输入保存、退出、查找和替换 等 控制命令，在 一般模式 打一个冒号再输入命令。 注：当不知道处于何种模式时，按 ESC 键返回到 一般模式。可以在 Ubuntu 中安装中文输入法。 更多可参考 vim命令大全 - 知乎 (zhihu.com)。 在 一般模式 的快捷键 i/a，在光标处的前/后进入 编辑模式。dw，删除一个单词；dd，删除光标所在行(d:delete) 。 单击 o （字母 o）键，在当前光标所在行的下方新建一行，并进入编辑模式。 单击 0（数字零） 光标移至当前行行首；$，光标移至当前行行末；%，在括号（）、[]、{}间移动。 gg，跳到第一行，（xgg 就是跳到第x行的行首）；G，跳到文件结尾。 ctrl + u/d 进行 半屏的前后滚动；ctrl + f/b 进行 全屏的 上下翻页。 使用 v 进入可视模式，移动光标来 选定文本块内容；用 y 复制选定块到缓冲区，用 d 剪切选定块到缓冲区，用 p 粘贴缓冲区中的内容。 u，撤销上一步操作；ctrl + r，恢复，回退到前一个命令。 针对 Ubuntu 界面来说，ctrl + “-” ，减小字号；ctrl + shift + “+\"，增大字号。 在 命令行模式 的命令 保存，:w；退出，:q；强制执行，在命令后加!；前面的命令可以组合。文件另存为，:w \u003cfilename\u003e。重命名当前文件，:f \u003cfilename\u003e。 查找，:/pattern 从光标开始处向文件尾搜索字符串 “pattern”，后按 n （在同一个方向重复上一次搜索命令）或 N （在反方向重复上一次搜索命令）；从当前光标位置开始搜索，若光标在文件开头，则为全文搜索。 替换，:%s/p1/p2/g 将文件中所有的 p1 均用 p2 替换；:%s/p1/p2/gc 替换时需要确认。释义，“ s“ 全称： substitute 替换；“ g“ 全称： global 全局；“ c“ 全称： confirm， 确认。 纵向分屏 来 新打开一个文件 :sp \u003cfile\u003e 或 横向分屏 :vsp \u003cfile\u003e，此时会同屏新增一个窗口；切换这多个窗口的方法（循环移动）：ctrl + w，w（先按 ctrl + w，再按键 w），在多文件编程时，切换不同的窗口很实用。让鼠标可以在多个屏幕间切换：:set mouse=a；在某个窗口输入:q，为退出此窗口。 跳转到第 n 行，:n。打印当前文件名和行数，:f 。 从 a 到 b 行的内容写入 filename 文件，:a,bw \u003cfilename\u003e。 在 Vim 命令行执行 Shell 命令，:！+ shell 命令。 一日，一人，代码前坐禅，贤者模式，顿悟，曰：整个键盘，都是 Vim 的快捷键。 恢复文件 vi 在编辑某一个文件时，会生成一个临时文件，这个文件以 . 开头并以 .swp 结尾。正常退出该文件自动删除，如果意外退出例如忽然断电，该文件不会删除，我们在下次编辑时可以选择一下命令处理： O 只读打开，不改变文件内容。 E 继续编辑文件，不恢复 .swp 文件保存的内容。 R 将恢复上次编辑以后未保存文件内容。 Q 退出 vi。 D 删除 .swp 文件。 使用 vi －r \u003cfilename\u003e 来恢复 filename 这个文件上次关闭前未保存的内容。 vim 命令行中的 选项 -d，Diff 模式 (同 “vimdiff”, 可迅速比较两文件不同处)。 -R，只读模式 (同 “view”)。 -b，二进制模式。 -r \u003cfilename\u003e，恢复上次崩溃的文件 filename (Recover crashed session)。 vim 编辑器的配置 命令行键入vim -version可以看到几个 vim 的配置文件在哪，包括 系统级配置文件（对所有用户有效）system vimrc file 一般在 /etc/vim/vimrc，用户级配置文件（对当前用户有效）user vimrc file 一般在 ~/.vimrc。 部分摘自 100ask，部分摘自 《嵌入式C语言的自我修养》 vim ~/.vimrc 在其中（选择性）加入如下内容： \" color scheme colorscheme molokai \" disply incomplete commands set showcmd \" set fileencodings set fileencodings=ucs-bom,utf-8,cp936,gb2312,gb18030,big5 set background=dark set encoding=utf-8 set fenc=utf-8 set smartindent set autoindent set cul set linespace=2 set showmatch set lines=47 columns=90 \" font and size \" set guifont=Andale Mono:h14 \" set guifont=Monaco:hll set guifont=Menlo:h14 \" Softtabs, 4 spaces \" 编辑时 backspace 键设置为2个空格 set backspace=2 \" 编辑时 tab 键设置为4个空格 set tabstop=4 \" 设置自动对齐为4个空格 set shiftwidth=4 set shiftround set softtabstop=4 set expandtab set smarttab \" Highlight current line au Winleave * set nocursorline au WinEnter * set cursorline set cursorline \" 底部显示光标所在行和列 set ruler \" 显示行号 set number \" 关闭行号为 set nonumber，即 \"option\" 前面加 \"un\" 前缀表失能此功能 \" 搜索时不区分大小写 set ignorecase \" 搜索时高亮显示 set hlsearch \" 关闭兼容功能 set nocompatible vim配置通过按键映射实现括号补全： 在 Vim 官网还有 很多 vim 扩展功能 .vim 文件 提供下载，放到~/.vim/plugin目录，再在~/.vimrc中对其进行配置即可使用。 更多 Vim 配置和插件可参考 Vim编辑器_~青萍之末~的博客-CSDN博客。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"GCC 命令详情 编译流程 gcc 编译器可以通过 apt-get 安装 或者 在 GNU 官网下载。 要使用 gcc 等编译器或交叉编译器，应先把编译器的可执行文件放在某个目录，然后给系统环境变量加此路径（Win平台为添加环境变量，Linux 为使用 export 命令，或者在 bashrc 文件中添加，具体步骤在 “换源 和 添加系统变量” 一节 里面的 “添加系统变量” 处），对于 Make 工具同理。可以在 命令行运行 gcc -v 即可使用。 C/C++ 程序文件的编译过程图示： gcc 基本命令 预处理（-E）：gcc -E main.c -o main.i，仅预处理。（通过重定向）输出到指定文件：gcc -E main.c \u003e main.i。 编译（-S）：gcc -S main.c -o main.s，编译到汇编文件。 汇编（-c）：gcc -c main.c -o main.o，只生成目标文件（机器码），不进行链接。 完成整个编译（-o filename） 单文件：gcc main.c -o main，编译输出最终可执行文件，-o 后面要紧跟 输出文件名。 多文件：gcc main.c sub.c add.c -o ouput，其中 main.c 里面 #include 了 sub.h 和 add.h。 输出所有警告：加上 -W 或 -Wall 选项。 文件编码指定 程序文件在保存的时候就选好编码（有 ANSI、GB2312、UNICODE，和很常用的并推荐的 UTF-8），使用 记事本 或者 notepad 可以选择和转换。 使用 gcc 编译器，器对于 程序文件 和 编译出的 二进制可执行程序 都默认为 UTF-8 编码。 若 程序文件 的编码 不为 UTF-8 编码，则应该指定：-finput-charset=GB2312 等。 对于编译出来的可执行程序，可以指定它里面的字符是以什么方式编码：-fexec-charset=GB2312 等。注意，是指定/告知 而 不是转换的意思， gcc 不能转换编码。 例子：gcc -finput-charset=GB2312 -fexec-charset=UTF-8 -o test_charset_ansi test_charset_ansi.c。告知 编译器 .c 文件为 GB2312 编码，编译出的程序应为 UTF-8 编码。 在代码中使用汉字这类非 ASCII 码 字符 时，要特别留意编码格式。 头文件选项 对于 #include \u003c...\u003e 的头文件（一般都是 标准库的头文件，比如 stdio.h、stdlib.h、string.h 等） 编译器在编译时会去 gcc 默认的路径中（编译器目录里面的 include 文件夹里）寻找头文件。可以通过 echo 'main(){}'| arm-linux-gnueabihf-gcc -E -v - 命令来 列出头文件目录、库目录（LIBRARY_PATH）。 对于 #include \"...\" 的头文件去 -I \u003cdirname\u003e 这个选项所指定的目录（dirname 目录）中去找（如果不加 -I 选项则默认搜 当前目录），-I \u003cdirname\u003e 即是将 dirname 目录加入到头文件搜索目录列表中，用户引用除了 上面 的标准库头文件 而是 自己的头文件，就用这种方式。例如 main.c 目录中有 inc 文件夹，里面有 test.h 文件，并且 main.c 中通过 #include \"test.h\" 调用了 test.h 文件，则命令为：gcc main.c -I inc -o main。 编译时寻找库文件： 默认的系统目录：就是交叉编译工具链里的某个 lib 目录。 自己指定添加库文件搜索目录：链接时（-L dirname）。 自己指定添加某一个具体的库文件：加载库名选项（-l name），比如想链接 libabc.so，那链接时加上 -labc。 静态库选项（-static）等选型 略。 运行时寻找库文件：（程序运行时不需要再加载头文件，因为编译时已经编译进去了） 系统目录：就是板子上的 /lib、/usr/lib 目录。 自己指定：用环境变量 LD_LIBRARY_PATH 指定，比如 export LD_LIBRARY_PATH=/xxx_dir。 代码优化选项 -O 或 -O1：基本优化，使代码执行的更快。 -O2 或 -O3：产生尽可能小和快的代码。如无特殊要求，不建议使用 O2 以上的优化。 -Os：生成最小的可执行文件，适合用于嵌入式软件。 调试模式选项 输出带调试信息，可以用于 GDB 单步调试来 debug：加上-g选项。 产生能被 GDB 调试器使用的调试信息：gcc main.c -g -o main。 GDB 的命令行调试指令详情略（包括运行、单步执行、加删查断点、打印变量等命令）。 下面引用 embedded-notes/linux.md at master · xiaowenxia/embedded-notes (github.com)。 gcc工具链 命令 描述 Binutils 由汇编器（as）产生的目标代码（*.o）是不能直接在computer上运行的，它必须经过链接器（ld）的处理才能生成可执行代码。 add2line 将地址转换成文件名或行号对，以便调试程序 ar 从文件中创建、修改、扩展文件 gasp 汇编宏处理器 nm 从目标文件列举所有变量 objcopy 使用GNU BSD库把目标文件的内容从一种文件格式复制到另一种格式的目标文件中。 objdump 显示目标文件信息可发编译二进制文件，也可以对对象文件进行反汇编，并查看机器代码。 readelf 显示elf文件信息 ranlib 生成索引以加快对归档文件的访问，并将其保存到这个归档文件中。 size 列出目标模块或文件的代码尺寸。 strings 打印可打印的目标代码符号（至少4个字符） strip 放弃所有符号连接，一般应用程序最终都要strip处理 C++filt 链接器ld通过该命令可过滤C++符号和JAVA符号，防止重载函数冲突。 gprof 显示程序调用段的各种数据 ld 交叉链接器 将多个编译后产生的过程文件连接为一个最终的可执行文件。 ld [options] 链接器脚本 -o 文件名.elf readelf 交叉ELF文件查看器 用来查看一个可执行文件的相关信息 可以查看elf文件的运行架构，大小端等信息: readelf -a 文件名.elf 显示程序需要的动态链接库: readelf -d 文件名.elf objdump 交叉反汇编器 将一个可执行文件转换为汇编下的程序 -objdump -D -S elf文件名 \u003e目标文件 objcopy 交叉转换器 将elf格式文件转换成其他的格式 objcopy -O 目标文件格式 原ELF文件 目标文件 例子： objcopy -O binary a.elf a.bin ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Makefile 简述和模板 解决问题：针对包含超多文件的工程；自动搜索被添加目录中的所有被调用的文件；在第二次全编译时，没有修改的文件只链接而不重复编译节省时间；等等。 基本格式 目标（target）：依赖（prerequisites） [Tab]命令（command） target：需要生成的目标文件。 prerequisites：生成该 target 所依赖的一些文件。 command：生成该目标需要执行的 命令行的命令。 在命令前加 “@” 符号，在 make 时不显示此条命令的执行过程，只显示结果。 举一个例子： # 在命令行执行 make 或者 make all 即执行这里，这里是执行 hello，其描述在下面 all:hello # 这是一个规则，包含 目标、依赖 和 命令 # 表示 执行 hello 命令/目标 ，所用到的 文件/原材料 有 main.o sum.o，要执行的命令为 gcc -o hello main.o sum.o # 从 多个 源文件 来组合 生成 执行文件 hello:main.o sum.o gcc -o hello main.o sum.o # 上面所依赖的 目标 main.o 要进行的命令 main.o:main.c gcc -c main.c sum.o:sum.c gcc -c sum.c # 清理，命令行键入 make clean 即可执行此 clean: rm -f main.o sun.o hello 变量赋值（ =、:=、?=、+= ） # Makefile 中的变量是字符串。 PARA = 100ask # 注，注释必须单独一行，不能写在语句后面 # = # 相当于 PARA 的指针给 CURPARA，之后 PARA 的值变，CURPARA 的值会跟着变。 CURPARA = $(PARA) # := # 仅赋值，之后 PARA 的值变，CURPARA 的值不会跟着变。 CURPARA := $(PARA) # ?= # 使用“?=”给变量设置值时，如果这个变量之前没有被设置过，那么“?=”才会起效果；如果曾经设置过这个变量，那么“?=”不会起效果。相当于函数定义时的 weak 修饰符。 # += # 这样的结果是OBJ的值为：”main.o，add.o，sub.o“。说明“+=”用作与变量的追加。 OBJ = main.o add.o OBJ += sub.o 自动变量（ $@、$^、$\u003c ） CC = gcc OBJ = main.o add.o sub.o output: $(OBJ) $(CC) -o $@ $^ # $@：表示规则中的目标（target），即 output # $^：表示规则中的所有依赖文件（All prerequisites），即 main.o add.o sub.o main.o: main.c $(CC) -c $\u003c # $\u003c：表示规则中的第一个依赖文件（The first prerequisites），即 main.o 右边的第一个依赖，即 main.c add.o: add.c $(CC) -c $\u003c sub.o: sub.c $(CC) -c $\u003c clean: rm $(OBJ) output 模式规则（ %.x ） CC = gcc OBJ = main.o add.o sub.o output: $(OBJ) $(CC) -o $@ $^ %.o: %.c $(CC) -c $\u003c # %.o: %.c 表示如下： # main.o 由 main.c 生成，add.o 由 add.c 生成，sub.o 由 sub.c 生成 clean: rm $(OBJ) output 伪目标 # 在目标和文件名重名时，加上这句指令，便可以正常执行。用于避免执行命令的目标和工作目录下的实际文件出现名字冲突。 .PHONY:clean clean: rm $(OBJ) output Makefile 函数 经常使用的 Makefile 函数，主要有两个(wildcard，patsubst)。函数的调用格式 $(function（空格或tab）arguments)，这里 function 是函数名， arguments 是该函数的参数。 # $(wildcard 指定文件类型) 用于查找指定目录下指定类型的文件 # 这条规则表示，找到目录./src下所有后缀为.c的文件，并赋值给变量SRC。命令执行完，SRC变量的值：./src/ask.c ./src/100.c SRC = $(wildcard ./src/*.c) # $(patsubst 原模式, 目标模式, 文件列表) 用于匹配替换 # 这条规则表示，把变量 SRC 中所有后缀为.c的文件替换为.o。 命令执行完，OBJ变量的值：./src/ask.o ./src/100.o OBJ = $(patsubst %.c, %.o, $(SRC)) # $(subst from,to,text) 字符串替换，在文本`text’中使用`to’替换每一处`from’。 # 结果为‘fEEt on the strEEt’ $(subst ee,EE,feet on the street) # $(strip string) 去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。 # $(findstring find,in) 在字符串`in’中搜寻`find’，如果找到，则返回值是`find’，否则返回值为空。 # $(filter pattern...,text) 返回在`text’中由空格隔开且匹配格式`pattern...’的字，去除不符合格式`pattern...’的字。 # $(filter-out pattern...,text) 返回在`text’中由空格隔开且不匹配格式`pattern...’的字，去除符合格式`pattern...’的字。它是函数filter的反函数。 # $(sort list) 将‘list’中的字按字母顺序排序，并去掉重复的字。输出由单个空格隔开的字的列表。 # 文件名函数 略 一个简易的 Makefile 模板 该 Makefile 模板 针对的 文件夹 的 树形目录结构 ├── inc │ ├── add.h │ └── sub.h ├── Makefile └── src ├── add.c ├── main.c └── sub.c # 编译输出文件加尾缀 \"_VERSION\" VERSION = 0.0.1 # 源文件 .c 文件的所在的名为 src 的目录 SOURCE = $(wildcard ./src/*.c) # 增加一个名为 src1 的源文件所在目录 #SOURCE += $(wildcard ./src1/*.c) # 引用文件 .h 文件的所在的名为 inc 的目录 INCLUEDS = -I ./inc # 增加一个名为 inc1 的引用文件所在目录 #INCLUEDS += -I ./inc1 # 编译输出目标文件的文件名 TARGET = output # 编译输出目标文件所在的文件夹名 OUTPUTDIR = obj # 编译器全名 CC = gcc # 以下都是固定的不用动 CFLAGS = -Wall -g OBJECT = $(patsubst %.c, %.o, $(SOURCE)) $(TARGET): $(OBJECT) @mkdir -p $(OUTPUTDIR)/ $(CC) $^ $(CFLAGES) -o $(OUTPUTDIR)/$(TARGET)_$(VERSION) %.o: %.c $(CC) $(INCLUEDS) $(CFLAGES) -c $\u003c -o $@ .PHONY:clean clean: @rm -rf $(OBJECT) $(OUTPUTDIR)/ 更加通用的 Makefile 模板 在文件 【1 Makefile CMake 教程 及其模板】\\general_Makefile.zip 里。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:4","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Ubuntu 下的包管理 / apt工具 包管理系统的功能和优点大致相同，但打包格式和工具会因平台（不同的 Linux 发行版）而异，如下表所示。 操作系统 格式 工具 Debian .deb apt, apt-cache, apt-get, dpkg Ubuntu .deb apt, apt-cache, apt-get, dpkg CentOS .rpm yum Fedora .rpm dnf FreeBSD Ports, .txz make, pkg 一般来说 Ubuntu 下很多软件是需要先自行提供源码，使用源码自行编译，编译完成以后使用命令 “install” 来安装到系统中。当然 Ubuntu 下也有其它的软件安装方法，使用得最多的方法就是自行编译源码后进行安装，尤其是嵌入式 Linux 开发。 自行对软件源码编译的一个好处是可以针对不同平台进行编译和部署。 我们利用软件包管理系统可以直接下载并安装所有通过认证的软件，其中 Ubuntu 下我们用的最多的下载工具： APT 下载工具， APT 下载工具可以实现软件自动下载、配置、安装二进制或者源码的功能。 在我们使用 APT 工具下载安装或者更新软件的时候，首先会在下载列表中与本机软件进行对比，看一下需要下载哪些软件，或者升级哪些软件，默认情况下 APT 会下载并安装最新的软件包，被安装的软件包所依赖的其它软件也会被下载安装或者更新，非常智能省心。 包管理工具 apt Linux apt 命令 | 菜鸟教程 (runoob.com)。 # \"package\" 替换为 包名。 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get install package 安装包 sudo apt-get remove package 删除包 sudo apt-cache search package 搜索软件包 sudo apt-cache show package 获取包的相关信息，例如说明、大小、脚本等 sudo apt-get install package --reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package --purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被那些包依赖 sudo apt-get source package 下载该包的源代码 换源 和 添加系统变量 换源 Ubuntu Ports更换成阿里云镜像源-阿里云开发者社区 (aliyun.com)。 首先备份源列表：sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup； 编辑 /etc/apt/sources.list 文件，在文件最前面添加镜像源： # 阿里源 deb https://mirrors.aliyun.com/ubuntu-ports/ xenial main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu-ports/ xenial-security main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse # deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse # 清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse # 中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:5","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 驱动和应用的体验 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"Ubuntu 主机 的配置工作 首先换源，参考前面 “换源 和 添加系统变量” 一节。 配置 100ask Ubuntu 主机 的环境，执行： wget --no-check-certificate -O Configuring_ubuntu.sh https://weidongshan.coding.net/p/DevelopmentEnvConf/d/DevelopmentEnvConf/git/raw/master/Configuring_ubuntu.sh \u0026\u0026 sudo chmod +x Configuring_ubuntu.sh \u0026\u0026 sudo ./Configuring_ubuntu.sh 这个会配置/安装一些基本应用如 NFS/TFTP 等，还建立 /home/book 目录，book 用户 等，具体看其 shell 程序。 百问网的 imx6ull pro 开发板的 SDK包（包括 Linux、uboot、buildroot 等源码和工具链，这个需要 windows 电脑 和 虚拟机 ubuntu 各存一份，前者用来阅读，后者用来编译）两个下载途径： 本地拷贝法：百问网 imx6ull pro 开发板 页面，找到 100ask_imx6ull_pro_2020.02.29_v2.0（这个很大，网盘下载），里面有固件、SDK包、原理图（底板+核心板）、应用例程、工具软件等等。其中 SDK包（包括 Linux、uboot、buildroot 等源码和工具链）在 07_Bsp_sdk (系统源码，包含uboot kernel rootfs 工具链 测试代码等)) 里面，自行拷贝到虚拟机 ubuntu 里面并解压。但是这是本地拷贝的不是最新的，最新的可以 git 下载（注意很大），看下面 “在线下载\u0026更新法”。 在线下载\u0026更新法：参考 百问网的《嵌入式Linux应用开发完全手册》里面 第二篇 的 《8.2 使用repo获取内核及工具链等》 里面的 《8.2.2 在线下载》。 配置 Git 邮箱和用户名：git config --global user.email \"user@100ask.com\"、git config --global user.name \"100ask\"。 执行四条命令： git clone https://e.coding.net/codebug8/repo.git mkdir -p 100ask_imx6ull-sdk \u0026\u0026 cd 100ask_imx6ull-sdk ../repo/repo init -u https://gitee.com/weidongshan/manifests.git -b linux-sdk -m imx6ull/100ask_imx6ull_linux4.9.88_release.xml --no-repo-verify ../repo/repo sync -j4 今后可以直接在 100ask_imx6ull-sdk 目录下执行 ../repo/repo sync -c 进行同步更新最新代码！ 推荐在 windows 端 使用 Source Insight 来阅读 Linux 内核源码，详见 百问网的《嵌入式Linux应用开发完全手册》里面 第二篇 的《8.4 使用Source Insight阅读Linux内核源码》。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"获取交叉编译工具链 这里提供三个获取方式。 用开发板厂家提供的 SDK 里的工具链 这里是 百问网的 imx6ull pro 开发板 的 SDK 中的工具链，在 /.../100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin 里面，使用 Vim 工具编辑 ~/.bashrc 文件，在最后添加： export ARCH=arm export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- export PATH=$PATH:/.../100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin 并在终端键入 source ~/.bashrc 使其生效。 然后在终端测试一下 arm-buildroot-linux-gnueabihf-gcc -v。 ARM 官网下载 合适的工具链 ARM GUN-A 官方编译器下载页面： GNU Toolchain | GNU-A Downloads – Arm Developer。下面几个连接是对各个编译器命名的说明，必看。 arm-linux-gnueabihf、aarch64-linux-gnu等ARM交叉编译GCC的区别_Namcodream521的博客-CSDN博客。 转：ARM交叉编译工具链分类说明 arm-linux-gnueabi和arm-linux-gnueabihf 的区别_Beyoungbehappy的博客-CSDN博客。 arm交叉编译器gnueabi、none-eabi、arm-eabi、gnueabihf等的区别 - 涛少\u0026 - 博客园 (cnblogs.com)。 带有 “bare-metal” 的为不支持操作系统的。 总的来说： 经过 Codesourcery 公司基于GCC优化，带有 none 标识的编译器。 ARM GUN-A 官方编译器下载页面 https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads。要下载的编译器要运行在 x86_x64 机器的虚拟机里面的ubuntu 18.04 里面，因此找到 x86_64 Linux hosted cross toolchains 下面的各个编译器版本。 AArch32 target with hard float (arm-none-linux-gnueabihf) —— 可用于交叉编译ARMv7 32位 目标系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。 AArch64 GNU/Linux target (aarch64-none-linux-gnu) —— 可用于交叉编译ARMv8 64位目标中的裸机程序、u-boot、Linux kernel、filesystem和App应用程序。 由 Linaro 公司基于GCC推出。 Linaro Releases 页面 https://releases.linaro.org/components/toolchain/binaries/。 arm-linux-gnueabihf-gcc：可用于交叉编译ARMv7 32位 目标系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。 aarch64-linux-gnu-gcc：可用于交叉编译ARMv8 64位目标中的裸机程序、u-boot、Linux kernel、filesystem和App应用程序。 在 x86_64 Linux hosted cross compilers下面找到 AArch32 target with hard float (arm-none-linux-gnueabihf)（i.mx6ull 为 A7 内核，即为 32 位的 armv7 指令集），并下载；（AArch64 Linux hosted cross compilers下的编译器可以运行在 64位的 嵌入式板子 SoC 的 Linux 上）； 使用 tar xvf 命令解压。 最后，添加环境变量。使用 Vim 工具编辑 ~/.bashrc 文件，在最后添加： export ARCH=arm export CROSS_COMPILE=arm-none-linux-gnueabihf- # 添加名为 CROSS_COMPILE、ARCH 环境变量，写 makefile 用 make 工具编译的时候会用到 export PATH=$PATH:/\u003c交叉编译器工具链的目录\u003e/bin # 交叉编译器工具链的 路径，可以直接在 shell 中 打编译器的名字来 执行编译器 bin 应用 并在终端键入 source ~/.bashrc 使其生效。 然后在终端测试一下 arm-none-linux-gnueabihf-gcc -v。 使用交叉编译工具链编译程序产生 固件/应用 后，通过 “PC 与 嵌入式板 传输文件的方式汇总” 一节提供的方法，传给 嵌入式 linux 开发板，再执行，也许需要添加执行的权限：chmod +x \u003c应用\u003e。 使用 Linaro GCC 编译器 p.s 这里作者没有试验，只是把说明放在这里。 正点原子的文章【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.5.1在 4.3.1.2 小节里说到个别版本能编译通过但是不能运行，多换换版本试试。 到 Linaro Releases 下载适合的编译器，使用方法与上面类似。Linaro 的编译器对应的名字为 arm-linux-gnueabihf-。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"第一个应用 略，略略略~。（在 百问网 imx6ull pro 开发板 页面 中的《2.2 全系列Linux教程：在线视频与配套资料》里面的 \\01_all_series_quickstart\\04_嵌入式Linux应用开发基础知识\\source 里面） ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"第一个驱动 注意： 驱动程序用到 Linux 内核的 API，编译驱动程序之前要先编译内核。 编译驱动时用的内核和嵌入式板子上运行的内核，要一致（不一致的话，不能正常安装 .ko 模块，强装会有意想不到的问题）。 板子使用新编译出来的内核时，板子上原来的其他驱动也要更换为新编译出来的。 编译内核 不同的开发板对应不同的配置文件，配置文件位于内核源码 arch/arm/configs/ 目录。 在 Linux 源码目录里执行： make mrproper make xxx_imx6ull_defconfig make zImage -j4 make dtbs 释义： make mrproper 命令会删除所有的编译生成文件、内核配置文件(.config文件)和各种备份文件，所以几乎只在第一次执行内核编译前才用这条命令。make clean 命令则是用于删除大多数的编译生成文件，但是会保留内核的配置文件 .config，还有足够的编译支持来建立扩展模块。所以你若只想删除前一次编译过程的残留数据，只需执行 make clean 命令。总而言之，make mrproper 删除的范围比 make clean 大，实际上，make mrproper 在具体执行时第一步就是调用 make clean。 得到 内核文件 和 设备树文件 这两个文件： arch/arm/boot/zImage arch/arm/boot/dts/100ask_imx6ull-14x14.dtb 编译内核模块 在 Linux 源码目录里执行： make ARCH=arm CROSS_COMPILE=\u003c选择一个编译器，比如 Linaro 的 arm-linux-gnueabihf-\u003e modules sudo make ARCH=arm INSTALL_MOD_PATH=/home/book/nfs_rootfs modules_install # 编译出的模块 都装存到 /home/book/nfs_rootfs 下，自行更换 释义： 第一条，如果设置好了 ARCH 和 CROSS_COMPILE 环境变量，直接键入 make modules 也可。 第二条命令是把模块安装到 /home/book/nfs_rootfs 目录下备用 ， 会得到 /home/book/nfs_rootfs/lib/modules 目录。 更新目标板 有很多种方式传输文件，详见 “PC 与 嵌入式板 传输文件的方式汇总” 章节。将 zImage 、100ask_imx6ull-14x14.dtb 和 内核模块的 lib 目录 这三者 分别放到嵌入式板子的 /boot 、 /boot 和 /lib 目录，比如使用方便的 nfs 文件系统；然后存储 sync，重启 reboot。 编写、编译驱动 按照驱动程序的编写规则，写好驱动程序（hello_drv.c）和 对其进行编译的 Makefile 文件，以及 相应的 应用程序/测试程序（hello_drv_test.c）。 举例 Makefile 文件（这里面也同时将 测试程序 给编译了）： # 修改为 Linux 内核所在目录 KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4 all: make -C $(KERN_DIR) M=`pwd` modules $(CROSS_COMPILE)gcc -o hello_drv_test hello_drv_test.c # 这里就用到 环境变量 CROSS_COMPILE 了 clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.order rm -f hello_drv_test obj-m += hello_drv.o 确保三个环境变量 ARCH、CROSS_COMPILE 和 PATH（交叉编译器的 /bin 目录）都以就绪。 执行 make 或 make all。产生 驱动程序的内核模块（hello_drv.ko）和 测试程序 ARM 端的二进制可执行文件，共两个文件，转移其到 嵌入式目标板子上。 在嵌入式 Linux 开发板上 安装驱动程序模块 insmod hello_drv.ko。 在 lsmod 命令下可以看到 hello_drv 模块；执行 cat /proc/devices 可以看到 对应的设备及其主设备号；执行 ls -l /dev/\u003c设备名称\u003e 可以看到此设备的主、此设备号等更多信息。 执行测试程序进行验证。 linux内核编译操作 make bzImage # 编译生成压缩的内核二进制文件 make vmlinux # 编译生成二进制内核文件 make modules # 编译生成内核模块 make modules_install # 安装模块 make bzdisk|fdimage|isoimage # 编译生成启动软盘镜像或者光盘镜像 make install # 安装内核文件 make all # 相当于vmlinux+modules+bzImage make rpm # 构建内核rpm包 make foo/bar/foobar.ko # 编译单个驱动 make header_install # 安装内核头文件 make M=some/sub/dir # 编译指定目录 make O=/path/to/some/dir # 指定生成的文件放到该目录 make kernelversion # 输出内核版本信息 make kernelrelease # 输出内核发行标识 make rpm-pkg|deb-pkg|tar-pkg|targz-pkg|tarbz2-pkg # 构建这种格式的内核包 make clean # 清除生成文件（保留.config和部分模块文件） make mrproper # 清除全部文件（包括.config和备份文件） make distclean # 在make mrproper上还清除编辑器其他的备份文件 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:4","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"学至此的一点启示 芯片厂家（大概）应该都会提供完整的 U-boot、 Linux 内核、芯片上硬件资源的驱动程序。 看韦东山的 imx6ull 板子的裸机开发源码，可以得知，启动文件 .s 文件需要看懂，都大同小异，然后官网会提供所有寄存器的 .h 文件及其结构体，然后每个外设似乎还会提供初始化、配置的代码（因为韦的源码里面，外设底层配置代码为英文注释的，99%的概率是官方提供的），这样就好了嘛，外设的底层驱动可以都扒官方例程。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:5","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"构建系统简约步骤 这里只简约说明编译步骤，并非详细使用说明（以后的系列文章可能会有）。 每个部分单独手动简约步骤 以下工作进行前，先配置好环境变量和开发链工具等工作，详见 “准备交叉编译工具链” 章节。 1、编译 u-boot，配置文件位于 u-boot 源码的 configs/ 目录，生成 u-boot 启动镜像 u-boot-dtb.imx。在 Uboot 目录下执行： make distclean make mx6ull_14x14_evk_defconfig make 2、编译内核，配置文件位于内核源码 arch/arm/configs/ 目录，生成 arch/arm/boot/zImage 内核文件 和 arch/arm/boot/dts/xxx_imx6ull-14x14.dtb 设备树文件。在 Linux 内核目录下执行： Linux-4.9.88$ make mrproper Linux-4.9.88$ make xxx_imx6ull_defconfig Linux-4.9.88$ make zImage -j4 Linux-4.9.88$ make dtbs 3、编译内核模块，并把模块文件导入 /home/book/nfs_rootfs/lib/modules 目录。在 Linux 内核目录下执行： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules sudo make ARCH=arm INSTALL_MOD_PATH=/home/book/nfs_rootfs modules_install 使用 Buildroot 构建系统简约步骤 Linux 平台上有许多开源的嵌入式 linux 系统构建框架，这些框架极大的方便了开发者进行嵌入式系统的定制化构建，目前比较常见的有 OpenWrt, Buildroot, Yocto 等等。其中 Buildroot 功能强大，使用简单，而且采用了类似于 linux kernel 的配置和编译框架。 制作根文件系统方法比较： Busybox。Busybox 本身包含了很了 Linux 命令，但是要编译其他程序的话需要手工下载、编译，如果它需要某些依赖库，你还需要手工下载、编译这些依赖库。如果想做一个极简的文件系统，可以使用 Busybox 手工制作。 Buildroot。它是一个自动化程序很高的系统，可以在里面配置、编译内核，配置编译 u-boot、配置编译根文件系统。在编译某些APP时，它会自动去下载源码、下载它的依赖库，自动编译这些程序。Buildroot 的语法跟一般的 Makefile 语法类似，很容易掌握。 Yocto。NXP、 ST 等公司的官方开发包是使用 Yocto，Yocto 语法复杂，容量大（10GB 以上），编译时间长。 Buildroot 是一组 Makefile 和补丁，可简化并自动化地为嵌入式系统构建完整的、可启动的 Linux 环境（包括 bootloader、 Linux 内核、包含各种 APP 的文件系统）。 Buildroot 运行于 Linux 平台，可以使用交叉编译工具为多个目标板构建嵌入式 Linux 平台。 Buildroot 可以自动构建所需的交叉编译工具链，创建根文件系统，编译 Linux 内核映像，并生成引导加载程序用于目标嵌入式系统，或者它可以执行这些步骤的任何独立组合。例如，可以单独使用已安装的交叉编译工具链，而 Buildroot 仅创建根文件系统。 学习更多关于 Buildroot 知识请参考这里。 扩展学习： buildroot 下进入 menuconfig 包选择配置配置界面 make menuconfig。 buildroot 下单独编译 u-boot make uboot-rebuild。 buildroot 下进入内核 make menuconfig 配置选项界面 make linux-menuconfig。 buildroot 下单独编译某个软件包 make \u003cpkg\u003e-rebuild。 buildroot 下进入 busybox 配置界面 make busybox-menuconfig。 buildroot 下生成系统 sdk，最后生成的目录在 output/images/ 目录下 make sdk。 构建根文件系统： 在 Buildroot 目录下执行： make clean make xxx_imx6ull_defconfig make all 漫长长长（2~6个小时，视电脑性能）的等待后编译完成。 可以配置多个不同的配置文件 xxx_imx6ull_defconfig，比如有的带 qt5 ，有的用于构建最精简的文件系统，有的用于另一块板子等待。 编译成功后文件输出路径为 output/images： buildroot 20xx.xx ├── output ├── images ├── xxx_imx6ull-14x14.dtb \u003c--设备树文件 ├── rootfs.ext2 \u003c--ext2 格式根文件系统 ├── rootfs.ext4 -\u003e rootfs.ext2 \u003c--ext2 格式根文件系统 ├── rootfs.tar ├── rootfs.tar.bz2 \u003c--打包并压缩的根文件系统，用于 NFSROOT 启动 ├── sdcard.img \u003c--完整的 SD 卡系统镜像 ├── u-boot-dtb.imx \u003c--u-boot 镜像 └── zImage \u003c--内核镜像 对应的文件更新到嵌入式板子的对应位置，或者使用 sdcard.img 或者 emmc.img 完整系统映像文件烧入 sd卡 或 emmc。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:6","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"PC 与 嵌入式板 传输文件的方式汇总（日常补充） ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:0","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"网络传输：ETH/WiFi 通过网络的方式来进行 登陆/操作/传递文件等 为最常用的。SSH、NFS、tftp SSH 使用 MobaXterm 或 FileZilla 等等，通过 SSH 连接 Linux 板，进行文件传输（可以使用拖拽上传）。比较基础，具体方法略。 NFS NFS 将服务端的文件系统目录树映射到客户端，而在客户端访问该目录树与访问本地文件系统没有任何差别。 在 Ubuntu 中安装、配置 NFS 确保安装：sudo apt-get install nfs-kernel-server。 设定目录，例如允许开发板通过 NFS 访问 Ubuntu 的 /home/book 目录，则在 /etc/exports 文件中添加以下内容： /home/book/ *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 重启 NFS 服务：sudo service nfs-kernel-server restart。 可以在 Ubuntu 上通过 NFS 挂载自己，验证一下 NFS 可用： sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/book /mnt ls /mnt NFS 使用 如果你使用的是 VMware NAT 方式，假设 Windows IP 为192.168.1.100，在嵌入式 Linux 板子上执行以下命令(注意：必须指定 port 为2049、 mountport 为9999)： mount -t nfs -o nolock,vers=3,port=2049,mountport=9999 192.168.1.100:/home/book/nfs_rootfs /mnt 如果你使用的是 VMware 桥接方式，假设 Ubuntu IP 为192.168.1.100，确保 嵌入式 Linux 板子 能 ping 通 ubuntu 后，在嵌入式 Linux 板子上执行以下命令： mount -t nfs -o nolock,vers=3 192.168.1.100:/home/book/nfs_rootfs /mnt mount 成功之后 ， 嵌入式 Linux 板子在 /mnt 目录下读写文件时， 实际上访问的就是 Ubuntu 中的 /home/book/nfs_rootfs 目录，可以在 Ubuntu 上把文件放到 /home/book/nfs_rootfs 目录中，在开发板上可以从 /mnt 目录中访问该文件。所以嵌入式 Linux 板子和 Ubuntu 之间通过 NFS 可以很方便地共享文件。 tftp 在 Ubuntu 启动 TFTP 服务，开发板通过 tftp 命令和 Ubuntu 互传文件。 在 Windows 启动 TFTP 服务，开发板通过 tftp 命令和 Windows 互传文件。 Ubuntu 安装 TFTP 服务 确保·安装：sudo apt-get install tftp-hpa tftpd-hpa。 创建 TFTP 服务器工作目录，并打开 TFTP 服务配置文件，如下： mkdir -p /home/book/tftpboot sudo chmod 777 /home/book/tftpboot sudo vim /etc/default/tftpd-hpa 在配置文件/etc/default/tftpd-hpa中，添加以下字段： TFTP_DIRECTORY=\"/home/book/tftpboot\" TFTP_OPTIONS=\"-l -c -s\" 重启 TFTP 服务：sudo service tftpd-hpa restart。 查看 TFTP 服务是否在运行：ps -aux | grep “tftp”。 在 Windows 安装 TFTP 服务 可用时再看（百问网的《嵌入式Linux应用开发完全手册》的 7.4.3 在Windows安装TFTP服务 一节、7.6.2 开发板通过tftp传输Ubuntu文件 一节）。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:1","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"USB 传输 最 低效 的方法 U 盘拷贝。 NXP 公司给 IMX6ULL 提供了烧写工具： mfgtools。或者对于 imx6ull 使用 100ask 开发的 100ask_imx6ull_flashing_tool（详看 百问网的《嵌入式Linux应用开发完全手册》）。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:2","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【主线剧情】Linux 系列"],"content":"串口传输：rz/sz 命令 在 “工地” 现场上 网口、USB 口 统统没有，那我们还可以使用串口。 这里使用的上位机是 MobaXterm，要先设置 MobaXterm 取消 “右击粘贴”，这样鼠标右击的时候才会出现菜单。 注意：串口传输非常非常的慢，KB 级别的文件还可以，MB 级别的传输十分漫长（十几分钟到一个小时），优先用网络吧。 注意： rz/sz 命令不稳定，不可靠，在没有其他办法的情况下再用它。 rz/sz 命令传输速率太小，适合传输小文件，不适合大文件。 上位机往板子发：rz 在 MobaXterm 里面通过串口连接并登录 嵌入式 Linux 板子，然后输入 rz 命令，此时终端会提示等待接收，此时在 MobaXterm 里面鼠标右键会弹出一个选择框，点击 Send file using Z-modem 来选择要传输文件。 板子往上位机发：sz 嵌入式 Linux 板子启动进入 Linux 后，在串口中执行命令 sz \u003c要发送的文件\u003e，然后按住 shift 键的同时，用鼠标右键点击串口界面，选择 Receive file using Z-modem，最后在弹出的文件框保存文件。 ","date":"2021-04-05","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:3","tags":["ARM","Linux"],"title":"【主线剧情02】ARM Linux 基础学习记录","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8502-arm-linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["【规范】系列"],"content":"软硬件规范化的伟大意义和远景","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"软硬件规范化（norm-of-software-and-hardware） ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:0:0","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"意义 不多言语，直接引用观视频工作室视频【大师计划·林宝军03】北斗三号总师：我来跟你说说，…里面总师受访时所说的话： 5:48：“…所以我经常讲，要把一个产品做好，其实有三方面，一个是技术，一个是质量，一个是管理，这三方面；技术水平，质量保障能力和管理能力，三条腿哪个都少不了，少一个，这个东西（航天）也做不上去，其实技术只是一方面，…” 6:44：“…光是技术上去了，不见得能做出一个系统。对我们工程来讲，就是（需要）规范的文化，什么意思呢，比如我们几十年的航天经验，我把这个经验总结成文字，总结成规范，不管是谁做，只要有一定的经验，按这个规范做出来，做得卫星出来，打到天上去就能好用，这就是规范文化。包括匠人文化和规范文化，最后都是按规矩去做，它强调的是解决了怎么做的问题，但它有一个缺点，没强调为什么，其实我认为在做的过程中，加个为什么可能更好。” 规范在实用层面的意义： 编程框架固定； 标准组件重用； 注重应用开发； 快速且不易出错； 易于问题定位； 快速提高项目组水平。 在网上规范文章随处有的情况下，我为什么还要自己总结规范？因为每一个文章都不会是全的，就这么简单，我吸收、整理和合并它们，成为更全的，并在我以后自己的项目中遵守这些规范，实现更好的阅读性、操作性、解耦性、分层次性、模块化等，集百家之长，此乃瞰百易之精髓之一。 还有一件事，根据脑科学的一些研究结果，大脑中的记忆，尤其是以前发生的事情的细节，是会发生改动的，而细节的偏差会影响大局的择决；就从日常生活经验也能感觉出，这个结论有一定真实性，所以，把几乎所有的细节都放到大脑里是非常不靠谱的事。 有的人因为看见所以相信，而有的人，因为相信所以看见，我想，后者更具有价值和希望。 “我一直认为，人类历史上最伟大最美妙的故事是通过科学讲出来的。科学所讲的故事，其宏伟壮丽、曲折幽深、惊悚诡异、恐怖神秘，甚全多愁善感，都远远超出文学故事。” ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:1:0","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"学习路径 本科阶段的嵌入式和计算机科学两个大方向的 短小精悍 的总结，在自己本科的实验室推广，效果拔群。 若要走嵌入式方向，尤其是嵌入式软件方向，“嵌入式方向-本科学习路线.docx” 文件中所描述的东西尽量在大三或毕业前全部熟悉一遍（FPGA部分为可选）；若要走计算机软件方向，“计算机科学-软件方向-本科学习路线.docx” 文件描述了推荐的基础和进阶部分的方向，应当广泛熟悉和学习。 若以才华待年华，匆匆岁月无足惜。 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:2:0","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"实践 经验之谈。 要高效的成体系收纳和运用，就要按照正确的学习路径和方法（可以参考 我的回答 和 文章 或 这个回答（人的一生到底该追求什么？） 找找启发）。目前以及将来一段时间 网上会 充斥着满屏口水话、抒情、矫情、写心情日记风格的 所谓的 经验贴 和 教程文章，还有无可救药的 碎片化 和 相互 “借鉴” 的 问题，不成系统，看多了会变得不幸，少看！看什么：正儿八经的 将 本科 高数、电路上下册、数/模电、自动控制原理、计算机系统 等等 相关的课本 从第一页一页一页地看到最后一页！依照 研究/做事 的领域，看经典或者全面的成系统的 文章 或 书籍（成系统的网络文章、大厂官网的教程手册、经典书籍都可以，一定要坚持），看书先看目录（有个大概认识和学习规划），做好整理和在脑海中形成节点与节点之间连线的网络，学新东西就像新入节点连接到已有的网络！到达前沿 则 多看论文。 开拓一个新领域，在找资料的阶段，可以去淘宝、咸鱼和拼多多等寻找资料，有时会碰到 很全的/整理好的，甚至瞬间解决大部分问题。 进军一个新领域，先找相关行业的\"行业分析报告\"。在哪里能找到各行业的分析研究报告？。 项目组在开始一个全新的项目时，应尽量由经验多、规范意识好、能力最强的一些人谋划和开篇这个新项目，做的尽量高内聚、低耦合、可重用、注解全，并且日后易于维护和增改，如果能配上详细的手册就太好了，大家都喜闻乐见。相反的情况就是让初入茅庐的人建立地基，结果就是一地鸡毛、一团乱麻，搞的大家都不舒畅。 开始一个全新的项目时，应首先 全！网！ 收集相关资料、文献和参考设计；例如笔者在筹备 BLDC 原理图时，就全网收集了数十张原理图方案；经过交叉横向对比后，快速形成考虑比较多的、功能齐全的和子系统优选的更新进的方案出来。 许多问题应在设计时避免，除了吃透各种官方文档，还要多找一些 相同/类似 的设计进行横向对比，找它们的不同之处并搞清原因；还要考虑增加安全性的设计（防错、纠错和相应的处理，对用户的 傻瓜化操作设计 和 防傻防呆设计（防止乱用错用））、冗余性设计（多路冗余）和可调试性设计（留有可以调试和改动的余地）。 关于软、硬件的模块化，在上面《规范》文章中说到了一些，除了 “增加通用性” 并且使方案可模块化的 “拆解” 和 “拼装”，在此基础上还应考虑 “故障点隔离”，故障的节点（软件或者硬件）做相应处理，失效的节点做隔离/孤立处理，这个往往需要软硬件协调的设计。 … ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:3:0","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"内容 以下链接中，括号内的为 知乎 和 CSDN 文章地址，其他链接为 GitHub 仓库地址。 软件框架，规范化。 关于 C \u0026 MCU 的规范（C \u0026 MCU编写规范和其他、【规范】万字集大成的C编写规范_瞰百-CSDN博客）（“低耦合，可重用，参数化，注释全”）。 关于 HDL \u0026 FPGA 的学习和规范（FPGA \u0026 HDL 学习和规范、【规范】万字集大成的HDL\u0026FPGA学习和规范_瞰百-CSDN博客）。 MCU Framework 项目。 IMU 选型和算法。 Awesome-K210。 开源协议汇总和选择。 Awesome-Embeded-AI。 ARM-Linux-Study。 硬件模块，规范化。 硬件规范（SCH \u0026 PCB 设计规范和 AD 的使用、【规范】万字集大成的SCH\u0026PCB设计规范和AD的使用_瞰百-CSDN博客）。 开源开关电源项目 （【开源电源】巧克力板、【开源项目】叠buff电源板-巧克力板_瞰百-CSDN博客）。 开源 BLDC FOC 项目（更新会超级慢）。 硬件保护项和措施。 硬件测试的指标条目、每个项目的测试步骤和测试报告，规范化。请戳这里（暂无）。 这些是我本科阶段触及的一部分（不是所有，本科玩的东西真多…字面意义的玩，不深入）领域及其顺延的小总结。下一篇就是硕士阶段的触及领域及其顺延的大总结了，内容定将极其多。 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:4:0","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"远景 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:5:0","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"关于软硬件标准化 这是 ZLG致远电子 在2018年的一篇肺腑文章。 开发者的最大问题是核心域和非核心域不分，大部分时间都在编写不可重用的非核心域的代码。没有聚焦提升产品竞争力的核心域知识，比如，需求、算法、用户体验和软件工程方法等方面，从而导致代码维护的成本远远大于初期的开发投入。 事实上，那些做出优秀产品的团队，不仅员工队伍非常稳定，而且收入也很高，甚至连精神面貌都不一样。因为他们使用了正确的开发策略和方法，而且短时间内掌握的技术远胜于那些所谓的“老程序员”。虽然每个企业都有拿高薪的员工，但为何不是你？别人开发的产品大卖，而你开发的产品却卖不掉？不仅浪费了来之不易的资金，而且导致我们失去了更多的创造更大价值的机会。 十几年前，作者也面临同样的问题，于是毫不犹豫地投身于软硬件标准化平台技术的开发，因为只有方法的突破才能开创未来。AWorks就是在这样的背景下诞生的，定义了外围器件的软件接口标准，“按需定制”为用户提供有价值的服务也就成为了现实。 基于此，ZLG为用户提供了大量标准的外设驱动与相关的协议组件，意在建立完整的生态系统。无论你选择什么MCU，只要支持AWorks，都可实现“一次编程、终生使用”，其好处是你再也不要重新发明轮子。 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:5:1","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"框图\u003c—\u003e仿真\u003c—\u003e实物 规范化的下一步，是包括软硬件的模块固定化，标准化设计资料（模块、内部结构和接口等标准化），往后的开发专注于框图设计和模块连接，用软件工具从框图直接生成代码，部署到硬件，这是早就开始的（2、30年前）时代趋势。所以巩固基础，按照规范，多做原创性设计，或者就个人而言，整条链路上下打通，做各个环节的细节和全环节的掌握。 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:5:2","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"设计工具 了解到，遇到新问题或新科研，看最新论文动向、行业报告等，收集需求和思考痛点，先进的科研往往先设计工具，或者备好工具和生产资料，再用工具做应用；而大多的企事业和科研单位，往往是在做应用。 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:5:3","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["【规范】系列"],"content":"基于模型的设计研发 以下图片的出处 传统研发如下图概括。 新理念（早已经不新了）如下图，基于模型的设计研发（Model-Based Design Process）。 这个基于模型的设计研发根据 “需求 \u0026 设计文件” 构建全模拟系统（包括控制、嵌入式、机械和电力电子等），相当于对未来的实物先构建一个 “数字孪生”，在模拟环境中看现象、定参数和找问题等，在 Matlab 中可以更多的做到 从模型生成设计文件、从设计文件生成模型、生成 C 代码，可视化物理仿真等等。 启发： 一个被控对象的非线性模型，先线性化得到一个 LTI 线性时不变模型（状态方程或传递函数），用传统控制理论中的方法（根轨迹、伯德图校正等）得到一组控制器的具体参数（如 PID），并留有较多的相位、幅度裕量，然后再把这些参数带入到非线性模块所在环路的控制器里面再仿真模拟；若裕度不够，则在非线性模型的仿真中会性能显著降低甚至不稳定。 控制系统仿真模拟时： 要么模型建的非常精准； 要么控制器的兼容性、容错性、鲁棒性等很强。 自动生成报表，自动测试。可以自己写一些自动化工具软件替代重复性工作，多做通用性工作。 ","date":"2021-03-26","objectID":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/:5:4","tags":["规范"],"title":"【目录贴】总览软硬件规范化的意义和内容","uri":"/%E6%80%BB%E8%A7%88%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%86%85%E5%AE%B9/"},{"categories":["人与世人的关系"],"content":"科幻小说《请留在未来》的注解篇","date":"2020-06-17","objectID":"/2%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/","tags":["科幻小说"],"title":"科幻小说《请留在未来》注解篇","uri":"/2%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/"},{"categories":["人与世人的关系"],"content":"小说发在 Github、知乎、BiliBili。 1、 冰冻三尺，非一蹴而就。既然要写，就写好，计划中，首先设计世界观和大背景，围绕我要表达的思想构思故事内核和主线，再填充对话和动作，最后在写的时候，站在第三视角叙事，站在第二视角交互，站在第一视角思考。 2、 关于文章的标题，在成文期间左右不能确定，可选择的有《未来往事》、《对话》、《灿烂的曙光》、《我和黄昏喝醉之前的故事》和最后想的《请留在未来（中标）》，每一个都有自己的视角和立意，经历这次，深知一千个读者有一千个读法。第一个标题让文章偏向科幻，发生在未来的往事？有点意思，另外也是在致敬《回到未来》；第二个标题重点表明此文包含大量对话，情节都在对话中展开；第三个标题表达一种期许，未来不一定都是灾难与不安，它也很可能是“灿烂的曙光”，文章写的也正是如此；第四个标题偏向两个人的感情，夏叶走之后，大潭看着金色的黄昏发呆，喝醉后打开记录仪开始记录这个黄昏之前所发生的种种事情，让这篇洒洒两万字的文章最后就变成一狗粮？第五个标题最后想出，也是中标的，也是很想表达的一种“正道的光”，就是心要有远景，年轻人，要看得长远，要留在未来！ 3、 我的创新观。很多人都说过到底何为创新，怎么做就算创新了，我就说点不一样的，具体的，可操作的，个人愚见。那就是贯穿全文的“二项玻”定则，你可以按照这个定则来想新的事物，比“TRIZ理论”简明，即“组合有意义的组合”和“简化能够之简化”。 4、 “一天晚上，夏叶吃过晚饭，戴上耳机听几首歌，一首流行英文乐，一首中文情歌，再出去压马路转一转，到公园稍微活动一下，同时还听着一首摇滚，一首民谣，一首说唱，一首future bass风格的电音，一首Vocaloid，一首日系轻音乐和一首交响乐，回到家，刷了几下朋友圈，聊一聊，对明天的日程做一个规划，查一下长期任务的完成情况，再洗漱完毕，便关灯睡去”，这一段明显罗列了好多种音乐，暗示之后出现的大潭的好友华和洁的多元身份“搞科研和私家侦探”，以及玻柏的“认知学家、计算机学者和DJ”，即有更多的“斜杠青年”，文中也有对这一现象的描述“现在又好像一千年前达芬奇时代那样，一些人掌握学科的门类相当广泛”，这也是因为文章的大背景，AI辅助学习和认知，几乎绝大部分知识的学习没有了壁垒，教育不均甚至学校教育都将消失，知识能力不再是造成人之间鸿沟的主要原因，在这种状况下自然推演，科研变成了文中所描述的“才艺”，一人能够感兴趣和深耕的领域变得多元。 5、 文中开头夏叶读的书，关于“圆周率包含了所有可能的数字排列”这一论点是本科幻小说的假设，因为目前尚未证明。 6、 文中的“精句”，已作标出。 7、 文中的注释符号如“①”等，均出自一本叫《平行地球漫游指南》的书，它描述了关于在平行地球漫游你想知道的一切，你买不到因为这本书只在平行地球发售。这个设置是致敬《银河系漫游指南》中的《指南》，其背后因写着大大的“Don’t panic！”而非常畅销，本文多处出现的“42”也在致敬于此。 8、 对于大潭弄来42克钯元素过程的详细描述，在真实世界也可能发生。 9、 “电脑AI温馨的提醒着“一会要有光，小心眩光”，在机器的容器内渐渐有了光”，这里是在模仿“上帝说，要有光，于是，就有了光”，有从无到有的意味，但是万物的原理还是要相信科学，一个高科技的高阶AI智慧说出这种话，也在反讽过度解读圣经的愚昧吧。 10、 “天呐，我是在科幻小说里吗？”夏叶惊呼。“不，因为这里没有宇宙飞船、全息投影和机器人！呃…科幻作品里面不都得有宇宙飞船、全息投影和机器人这‘老三样’吗”，这一段啊，这一段是在一个科幻作品里把其他科幻作品的套路揭底，本文虽然描述未来世界，但确实没有出现这三样。还有后面的大潭对夏叶解构科幻作品，同理。 11、 文中仿写了一段SCP故事，是一个永远也不会让人通过的面试官。这篇文章中某些内容写的很早，SCP这一段就是2019年面试被拒后写的，在这之前所有人都说我的能力足够通过那个面试，当时真的真的很难。 12、 文中“施教授与一位国外科学家聊天”这一片段的前两段出自施一公演讲，第三段为本文增加的后续对话。 13、 “国外的杂志《竹叶刀》”，对标真实世界的《柳叶刀》。 14、 “有的人讲人机共处的社会没有民主和自由”，“研发出了一种化学试剂，当作疫苗一样注射，可以消除人们的种族主义心理”，“他们强烈反对与AI人共同生活的人机共处，却用着AI发明的科技悠哉生活”，结合魔幻现实，你细品。 15、 文章最后以AI为主要视角续想第四次工业革命之后的两次科技革命的形态，一般来说，第四次工业革命的突破口在哪里，是什么形态都很难想象，更不要说其后的两次科技革命是什么样子，但想象嘛，可以讲出来。内容不一定准确，但提出一个观点，不论科技再怎么先进，人认知的方式和深度决定着发展的上限，如果这个上限突破了，科技发展等就像文中描述的一样潜力无穷了。就控制科学的角度说，控制算法再先进也是无限逼近被控对象的能力上限，想办法改进被控对象自身才会提升这个上限。 16、 文章故事发生在第六次科技革命伊始，夏叶走后，大潭进入休眠等待夏叶回来。但是（转折），文章注释⑧中说，由于那时的科技进步飞快，就是上面所说的“上限”被突破，使得历史进程急速加快，平行地球随即进入隐匿状态，外人无法观测、无法理解和无法叙述，也即是说，大潭和他所在的平行地球“消失”了，夏叶应该永远回不来了，对于他们二人，这真是个悲伤的故事。 2021.1更新 17、 我后来注意到，关于核聚变实现后现实世界的改变的一些想象在《三体2》中有竟大部分雷同，以及x米公司实现了与大刘描述的很像的初步的“隔空充电”；我得在这澄清一下，在行文期间我还没读到《三体2》；我一贯主张行走在想新的事物这条路上，平时连重复的“梗”都很少玩（但是一玩大家就欢快起来，就像触发器一样）；与大刘在“核聚变实现后的世界”这方面的想象有所重合我又惊又喜。 2021.9 更新 18、正文大幅修改，为投稿补充更多细节内容，修正一些Bugs使文章更合理，将结局修改为开放结局版本。版本为 v1.0。 19、半补全结局，版本为 v2.0。 20、平行地球简史攻略图 “别担心，我们地球的光会到达遥远的星系，在每个太阳系中，我们都重生，所以我们会永远在一起。”————格卢什科夫 ","date":"2020-06-17","objectID":"/2%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/:0:0","tags":["科幻小说"],"title":"科幻小说《请留在未来》注解篇","uri":"/2%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5-%E6%B3%A8%E8%A7%A3%E7%AF%87/"},{"categories":["人与世人的关系"],"content":"只剩结论的故事便是短句合集啊~","date":"2019-10-15","objectID":"/2.5%E5%8F%AA%E5%89%A9%E7%BB%93%E8%AE%BA%E7%9A%84%E6%95%85%E4%BA%8B%E4%BE%BF%E6%98%AF%E7%9F%AD%E5%8F%A5%E5%90%88%E9%9B%86/","tags":["杂谈"],"title":"只剩结论的故事便是短句合集","uri":"/2.5%E5%8F%AA%E5%89%A9%E7%BB%93%E8%AE%BA%E7%9A%84%E6%95%85%E4%BA%8B%E4%BE%BF%E6%98%AF%E7%9F%AD%E5%8F%A5%E5%90%88%E9%9B%86/"},{"categories":["人与世人的关系"],"content":"只剩结论的故事便是短句合集 前言：我有两个有关总结自己社交账号发的情绪化或理性化的随笔、想法，一个是给我自己也希望帮助到别人——《只剩结论的故事便是短句合集》，另一个是给别人也希望帮助到自己——《批判与扶正歪气》。（P.S 主要收集自 知乎，Qzone、微博和微信朋友圈没有加入到这里，也有不少好的短句） 长期更新，始于2019… 于外“高调做事，低调做人”，于己“明修栈道，暗度陈仓”。 不要揪着一个人的弱项不放，弱项不能评价一个人，每个人都有高光时刻；但是每个人的选择能力高低不同。 结构化一切知识，清单化一切事务。 说话有重点，前后有逻辑。 尽量关闭对周围搞负能量的人或事情的视听。 广开言路，不惧陌生；积累越多，成功率越高。 想到前头，做到前头。 有趣的人不一定是会玩梗和说笑话，应是脑洞大开，知书达理，看书行文，写诗写歌，能够在必要时生动有趣的提供可靠观点。 在做了很多事，见了很多人，聊了很多话之后，会对这句话更加信仰：从想做的那一刻起，事情已经成功了一半。选择的路，要谨慎，要对得起其过程的苦难挫折。 人在生气、绝望等情况下脾气会有波动，但远离那些波动最大的。人在处理各种事情时的表现，是人最好的试金石。 任何事务都有底层逻辑，任何学科都有一大票知识点。一个高效的学习方法是，广泛搜集相关课题，在其错综复杂中尽快总结出其底层逻辑，之后将各个知识点看作主干逻辑树上的分支，即结构化知识，然后选择一个综合性和难度比较大的课题去踏踏实实实践至少一遍。“底层逻辑”是章法，可以以不变应万变；“综合性课题”是理性的以较少作业量掌握大部分知识点的途径，“实践”是加强感性认识和牢固记忆。 使人对一个事物感兴趣的原因，可能是找到了这件事物的意义。意义这个东西虽然在不同人那里因为见识和理解而不同，但是找到意义很大概率上就会导致对事情感上兴趣，感兴趣就会想做，再配合上文的第九条一起食用。为什么说是可能，我目前是这么认为的。 你要定计划，可以定短期计划和长期计划。长期计划是这段时间的大方向，短期计划是具体到每一天该干什么。你有一大堆的事要做，可以由主要矛盾和次要矛盾决定顺序。 高级的：说话是每一词都用的准确，每一句都言出必行；聆听是别人的一字一句都听清楚，一眼一眉都看清楚。用词准确的意思是说，在诸如“培养”和“供养”区分上的准确使用。 只要年轻人独立后能成龙成凤，就不多管无论中间是走着爬着跑着玩着过去的（在正当途径上），长辈多在包容、尊重的基础上沟通。 因为一点看不惯的小事，就大做文章吵吵闹闹，次数多了就是难修复的真伤，内耗太傻。 直男“四连”：不知好意，不会照顾，不懂赞美，不顾氛围。 互相信任和理解能够省去琐碎的善意谎言，让更多的交谈变得更加真诚。 当周围很多人期待、看好你时，不要有压力，他们说笑而已；当周围人不信任、不理会你时，不要有压抑，他们看不见你的发光时刻而已，让时间证明一切。 个人见解，三个思维活跃的标志:①自己能给门外汉讲清楚复杂的机理；②自己敢于面对和操作不熟悉、相对困难或者陌生的领域；③自己能够产生新经验或新知识。人也许能把经验和结论全部背下来，但是思维不一定活跃，思维活跃科研导致很多不一样的作为，没有绝对靠谱的预先式评判选拔标准，但作为可以。 —————— 续1： 与其说自信的识人能力失效或者看不穿猜不透，不如说仅仅是缺少有效的高强度对话；沟通的少，信息都不全，能识别啥可确信的或者有价值的，尽搁那自觉或不自觉的瞎猜，还觉得挺能说服自己，我xx（划掉）。 有一点种族主义倾向（拳师也算）的和思想容易走极端的（比如听见一个人说了一句逆耳的话就认为那个人的一类人都是这样等等）重合度至少一半以上，而且其中相交的部分里可能还有一多半自己觉得很正常没什么问题。包容、辩证的看待问题很重要。（2020.9.27 想法） —————— 续2： 之前回答的一个问题“学习能够得到什么？”：建设祖国的崇高荣耀，早日实现财务自由的重要途径，一种喜悦内心的兴趣爱好，杜绝千篇一律，过灵魂内涵丰富的生活。（2020-10-07 想法） 博物馆三规律： 1、博物馆的大门开放，没有藏着掖着的； 2、99.9%的来客都不敢说自己很了解整个博物馆； 3、博物馆的地下室或者不起眼的角落总会藏着各种秘密。 所以作为博物馆管理员会保持着开放、谦逊和神秘。（编完了，懂的都懂）（2020-10-08 想法） （这里消失了，转移到 【杂谈】师之传达 文章里了） 注意观察，当接近理想的速度低迷时，人的反映各有不同，特别好玩。有的理直气壮：“爷就是废物”；有的波澜不惊：“冷静分析，韬光养晦”；有的激情澎湃：“干就完了老铁们”；有的则：“嘻嘻哈哈，没有头脑”；有的则：“顺其自然，平平淡淡”；有的则：“及时行乐，人生要义”。人的经历不同，相信的不同，立场各不同，不同的人时常互吵，这就是多元。我还没很复杂。（2021-02-15 想法） 人生的剧本该怎样编写，主线剧情该如何推演。 我们是应该先构造大纲，然后丰富细节，还是大纲随遇而安，主要构造生活的点滴。 后者，推到极端，那就是，永远感性，永远随遇而安，永远随风飘摇，永远没有方向。 对待这种，以后要多回答：“我不知道，你不需要知道”，继续惯着（气）。 没有方向，也许就会搞错潜意识所想，也许就会搞错对别人的判断，我不清楚，可能是因为我觉得我始终有方向。 每个人都对，在各自的角度，看到世界的不同侧面。 同样的话语，有的人觉得功利，有的人同时也看出其中有许多故事和乐趣。 我希望的世界，本来，就好像我曾说的“过着不同的生活，却描述着共同的画面”。 少年心中会埋下的种子，天真，用善良和希望去揣测世人。这才是归来仍是少年，但不一样的是，那时的心中种子，归来的胸有建树。（2021.4.8） 在初中的时候，必要遵守的一点是先写完作业然后玩。 完成作业有三种模式： 1 先写完再玩；2 一边写一边玩（写完了时间也快没了）；3 先玩后补。 如果把这三种状况扩展到人生的长度，那么就是三种人生观，也可以叫三类人： 1 先努力，尽早实现，然后余下皆自由；2 学一点，干一点，然后玩玩玩，再循环，充满一辈子；3 先玩后补。 坑挖好了，你跳哪个？（2021.3.14） 我想以后我要只做组织设计、项目管理、看行业报告、画方案框图和规划技术路线等事（如果能够的话），而不必去做具体的实现，后者在深入了解之后大抵只是消耗时间去搬砖而没什么难度罢了，画饼什么的才最快乐了；遇到一个人，如果能够举一反十、抛砖引玉、风暴般的摄入，那么做大框架设计或者往无人区前进会更合适。（2021.4.25） （日常瞎想）关于四象限图的实用性 （日常瞎想)关于四象限图的实用性2.0 迷茫，虽然这事学校基本没教过真正怎么有效的破解，但何必搞这么难呢，多尝试，多思考，多行动，就更多得到成功的喜悦，最顺手的那个，便是。 往往，我们会把简单的事搞复杂，复杂的事搞不了，其实在于不上道，在于努力没有效，不要总抗拒，难能可贵的是保持好奇，一个善于好奇的人不会迷茫。 往往，生活会待你如泥潭，社会会待你如杂质，人际会待你如透明；焦虑不可怕，要和自己比，每一天，填补一点未知，提高一点已知。（2021-06-06） 人生终极问题“明天中午吃点啥”，换个角度去说可以是“如何做好当下”。作为人间观测者，我曾预测对过多个身旁的事。大部分人都可以看到和获取的东西早晚贬值，那些高价值的原初物，人们会自觉的保持它们的神秘。（2021-06-24） 《乱语胡言》这本书就是喜欢满嘴开炮：“浅显的思维为浅显的事服务，深刻的思维为深刻的事服务。只能识别浅显所以习惯浅显，能够识别深刻所以喜欢深刻。”（20210-08-04）（注：“《乱语胡言》”来自我写的科幻小说《请留在未来》里面） 无知、暂时不会和不关心是三回事，不要把不关心当做不会，也不要把暂时的不会当做无知。（2021-08-09） 复杂系统构建可以用此法集约人力：一务一权，群策群力。一务是用一张清单约定每个人的事务和时间表，一权是用另一张清单罗列可能出现的意外情况和应对方案，下放权力让负责人根据收集的信息和能力范围自主做最佳决定并讲好理由，群策群力就是喜闻乐见的开会集中解决这段时间积累的各种棘手的问题，解决方案要得到每个专家充分考虑和认可并签字。上层把工作重点放在设定目标、监视进度和保持联络。读《清单革命》。（2021-09-02） 信噪比极低的信息的流动和被动地信息不对称带来了一半儿的凑合事儿和低效，另一半是形式主义。很多事情的设计初衷是好的，但好的方面也只能说到这罢了。 所以说信噪比极高、参考价值极高的事物才是值钱的，可别迷了眼睛。（2021-10-22） 应该还有太多的人认为科技是如同魔法一样的陌生而遥远，某种意义上没有错，科技就是人类的魔法，但是我们应该认为我们就是生活在一个“魔法世界”里，科技、科幻就如同阅读散文、写日记、旅游、吃饭一样稀松平常。（2021-10-29） 补充：为麻瓜开发“魔法”的人（科技相关工作者），何不能兼容世界上所有其他的美好，https://www.zhihu.com/pin/1466396552445554688（2022-01-17） 我有“天”的概念（规划），于是我感觉一天过的比较慢，我有“周”的概念，所以我觉得一周过得比较长，我有“年”的概念，所以我感觉一年很长很长了，我唯独没有“月”的概念，所以我觉得一月一月过的贼拉快😕。（2021-12-06） 人情关系机制，是既没有优胜劣汰的公平，也没有选贤举能的效率。（2021-12-07）注：咱只是一说，咱也离不开这个环境。 关于“神舟飞船首任总设计师呼吁青少年参与第四疆域建设，即航天技术”，对此我想说，看看我们有几个出名的航天/宇宙科","date":"2019-10-15","objectID":"/2.5%E5%8F%AA%E5%89%A9%E7%BB%93%E8%AE%BA%E7%9A%84%E6%95%85%E4%BA%8B%E4%BE%BF%E6%98%AF%E7%9F%AD%E5%8F%A5%E5%90%88%E9%9B%86/:0:0","tags":["杂谈"],"title":"只剩结论的故事便是短句合集","uri":"/2.5%E5%8F%AA%E5%89%A9%E7%BB%93%E8%AE%BA%E7%9A%84%E6%95%85%E4%BA%8B%E4%BE%BF%E6%98%AF%E7%9F%AD%E5%8F%A5%E5%90%88%E9%9B%86/"},{"categories":["随机技术情报"],"content":"IEEE1451.5标准协议尝鲜实现","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"读标准03-IEEE1451.5标准协议尝鲜实现 前面两个文章里面已经详细描述了 TEDS 和 Message 的组成，这里 C 的实现分两个部分：分别对 TEDS 和 Message 的 数据结构实现 与 帧打包与解析的算法实现（第一版 2021.7）。从这个应用层协议标准原文来看，1451 协议内容相当繁杂（有关这种优缺点的论述在前两篇文章里面列举过）但是结构清晰，其类似表格化的结构可以比较顺畅的建模成编程语言的基本数据结构，并且一个编程基本哲学是设计优良的数据结构会使算法设计事半功倍。 本文描述成文时（2022.11）的程序状态、数据建模方式 和 API 设计，日后有更新只以 开源仓库内的 源码 和 其内的注释 为准，这里文章或许不跟进，只是一个程序初始版本的引导介绍。 ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:0:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"放在前面的说明 本实现开源在 如下 Github 和 Gitee 仓库，以及对应的 系列介绍文章： Staok/IEEE-1451-study: IEEE 1451 智能传感器接口标准，读原文、相关论文，学习记录，源码实现。 (github.com)。 IEEE-1451-study: IEEE 1451 智能传感器接口标准，读原文、相关论文，学习记录，源码实现。 (gitee.com)。 小站——读标准 - 分类。 CSDN——【读IEEE 1451标准】系列。 知乎——读 IEEE 1451标准 。 内容说明： IEEE 1451 标准特别繁琐，以下列举没有在本程序中 实现的部分（主要部分，不是全部）： TransducerChannel TEDS 的一些 标准源文要求 “必要” 有 的 域类没有加入到结构体中。 没有细致读标准源文，所以不清楚如果一个 TIM 下面挂接 多个 传感器通道，同时其种类有很多种，这种情形下该如何用 TEDS 描述（一定又相当繁琐）。 在下面 Message API 定义 里面可以看到只实现了 6 个左右的信息命令及其回复信息。 标准源文描述的功能非常全面了，但实现起来又只是纯体力活，所以 这里只实现最最最基本的功能。 TEDS 和 Message 的 基本数据结构 在 .h 文件里面。 程序实现的比较早，现在看起来确实需要应先好好规划规划，一些有待改进的地方记录在 .c 文件最上面的注释里面。 ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:1:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 实现 ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"整体设计简述 参考 【读标准01】IEEE1451 智能传感器接口标准介绍 - 欢迎来到 Staok - 瞰百易 (github.io)。 要实现四种必要的 TEDS：Meta-TEDS、TransducerChannel TEDS、User’s transducer name TEDS 和 PHY TEDS。 它们的结构均是 4byte 的 Length + 一个一个 TLV 域类 + 2byte 的 checksum，其中 一个一个 域类 细看标准原文去 用结构体 打包实现，四个 TEDS 就 四个 结构体即可 完成 数据的建模。 然后用一个结构体打包以上整体，再和一个 uint8_t 数组 一同放到一个 union 联合体 里面，就可以通过 访问那个 数组 来 逐字节的 访问和处理 TEDS，发送的时候，先装填好 TEDS 结构体，然后按字节 发送那个数组 即可，接收同样，接收到一个 TEDS 二进制的大数组，直接放到 联合体 里面的 的数组的位置，那么 TEDS 二进制数据流就直接填充到 TEDS 结构体里面了。 优点就是：1、减少拷贝 或者叫 0 拷贝，提升打包发送和接收解析的效率；2、结构体易于扩展。 如果这里讲的抽象，那么下面直接看程序。 以下只以 Meta-TEDS 的构建为例，都摘自 .h 文件，其余部分思路相通，详见源程序便好。 ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:1","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 头 即 TEDS identification header，详见 01-“TEDS 头” 一节。 /*************************** TEDS 头 通用结构体 ***************************/ struct TEDS_ID_struct { uint8_t Type; /* TEDS 头的域类号为 3 */ uint8_t Length; /* 总为 4 */ uint8_t Family; /* IEEE 1451.x */ uint8_t access_code; /* TEDS 的代码 */ uint8_t Version; /* TEDS 版本，1 为初始版本，往后排 */ uint8_t Tuple_Length; /* TLV 中 Length 占的字节数，为 1*/ }; ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:2","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 域类 /* Meta TEDS 数据区 每一个域类一个结构体 */ struct M_TEDS_UUID_TLV_struct { uint8_t Type; uint8_t Length; uint8_t Value[10]; }; struct M_TEDS_OholdOff_TLV_struct { uint8_t Type; uint8_t Length; uint32_t Value; }; struct M_TEDS_SHoldOff_TLV_struct { uint8_t Type; uint8_t Length; uint32_t Value; }; /* 等等等等，按照 标准原文 一个一个实现...特别多 */ ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:3","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 结构体 /* Meta TEDS 结构构建 */ struct Meta_TEDS_struct { uint32_t Length; /* 包括 DATA BLOCK 和 CHECKSUM 的 长度 */ struct TEDS_ID_struct ID; /* TEDS 头，Value 占 4 个字节 */ struct M_TEDS_UUID_TLV_struct UUID; /* Globally Unique Identifier，Value 占 10 个字节 */ struct M_TEDS_OholdOff_TLV_struct OholdOff; /* Operational time-out，整数，单位秒，Value 占 4 个字节 */ struct M_TEDS_SHoldOff_TLV_struct SHoldOff; /* Slow-access time-out，整数，单位秒，Value 占 4 个字节 */ struct M_TEDS_TestTime_TLV_struct TestTime; /* Self-Test Time，整数，单位秒，Value 占 4 个字节 */ struct M_TEDS_MaxChan_TLV_struct MaxChan; /* Number of implemented TransducerChannels，整数，Value 占 2 个字节 */ /* Group 相关内容过于复杂，略过 */ uint16_t Checksum; /* TEDS 校验，从 TED Length（最开头） 到 DATA BLOCK 的最后一个字节（本域类的上一个字节） 的加和，再用 0xFFFF 减去该加和值。 */ }; ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:4","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 总结构 /*************************** TEDS 联合体定义 ***************************/ /* 为了可以逐字节的处理 TEDS 结构体 */ union Meta_TEDS_union { struct Meta_TEDS_struct M_TEDS; uint8_t TEDS_load[MAX_TEDS_LOAD_SIZE]; }; 注意，因为 struct Meta_TEDS_struct M_TEDS; 是与 数组 uint8_t TEDS_load[MAX_TEDS_LOAD_SIZE]; 一同放到一个 联合体里面的，因此 前者 那个 TEDS 结构体 必须要 以 1 字节对齐，才能让 后者 数组 准确的 逐字节的 访问和处理 TEDS 结构体。源程序中使用 GNU Gcc 扩展关键字 pack 实现，具体如下。 #pragma pack(1) /* 让编译器做 1 字节对齐 */ ... 各种结构体 ... #pragma pack() /* 取消 1 字节对齐，恢复为默认对齐 */ 然后就是将 四个 TEDS 联合体 与 其它信息 都放到一个大结构体里面，我喜欢做一个总的打包，结构清晰，层次分明，调试易查。 /*************************** TEDS 总结构体，用户使用 ***************************/ struct TEDS_struct { /* 下面 TEDS 联合、属性 结构体 和 状体 结构体 都是 指针，用于承接 .c 文件里面 例化的 实体结构体 的 地址 */ union Meta_TEDS_union * M_TEDS_u; uint32_t M_TEDS_load_Length; union TransducerChannel_TEDS_union * TC_TEDS_u; uint32_t TC_TEDS_load_Length; union User_Transducer_Name_TEDS_union * UTN_TEDS_u; uint32_t UTN_TEDS_load_Length; union PHY_TEDS_union * PHY_TEDS_u; uint32_t PHY_TEDS_load_Length; struct TEDS_attributes_struct * M_TEDS_attr; struct TEDS_attributes_struct * TC_TEDS_attr; struct TEDS_attributes_struct * UTN_TEDS_attr; struct TEDS_attributes_struct * PHY_TEDS_attr; struct TEDS_status_struct * M_TEDS_status; struct TEDS_status_struct * TC_TEDS_status; struct TEDS_status_struct * UTN_TEDS_status; struct TEDS_status_struct * PHY_TEDS_status; /* TEDS 的名称字符串 */ uint8_t* M_TEDS_str; uint8_t* TC_TEDS_str; uint8_t* UTN_TEDS_str; uint8_t* PHY_TEDS_str; }; extern struct TEDS_struct TEDS; ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:5","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 属性和状态 结构体 参考详见 01-“TEDS 属性” 一节。 /*************************** TEDS 属性 结构体 定义 ***************************/ struct TEDS_attributes_struct { uint8_t ReadOnly :1; /* Read-only—Set to true if TEDS may be read but not written. */ uint8_t NotAvail :1; /* Unsupported—Set to true if TEDS is not supported by this TransducerChannel. */ uint8_t Invalid :1; /* Invalid—Set to true if the current TEDS image is invalid. */ uint8_t Virtual :1; /* Virtual TEDS—This bit is set to true if this is a virtual TEDS. (A virtual TEDS is any TEDS that is not stored in the TIM. The responsibility for accessing a virtual TEDS is vested in the NCAP or host processor.) */ uint8_t TextTEDS :1; /* Text TEDS—Set to true if the TEDS is text based. */ uint8_t Adaptive :1; /* Adaptive—Set to true if the contents of the TEDS can be changed by the TIM or TransducerChannel without the NCAP issuing a WriteTEDS segment command. */ uint8_t MfgrDefine :1; /* MfgrDefine—Set to True if the contents of this TEDS are defined by the manufacturer and will only conform to the structures defined in the standard if the TextTEDS attribute is also set. */ uint8_t Reserved :1; /* Reserved */ }; /*************************** TEDS 状态 结构体定义 ***************************/ struct TEDS_status_struct { uint8_t TooLarge :1; /* Too Large—The last TEDS image received was too large to fit in the memory allocated to this TEDS. */ uint8_t Reserved_1 :1; /* 为 IEEE 1451 标准做保留 */ uint8_t Reserved_2 :1; uint8_t Reserved_3 :1; uint8_t Open_4 :1; /* Open to manufacturers */ uint8_t Open_5 :1; uint8_t Open_6 :1; uint8_t Open_7 :1; }; ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:6","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS 各个结构实例化 在 .c 文件里面，分别 实例化 四个 TEDS 的 联合体、属性结构体 和 状态结构体（这里只放 Meta_TEDS 的）。 struct TEDS_struct TEDS; struct TEDS_attributes_struct M_TEDS_attr = { .ReadOnly = 0, .NotAvail = 0, .Invalid = 0, .Virtual = 0, .TextTEDS = 0, .Adaptive = 0, .MfgrDefine = 0, .Reserved = 1 }; struct TEDS_status_struct M_TEDS_status = { .TooLarge = 0, .Reserved_1 = 1, .Reserved_2 = 0, .Reserved_3 = 1, .Open_4 = 1, .Open_5 = 1, .Open_6 = 0, .Open_7 = 1, }; /* 开始装填 M_TEDS 结构体 */ union Meta_TEDS_union M_TEDS_u = { /* Length 和 Checksum 会在 TEDS_init() 中自动计算装填 */ .M_TEDS.ID.Type = 3, /* TEDS 头的域类号为 3 */ .M_TEDS.ID.Length = 4, /* 总为 4 */ .M_TEDS.ID.Family = 5, /* IEEE 1451.x */ .M_TEDS.ID.access_code = M_TEDS_ACCESS_CODE, /* TEDS 的代码 */ .M_TEDS.ID.Version = 1, /* TEDS 版本，1 为初始版本，往后排 */ .M_TEDS.ID.Tuple_Length = 1, /* TLV 中 Length 占的字节数，为 1*/ /* Globally Unique Identifier，Value 占 10 个字节 */ .M_TEDS.UUID.Type = 4, .M_TEDS.UUID.Length = 10, .M_TEDS.UUID.Value = {0x8d,0x4d,0x9d,0xa6,0x52,0x81,0xf7,0x00,0x00,0x00}, /* Operational time-out，整数，单位秒，Value 占 4 个字节 */ .M_TEDS.OholdOff.Type = 10, .M_TEDS.OholdOff.Length = 4, .M_TEDS.OholdOff.Value = 5, /* Slow-access time-out，整数，单位秒，Value 占 4 个字节 */ .M_TEDS.SHoldOff.Type = 11, .M_TEDS.SHoldOff.Length = 4, .M_TEDS.SHoldOff.Value = 10, /* ...... */ }; ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:7","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"TEDS API 给出若干 API。 void TEDS_init(void); void TEDS_pack_up(uint8_t* dest_loader,uint32_t* length,uint8_t access_code); void TEDS_decode(uint8_t* TEDS_load); /* TODO ，暂不实现 */ void TEDS_init(void) { M_TEDS_u.M_TEDS.Length = sizeof(struct Meta_TEDS_struct) - 4; /* 计算 TEDS 的数据区长度 */ /* 42，宇宙的终极答案，yyds */ /* 这个长度 只包括 TEDS 的 DATA BLOCK 和 CHECKSUM，不包括 占 4 byte 的 length */ TEDS.M_TEDS_load_Length = M_TEDS_u.M_TEDS.Length + 4; /* 计算 TEDS 总长度 */ TEDS.M_TEDS_u = \u0026M_TEDS_u; /* TEDS 的 M_TEDS_u 指针填充，后面 TEDS_calc_Checksum() 要用 */ M_TEDS_u.M_TEDS.Checksum = TEDS_calc_Checksum(M_TEDS_ACCESS_CODE); /* 计算 Checksum */ /* ... 这里 略 其它 TEDS 结构体装填 代码 */ /* 开始装填 每个 TEDS 的全名字符串 */ TEDS.M_TEDS_str = \"Meta-TEDS\"; TEDS.TC_TEDS_str = \"TransducerChannel TEDS\"; TEDS.UTN_TEDS_str = \"User’s transducer name TEDS\"; TEDS.PHY_TEDS_str = \"PHY TEDS\"; /* 指定对应 TEDS 的 属性和状态 */ TEDS.M_TEDS_attr = \u0026M_TEDS_attr; ... TEDS.M_TEDS_status = \u0026M_TEDS_status; ... } /* TEDS 打包函数 第一个参数给一个存放 TEDS 字节数据的空间，至少 200 个字节空间； 第二个参数指定 有效数据长度（字节数）； 第三个参数选择哪一个 TEDS。 */ void TEDS_pack_up(uint8_t* dest_loader,uint32_t* length,uint8_t access_code) { uint8_t* load_ptr; uint32_t whole_length = 0; switch (access_code) { case M_TEDS_ACCESS_CODE: whole_length = TEDS.M_TEDS_load_Length; load_ptr = TEDS.M_TEDS_u-\u003eTEDS_load; break; case TC_TEDS_ACCESS_CODE: whole_length = TEDS.TC_TEDS_load_Length; load_ptr = TEDS.TC_TEDS_u-\u003eTEDS_load; break; case UTN_TEDS_ACCESS_CODE: whole_length = TEDS.UTN_TEDS_load_Length; load_ptr = TEDS.UTN_TEDS_u-\u003eTEDS_load; break; case PHY_TEDS_ACCESS_CODE: whole_length = TEDS.PHY_TEDS_load_Length; load_ptr = TEDS.PHY_TEDS_u-\u003eTEDS_load; break; default: break; } *length = whole_length; memcpy(dest_loader, load_ptr, whole_length); } ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:2:8","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"Message 实现 参考详见 01-“消息 的格式” 一节。 ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:3:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"各个命令类的枚举实现 /* 命令类 枚举（Command Class） */ enum Command_class_enum { Reserved_Command_class = 0, CommonCmd, /* 给 TIM 的通用命令（Commands common to the TIM and TransducerChannel） */ XdcrIdle, /* 传感器 空闲状态命令（XdcrIdle，Transducer idle state commands） */ XdcrOperate, /* 传感器 工作状态命令（XdcrOperate，Transducer operating state commands） */ XdcrEither, /* 传感器 空闲状态或工作状态命令（XdcrEither，Transducer either idle or operating state commands） */ TIMsleep, /* TIM 睡眠状态命令（TIM sleep state commands） */ TIMActive, /* TIM 激活状态命令（TIM active state commands） */ AnyState, /* TIM 任何状态命令（TIM any state commands） */ ReservedClass = 8, /* 编号 8—127 做为 1451 标准的保留 */ ClassN = 128, /* 编号 128—255 为用户保留，用户可以自定 */ }; /* 给 TIM 的通用命令枚举 CommonCmd（Commands common to the TIM and TransducerChannel） */ /* 即 Command Class 为 CommonCmd 时，Command function 具体的值 如下 */ enum CommonCmd_commands_enum { Reserved_Common_command = 0, Query_TEDS, /* Query TEDS command（询问 TEDS 信息命令） */ Read_TEDS_segment, Write_TEDS_segment, Update_TEDS, Run_self_test, Write_service_request_mask, Read_service_request_mask, Read_StatusEvent_register, Read_StatusCondition_register, Clear_StatusEvent_register, Write_StatusEvent_protocol_state, Read_StatusEvent_protocol_state, ReservedCommands = 13, /* 编号 13–127 做为 1451 标准的保留 */ Open_Common_commands_for_manufacturers = 128, /* 编号 128—255 为用户保留，用户可以自定 */ /* 这里自定 TIM 初始化完毕标志 */ TIM_ALL_TC_initiated = 130, }; /* 传感器 空闲状态命令枚举（XdcrIdle，Transducer idle state commands） */ /* 即 Command Class 为 XdcrIdle 时，Command function 具体的值 如下，以此类推 */ enum XdcrIdle_commands_enum { Reserved_XdcrIdle_command = 0, Set_TransducerChannel_data_repetition_count, Set_TransducerChannel_pre_trigger_count, AddressGroup_definition, Sampling_mode, Data_Transmission_mode, Buffered_state, ... 等等等等 太多了... ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:3:1","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"Message 结构体 #pragma pack(1) /* 让编译器做 1 字节对齐 */ /* 消息/命令 帧 结构体，也用于 TIM 发送初始化完毕的消息 */ struct Message_struct { uint8_t Dest_TIM_and_TC_Num[2]; /* This field gives the 16 bit TransducerChannel number for the destination of the message. */ uint8_t Command_class; uint8_t Command_function; uint16_t dependent_Length; /* Length is the number of command-dependent octets in this message. */ uint8_t dependent_load[MAX_Message_dependent_SIZE]; /* 用于暂存 command_dependent，有效长度为 dependent_Length */ }; /* 回复/响应 帧 结构体，还用于 TIM 发传感器数据 */ struct ReplyMessage_struct { uint8_t Flag; /* If this octet is nonzero, it indicates that the command was successfully completed. If it is zero, the command failed and the system should check the status to determine why. */ uint16_t dependent_Length; /* Length is the number of reply-dependent octets in this message. */ /* Peply_Message_struct 中的附带参数长度 dependent_Length 占俩字节，最大 65535，即一帧回复帧中 Reply dependent 的最大字节数 */ uint8_t dependent_load[MAX_Message_dependent_SIZE]; /* 用于暂存 Reply dependent，有效长度为 dependent_Length */ /* 这里我自己再定义，dependent 的尾部再添加两个字节，表回复对应命令的 class 和 command */ }; #pragma pack() /* 取消 1 字节对齐，恢复为默认对齐 */ ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:3:2","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"Message 总结构 与 TEDS 总结构 定义相似的，先与一个 以字节为单位的大数组 一同放到一个 联合体中，再来个 总体打包。 /*************************** Message 和 ReplyMessage 联合体定义 ***************************/ /* 这么做 让 Message 和 ReplyMessage 结构体可以 逐字节 处理 */ union Message_union { struct Message_struct Message; uint8_t Message_load[MAX_Message_dependent_SIZE + 10]; /* 数组空间 里面 +10 是因为 Message 结构体里面 除了 dependent 的 MAX_Message_dependent_SIZE 还有 前面几个 不超过 10 byte 的变量 */ }; union ReplyMessage_union { struct ReplyMessage_struct ReplyMessage; uint8_t ReplyMessage_load[MAX_Message_dependent_SIZE + 10]; }; /*************************** Message 和 ReplyMessage 总结构体，供用户用 ***************************/ struct MES_struct { /* 联合指针形式，在 Message_init() 中 将 .c 中的 联合体 实体的地址赋给这里 */ union Message_union* Message_u; uint32_t Message_load_Length; union ReplyMessage_union* ReplyMessage_u; uint32_t ReplyMessage_load_Length; }; extern struct MES_struct MES; ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:3:3","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"Message API 给出若干 API。 /* API 具体注释看 .c 文件 函数定义处，具体使用实例看 .c 最上面 注释 */ /**************************** Message init，用户使用 ****************************/ void Message_init(void); /**************************** 根据不同命令 填充 Message 结构体 并打包数据的 API，用户使用 ****************************/ /* 打包好的消息数据在 MES.Message_u-\u003eMessage_load 里面，有效数据长度为 MES.Message_load_Length */ void Message_CommonCmd_Query_TEDS_pack_up(uint8_t Dest_TIM, uint8_t Dest_TC, uint8_t which_TEDS); void Message_CommonCmd_Read_TEDS_segment_pack_up(uint8_t Dest_TIM, uint8_t Dest_TC, uint8_t which_TEDS, uint32_t TEDSOffset); void Message_XdcrIdle_Set_Data_Transmission_mode_pack_up(uint8_t Dest_TIM, uint8_t Dest_TC,enum Data_Transmission_mode_enum mode); void Message_XdcrOperate_Read_TC_data_pack_up(uint8_t Dest_TIM, uint8_t Dest_TC, uint32_t Offset); void Message_XdcrOperate_Trigger_pack_up(uint8_t Dest_TIM, uint8_t Dest_TC); void Message_XdcrOperate_Abort_Trigger_pack_up(uint8_t Dest_TIM, uint8_t Dest_TC); void Message_TIM_initiated_pack_up(void); /**************************** 消息的 发送，用户使用 ****************************/ void Message_pack_up_And_send(void); /**************************** 解析接收到的 Message 的 API ****************************/ // void Message_decode(struct Message_struct* messageReceived,uint8_t* mes_load); /**************************** 根据相应 Message 填充 ReplyMessage 结构体 并打包数据的 API， 的 API ****************************/ /* 打包好后的回复消息数据在 MES.ReplyMessage_u-\u003eReplyMessage_load 里面，有效数据长度为 MES.ReplyMessage_load_Length */ // void ReplyMessage_CommonCmd_Query_TEDS_pack_up(uint8_t which_TEDS); // void ReplyMessage_CommonCmd_Read_TEDS_segment_pack_up(uint8_t which_TEDS, uint32_t TEDSOffset); // void ReplyMessage_XdcrIdle_Data_Transmission_mode_pack_up(void); // void ReplyMessage_XdcrOperate_Read_TC_data_pack_up(void); // void ReplyMessage_XdcrOperate_Trigger_pack_up(void); // void ReplyMessage_XdcrOperate_Abort_Trigger_pack_up(void); // void ReplyMessage_TIM_initiated_pack_up(void); /**************************** 回复消息的 发送 ****************************/ // uint8_t ReplyMessage_send(uint8_t class, uint8_t command); /**************************** 解析接收到的 回复消息 的 API ****************************/ void ReplyMessage_decode(struct ReplyMessage_struct* replyMessageReceived,uint8_t* received_rep_mes_load); /**************************** ReplyMessage 服务程序，自动解析 Message 并回复，用户使用 ****************************/ void ReplyMessage_Server(uint8_t* received_mes_load); 具体 void Message_init(void); 这个 的实现如下，在 .c 文件里面： struct MES_struct MES; /* 给 Message_u 和 ReplyMessage_u 填充默认值 */ union Message_union Message_u = { .Message.Dest_TIM_and_TC_Num[TIM_enum] = TIM_3, .Message.Dest_TIM_and_TC_Num[TC_enum] = TC_12, .Message.Command_class = CommonCmd, .Message.Command_function = Query_TEDS, .Message.dependent_Length = 1, .Message.dependent_load[0] = PHY_TEDS_ACCESS_CODE, }; union ReplyMessage_union ReplyMessage_u = { .ReplyMessage.Flag = 0, .ReplyMessage.dependent_Length = 1, .ReplyMessage.dependent_load[0] = 0xAA, }; /**************************** Message init，用户使用 ****************************/ void Message_init(void) { MES.Message_u = \u0026Message_u; MES.ReplyMessage_u = \u0026ReplyMessage_u; /* MES 的 Message_load_Length 和 ReplyMessage_load_Length 根据不同的情景在打包发送数据的时候再填 */ } ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:3:4","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["随机技术情报"],"content":"一个实例 流程： 0、NCAP 发出 WiFi 热点， TIM 们上电开机后分别自动的连上 NCAP 0.5、TIM 给 NCAP 发送初始化完毕消息（Message_TIM_initiated） 1、NCAP 自动询问 TIM 的 TEDS（CommonCmd_Query_TEDS），TIM 自动做回应 2、NCAP 再自动读 TIM 的 TEDS（CommonCmd_Read_TEDS），TIM 自动做回应 3、以上步骤均无误后，NCAP 根据一个标志位判断自动启动 TIM 还是等待上级进一步操作 3.1、若是前者，即自动启动 TIM 3.1.1、NCAP 根据预先设定去设 TIM 的上传数据模式（XdcrIdle_Data_Transmission_mode），TIM 自动做回应 我这里设计三种模式： OnCommand_custom：（这个暂不实现） NCAP 发送 读 数据 命令 给 TIM 的时候， TIM 空闲时候则响应，开始采集 1s 数据并上传；若TIM 正在工作则继续原来的采集和上传，不予回应 Interval_1s：TIM 定时 上传数据，在我这里是 每秒 发送一帧数据，但上位机显示的是连续的 BufferHalfFull：缓冲区半满时候 上传一次数据 3.1.2、NCAP 发送 触发命令（XdcrOperate_Trigger），TIM 按照 Interval_1s 或 BufferHalfFull 模式 上传数据 到此，以上所有步骤都是 TIM 上电后自动完成的 3.1.3、NCAP 发送 终止触发命令（XdcrOperate_Abort_Trigger），TIM 停止上传，停止采集 3.2、若是后者，即等待上级进一步操作，则 NCAP 受上级的具体控制（启、停、设置模式、待机等等） 本库使用流程：（NCAP 和 TIM 同用此库，只调用不同 API 即可） 上电 TEDS 初始化，调用如下：一般是 TIM 调用 TEDS_init(); 上电 Message 初始化，调用如下：一般是 NCAP 调用 Message_init(); 发送一次命令，这里一般是 NCAP 调用的 API： 比如 NCAP 自动 发送 询问 TIM 的 TEDS 的命令（CommonCmd_Query_TEDS），则例子如下，其他命令同理 Message_CommonCmd_Query_TEDS_pack_up(TIM_3, TC_12, PHY_TEDS_ACCESS_CODE); Message_pack_up_And_send(); NCAP 解析回复消息 API：填入接收到的回复消息字符串，接收回复消息解析，并讲结果存在 replyMessageReceived 结构体地址里 void ReplyMessage_decode(struct ReplyMessage_struct* replyMessageReceived,uint8_t* received_rep_mes_load) 回复消息，这里一般是 TIM 调用的 API： TIM 首先主动发送初始化完毕消息： Message_TIM_initiated_pack_up(); Message_pack_up_And_send(); TIM 处理 接收消息 和 自动回复消息 API：填入接收到的消息字符串，会根据已经实现的消息解码字符串和自动回应 void ReplyMessage_Server(uint8_t* received_mes_load) ","date":"2022-11-28","objectID":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/:4:0","tags":["IEEE 1451","标准","1451.5"],"title":"【读标准03】IEEE1451.5标准协议尝鲜实现","uri":"/10.3%E8%AF%BB%E6%A0%87%E5%87%8603-ieee1451.5%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE%E5%B0%9D%E9%B2%9C%E5%AE%9E%E7%8E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"介绍 ARM 内核的主要芯片大厂的各个 SoC 系列","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM \u0026 SOC 系列快速鸟瞰 编辑整理 By Staok，如有错误恭谢指出，侵删。CC-BY-NC-SA 4.0。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:0:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"零 鸟瞰 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:1:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM Cortex 系列框图 图中包含现今主流处理器架构和内核层，ARM架构处理器的架构层、内核层和具体芯片（举例）三个维度的进化/迭代示意。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:1:1","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM 体系结构的几大分类 ARM7 处理器； ARM9、ARM9E 处理器； ARM10E 处理器； SecurCore 处理器； StrongARM 处理器； ARM11 处理器； Cortex 系列处理器。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:1:2","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"一 定位 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:2:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"ARM Cortex-A 系列对比 更详细的介绍参看： ARM Cortex-A系列处理器性能分类比较ARM处理器排名_ZNDS资讯 ARM版本系列及家族成员梳理_ 韦东山嵌入式专栏-CSDN博客 _arm系列 哪种ARM Cortex内核更适合我的应用：A系列、R系列、还是M系列？_water1730的博客-CSDN博客 ARMCortex各系列处理器分类比较 - 百度文库 (baidu.com) 引用： 如图所示，绿色的部分都是v7-A的架构，蓝色的是v8-A架构，基本上绿色都是可以支持到32和64位的，除了A32，只支持到32位。在右边的每个部分，比如说需要高效能的最上面的A15-A73这个部分是最高效的，接下来就是比较注重整个效率的部分了，中间那个部分是比较高效率的，最下面那栏的是效率最好的，在电池的效能方面达到了最好的标准。 如果非要给他们一个排序的话，从高到低大体上可排序为：Cortex-A73处理器、Cortex-A72处理器、Cortex-A57处理器、Cortex-A53处理器、Cortex-A35处理器、Cortex-A32处理器、Cortex-A17处理器、Cortex-A15处理器、Cortex-A7处理器、Cortex-A9处理器、Cortex-A8处理器、Cortex-A5处理器。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:2:1","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["【主线剧情】Linux 系列"],"content":"二 展望 基于 Linux 系统方案的优势： 更高性能，可以运行复杂的算法； 高效开发，专注于梳理任务，应用以 APP 形式编写和更新； 智能终端，可以外接触摸屏，运行 Qt 上位机做人机界面； 协议丰富，使高级接口如网络、USB 等更易于开发； 平台通用，开发形式更加固定。 ","date":"2021-05-01","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/:3:0","tags":["ARM"],"title":"【主线剧情 番外01】ARM 系列快速鸟瞰","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9601-arm%E7%B3%BB%E5%88%97%E5%BF%AB%E9%80%9F%E9%B8%9F%E7%9E%B0/"},{"categories":["人与世人的关系"],"content":"考研个人经验汇总","date":"2020-10-01","objectID":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/","tags":["杂谈","考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["人与世人的关系"],"content":"纯干货，不上升到哲学，提个醒，实际安排可调整。 安静，是好环境。 我默认你心理素质强大，所以下面不讲心态的事情。 ","date":"2020-10-01","objectID":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:0:0","tags":["杂谈","考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["人与世人的关系"],"content":"选学校 即给多个意向学校的难度做个排列。 首先搜索意向专业的全国高校排名（即搜XX专业大学排名），然后在专业排名名单里逐个查看以下四个内容，形成难易程度可以对比的一个自己的名单。 难度主要看： 对于学校的初试专业课自己是否熟练或者能够熟练； 往年复试分数线； 往年报录比（最好是报的人可以，而且录的人还挺多），看专业统考招生人数和录取名单，以及录取名单上面有多少人和其分数； 复试科目（笔试+面试，初试以前不很重要）。 最后在名单中的前三个，看城市、学校综合排名、牌子等要素确定一个学校。 ","date":"2020-10-01","objectID":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:1:0","tags":["杂谈","考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["人与世人的关系"],"content":"备考 专业课往年真题（要烂熟于心）。 英语：先背单词，往年20年真题中所有不会的单词尽量全背，我使用“文本处理工具Replace Pioneer”把20年真题全文粘到这个软件里面，然后给所有单词按照出现次数排序（没错，word 没有这个功能），这样列出所有真题的不重复的单词列表，然后过一遍，着重所有一开始不认识的生词；因为我是稍微有点语感的，所以只要单词认识然后长难句顺口翻译，所以先全背一遍单词；做真题的阅读，读多了慢慢就快了，先看问题，然后去文章中找答案；作文，就准备自己独特的模板，从多个模板各摘一点； 数学：过1、2遍所有课本（数一：高数上下册、线代和概率论），认真总结所有知识到笔记本，要有框架的概念，日后查和背很好用；过1、2遍名家全知识点解析书（毛纲源的（推）、张宇的或者课本配套的解析书（同济绿皮的）等）；烂熟地做真题（近20年）；多关注张宇和李林的微博，不但有测试题，临考还有画重点，准确性值得去会；不要只看重点，全面的看；最后认真做李林（推）、张宇等的预测卷； 政治：看网课（徐涛的），有个印象；过1遍知识解析书（徐涛的或肖秀荣的）；最后必背肖八、肖四（推，感觉太多就只背肖四）；并多关注徐和肖的微博或者公众号，不但有每日测试，临近考试还有画重点，如果肖画了肖四的重点题，那么就只背重点题，其他不管，成功写上也就有60分左右了；背的技巧：编短语，比如最后画了重点题，这几个题可以归纳出八个大段的话需要背，每一段摘一个字或者两个字，然后组合编成8个字或者16个字的类似“顺口类”的短语，做到把其中的字对应一大段话，做到只要一说这个短语就能全部说出来，就都能记。 下面是一张“泛泛经验”的图。 如下图，这是把大概五本书的内容总结成一个小册子。 精简，找到规律，形成框图和节点的连接关系，也好理解也好记，每天看一些，记一点，慢慢就看完了。 ","date":"2020-10-01","objectID":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:2:0","tags":["杂谈","考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["人与世人的关系"],"content":"复试 复试是竞争，要先回想和归纳一下本科所有有价值的经历（认真的，不开玩笑），列出来，并形成一个简历（成就罗列）。 复试看能力，除了学业就是相关领域的竞赛奖项、经手的项目、论文等，还有毕设的完成情况和含金量，这些要尽量主动多说，问一句要回答的多而全，言之有物，尽量表达自己的亮点（经历的难点或与众不同的点）。 如果相关竞赛等成就囊中羞涩，老师会多问学业、专业课上的细节问题，不但书本上大部分概念要记全面而清楚（尽力），还要有一个总体认知（总体认识也便于对一个学科记忆和应用）。 即便是人生困难时期，到坎上了，也会默默持续去做，让自己忙起来，就像独自一人穿过森林（日后虽然不想回忆，但也是人生组成部分）。 耐下性子，多想一想做一做，然后过去就好了。 希望我们稍后在森林另一头见到。 ","date":"2020-10-01","objectID":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:3:0","tags":["杂谈","考研"],"title":"【考研】噫嘘唏，考研个人经验汇总","uri":"/3%E8%80%83%E7%A0%94%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["【规范】系列"],"content":"比较详细、精炼的介绍了 SCH \u0026 PCB 设计规范、实用技巧 和 AD 的使用","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH \u0026 PCB 设计规范、技巧以及AD 的使用（SCH-\u0026-PCB-rules-and-AD`s-usages） ***p.s 温馨提示：点个 star 收藏一下回头慢慢看；或者下(白)载(嫖)下来，在 Typora 中阅读； [本文知乎地址（不是最新）](https://zhuanlan.zhihu.com/p/356679916) ；一个人整理不易，这么丰富的仓库只顾着看和克隆而忘了点 star？。***\r编辑整理 by Staok，始于 2020.7 且无终稿。转载请注明作者及出处。本文系作者纯属对硬件的兴趣（但不走硬件岗）而对过去实践过的、没实践过的硬件概念、经验做的总结，广泛撷取、借鉴和整理，参考的公开文档、书籍和网络文章数量已经不可数。看本文的你最好已经对数模电比较熟悉。适合刚入门的人阅读和遵守，已经有较多经验的人看一看图个乐。如有错误恭谢指出！本文已经是长期积累和堆叠而形成一定规模，不必按照从前到后的顺序去看，可以挑感兴趣的章节去看。 本文件是 “瞰百易” 计划的一部分，尽量遵循“二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明（这中二魂…）！ 本文对应的 Github/Gitee 仓库地址，本文最新的原文 和 一些源码、备查手册等等 均放在里面。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:0:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"O 目录 [TOC] ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:1:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"0.5 电子类网站收集 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"大厂官网 筛选器件型号的选型、获得器件手册+参考设计+设计要点等文档资料 TI（德州仪器）：模拟 | 嵌入式处理 | 半导体公司 | 德州仪器 TI.com.cn。 ADI（亚德诺）：ADI | 混合信号和数字信号处理IC | 亚德诺半导体 (analog.com)。 Infineon（英飞凌）英飞凌——半导体与系统解决方案 - Infineon Technologies。 MPS：MPS | Monolithic Power Systems 芯源系统有限公司。 Microchip：Smart | Connected | Secure | Microchip Technology。 ON（安森美）：智能电源和感知技术I安森美 (onsemi.cn)。 Maxim（美信）：模拟, 线性, 混合信号, 半导体 | Maxim Integrated。 NXP（恩智浦）：恩智浦半导体官方网站 | 主页 (nxp.com.cn)。 ST（意法）：首页 - STMicroelectronics。 Xilinx（赛灵思）：Xilinx -灵活应变. 万物智能.。 TDK：TDK Product Center。 Renesas（瑞萨）：瑞萨电子 (Renesas Electronics Corporation)。 Powerint：Homepage (CN) | Power Integrations, Inc.。 Keysight：资源 | 是德科技 (keysight.com)。 更多见 额外文档/电子元件官网汇总.pdf。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"综合类网站、论坛 电子发烧友网：领先的电子工程师技术社区，为工程师创造价值 (elecfans.com)。 21IC电子网 - 电子工程师的优选网站。 OpenEdv-开源电子网-正点原子论坛。野火电子论坛 - Powered by Discuz! (firebbs.cn)。硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn)。硬石电子 - 社区 (ing10bbs.com)。意法半导体STM32/STM8技术社区 - 提供最新的ST资讯和技术交流 (stmcu.org.cn)。 一个专注于智能硬件、嵌入式系统、物联网、电子产品设计美学的独立博客 - 吴川斌的博客 (mr-wu.cn)。 电子工程师的在线课堂_Moore8摩尔吧。 38度发烧友论坛-38Hot Volt-Nuts 仪表 基准 工具 万用表 示波器 焊台 电烙铁 电钻电子爱好者专业论坛 - Powered by Discuz!，对一些仪器仪表、电源基准等研究很深。 51黑电子论坛-单片机 电子制作DIY MCU 嵌入式技术学习 (51hei.com)。 在家学习——硬十宝典【20200127】 (qq.com)。 一个专注于智能硬件、嵌入式系统、物联网、电子产品设计美学的独立博客 - 吴川斌的博客 (mr-wu.cn)。 一个目录：扩展获取信息/学习的渠道（以EE为例） - 知乎 (zhihu.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"开源电子项目分享类/资源类 当作兴趣，交流爱好的社群。 All projects | Hackaday.io，开源硬件项目网站。 硬件设计，立创EDA开源硬件平台，硬件工程师的电路家园。 (oshwhub.com)，开源 PCB 项目分享。 电路方案-电路城 (cirmall.com)。 应用方案_ 电路图_ 开发板资料_ 应用设计_ 行业软件_电子工程师资料下载网站-电子芯吧客（www.icxbk.com）。 融创芯城|融创电子社区|融创芯城电子工程师社区|电子技术论坛|电子技术问答 (digiic.com)。 eesites 电子森林 (eetree.cn)。 Projects | CircuitMaker，硬件版 Github。 逆天PCB论坛-逆天电子论坛-电子工程师俱乐部-中国PCB论坛-PCB封装库-全球最大硬件开源网 - Powered by NTpcb，内容丰富。 电子制作实验室网站欢迎您！ (xie-gang.com)。 GitHub。 delftopenhardware/awesome-open-hardware: 🛠Helpful items for making open source hardware projects. (github.com)。 sindresorhus/awesome: 😎 Awesome lists about all kinds of interesting topics (github.com)。 手机电路图大全 - 消费电子 - 电子工程网 (eechina.com) 资料丰富。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"教程类 活到老学到老系列。 德州仪器（TI）官方视频课程培训 - 21ic电子网。 学堂在线 - 精品在线课程学习平台 (xuetangx.com)。 网易公开课 (163.com)。中国大学MOOC(慕课)_国家精品课程在线学习平台 (icourse163.org)。 培训资源-全国大学生电子设计竞赛培训网 (nuedc-training.com.cn)。 PCB 类： 逆天PCB论坛-逆天电子论坛-电子工程师俱乐部-中国PCB论坛-PCB封装库-全球最大硬件开源网 - Powered by NTpcb。 凡亿教育-凡亿PCB,实战教学PCB视频PCB培训，十天入门到精通多层高速PCB设计 (fany-online.com)。 志博教育-电子工程师PCB开源社区 (zbpcb.com)。 哔哩哔哩 (゜-゜)つロ 干杯~-bilibili，把 B 站放在这里没什么不对吧。 微雪课堂 (waveshare.net)。深圳百问网科技有限公司 (100ask.org)。 硬件工程师技能树 - 知乎 (zhihu.com)。HardwareDesign: 介绍硬件设计的一些内容 - Gitee.com。走硬件岗的推荐把这个人总结的都值得深深研究研究！ ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"大型电子器件商城 立创商城：立创商城_电子元器件采购网上商城_领先的现货元器件交易平台-嘉立创电子商城 (szlcsc.com)。 得捷电子（Digi-Key）：得捷电子 中国 Digi-Key官网 | 供应商直授权电子元器件分销商 (digikey.cn)。 华秋商城：华秋商城(原\"华强芯城\")官网_电子元器件采购网_自营现货电子元器件商城-一站式电子元器件商城 (hqchip.com)。 泽贸电子（Mouser Electronics）：电子元件分销商 - Mouser Electronics。 云汉芯城：云汉芯城ICKey.cn_电子元器件采购_BOM配单_SMT贴片_PCB打样。 淘宝（货源存疑望小心，便宜没好货），咸鱼（或可超廉价入拆机盲盒芯片）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"优秀参考/书籍/数模电基础（新人必看） 请转到 本文最后一章 “9 优秀参考/书籍/数模电基础（新人必看）”。 那里面有 系统入门、学习的 书籍、视频，还有适合零碎时间翻看汲取各种硬件设计中经验技巧的小文章。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:2:6","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1 最基本的设计理念和器件选型 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"硬件岗位描述 引自从事硬件工作朋友的口述。 “一般是原理图修改、画PCB、跟线工厂贴片生产，以及后面生产完了使用出问题的话，要解决。有的在自己办公室用示波器之类的测，有的时候要到外地去看现场到底出的啥问题。有些需要满足国标的还要跟测试，看EMC，或者其他高低温测试之类的。 最后还有些文档，写写使用手册，维护手册，系统里改改BOM，走走各种流程。” “首先是项目初期方案评审，主要考虑到项目的可实施性，第二是原理图框架评审，保证你后期设计不会跑偏，再者是原理图评审以及PCB评审，包括整个PCB绘制过程都是由硬件工程师主导。投板后开始写测试用例，其中就包含固件需求文档。板子回来就进入调试过程，这个过程完全脱离固件，你只保证你的硬件没有问题与设计符合就可以，测试完成需要进行测试结果评审查看是否可以转发布，发布完成就要给生产写生产指导文件以及跟踪前期试产，试产完成需要转C4测试这个是由测试部门主导，如果有问题随时反馈硬件工程师，测试不过需要重新设计。主要还是在设计技术和设计理念上下下功夫就好。” 硬件产品开发30个流程总结参考：离线在 额外文档/硬件产品开发30个流程-一路带飞up-提供.pdf。 调侃硬件设计的一个有趣回答：为什么电路要设计得这么复杂？ - 知乎 (zhihu.com)。 推荐：硬件工程师技能树 - 知乎 (zhihu.com)。HardwareDesign: 介绍硬件设计的一些内容 - Gitee.com。走硬件岗的推荐把这个人总结的都深深研究研究！ p.s 免得我这个文章误人子弟，我要反复提醒，本文只非硬件专业的我基于兴趣的长期、大量的做硬件、踩坑的经验总结，想要专业搞硬件的，还需要经过相当专业的理论学习、软件使用和大量实践，每个好的硬件工程师都是大量实践（硬件调试、金钱、时间）喂出来的！ ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"顶层设计 设计原则 分别严肃考虑以下几个方面： 性能：要满足设计要求，并留有一些裕量。 成本：满足性能前提下降低成本，除非科研或全功能测试/调试版本。 兼容性：软硬件兼容（相互影响）、模块化时候接口兼容（压流范围、驱动能力、阻抗、保护等）、多种应用场景兼容、可以反复使用等等。 实施和调试难易程度：综合时间、方案成熟度、是否值得付出大量精力。 方案成熟度：尽量选择成熟方案，选择典型电路，容错强 或 新功能调试版本 开发 的情境下可以适当尝试创新的组合，但要在进入实物制作之前要进行充分的仿真和子单元测试，尽量减少在实际硬件上的错误概率。 实施要点： 硬件低功耗。即降低静态电流、工作温度、电磁辐射、散热成本、热噪声，延长寿命；低功耗要细致设计，从整体规划到每一个芯片的静态电流和每一个电阻里流过的电流等等的考虑，即设计新电路时注意着不要太多增加消耗无用功率和静态功耗，尽量降低静态电流。 硬件的可靠性。设计时参考芯片手册的电气参数并留有一定裕量，并且无论软件有什么操作硬件也不会发生永久性损坏，也尽量避免用户按错按键或者插错接口就坏掉，即无论在接口错误（物理错误 或 软件通讯错误）、环境变化、软件操作、用户错误使用等情况，都考虑增强鲁棒性，并能自恢复。 软件提高效率、减小体积、节省存储空间，并且要配合硬件做低功耗。 .etc 如无必要，少增实体！ 电路模块化 分为两种层面的 “模块化” ，原理图形式的模块化 和 电路板实体的模块化。 电路原理图必须要模块化，便于以后的开发可以直接参考或复制之前已经设计的固定下来的功能模块。 电路板实体的模块化（接口形式可以是 插接键 或者 邮票孔 ），要视具体应用而定：如果电路板要抗震、要空间集成度高（即占用空间紧张）、要低噪声（即精密设计），那么就不宜用电路板实体的模块化，那么此时直接用原理图模块化的形式（可以借鉴或复制之前设计的模块化的原理图）进行原理图层面的框图连接，然后所有器件画在一个板子上，PCB 也直接借鉴之前的设计，这样就实现比较高效的设计。 另外要注意的： 标准化、通用化和可靠性设计高于功能设计； 接口要考虑到电平兼容，比如 TTL 和 CMOS 两大电平标准（提醒不能忘：未使用的 TTL 的输入口可以悬空，未使用的 CMOS 的输入口不能悬空，需要拉到一个确定的电平）； 设计系统要尽量利用硬件资源和外设资源，减少 CPU 负担。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"选型的原则 高性价比； 采购方便； 归一化：整板上相同作用的器件尽量选择一种器件，减少 BOM 表长度； 利用率高：引脚利用率、器件利用率； 兼容、可替代性：芯片替换时封装兼容、方案扩展性； 普遍性：选成熟的方案或芯片； 开源性：手册、应用资料和原理图例子的丰富； 持续发展：环保、供货周期长； 更多内容见/额外文档/一篇很完整的元器件选型指南.docx，巧学系列——各种基础器件介绍 (qq.com)。 元器件降额参数基本要求 【一张图概括】元器件降额参数及要求 (qq.com)。 电子元件可靠性：→→ 电子元件可靠性相关专辑 6册 1091页 22.8M ←← - 无源器件/分立半导体 - 电子工程网 (eechina.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"MCU / MPU 【主线剧情 番外01】ARM \u0026 SOC 系列快速鸟瞰 - 知乎 (zhihu.com)，PCIe接口及其衍生接口大总结 - 知乎 (zhihu.com)。 内核架构，RAM，ROM，I/O 数量，通讯接口（UART，SPI，I2C，CAN，USB，SDIO，PCIe，HDMI 等），其他特色外设，低功耗模式，抗扰能力。 官方手册、工具链是否齐全，官方是否提供 EVK 开发板及其 BSP 底层支持包。 最小系统：电源轨需求（电源树），时钟（晶振），复位（RC + 开关，内部看门狗，专用看门狗芯片等），RAM（SRAM、(LP)DDR2/3/4 SDRAM），FLASH（SPI FLASH、eMMC/Nor/NAND）。 功耗，价格，封装，供货周期。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"电源 更多具体设计相关内容见 电源规范设计 一节，这里是笼统列举。 顶层设计 电源设计四要素（设计一个好电源，打好整板的 “地基”）： 体积小。 效能高（效率高（轻载、重载情况下均 90% 以上）、低静态电流、热控制好）。 低 EMI。 好的动态响应（负载调整率好，负载快速变化时输出波动（过冲和下降）小且恢复快，输出纹波良好（20mV 左右 可以，10mV 以下优良））。 通用 电源树/电源轨 框图，看 “电源规范设计” 一节。 确定一些参数 合理的 明确 和 设计 电源轨，也就是 板级的 顶层设计。 确定入、出的压、流范围，纹波，温度特性。 功率限制（负载是什么，需要多大功率），电压、电流裕量。 预期的 电压 和 电流调整率（带载后 压、流 的 下降 在合理范围内）。 体积 \u0026 成本限制。 布局布线考虑。 保护机制完善程度考虑（参考上一小节）。一般电源要加的多重保护：EMC 环节 + 防反接 + 防过流、过压、欠压（按照电源供电的前后顺序）。 目前 电源设计 大多是基于 芯片的，电源芯片选型看下面 “开关电源芯片” 和 “线性电源芯片” 两个列出的一些参考要素。 开关电源芯片 即 DC-DC 的 BUCK、BOOST、BUCK-BOOST 和 AC-DC 的 正激、反激 等。 拓扑形式，频率，是否集成开关管。 输入、输出的电压、电流范围。输出是否可调。 是否带 COMP 环路补偿端。 静态功耗。 线性电源芯片 即 LDO。 输入、输出的电压、电流范围。输出是否可调。 最低输入和输出之间的压差。 静态功耗/静态电流（如 HT7333 最低 1uA）。 输出噪声。 线性调整率，负载调整率。 过流和温度等的保护。 多种封装选择，或根据不同功率选用不同封装的具体型号（如 78 系类有 m、l 系列等，1117 系列有 sot-223、sot-89 等系列）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"运放 更多具体设计相关内容见 运放设计注意 一节。 括号内为最廉价运放的典型值，即不是各种具有特殊特性运放的参数值，比如主打低噪声的运放、主打低功耗的运放、主打性价比的运放等等。 输入、输出电压范围（供电是否必须双电源，输出是否轨到轨），带宽/摆率/电压转换速率（SR，0.5V/us），开环差模增益（Aod，100dB）/频率响应/伯德图/频带宽（-3dB的频率，0.5~2MHz），放大倍数温漂。 差模输入阻抗（Rid，大于2MΩ），共模输入阻抗，共模抑制比（KCMR，大于80dB）。 输入失调电压（Uio，小于2mV），输入失调电流（Iio，0.2~2uA），输入偏置电流（Iib，0.3~7uA），它们的温漂。 功耗（80mW）。 补充：【一张图概括】运放关键参数 (qq.com)。 较全面的一文 硬件-TI-OPA - 知乎 (zhihu.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:6","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"ADC 主要参数列举需要考虑： 位数（8、16、24bit 等）。 采集速率。 参考电压范围 和 具体选择（与 位数 一同决定 采集精度）。 输入阻抗（注意阻抗匹配）。 数字接口（SPI、并口总线 等）。 同步采集特性，是否支持多片级联 等。 封装、功耗 等等。 较全面的一文 硬件-TI-ADC - 知乎 (zhihu.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:7","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"电阻，电容，电感 对于电容、电感和电源的一个较全面的科普性介绍：TDK：电力电子，电感和电容产品指南（科普文档） (sohu.com)。 电阻：先考虑类别（贴片电阻、金属膜电阻（稳定）、水泥电阻等等），阻值，功率，精度（E24-5%，E96-1%），温漂，品牌厂家，封装，价格，热噪声。 电容：容值，耐压，材质（优先选：固态，铝聚合物，多层陶瓷电容（MLCC，也有叫“独石电容”）（优先选：NPO（温度稳定性很高，容值小，适合信号处理），X7R（容值范围大，适合电源滤波），X5R（容值可以很大，低压大容值滤波（47uf/100uf 的 6.3V等））），钽电容（大容量的钽电容耐压很低），X/Y安规电容（掉电后不存电，安全）），ESR（等效电阻，要低），纹波电流额定值（rated ripple current），温度特性，泄露电流，封装，寿命年限（一般 10 年就明显老化）。一文看透MLCC，附原厂及代理商名单！ (sohu.com)。 电容 ESR 相关，重要： 关于电容的ESR参数，它是什么？为何重要？以及测量它的 N 种方法_哔哩哔哩_bilibili。 电容的ESR知识汇总（很全） (sohu.com)。 ESR性能排序，从好到差：MLCC\u003e聚合物铝电解电容(固态电容)\u003e聚合物钽电解电容\u003e钽电容\u003e铝电解电容。 注意：MLCC的ESR相比于其它几种电容非常小，因此也就造成上电瞬间充电的电流（瞬时电流）会非常大（打个比方，普通铝电解电容220uf充电瞬时电流 10A 吧，MLCC能干到40A），如果此条链路上有MOS管（比如用P-MOS和BJT等分立元件搭建的线路上的电子开关）等，可能这样很不安全，反复折腾后MOS管可能就挂了，就造成硬件总坏，这时可以考虑加点软起电路，比如MOS的GS极之间加1uf的电容让其缓慢在线性区的开启，不过这样做也会增加 启动时间 和 关闭时间 对于整系统的 多路电源 的 启动顺序 会造成影响，对电路的调整需要从硬件整体考虑。对时序控制要求高的场合，还是用专门的负载开关去处理吧，分立MOS开关搞起来就太折腾了。MOS管电源开关？没想的那么简单 - 知乎 (zhihu.com)。 不同电容的 频率-阻抗 特性不同，每个容值都有一个对应的阻抗最低频率（谐振频率），所以对于重要器件如主控制器、FPGA等，其供电处应将很多、容值从大到小（uf 级别~nf 级别）的贴片电容并联用于对电源的去耦/滤波。相同容量电容的并联时并未展宽低阻抗频带，只是在谐振频率点处的阻抗降低了。多个不同容值（和多个封装大小）的贴片电容并联才可以有效的展宽低阻抗频带。每一个电容对某一个频率段呈低阻抗，外部电源的噪声的这个频率段的分量会在该电容泄放到地，因此好的电源噪声滤波是尽量覆盖全频段的多容值的好电容的并联，即 展宽 低阻抗 的 频带，或描述为 在 更宽的高频带内 使噪声 对地 形成 低阻抗的 泄放通路。 电容Q值计算公式-电子发烧友网 (elecfans.com)，ATC的宽带电容，几乎全频带都是低阻抗！~ 用于芯片电源脚旁边 “滤波” 用的电容 可分为 去耦 和 旁路 两种作用，去耦降低线路上的扰动（电源纹波、其它器件的高频或大电流脉动对电源线路的干扰等），也就是泄放高频信号到地，旁路则相当于 “小电池”，电源较远不能及时供上能量的时候就靠 旁路电容 “小电池” 放电供能，而这个电容的 ESR 就相当于 “小电池” 的电源内阻，当然 电源内阻小 放电能力 就强~ 重要说明，这里都是 定量分析，属于 “感性”/“想当然” 分析，对于低频、小功率电路无所谓这么多，对于高频电路就要考虑负责的线路和器件的分布参数（等效串并复杂的联电容、电感），需要做仔细、专业的仿真和实测！ 电感：Irms 温升电流（电流-温度特性图表），Isat 饱和电流（电流-感值特性图表），直流电阻（DCR），封装/构成类型（电源用的功率电感优先选：一体成型带屏蔽层的 0630/4040 较小封装的功率电感，线艺公司的 扁铜带/扁铜线型（大电流，封装紧凑），铁硅铝（适合做电源滤波的大电流、大感值的功率电感））。 Isat(饱和电流，感值下降20%的电流)，Irms (温升电流，温升20°/40°的电流)相关：功率电感的痛点：两个额定电流Isat , Irms 如何理解？_ 清风度面-CSDN博客_irms。 关于阻容的封装的补充说明：电阻的直插（金属膜电阻）封装比表贴（碳膜电阻）和电容的直插（MLCC独石，NPO或X7R）比表贴（陶瓷，NPO或X7R），要来的更加稳定（精度高、热稳定好），噪声可能更小。对于要求精密、稳定的硬件可选此。 较全面的一文 硬件-基本元件 - 知乎 (zhihu.com)。关于 电阻，电容，电感 比较全面的 参数介绍 和 高速的等效模型介绍。 电阻、电容、电感品牌（包括国内、国外品牌） 电阻 美国：AVX、VISHAY威世 日本：KOA兴亚、Kyocera京瓷、muRata村田、Panasonic松下、ROHM罗姆、susumu、TDK 台湾：LIZ丽智、PHYCOM飞元、RALEC旺诠、ROYALOHM厚生、SUPEROHM美隆、TA-I大毅、TMTEC泰铭、TOKEN德键、TYOHM幸亚、UniOhm厚声、VITROHM、VIKING光颉、WALSIN华新科、YAGEO国巨 新加坡：ASJ 大陆：FH风华、捷比信 电容 美国：AVX、KEMET基美、Skywell泽天、VISHAY威世 英国：NOVER诺华 德国：EPCOS、WIMA威马 丹麦：JENSEN战神 日本：ELNA伊娜、FUJITSU富士通、HITACHI日立、KOA兴亚、Kyocera京瓷、Matsushita松下、muRata村田、NEC、nichicon(蓝宝石)尼吉康、Nippon Chemi-Con(黑金刚、嘉美工)日本化工、Panasonic松下、Raycon威康、Rubycon(红宝石)、SANYO三洋、TAIYO YUDEN太诱、TDK、TK东信 韩国：SAMSUNG三星、SAMWHA三和、SAMYOUNG三莹 台湾：CAPSUN、CAPXON(丰宾)凯普松、Chocon、Choyo、ELITE金山、EVERCON、EYANG宇阳、GEMCON至美、GSC杰商、G-Luxon世昕、HEC禾伸堂、HERMEI合美电机、JACKCON融欣、JPCON正邦、LELON立隆、LTEC辉城、OST奥斯特、SACON士康、SUSCON冠佐、TAICON台康、TEAPO智宝、WALSIN华新科、YAGEO国巨 香港：FUJICON富之光、SAMXON万裕 大陆：AiSHi艾华科技、Chang常州华威电子、FCON深圳金富康、FH广东风华、HEC东阳光、JIANGHAI南通江海、JICON吉光电子、LM佛山利明、R.M佛山三水日明电子、Rukycon海丰三力、Sancon海门三鑫、SEACON深圳鑫龙茂电子、SHENGDA扬州升达、TAI-TECH台庆、TF南通同飞、TEAMYOUNG天扬、QIFA奇发电子 电感 美国：AEM、AVX、Coilcraft线艺、Pulse普思、VISHAY威世 德国：EPCOS、WE 日本：KOA兴亚、muRata村田、Panasonic松下、sumida胜美达、TAIYO YUDEN太诱、TDK、TOKO、TOREX特瑞仕 台湾：CHILISIN奇力新、Mag.Layers美磊、TAI-TECH 台庆、TOKEN德键、VIKING光颉、WALSIN华新科、YAGEO国巨 大陆：Gausstek丰晶、GLE格莱尔、FH风华、CODACA科达嘉、Sunlord顺络、紫泰荆、肇庆英达 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:8","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"二极管 分类 / 各个类别的区分： 二极管整理分类_sternlycore的博客-CSDN博客_二极管分类 好文。 二极管有哪些种类 (baidu.com)。 二极管的分类及用途介绍-电子发烧友网 (elecfans.com)。 常用到的： 肖特基二极管 SBD。 快恢复二极管 FRD。 稳压二极管 / 齐纳二极管，关于稳压二极管的坑，你一定要知道 (qq.com)。 TVS \u0026 ESD .etc，瞬态抑制、保护类的 器件见 下面 “保护机制” 一节。 二极管的主要参数： 额定整流电流 IF。 最大整流电流（平均值）IOM，在半波整流连续工作的情况下，允许的最大半波电流的平均值。 最大浪涌电流 IFSM，允许流过的过量的 瞬间的 正向电流。 正向电压降 VF。 最高反向工作电压 VRM，反向击穿电压 VB，通常 VRM 为 VP 的三分之二或略小一些。 反向漏电流 IR，在规定的反向电压条件下流过二极管的反向电流值。 最高工作频率 FM（二极管具有单向导电性的最高交流信号的频率） / 结电容 CJ / 反向恢复时间 Trr。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:9","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"功率开关管 较全面的一文 硬件-BJT MOSFET - 知乎 (zhihu.com)。 Vds（漏源极电压），Vgs（栅极源极电压），Ids（漏源电流），Rds(on)（导通电阻）。 分布/寄生电容（符号：Cs，Cg。其越小，开关速度越快，开关损耗越小，普通硅基材料 MOS 可选 TI 的 NexFET 型）（防止因 寄生电容 较大 导致 米勒效应（开关过程中停留在米勒平台的时间） 较大 而造成开关损耗大）。 封装（小的 如 SOT-23 一般在 30V/4A 以内，大的如 TO252，还有贴片封装的 MOS 可以具有更好的性能和小巧的封装）。 目前三类 MOS 开关管：硅基（Si），碳化硅（SiC），氮化镓（GaN），目前英飞凌（Infineon）能提供很广泛的 MOS 选型和对应的预驱 IC，官网有不少选型指导手册。下图是三类 MOS 的适用范围： 总结目前适用范围： 传统硅基：成熟、稳定可靠，低压，低电流，低频； 碳化硅：高压领域，强电； 氮化镓：低压大电流，高频，强减小功率变换器的体积。（不过预驱参数和传统硅基不同，需要细看）。 以碳化硅为例，相比于 IGBT，其低阻值，高频率和高温工作（250 ℃），可明显将目前大功率变换器小型化，甚将改变工程设计模式。且碳化硅做的二极管，反向过压比硅基的小的多的多。碳化硅的开关管的开关损耗比传统硅基要减少 90%（理想）。 更多： Wide Bandgap Semiconductors (SiC/GaN)。 体验三类 MOS： CoolMOS™ 7- CoolSiC™ - CoolGaN™ 和互补的EiceDRIVER™ IC.pdf。 选型和设计： 英飞凌功率器件选型。并联 MOS 设计：英飞凌在大电流应用中并联功率MOSFET的技巧 (eefocus.com)。 德州仪器（TI）的 NexFET MOS 选型（CSD 系列）。 谨防买到假货 MOS 管！识别经验现有两点（真实趟过雷的），一点是如下图识别丝印大小（左边两个真品，右边两个赝品），另一点是真货 MOS 的边缘是圆角，而方角的可能是假货，也不是绝对，需要进一步测量验证，比如加 Vgs，然后测量 Rds，假货肯定有 内阻不正常 / 最大承受电流很低 等等问题。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:10","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"保护机制 保护设计 主要是针对 电源线 的 抗冲击设计 和 对 信号线 的 抗干扰保护（EMS） 与 防电磁辐射（EMI）。 过压，欠压，防反接，软起动——主要针对 电源设计。 过流，过温——主要针对芯片、发热元件，电路板整体散热规划 等。 EMC 电磁兼容性设计，如 瞬态抑制 / 防浪涌，防静电 ESD，RC 抑制尖峰噪声/消火花。共模、差模干扰噪声抑制。 信号的缓冲和隔离。信号隔离（光耦隔离、磁隔离等）。电源隔离（通过变压器线圈在物理上隔离）。 共阻抗地干扰抑制（高频）。 上述保护电路更多细节内容可详看这个，非常实用的各类保护电路的总结：Github Staok/protection-circuits: 对保护电路中的过流、过压、软起动、防反接、通讯和信号隔离、电平转换、防共地干扰、TVS瞬态抑制、共模抑制和电磁兼容做一个大总结 (github.com)。Gitee protection-circuits: 对保护电路中的过流、过压、软起动、防反接、通讯和信号隔离、电平转换、防共地干扰、TVS瞬态抑制、共模抑制和电磁兼容做一个大总结 (gitee.com)。 关于隔离 电源隔离：常为使用变压器的磁路形式隔离（如金升阳等的电源模块） 信号隔离：常有 逻辑缓冲/中继（74 系列的 244、245 等等）、光耦隔离 和 磁隔离（如 I2C、SPI 专用的磁隔离芯片）等等；要注意的是信号的隔离往往是两个单独的电路回路之间的信号连接，所以如果用光耦进行信号隔离，那么光耦两边的电源连接应该用两边对应的单独电路回路里面的电源，而不是公用一个地或者电源，这样起不到隔离效果。 硬件- Isolation Power Design - 知乎 (zhihu.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:11","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"更多元件选型 有总结比较好的资料放在这里。 关于具体的光耦的选择和应用 简记_光耦的主要参数及应用_土豆19891021的博客-CSDN博客_光耦的主要参数 好文。 光耦的主要参数及分类都有哪些？ (baidu.com)。 详解光耦的重要参数——CTR值 - 百度文库 (baidu.com)。 光耦参数的理解 - 百度文库 (baidu.com)。 几种常用的光耦反馈电路应用 - 百度文库 (baidu.com)。 自恢复保险丝 在 额外文档/具体器件选型/自复保险丝基础.pdf。 晶振 在 额外文档/具体器件/选型晶振的选择.pdf。 .etc ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:3:12","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1.25 硬件测试规范化 硬件测试（或称可靠性检验）的指标条目、每个项目的测试步骤和测试报告等规范化，还可以包括优化点、解决思路和方案，长期总结与方案的反馈校正等等。 （这条目前对于我个人是空白比较多的，以后慢慢积累）。 电源的测试项 具体文档有 \\额外文档\\测试相关\\电源测试方法.pdf。 包括开关电源和线性电源；每一项都含有最小值、标称值和最大值与单位和测试条件。 输入、输出的电压、电流范围；效率；工作温度范围； 纹波/噪声； 输出启动过冲；启动上升时间；输出关机过冲； 短路保护（过流保护）； 温升；温度考核试验（高低温环节循环测试）； 电压、负载调整率； 电压裕量；电流裕量； 体积限制；成本限制；材质和外观（比如铝壳黑漆）；引脚排布； 最后加上我个人要求的保护完善程度：防反接，输入、输出的电压、电流过大保护，EMC合格，防电子干扰等等。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:4:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1.50 元件手册的准备 在画原理图和 PCB 之前应该先把所有用到的器件的手册准备好。找器件手册的地方主要有以下几个方法： 芯片所在官网。有的芯片的官网进去太慢或者不提供手册，就略过此法。 TI 模拟 | 嵌入式处理 | 半导体公司 | 德州仪器 TI.com.cn。 ADI ADI | 混合信号和数字信号处理IC | 亚德诺半导体 (analog.com)。 NXP 恩智浦半导体官方网站 | 主页 (nxp.com.cn)。 Infineon 英飞凌——半导体与系统解决方案 - Infineon Technologies。 ST 首页 - STMicroelectronics。 MPS MPS | Monolithic Power Systems 芯源系统有限公司。 ON 半导体和集成电路器件 (onsemi.cn)。 等等等等，更多详见 0.5 电子类网站收集 小节。 大型商城。 立创商城 立创商城_电子元器件采购网上商城_领先的现货元器件交易平台-嘉立创电子商城 (szlcsc.com)，直接搜芯片型号，型号比较全，可以下载到手册和封装。 云汉芯城 云汉芯城ICKey.cn_电子元器件采购_BOM配单_SMT贴片_PCB打样。 等，更多详见0.5 电子类网站收集小节。 芯片手册搜索网。 ALLDATASHEET.COM - Datasheet search site for Electronic Components and Semiconductors and other semiconductors.。 netCOMPONENTS 电子元器件查询。 搜索替代型号 道合顺大数据infinigo官网-国产芯片替代查询,datasheet规格书下载,电子元器件IC交易网上商城，一款专门做国产替代芯片查询的搜索引擎，输入芯片型号就可搜索出国产替代芯片型号。 以下网站的收录型号相对较少。 半导小芯-芯片查询工具_芯片替代查询_数据手册查询_规格书查询_datasheet查询_IC查询 (semiee.com)。 丝印反查 芯片丝印反查网 - IC芯片丝印,IC芯片代码,IC芯片印字,IC芯片顶标,SMD code,marking code,top mark (smdmark.com)。 Datasheet,Datasheet下载,电子元器件查询网-datasheet5.com。 datasheet-PDF中文资料大全-电子产品世界 (eepw.com.cn)。 EasyDatasheet | 次世代元器件搜索引擎。 等。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:5:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1.75 元件原理图和封装的准备 法一：淘宝大法，针对基础器件库。淘宝上有很多卖封装的，也不贵，买一次一劳永逸真的划算，如 源创客 的等。 法二：开源大法，扩充器件库。如： issus/altium-library、KitSprout/AltiumDesigner_PcbLibrary。 RedCommissary/altium-library: Component’s library for Altium Designer (github.com)。 嘉立创SMT (JLC_SMT) - Gitee.com。 AD_SCH_2D_3D_Libraries: AD原理图库、2DPCB封装库、3DPCB封装库 (gitee.com)。 Queeneren/AD_Library: 主要是AD软件的原理图库和封装库，不断更新ing (github.com)。 等等。 法三：原厂大法，特殊器件针对性下载。选定大厂的芯片后，一些大厂官网会直接提供该芯片对应的原理图和 PCB 封装，如 TI 等大厂官网对应 IC 页中寻找提供的 PCB 封装进行下载。 举例：如在 TI 搜索器件 CSD18540Q5B CSD18540Q5B 数据表, 产品信息与支持 | TI.com.cn ，在页面下面找到 CAD/CAE 符号 一栏，其下有下载一栏，点进去会跳转到 Ultra Librarian For TI 网站中的封装选择页面，再点击 Choose CAD Formats \u0026 Download 按钮，在下一个页面中在 Choose CAD Format(s) 中选择 Altium Designer，然后在 Symbol Pin Ordering 选择 Functional ，再点击 Submit 即可下载封装数据文件，接下来在 AD 软件中使用该封装数据生成封装文件，步骤参考 Ultra Librarian Altium Designer Import。 其他芯片大厂（如 ST 等）的具体芯片型号封装的获取步骤类似。 AD 21 新版软件里面 如何优雅地服用AD 21的在线元件库_哔哩哔哩_bilibili。 法四：经销商/三方大法，针对性下载。如在： 在 Component Search Engine: Free Symbols, footprints, \u0026 3D models 搜索器件并下载封装。 还可以在 AD 软件（AD 17 及以上版本）内安装 Altium Library Loader 组件来脱离网页直接搜索器件并下载器件原理图和封装，如下图所示： 安装和使用的步骤 Altium Designer PCB Library - FREE - Footprints - Symbols - 3D Models (samacsys.com)； 下载地址 Altium Designer Loader Download (componentsearchengine.com)； 桌面版本（Library Loader）下载地址 电子元件搜索引擎 - 免费获取原理图符号、PCB封装和3D模型 (componentsearchengine.com)（在这个网页里翻到最下边可以看到下载按钮）； FAQ（比如遇到安装不成功等问题看这里） Altium Library Loader FAQ (samacsys.com)。 上面所述的 Altium Library Loader 软件安装包 已经离线在 /PCB LOGO-画法集合-PCB工具-规则文件/LibraryLoaderSetup2v49.msi.zip。 另外，在 贸泽电子 搜索器件并点击下载封装后会跳转到 Component Search Engine 网站，下载步骤同理。 电子器件商城。如立创商城自己维护的库，在立创商城搜索器件后可以得到 立创 EDA 的器件原理图和封装，导出到 Altium 即可，具体步骤参考立创EDA元件转换为AD库封装(Altium Designer)_Mark_md的博客-CSDN博客，如何将嘉立创的原理图封装导入到AD20?，需要注册登录。注：网页端的 “立创 EDA” 导出器件的 AD 格式为 SCH 和 PCB 的文件格式（SchDoc、PcbDoc）而非库文件格式，PCB 文件里面的封装可以直接复制到自己新建的 PCB 库里面，但是 SCH 文件不能复制到自己新建的 SCH 库里面，对于 SCH，可以点击 Design-\u003eMake Sch Library 即可生成 SCH 库文件，打开新生成的 SCH 库文件，里面的器件的每个 端口 均可编辑且可以复制到 自己的 SCH 库里面为画原理图而调用；若立创 EDA 导出的原理图文件内包含该器件的多个 Part，这时点击 Make Sch Library 只能生成其中一个 Part 的原理图库，但一样的，只需分别将每个 Part 都 “Make Sch Library” 一次，然后分别复制到自己新建的原理图库的器件的各个 Part 页里面即可（文字描述有些局限，意会吧）。 在 Ultra Librarian 搜索并下载封装 Free Altium PCB Library Online for Footprints \u0026 3D Models | Ultra Librarian，需要注册。如果下载到的封装数据是 CAD File（.bxl）类型的，那么通过 UltraLibrarian 软件 生成 AD 封装步骤参考使用ULIB+Altium Designer绘制元件原理图及封装_dodwind的博客-CSDN博客， 利用UltraLibrarian生成Altium designer原理图、PCB封装_fpga_start博客-CSDN博客，Ultra Librarian下载与安装使用教程_chengoes-CSDN博客，UltraLibrarian 软件下载链接。 最新发现一方法：DigiPCBA 这也许是最全、最完整的封装库资源。具有器件封装库及器件参数信息。 (qq.com)。 官方 DigiPCBA是将 PCB 设计、MCAD、数据管理和团队合作相结合的云端电子产品设计平台。| DigiPCBA。 如何看待DigiPCBA这个现在特别火的EDA云平台？ - 知乎 (zhihu.com)。 【DigiPCBA】使用DigiPCBA创建和复用PCB封装-软服之家 (ruanfujia.com)。 是一个硬件协作服务提供的平台 解救PM于水火的竟是一个免费的平台——DigiPCBA-软服之家 (ruanfujia.com)。 法五：以上方法都没有，是特殊的器件，可以自制。对于原理图，一般元件的引脚和其划分不会特别复杂，应该很快就能画好；对于PCB 封装，常见的可用 AD 的 IPC 自动创建常用封装工具，先选择封装类型，再根据手册设置各种长宽参数，自动生成PCB封装以供使用，不常见的那只能最后的最后才自己画啦，按照芯片手册提供的封装规格，尺寸的单位看准了。 至于 3D 模型若没有，简单的可在 AD 的 PCB 库中的元件上添加 3D 实体（通常在机械1层）自己画，复杂的可去： 找3D模型和导入的一个教程。 IC封装网-行业IPC标准化的元件库及PCB封装库资源下载平台 (iclib.com)。 3D ContentCentral - 免费 3D CAD 模型、2D 工程图和供应商目录。 白嫖 立创 EDA 专业版（且为在线版） 的 3D 封装，如何下载立创EDA的3D封装？后悔没有早点发现这功能〒▽〒_ 哔哩哔哩_bilibili。 等网站下载。 up 北冥有鱼qzs 的 总结：【汇总】都有哪些免费下载PCB封装的网站或者软件（一）_ 哔哩哔哩_bilibili。 https://www.szlcsc.com/。 https://componentsearchengine.com/。 https://www.snapeda.com/home/。 https://www.pcblibraries.com/。 https://www.ultralibrarian.com/。 Altium 官方：https://mp.weixin.qq.com/s/U5_yQ3ezFTjMD5twE8RMkA。 凡亿PCB：www.iclib.com 。 3D封装: https://www.traceparts.com/zh。 https://www.3dcontentcentral.cn/Default.aspx。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:6:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"2 SCH 绘制规范和 AD 使用 个人规范，仅供参考。这里是针对 AD10 版本。 在使用 AD 时候，应先导入我的软件配置和 PCB 规则 Rules 文件，具体文件和方法说明在“AD 软件设置和PCB规则Rules配置文件”文件夹中。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH 中的快捷键 这里是针对 AD10 版本，AD20 以及以后版本 见 AD20 软件设计 一节等。快捷键可以自定。 本人习惯：鼠标滚轮 为 放大缩小 SCH 视图，鼠标右键拖动 为 平移 SCH 视图。 拖住器件时，按 x、y 为镜像翻转。 选中一根线，Ctrl+R，可以复制重复放置。 先点 Tools -\u003e Cross Probe，扫描所有原理图中相连的线，再 ctrl + 鼠标左击，点击一根线全局高亮。 原理图和 PCB 界面分别选择 Tools -\u003e Cross Select Mode，可以在 SCH 和 PCB 界面交叉选择，即同时高亮选中同一个元件，有利于定位。 … ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"最基本的 SCH 绘制过程 顶层设计/前置设置 统一的标题栏：每一页原理图都使用 A4 大小，标题栏使用模板文件比如./PCB LOGO-画法集合-PCB工具-规则文件/标题栏模板/A4 - 瞰百易.SchDot，将其复制到 AD20 安装目录下的 /Altium/AD20/Documents/Templates，然后在 SCH 界面的属性栏的 Page Options 的 Formatting And Size 中选 Template，下拉选择 “A4 - 瞰百易” 选项，在属性栏的 参数页面加上 标题、作者、版本号等等信息。 对电路原理图进行电源、主控和其他外设等模组分页绘制（这里仅为示例，没有用 层次原理图设计模式，详看同名章节）；第一页可以是目录页，附文详细说明等，可以再加上历史版本和改动说明；第二页可以是原理图框图；原理图第三页可以加上 电源轨框图 示意。后二者在原理图比较复杂的情况下，很有必要。 原理图第一页的 目录 规范示意： 原理图第一页的 历史版本 规范示意： 原理图第一页的 目录 和 历史版本 和 说明 兼有，示意： 原理图第二页的 框图 示意： 原理图第三页的 电源轨框图 示意： 可以用画框图的工具（draw.io/visio/Xmind 等等）画 该电路的 电源树图（同时也可以是电路框图），并标出 每一路/电源轨 的最大电流，放在原理图内。 层次设计/细节标注 统一的设计模式：原理图都使用 “层次原理图设计” 的模式。原理图的层次设计，每个原理图 是一个模块，也方便以后在别的地方直接复制和调用。详见 “SCH 层次原理图设计” 一节。 对于每一页SCH（这里仅为示例，没有用 层次原理图设计模式，详看同名章节）： 各个子模块用线格划分； 并在各个格子里写上子模块名称； 页面右下角写上本页名称，x / Total（x 当前页编号，Total 为总页数），作者和日期； 可在子模块旁边放上实物图片、官方推荐PCB图等方便画原理图； 信号/小电流线用细线，电源/驱动/大电流线用粗线。 原理图作画要布局工整，走线清晰，注释到位！ 每个器件的命名。在 Designator 写上准编号，电容是C?，电阻是R?，电感L?，芯片IC?，晶体管Q?，以此类推；在 Comment 写上器件的名称，是具体的型号。 型号名补全，查看器件手册的发货信息（Order information），确定具体的封装、温度范围和功能等的一个器件型号全名，在原理图的器件中写清，方便导出 BOM 表和采购。 原理图中元件标识的规范，供参考，不是必须。如下图（引自野火），电阻原理图的左上角、右上角、左下角和右下角以此标识 Designator、Comment（一般为阻值）、封装和精度，对于电容类似，对于电感要有饱和电流标识，其他器件同理。 更加全面的器件参数标识（来自 iphone 4s原理图）：电容包括标号、容值、误差、耐压、材质、封装，电阻基本同。 网络标识的命名规范。MCU/FPGA/SOC 芯片的GPIO引脚网络标号规范（特定功能引脚就直接标其功能名称即可，这里是针对繁杂GPIO网络标号的规范），这里只自己经验之谈： MCU：先标所有功能引脚比如电源、复位、BOOT、JTAG、USB、串行通讯口（UART、I2C、SPI、I2S 等等）、网口 等等，最后剩下的用做 GPIO，标法如下： \u003cmcu型号简称\u003e_\u003c外设英文大写缩写\u003e_\u003c外设的具体引脚名称 或者 功能\u003e，比如： STM32F4_TIMER1_PWM1、STM32F1_ADC_PA1、STM8S_GPIO_PA6。 实例（这里的尾缀就不加芯片 IO 的编号了）：基于 器件名（或器件类型）_IO性质（数字还是ADC）_IO名（管脚名）。常用于 MCU 的网络命名，其他非 MCU 器件非必须。例如，MCU_IO_KEY1、MCU_IO_TPS5450_EN、DRV_EN_BUCK 等，如下图示意，并且一组的 IO 旁边用黑色竖线括起来，用大括号图形括住最好。 FPGA：先标所有功能引脚比如电源、JTAG、PCIe 等等，然后剩下的用作 GPIO 的引脚，都按照序号顺序，在 FPGA 芯片上由上到下由左到右按顺序标，即可，即 IO1、IO2... 等等这样，要在这些分组的 IO 旁边写上它的 IO 电压。 当 FPGA 芯片用作核心板的时候，为了布线方便可以在插接件上（不按标号顺序）去调整标号，这样在查找 IO 的时候，只要确定了其编号就可以在芯片的原理图上直接找到它连接的 FPGA 引脚和它周围按顺序标号的引脚。 但是如果 FPGA 芯片是在一个大板子上，那么为了布线方便，就不得不在芯片原理图上调整标号的顺序了。 SOC：与 MCU 的大同小异。 注意点/建议/检查 一些注意点： 原理图中添加 线组（Net Class）和 差分对（Diff Pair）（尽量在原理图中将线分组完成，而不是在 PCB 中手动挨个添加，因为从原理图更新 PCB 时原来在 PCB 单独添加的线组会被清除），并在原理图中对电源线线宽规则、数据线线宽规则和差分线对均设置完成。原理图绘制完毕后要紧接着添加 线组（Net Class）、差分对（Diff Pair）和其它如电源线等单独添加规则，这些都尽量在 SCH 中完成（尽量不要在 PCB 界面中另设置，PCB 界面中只专注与画 PCB），方法详看 “SCH 线组和差分对设置” 一节。针对线宽的规则可以做依不同 线组（Net Class）设置不同线宽规则（Parameter Set 添加到线或 Blanket 上，并在其内添加 Rules，在 Rules 界面的左下角设置优先级（手动布线时低优先级不起作用））；针对高速线的规则要依 线组（Net Class）单独设置规则，详见下面的 “等长线/蛇形线设计” 小节；针对差分线要设置 差分对（Diff Pair）规则，详见下面的 “差分走线设计” 小节。 对于带有 总线或差分线对 的 数据输入\\ 输出的 模块，都在模块内 对其 数据输出处添加 线组（Net Class）和 差分对（Diff Pair），这样保证各个 模块 连起来时候可以相互兼容。差分线对的阻抗匹配 可以依靠 PCB 上走线时的 线宽和线距的 测算和设置，也要在原理图中 分别串个小电阻，以方便后期拿到实物可以再 改电阻 来对线路的 阻抗 进行微调。 对于电源模块，总是在输出处添加足够的 X5R/X7R 贴片陶瓷电容（可选：贴片固态电解电容 和 功率共模电感）和 TVS 管，输入处的滤波添加足，但是保护环节如 TVS 管为可选。在每个电源模块的输出处添加足够的滤波和保护，连起来的时候可以相互兼容，也不浪费。详参 “保护机制” 和 “EMC 电磁兼容设计” 等小节。 对于有极性的器件（DIO、BJT、MOS、有极性电容等）要在原理图中露出器件引脚的数字号，并仔仔细细检查引脚是否均正确（在器件的 Component 窗口左下角 Pins 里面对引脚编号打对勾表示显示出来，在 PCB Model 里面的 Pin Map.. 里面可以交换引脚直到正确）。 初次研制阶段，可多用 0 欧电阻、磁珠和跳线帽等，留出可以可测试、可断开和可配置的地方，方便逐个电源域、逐个模块的测试电流、功能裁剪等。比如加在电源出口，初次上电前可以先断开，不给后面的的电路供电，上电后测量电压和纹波，合理后，即可再接上，或者可以在此缺口直接测量电流。 原理图画好后该给各个元件建立唯一编号。打开“工具”-\u003e“注解”，点 Reset All ，再点“更新更改列表”，最后执行“接受更改”。 对原理图进行编译和查错。依次点 “工程”-\u003e“Compile Document” 和 “工程”-\u003e“Compile PCB Project”。没错后即可导入PCB。 原理图中一些器件 尤其是接口件，旁边放上实物图，图片设置为内嵌型。可以通过 “放置” 来导入图片到原理图内，也可以从 剪切板 直接复制出来（比如截图后复制、word/excel/ppt 里面直接复制 等等）。 **注意！**更多常用技巧总结在 4 SCH-PCB 设计规范 章节里。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:7:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"3 PCB 绘制规范和 AD 使用 个人规范，仅供参考。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"板层标识定义 Top Overlay 为丝印层。 Top Solder 为开窗层。 Keep-out Layer 为板边界。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB 中的快捷键 这里是针对 AD10 版本，AD20 以及以后版本 见 AD20 软件设计 一节等。快捷键可以自定。 本人习惯：鼠标滚轮 为 放大缩小 PCB 视图，鼠标右键拖动 为 平移 PCB 视图。 q 为单位在 mil 和 mm 之间切换。 拖住器件，按下 L 切换器件所在层。 Ctrl+鼠标左键点击一根线为高亮此线，点右下角“清除”清除高亮。 按住 Alt，鼠标在板子器件上移动，会显示器件轮廓。 Shift+s：为高亮所在层，重复操作取消高亮。 处于布线状态时，shift+空格为改变线类型，空格为改变线凹凸。 Ctrl+g：为选择切换栅格类型为线或点。 Backspace 为布线时回到上一步。 线状态下按*（乘号）为带过孔换层。 Ctrl+m：为测量长度。 Ctrl+左键点一下对正在布的线完成自动布线连接。 Ctrl+h：再点一根线会全选之，然后 del 删除整根线。 Shift+h：PCB 的左上角状态栏是否显示。 Shift+g：PCB 左上角状态栏是否固定不动。 键盘上边数字“3”为显示 3D 视图，数字“2”还原。 3D 视图中依次点“v”、“b”为翻转板。 按 L 按键，在视图选项中隐藏相关元素，比如隐藏覆铜（Polygons）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"最基本的 PCB 绘制过程 除了下面的内容，还要全程符合 4 SCH-PCB 设计规范 章节的内容和经验。 如果有双屏幕的话，在画 PCB 的时候我一般会把原理图视图放在左屏（在 AD 软件中将原理图标签拖过去就是），PCB 视图放在右屏，或者相反，这样双屏左右对照着看和画，不用来回切。 前置设置 先定义PCB规则。点开“设计”-\u003e“规则”，主要设置线宽范围，元件最小间距，焊盘的开窗范围，默认过孔尺寸，覆铜类型为直接连接等。 过孔尺寸：焊盘比孔至少大6mil。例如最小孔直径为12mil（0.305mm），焊盘直径至少18mil。更多 PCB 生产 工艺 参数 看 本节后面 “打板” 一段。 本规范已经有 AD 的 PCB 的 规则（Rule）模板，就是按照 上面的 工艺参数 来的，新建 PCB 文件后导入即可，在 PCB 文件中导入 AD20 的 PCB Rules 规则配置文件，参考 “7 AD 导入导出配置文件” 章节（AD的 PCB规则（Rule），最主要的几个就是按照 PCB 厂家的最小加工能力来改参数，比如 嘉立创PCB工艺加工能力范围说明-嘉立创PCB打样专业工厂-线路板打样 (jlc.com)））。 确定板尺寸，划定板形。在 Keep-out Layer 层绘制板边界闭合线，然后执行“设计”-\u003e“板子形状”-\u003e“按照选择对象定义”。 放置 PCB 原点到 PCB 边界的左下角。依次点击“编辑”、“原点”和“放置”，然后放置原点。 把每个模块包含的所有元件移动到一堆。 首先开启交叉选择，分别打开在原理图和PCB界面的“工具”-\u003e“交叉选择模式”选项。 在原理图界面中，选中一个子模块内所有器件，再到PCB界面，点“排列工具”-\u003e“在区域内排列器件”（这个经常用，可以设置快捷键，比如 shift+q），在空白区域内拖出一个矩形，此子模块所有的器件便都堆在此矩形区域内。 PCB中显示元件的原名（此步骤非必须；此步骤可以放到最后去做，找缝隙和空白的地方放下器件标号的丝印）。 随便选中一个元件，右键点开“查找相似对象”，都是“any”情况下点“应用”，此时所有器件已全选，再点“确定”，出现“PCB Inspector”窗口，在其中取消选中 “Show Name” 或者 “Show Designator”，打开选中 “Show Comment” 即可。 PCB Inspector 对于多器件批量改属性特别好用。选中要统一修改的器件，然后按 F11 调出 PCB Inspector 窗口，然后在 PCB Inspector 窗口改属性，所选中的多个器件就一同更改了。 多层板（多于 2 层的偶数层）。 在 PCB 里连按快捷键 “D”、“K” 调出层叠管理，或者在“设计”里面找“叠层管理”，或者空白处右击，“选项”里的“层叠管理”。 多层板的推荐板层分布图在“PCB 布局布线规范”章节里。 注意内电层在拼板的时候网络会丢失，暂时没有简便的办法。有内电层在需要拼板的时候，建议这样处理：先把PCB文件直接复制一个，命名为“xxx_不含内电层版.PcbDoc”，然后打开此文件，执行以下步骤： 先把内电层的分割线都删掉，然后 D K 快捷键调出板层管理，把内电层（负片层）删掉，换为普通层（正片层）。 然后在新的普通曾里按照原来分割线的形状覆铜，网络选择跟原来一样。 四层板举例： 在“层叠管理”中，在中间添加“Signal1”和“Signal2”两个信号层，或者添加“GND”和“VCC”两个内电层(Internal Plane)； 前者的信号层可直接布线。后者的内电层特性为负片，即布线的地方不铺铜，什么都不画的时候是一整块铜皮，专用于电源划块，即内电层分割；双击一个封闭区域可设置此区域覆铜连接的net。 信号层和内电层可以各有一个，混搭组成四层板，这样内电层专走电源和地，还多了一个信号层。 其他注意点：画线不要用交互式走线，要用工具栏中的“应用工具”的“走线”等功能；典型内层厚度为1.4mil；通常采用默认的 Layer Pairs（层成对）模式；不允许在内电层上布置信号线；内电层不同区域之间的间隔宽度不小于 40mil。 典型四层板板层分布为（由上到下）： 信号层 - 内电层（GND层） - 电源层 - 信号层（把信号层露在外面是为了好实物修改，也可不这样）； 信号层 - 内电层（GND+VCC层）- 信号层 - 信号层。 将在线 DRC 打开：首选确保 AD 软件设置界面里面的 PCB Editor 里面的 General 里面的 Online DRC 打勾，再 打开 DRC 界面（Tools -\u003e Design Rule Check），在 Rules to check 里面的 Electrical 和 Routing 和 Placement 里面的全部打勾，其它选项的勾选视情况而定。 布局布线 元器件布局。 除了较大的插件和较少的芯片，可以将其余的阻容感以及二极管（RCLD）的标号和器件名均 隐藏/不显示，再去布局，等布局、布线都完成之后再显示这些器件的标号再专门摆一遍标号，没空间就摆远一点再用箭头指引，密集的按照器件的布局在一片空白按照对应位置关系摆标号丝印再用丝印线围一圈（业内惯例做法）。 ！数模分离；功率驱动和信号处理分离；高频低频分离（尤其是高频数字部分和模拟部分之间做地线的隔离（单点接地、磁珠分隔等），且布局上空间的分离）。 ！器件布局和走线推荐，优先参考 IC 的数据手册。 ！根据主信号流向摆放主要元器件。 布局的好，走线容易，布局不好，走线困难。 先大后小，先难后易，均匀分布，整齐划一。 按照板功能区域的划分，理清整板上电源、信号的流向，先摆接口插件、主要芯片等的大致位置，再围绕其摆放阻容等小器件。再微调，并锁住接口器件和主要芯片等尺寸大的器件的位置。 间隔充分，模块独立。间隔充分，即高压、低压区域之间要保证 1~2mm 以上的距离，干扰源和敏感区域相互远离，发热源（电源、测流电阻等）要给予散热空间（在 PCB 板上挖空一定区域增加透风，或预留散热器件的安装空间）并摆放在出风口附近等。元件的放置要便于调试和维修。大元件边上不能放置小元件；需要调试的元件周围应有足够的空间。 整齐美观，有规律。 考虑 PCB 板 在机箱中的位置和方向。 主要元器件在 PCB 中放好后，锁住其位置（锁住的元件通过 双击 来再选中）。 更多规范请参考 “4 SCH-PCB 设计规范” 章节的内容。 布线。在 布局 阶段进行粗布放，布线的时候再进行精细调整，为 器件之间保持合理间距、更方便布线等。 除非可以混过去的项目，否则坚决不用自动布线（你晓得）（除了用ActiveRouting走内存、总线等线除外）。 先不手动布地线，地线的布线在下一小节 “后续工作和润色” 中用覆铜和过孔解决，可以先隐藏地线（AD 10 的方法现查）。 对于两层板而言：先走电源线，再走信号线；对于四层板而言：摆好器件，先划分好内电层区域，再走电源线，再走信号线。 确定整个板上大部分走线和过孔的规格，即 各类线的粗细和其过孔孔径 都提前定好。比如信号线均走 4~10mil，功率线为 20mil~60mil 不等，信号线过孔 4/10mil、8/16mil、12/18mil 等，功率线过孔 20/28mil。这些都要提前确定好。关于 线宽、过孔孔径 与 电流之间的关系 详见 “4 SCH-PCB 设计规范” 里面的 “幼稚园级” 一节。过孔不要 密集/紧挨着 排列，相互之间保持一定间距，否则加工易出现 钻孔披锋/金属披锋/铜皮倒刺。 电源线足够粗，功率走线必要时考虑开窗加锡。功率走线可以用覆铜来布线，然后原地复制粘贴一个再换成开窗层，得到整块覆铜的开窗。 走信号线时，模拟信号、高速信号和时钟线优先布线，尽量短。电流和地路径不形成环。即 电源、模拟小信号、高速信号、时钟信号和同步信号等关键信号优先布线。 关键信号、模拟信号、高频线等等尽量用曲线走线（另外，曲线也蛮好看的），尽量采用菊花链拓扑形式连接而不是总分式；其它的数字低频电路避免直角、锐角、环形、电压/流快速变化的线（尽量短、避免环形）可不用曲线快速地走完。尽量避免信号线形成环路、尽量使环路面积小。 过孔尽量避免在焊盘、丝印上面（酌情考虑，不是必须）。 检查布线完成情况：工具栏 “Report”，“Board information”，勾上 “Routing information”，点 “Report”，新页面中查看布线的完成情况。如果还差最后几根不容易发现的线，在 PCB 页面中以 shitf + s 显示单独层来查看未连接的线。 查看 有多少个 pin：原理图界面，找到 tools 下面的 parameter manager，只选择 pins 选项，点确定即可查看有多少个（以 xxx objects 显示数量）。 检查不要超过PCB加工工艺指标，重点在 线距（JLC为 0.1mm，尤其是蛇形线容易超）、线宽（5mil 以上）、过孔直径和孔焊盘直径（8/16mil 以上）、丝印层字符大小（60mil 以上）等等。 更多布线规则请参考 “4 PCB 布局布线规范” 章节的内容。 AD 10 的等长线/蛇形线设计： 画法参考文档 ./PCB LOGO-画法集合-PCB工具-规则文件/AD10教程/AD10 蛇形等长线的画法和规则设定.pdf； 先走好线，然后等长线都加到一个网络，按T R，选择最长线确定，移动鼠标拖蛇形线。 快捷键：“1、2” 改弧度，“3、4” 改间距，“，、。” 改绕长，在左下角导航选 “PCB” 窗口，可见加入网络的要等长","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:8:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"3.5 AD20 SCH \u0026 PCB 常用设置 这里没有说到的都与上面 2 SCH 绘制规范和 AD 使用 章节中的一样。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"AD20 软件设置 改中文界面：AD20 界面右上角的设置图标，选 “system”，选 “General”，选 “Use local resource”，重启软件。但建议使用全英文。 窗口找不到：AD20 界面右上角的设置图标，选 “system”，选 “View”，选 Desktop 中的 “Reset”。 自定菜单项的快捷键：按住 Ctrl 键点击所选功能项，打开 Edit Command 窗口，并设置快捷键，注意不要与已有快捷键的提示（Currently in use by）冲突；取消快捷键：在快捷键选项框中下拉选择 None 即可。 将 AD 软件的线标适用范围改为“分层级的（Hierarchical）”：Project，Project Options，里面的 Options，在 Net Identifier Scope 选择 Hierarchical。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"AD20 快捷键 \u0026 绘制技巧 在拖动元件的时候按 “Tab” 键调出元件属性进行参数修改和设置等。 在原理图中器件的属性界面有 “Pin” 标签栏，进去可以选择显示/隐藏引脚标号和名称。 取消高亮：Shift + c，或者右键点 “Clear Filter”。 修改器件移动时的网格，SCH 为修改 “Snap Grid” 参数，PCB 为 ctrl+g 或者在属性中双击 “Grid Manager” 调出 Grid Edtior，修改 Steps 参数；PCB中修改 Steps 可以以准确、固定的间距放置多个器件。 跨图连接器 Off Sheet Connector，尽量不要用，这就像 C 中的 goto 一样容易混乱，要么设计成 层次原理图设计，要么设置网络标号为全局使用（选择 project-\u003eproject options-\u003eoptions，在 Net … Scope 中选 “Global …” 即可）。 … SCH 中的： 多个相似器件的批量修改，如所有电容的 Designator 修改为 “C?\"，或者统一修改封装等等：右击一个器件，点 “Find Similar”，把 Symbol Refrence 选为 same，或者其他选为 same，然后点 Apply，会高亮出所有相似器件，然后鼠标在空白处按住左键拖动框选所有相似器件，便可以在属性栏中批量修改属性，调出属性栏可以按 F11。或者手动单独多选要批量修改的多个器件，然后在属性栏中可以批量修改。PCB 中同理，可用于批量修改封装、修改焊盘/过孔等等，只是在 “Find Similar” 步骤中点 Apply 后相似器件会自动都被选中，直接在属性栏批量修改即可。 按住 shift 拖动一个元件，可以拖出一个复制元件。 原理图编译和查看错误：AD 20 是实时查错的，右下角点 Panels 打开 Message 即可看到，重新编译点 Project 里面的 Validate … 即可。 … PCB 中的：（注意，bug 记录会写在最前） AD 20 遇到 bug 记录：PCB 开始不先前先隐藏一些线（比如 gnd 等），然后走线，然后再在左边 “PCB” 面板 “All Net” 里面选择 显示全部线 有可能显示的线 还是原来 位置的 没有更新，这时 选择 “All Net” 之后 下面一栏会显示所有线，在下面全选所有线，右键 里面 ”Connections“ 先 选择全部 关闭显示，再开启显示，则就正常了。 AD 20 遇到 bug 记录：加泪滴时候，teardrop style 选择 line，选择另外一个 “曲线” 类型泪滴则会有毛刺泪滴！很恶心！ 更新 PCB 后会生成一堆 Room，通过 寻找 相同元件 来选中全部 Room 来一同删除而不用一个一个删。 切换 PCB 网格大小和网格类型：Ctrl+g；推荐在摆元件的时候 移动网格 改为 3 or 5mil，走线的时候改为 1mil。 隐藏覆铜：按 L 按键，在视图选项（View Options）中选择关闭覆铜（Polygons）显示；在视图选项（View Options）中还可以关闭 3D 模型显示，等更多选择。 禁止/启用自动吸附：Shift+e（多按几次再试试）。或者，拖动元件，按住 “Ctrl” 的时候器件不会吸附网格而自由移动。 切换三种布线模式（忽略，避开，推挤）：Shift+r。 把选中的器件排列到框里：“Tools”，“Component Placement”，”.. Within Rectangle\"；或者设置个快捷键，可以设置为 Shift+Q。 选择一整条连接的线：选择多条连接线的其中一段再按 tab 即可，这个对于任何线都有效；Ctrl + h 然后单击一条走线可以选择整条线上的所有，这个只对 wire 走线有效。 隐藏线或线类：点右下角的 Panels 里面，打开 名为 “PCB” 的面板，选择线或网络，右击选择 “Connections（连接）” 里面的隐藏即可。在这里也可以对线、线组或差分线对设置不同的颜色（打对勾就显示），来明显区分显示。 覆铜：选择好网络、选择移除死铜、设定移除小于比如 10mil 的铜片和选择 “Pour Over Same Net ..\"；移动覆铜后，要右键选 “Polygon Actions” 的 “Repour All”。覆铜的属性栏里面的 Actions 里面有重新覆铜、设置网络（再手动点一根要连接的网络的线）、前置/后置和修改（手动画线微调边缘）等。 挖掉一块覆铜：选 Polygon Pour Cutout 工具，在已经覆铜的区域画个框，然后重新覆铜 “Repour All”。 批量放过地孔：给覆铜添加或者围绕某个线添加，选 Tools 的 Via Stitching/Shielding，在里面设置孔连接的网络、孔分布和孔大小等信息，可以选择给整个板面均匀加接地孔（孔间距可以打一些防止孔过多了），也可以选择给信号线的周围围绕着加接地孔，比较方便。 只能选择某种类型要素而其他元素不能被选中，方便只修改某一类元素而防止误碰其他要素：点工具栏的 Selection Filter，哪一项打开哪一项就能被选中，反之不能被选中；一般在覆铜后可以把覆铜 Polygons 关闭使能选中。 调节 PCB 线高亮时候与背景对比的程度：点右下角 Panels，点进 View Configuration，在 View Options 栏中下面调节 Mask and dim，还可以调节 Object Visibility，可以把 覆铜 Polygons 的亮度调低，以区分覆铜和走线、焊盘。 板子镂空：先围绕要镂空的区域画 Keep-out-layer 闭合曲线，然后工具栏选择 Designer，Board Shape，Define Board Cutout，然后围绕刚才画的镂空区域的 Keep-out-layer 闭合曲线 画一圈。 2D 和 3D 视图切换，使用 2 和 3 按键时视图不会同步，使用 Ctrl + Alt +2/3 视图是同步的（暂时不知如何解决使用 2/3 按键是同步视图的）。 过孔盖油。如果发给 PCB 厂家 PCB 文件，可以选择过孔盖油然后由厂家设置，如果不想泄露 PCB 文件而发的是 Gerber 文件，则必须要先设置过孔盖油，否则发过去是默认的，默认过孔是不盖油的。选择全部过孔，打开属性栏 -\u003e 勾选两个 Tented。详见 Altium AD20过孔盖油，通过设计规则实现过孔盖油，简便实用不会造成遗漏出错_Mark_md的博客-CSDN博客。 多层板，我这里一般内电层（负片层）只用于地层而不是电源层。如果有电源层（或者大面积连接电源网络的覆铜），其边缘要内缩 1 ~ 2mm（40mil 以上）（20H 原则）。对于内电层可以设置让其自动内缩 详见 Altium AD20的四层板叠层管理、平面层20H内缩_Mark_md的博客-CSDN博客。 通过 selection filter 可以设置只能选中某一些 PCB 中的元素，比如不能选择覆铜： 在 PCB 定型之后，可以设置 全部不能选择，或者不能选择 Components，防止后面 查看 PCB 时候误操作。 … 器件原理图库绘制的技巧： 引脚名字上要加横线表示低有效：绘制器件原理图库，在名字的每一个字符中间加 \" \\ \" 字符即可。 快速添加各个引脚名：在一个器件原理图库的界面，其属性的 “Pin” 标签中，下面有笔形状的 “编辑” 按钮，点进去可以以表格形式编辑当前器件各个引脚属性。 每个引脚有属性，比如 I/O、Power、Passive 等等，可以如实设置，如果嫌麻烦可以一律设置为 Passive，这样连接时候不会报错。在 SCH 中可以改元件 SCH 的每个引脚属性、显示标号等，双击打开一个元件 Component 页面，左下角点 Pin 打开引脚属性设置界面，在里面即可更改。 .. 更多 AD20 快捷键参考./PCB LOGO-画法集合-PCB工具-规则文件/AD20常用快捷键总结（北冥有鱼）.xlsx。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"通用 AD 规范-今后尽量适用 导入 AD20 软件的配置文件，参考 “7 AD 导入导出配置文件” 章节。 统一的标题栏：每一页原理图都使用 A4 大小，标题栏使用模板文件./PCB LOGO-画法集合-PCB工具-规则文件/标题栏模板/A4 - 瞰百易.SchDot，将其复制到 AD20 安装目录下的 /Altium/AD20/Documents/Templates，然后在 SCH 界面的属性栏的 Page Options 的 Formatting And Size 中选 Template，下拉选择 “A4 - 瞰百易” 选项，在属性栏的 参数页面加上 标题、作者、版本号等等信息。 SCH 和 PCB 的基本设计流程 看 “最基本的 SCH 绘制过程” 和 “最基本的 PCB 绘制过程” 小节，其中的每一个句子和步骤 均要看过！ 硬件规划/设计框图/逐级细化确定可实施 -\u003e SCH 各个子页设计 -\u003e SCH 中设置线组/差分对/线上的规则 -\u003e SCH 顶层原理图设计/个子页模块的连接 -\u003e SCH 检查 -\u003e PCB 导入/设置规则 -\u003e PCB 器件布局和检查 -\u003e PCB 布线 -\u003e PCB 检查 -\u003e PCB 板面信息完善 / 打板准备。 设计时遵守的规范：按照下面 “4 SCH-PCB 设计规范” 小节中介绍的内容进行 SCH 绘制 和 PCB 布局布线 和 完善。 SCH \u0026 PCB 的检查：设计完之后的查错表格：首要确保 SCH \u0026 PCB 全部编译无错，接着检查每个元件的封装、封装 BOM 名称、线路连接、功率线加粗、PCB 上放置元件留出焊接调试空间、地平面覆铜和加泪滴；然后按照检查表格（Check List）检查一遍，参考 “SCH \u0026 PCB 检查表 \\ Check List” 一节。 … 准备焊接实物 PCB 的准备：AD20 中 PCB 界面右下角 Panels 里面打开 PCB List 栏，该栏的 顶部 左边 选 View All Objects，再在其 右边 选 Components，即列出所有器件并按照 Comment 排列，可以选中所有一个值的阻/容器件然后器件会高亮显示，并且 PCB List 栏的下面会显示被选中元件的数量，接着焊接这一值的阻/容器件，然后换下一波相同值的器件，以此类推。使用钢网和加热台快速手工贴片：如何快速高质量手工PCB贴片。 调试使其能工作，再测试性能。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH 层次原理图设计 进行原理图设计时，一般都是先设计系统的框图，自顶向下逐层细化。然后使用 CAD 工具进行绘制，先绘制好每一个模块，然后在顶层原理图将其一一作为模块相互连接起来。 一个比较全的示例看 “总线连接” 一节。 顶层以框图形式，方便原理图各个子系统部分模块、固定和规范化，也方便从顶层快速了解整个原理图工程。通常先把各个子系统的局部电路原理图画好，放置好端口 Port，最后在顶层做框图把各个模块连接。以下介绍的是自下而上的画，若是架构设计人员可以自上而下设计。 一个模块只用一页原理图，画好各个子系统电路模块原理图，并添加好 Net Label（局域级别有效），然后再添加各个模块对外连接的 Port，并填好 Port 的网络标号名字（可以与 Net Label 重名），输入输出类型； 新建一个顶层原理图文件，在其中 点工具栏 Design，点 Creat Sheet Symbol Form Sheet，选择一个子原理图模块，放置 Sheet Symbol，其中的 Port 和 Sheet 框图的大小均可调整，然后连线；如果子原理图模块更新了端口，在 Top 层的 Sheet Symbol 上右击，选择 Sheet Symbol Actions 里面的 Sync.. 同步即可。 在所有原理图都是平级的时候（即没有顶层 Top 原理图 SCH 的时候）：当单独使用 Port 或 Net Lable 时候，这两个都是全局作用的；当同时使用的时候，Port 是全局作用的，Net Lable 是局域级别作用的（即所在 SCH 页内）；从电源符号那一栏中拖出的（有 GND、VCC 等各种电源符号）的网络标号总是全局作用的，因为其名字都带 Port（或 Net Lable？）。~~但是当原理图有分层的时候，Port （包括电源符号的 Port）也变成局域级别作用，仅当在上级原理图中用线连接后才会连接。~~这句不确定，电源符号 Net Lable 总是全局作用的，所以每个原理图内的 电源和地 要互相不同，做好区分，比如 AD 模块 原理图内的电源 都标为 AD_Vcc，地都标为 AD_GND，其他模块同理都标为 xxx_Vcc 和 xxx_GND，然后用 Port 引出。 推荐将 AD 软件的线标适用范围改为“分层级的（Hierarchical）”，详看AD 20 软件设置小节。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH Variant 设置 NC 器件 AD Variant 设置用于在画好的原理图中设置一些不焊接的元器件，即 NC 器件，比较常用到。 在 AD20 软件原理图界面，点击 Project -\u003e Variants，打开 Variant Management 界面，其左下角 Add Variant，新的 Variant 这里规范命名为 “Variant of 实际打板”，确定并关闭后，工程目录会出现 Variants 目录，其下有 “Variant of 实际打板” 一项； 然后在原理图中，对要 NC 的元器件 右击，点击 Part Actions -\u003e Variants，新界面里面 对器件 设置为 Not Fitted，即对其 NC 了；在此界面的下边还有对 Variants 进行设置的选项，比如 NC 标识的样式等等。 工程目录有 Variants 目录，其下有 “Variant of 实际打板” 一项，双击切换到此项，然后到某个原理图页面，其下方有 “Editor” 栏，其右边有 “U_\u003c原理图名称\u003e” 栏，单击，即可看到被 标记为 NC 的器件。 其方法记录在\\PCB LOGO-画法集合-PCB工具-规则文件\\AD Variant 设置\\AltiumDesigner20装配变量Variant使用说明 .pdf文件里。 另一个详细的网络文章教程：(1条消息) 硬件工程师必备技能之Variant_地主家也没有余粮啊的博客-CSDN博客。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH 总线连接 看图自学。以下原理图源文件在\\PCB LOGO-画法集合-PCB工具-规则文件\\多层次原理图 总线连接 示例里。 Sheet 2 SCH 图： Sheet 3 SCH 图： Sheet 1 SCH 图：创建一个名为 SPI 的 Harness，且引出在其中心引出 Port 名为 SPI。 Sheet 4 SCH 图：引用 名为 SPI 的 Port，创建一个名为 SPI 的 Port，使用 Signal Harness 给该 Port 拉线，则该 Port 会自动变为 Harness 类型，双击该 Port 打开属性，修改 Harness 的类型为 “SPI”（该 “SPI” 名字即上图中 Harness 的名字）。 Top SCH 图： 注意，一个 sheet 的所有 port 都要加上，不能少。 PCB 效果： ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:6","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH 线组和差分对设置 原理图中添加 线组（Net Class）和 差分对（Diff Pair）（尽量在原理图中将线分组完成，而不是在 PCB 中手动挨个添加，因为从原理图更新 PCB 时原来在 PCB 单独添加的线组会被清除），并在原理图中对电源线线宽规则、数据线线宽规则和差分线对均设置完成。 添加线组（Net Class）和规则： （首先确保 工具栏—\u003eProject—\u003eProject Options—\u003eClass Generation 里面的 Gentrate Net classes 勾选，这样设置才能原理图产生线组 Class，软件默认勾选） Place 中选择（空白处右击选择 Place 或者 原理图界面软件上方工具栏选择 Place 或者在原理图上方的工具栏里面）Directives 里面的 Blanket，包围要添加一个线组的所有线（可以画成不规则形状，关键要在只剩最后一处连接的时候右击完成放置）；再在上述位置找到 Parameter Set，选择后 TAB 键修改参数，在里面 add 一个 Net Class 参数，并写上线组名，可以选择是否显示该参数，推荐 Label 名修改为 “Class _ \u003c线组名\u003e”，然后放置并连接到 Blanket 上面；再添加一个 Parameter Set，add 一个 Rule 参数，选择线宽项，设置线宽，最后放置并连接到 Blanket 上面。如下图所示，这样就将这一组线命名为 “I2S _ LINE” 并设置了线宽规则。然后从原理图更新到 PCB 即可。 如果要设置线组的线不在一块并且也不好用 不规则形状的 Blanket 全部包围住，那么就将这些线的线标单独拿到一块空白区域，然后围住即可。 在 PCB 中查看线组： 在 PCB 界面，右下角 Panels 点开 “PCB”，左侧即可看到 “PCB” 栏，里面即可看到线组。 在 PCB 界面，上方软件工具栏选择 Design 里面的 Classes 栏，里面即可看到线组。 添加差分对（Diff Pair）： 每一对差分对的线标有要求，前缀必须相同，后缀必须为 “_ P” 和 “_ N”，软件才会识别。 如下图设置。执行原理图更新到 PCB 操作。在 PCB 视图 中的 左边 “PCB” 栏里上面选择 “Differential Pairs Editor” 即可看见刚刚添加的差分对。也可以不画 Blanket 而在线上直接添加 Differential Pair 标识符，要写好差分对名称。 可以同时添加多组差分对，如下图所示，只要线标名字按照要求即可识别。 差分线对走线： 在 PCB 视图中，工具栏选择 Interactive Differential Pair Routing 在差分线对上走线即可，走完之后还可以用 Interactive Diff Pair Length Tuning 确保差分线等长。 更多差分线的规则设置看“差分走线设计”小节。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:7","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB 布局复制 手动按照坐标来布局复制 针对多个一样的模块，PCB 中器件摆放/布局都一样化。 先布局好一套模块，另外几套模块的位置可以乱，先放着； 打开 Panels 中的 PCB List，选择 View Selected Objects，再选 Components，再把上面布局好的一套模块的所有器件选中，这时 PCB List 中会显示所有被选中的器件信息表，找到表中的 X1 和 Y1，右击选择 Switch to edit mode，然后选中 X1 和 Y1 复制，然后选中另外一套模块的所有器件，在其 X1 和 Y1 上粘贴即可，这时两套是重叠的，不要取消刚才的选中状态，进行整体平移到两套不重叠，然后选中第一套模块的所有器件，在 PCB List 中复制所有的 Rotation，然后选中第二套模块的所有器件，在其 Rotation 栏粘贴即可。 按照多个相同 Sheet Symble 的自动布局复制 这种根据多个同样的 Sheet Symble，只要布局好其中一个，其它相同 Sheet Symble 的元件都自动布局复制。其方法在 \\PCB LOGO-画法集合-PCB工具-规则文件\\多个相同 Sheet Symble 布局复制\\Altium Designer 多个相同电路快速布局.pdf文件里。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:8","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB 差分走线设计 差分高速线概念、要点 差分线具有抗干扰能力强、信噪比高、辐射小和带宽容量大等优点，常用于高速链路设计。更多 信号完整性（SI）基本概念说明可见 SI/PI/HS/RF X 和 本科生级一节。 阻抗匹配概念简单入门 p.s 这几个都是入门好文 技术指导：阻抗设计说明 (jlc.com)。 画PCB板时阻抗设计的重要性 (qq.com)。 PCB板画废了，才知道阻抗设计这么重要！ (qq.com)。 阻抗匹配是差分线对的输出端、传输路径 和 接收端 三个位置的 阻抗 均相同，从而不会产生信号的反射。“信号源内阻与所接传输线的特性阻抗大小相等且相位相同，或传输线的特性阻抗与所接负载阻抗的大小相等且相位相同，分别称为传输线的输入端或输出端处于阻抗匹配状态，简称为阻抗匹配（引自百度百科）”。 如果差分线对的两根线不等长会怎么样：高速 PCB 蛇形线，等长线，差分对是咋回事，我们再做个实验_ 哔哩哔哩 _bilibili。 如果差分线对的阻抗不一致会怎样：做个实验告诉你高速PCB为什么要阻抗匹配_ 哔哩哔哩 _bilibili。 更具体的差分线阻抗匹配原理介绍 lvds匹配阻抗 (360doc.com)。 常见信号的阻抗需求 注意下面的信号线的阻抗和推荐线宽，不是电源线~电源线要看电流等再决定线宽。 做阻抗匹配通常为单端阻抗和差分阻抗，前者如 天线 RF（50Ω）、SDIO（50Ω），后者如下： 常见差分线的阻抗： 一般的高频差分信号线均为 85 欧姆 ~ 100 欧姆。 USB 差分信号线阻抗为 90 欧姆（参考设计：信号线 线宽 10mil，线距 6mil，地线和信号线距 6mil）。 PCIe 差分线为 100 欧姆（85 欧姆 到 115 欧姆）。 以太网 差分信号线阻抗为 100 欧姆。 MIPI 差分线阻抗规定为 80 ~ 125 欧姆。 LVDS、HDMI、SATA 差分线阻抗 100±15% 欧姆（参考设计：线宽 10mil，线距 6mil，每两组差分信号线对间距超过 20mil）。 这些 同 PCIe，物理信号线 都是 LVDS 信号线标准。 DDR 走线，尽量不走过孔、信号线等宽、线等距、满足 2W 原则（线中心间距不少于 2 倍线宽）、等长、保证阻抗匹配等。 RS422、RS485、CAN 差分信号的差分阻抗为 120 欧姆，一般在终端并联 120Ω 匹配电阻。 电视信号线 AV 线 是 75 欧姆。 AD 中添加和设置差分线对 输入端和输出端的阻抗从 原理图的电路和IC选型上就能定好，传输过程的阻抗调节有两种方法，设置差分线对的 线宽 和 线距 来产生一定的阻抗，或者差分线对 分别 串联 电阻 进行后期的调整。在 PCB 上走差分线对 需要先 严格的 测算和设置 线宽 和 线距 等，以达到目标阻抗。实际中，若在调试阶段，除了走计算好的差分线之外，还应该添加上 阻容感 元件 的位置用于后期调试的阻抗调整。首先要原理图中添加差分线对：步骤详看“AD 20 快捷键 \u0026 绘制技巧” 小节里面的 “SCH 中” 部分的 “添加差分线对” 部分！ 阻抗计算软件 TXLine TXLine_百度搜索 (baidu.com)。 Polar Si9000 [Polar Si9000_百度搜索 (baidu.com)](https://www.baidu.com/s?ie=UTF-8\u0026wd=Polar Si9000)。 PCB阻抗设计及Polar Si9000 PCB阻抗计算软件的使用_ qlexcel的专栏-CSDN博客 _polar si9000。 特性阻抗计算神器Polar SI9000 2021 V21.04 版本更新 (qq.com). SaturnPCBToolkit 小工具 对于该软件的介绍 PCB参数计算神器-Saturn PCB Design Toolkit下载及安装指南 8.02 更新 - 吴川斌的博客 (mr-wu.cn)。 本地离线包：SCH\u0026PCB 设计、计算和检查的工具和软件\\SaturnPCBToolkit。 嘉立创阻抗计算器 这里的步骤以 嘉立创 提供的计算工具和下单助手提供的阻抗生产选项为准。下面以 USB 差分走线（阻抗一般为 90 Ω）为例。 嘉立创提供的阻抗计算工具。 网页版：嘉立创阻抗计算 (jlc.com)。 手机上：下图。 嘉立创下单助手的 工艺信息 一栏选择 “需要阻抗”，并选择层压结构（一般为第一个 JLC7628）。 在 PCB 的 规则 Rules 中，点进 DiffPairsRouting 栏里，改差分走线的 最小间隙和优选间隙 为步骤1中指定的（7 mil），最小宽度、优选宽度和最大宽度 改为步骤1中指定的（9.72 mil）。 在 SCH 或 PCB 中添加差分对，一个详细步骤文章，另一个详细步骤文章，然后在 PCB 页面中打开 panels 的 PCB 栏，在其中选择 Differential Pairs Editor，可以看到差分对的名称以及其具体的每一个差分线。 在 PCB 界面中选择 “交互式差分对走线” 进行走线。 各差分接口布线要点 更多 见本文的差分布线规范的小节如 “本科生级” 里面的等。 每一组 LVDS 内的两根信号线要 “紧耦合” 和 “等长” 处理，当两者不可兼得时，应该优先考虑等长。“紧耦合” 即两根信号线间距尽量一致（使 共模抑制比 CMRR 最大）。 控制/设置阻抗所要求的线宽、线距等。 差分线对尽量走直线，拐弯时走圆角。 差分线对的接收端的电阻要靠近接收管脚。 线路途径元件尽量使用表贴元件，线对尽量避免过孔，若需要过孔则一对差分线上的过孔数量要一致。 PCB 中走差分线对要保证等长、等距和过孔数量一致，其中必须要满足等长（要保证相位匹配，等长的优先级最高）而另外两项可以妥协一点。差分线的等长要尽量让两根线靠近（等长线的蛇形线的凸起要小），而且尽量在靠近发射端的一边将等长处理完毕。 USB 走线要点 参考： USB走线布局，不要搞错了！ - 知乎 (zhihu.com)。 PCB设计笔记(一)——USB布局布线设计_usb走线_南林电工帆的博客-CSDN博客。 一般 USB接口： USB接口一定要靠近板边放置，便于插拔。 串阻、串容以及ESD器件靠近USB接口放置，USB接口接线先通过ESD器件，再供给后级电路，放置静电浪涌电压对后级电路造成影响，也要遵循先防护后滤波的原则，同时器件要与USB接口留有一定的距离，放置手工焊接时器件对接口焊接造成影响。 终端匹配电阻应该尽可能靠近连接器放置，电压稳压器也应该尽可能靠近连接器放置。 USB的数据差分控制90欧姆阻抗，需要包地处理，总长度不要超过1800mil，对内长度误差控制在5mil以内，USB差分走线时尽量避免打孔换层，在每次打孔换层的附近需要放置一对回流地过孔尽可能缩短走线长度，优先考虑对高速USB差分的布线，尽可能的减少在USB信号线上的过孔数和拐角，从而可以更好的做到阻抗的控制，避免信号的反射。 高速差分信号尽量走在同一层，避免出现跨分割现象。 如果USB定位柱接保护地(外壳地)，在进行地平面分割时需要与GND距离2MM以上，同时在保护区域内多打孔。 Type-C： ESD、共模电感器件靠近USB接口，放置的顺序是ESD-共模电感-阻容；同样也要注意ESD和USB的距离，留有1.5mm的间距，考虑后焊的情况。 Type-C 有RX/TX1-2四组差分信号，两组D+/D-差分信号 ，一共六对差分线，差分信号线要求至少紧邻一个地平面，两侧都紧邻地平面最好。 保证差分线的的线问距在走线过程中的一到致性，差分线要尽量等长，如果两根线长度相差大时，可以绘制蛇行线增加短线长度。 CC1/CC2是两个关键引脚，作用很多：探测连接，区分正反面，区分DFP和UFP，也就是主从配置Vbus，走线时面要加粗处理。 PCIe 走线要点 引自 pcie全面解析（PCIe接口学习笔记） - 百科 - 晓霜阁 (xiaoshuangge.com)。 为保证信号质量，要求PCB LAYOUT时保证： a． 完整的参考平面。 b． 信号间距不小于20mil。 c． 走线尽量走off-angle 线，或者是圆弧线。 d． 在换层的地方添加回流地via。 e． 尽量避免出现stub 的情况。 f． 如果PCI-e 信号线通过金手指进行通信，则金手指下面需要全部掏空。 尽量把差分对与对之间的间距拉开以减少串扰。 不同 PCIe插槽 之间距离不应高于 38cm，参考时钟传输延迟不高于2.5ns（虽然 PCIe 控制器件里 有 Deskew 进行 测量 和 时延/相位 的 补偿）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:9","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB 等长线/蛇形线设计 这里是针对 AD20 的操作。 PCB 界面的右下角 Panels 按钮里面打开 PCB 栏，左边 PCB 栏中显示 Nets，在 Net Classes 栏里面添加要等长的线的 Class 命和线。参考 “通用 AD 规范” 一节，线组在设计原理图的时候就要设置好，不推荐在 PCB 界面添加线组。 然后在 Rules 里面，High Speed 里面的 Matched Lengths 上右击新建一个规则，进去在 Where The Object Matches 栏里面的 第一个选 Net Class，第二个选 要等长的线的 class，然后在下面设置 Tolerance，容忍等长的误差，最好填小一点如 3 mil。 PCB 界面 工具栏 选择 Interactively Tune Trace Lengths 工具，从最短的线开始画线进行等长变化的区域；鼠标开始拉蛇形线的时候，按下 TAB 键，打开属性窗口选择 本线组中最长的那根线，然后继续拉线，这样当等长的时候鼠标继续拉蛇形线也不会继续增加长度了。 快捷键：“1、2”改弧度，“3、4”改间距，“，、。”改绕长，在左下角导航选 “PCB” 窗口，可见加入网络的要等长的线及其各自的长度；走线等长变化的区域可以调整，直接对等长变化区域选中的矩形框的四周拖拽，改变等长区域；删除等长，直接选中线的等长变化区域再按 del。 其它重要注意： 线距不要超过PCB加工工艺指标，JLC 是 0.1mm，蛇形线有时候空间小会很密容易超。 查看信号的等长，而不是线的等长：等长需要在 Xsignals 里面看，因为 NET 里面的等长是没算串阻的距离或者是把到ESD器件的距离算进去了，是不准确的。如下图所示： ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:10","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB ActiveRoute 用好省时 AD18中高速信号等长线使用_t wx11213030422的博客-CSDN博客 _ad18等长布线。 关键步骤： PCB 界面的右下角 Panels -\u003e PCB ActiveRoute。 按住 Alt 并按住鼠标左键从右向左拖动 选择 全部要 ActiveRouting 的线。 选择在哪层布线，在 PCB ActiveRoute 窗口中的 Layers 区域选。如果线要走不同层，需要两个引脚端分别手动打好过孔，这里不会自动打过孔。 绘制布线 区域规划，在 PCB ActiveRoute 窗口中 Action 区域点击 Route Guide 按钮，然后在 PCB 里面 画 走线区域，键盘上 上下箭头按键 调节区域宽度。 执行 ActiveRoute 命令，在 PCB ActiveRoute 窗口中 Action 区域点击 ActiveRoute 按钮，执行 ActiveRoute 布线命令，软件左下角进度条 显示执行进度。 可以自动进行等长线、和差分线的走线，用时学即可，网上教程很多，这里不重复。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:11","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB 添加 LOGO 图案 下面给出 3 + 1 方法，第二种和第三种精度高，但第三种操作最方便且通用（你看，本文就是这么干货，口水话几乎没有）。 PCB Logo Creator 生成丝印图案的方法，具体教程 pdf 和所需软件在 ./PCB LOGO-画法集合-PCB工具-规则文件/创建-收集 PCB Logo 图形/PCB Logo Creator 生成丝印图案的方法.zip 里面。 LOGO 字体 添加 PCB 图案的方法，具体教程和所需软件在 ./PCB LOGO-画法集合-PCB工具-规则文件/创建-收集 PCB Logo 图形/LOGO 字体 添加 PCB 图案的方法.zip 。AD20 添加字体logo 视频教程 - 北冥有鱼。PCB个性logo设计-面包板社区 (eet-china.com)。 新版 AD 直接在 PCB 里导入 图形即可，AD21如何快速添加LOGO_ 哔哩哔哩_bilibili。当前在哪个导入，就会是那个图层的图形，导入的时候选择多大的框就导入多大！推荐这种！ 网友收集： 各种花活标志 - 立创EDA开源硬件平台 (oshwhub.com)，在 立创 EDA 打开此工程 然后导出 AD 格式 的 PCB 即可，最新离线在 文件夹 ./PCB LOGO-画法集合-PCB工具-规则文件\\创建-收集 PCB Logo 图形\\各种花活标志/ 里。 etc. ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:12","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"AD 更多高级功能罗列 杂技巧罗列 缩减PCB文件体积 Altium Designer PCB文件太大怎么办-百度经验 (baidu.com)。 AD20、21、22实用技巧教程汇总【20220315】 (qq.com)。 AD20如何添加字体LOGO AD20如何更改标题栏 Port和Netlabel的区别 AD20如何精确添加3D封装 AD20如何显示3D捕捉点 AD20如何自定义BOM模板 如何快速高质量手工PCB贴片 如何将嘉立创的原理图封装导入到AD20 AD20如何高亮显示元器件 61个AD20常用快捷键介绍 总结AD20常用规则设置 AD20铺铜相关操作技巧 如何计算走线线宽和过孔 AD20如何复制PCB布局 AD20如何在原理图中画虚线 AD20如何制作异形焊盘 AD20如何邮票孔拼板，V割拼板，添加工艺边、Mark点 【PCB拼板重新录制】使用AD20+华秋DFM进行快速PCB拼板 从大坝来看GND和铺铜到底该如何处理！ 如何使用AD脚本输出交互式BOM AD21如何调整铺铜间距 如何解决AD中拖动元器件，电气走线连接不显示的问题 【汇总】都有哪些免费下载PCB封装的网站或者软件（一） 【汇总】都有哪些免费下载PCB封装的网站或者软件（二） 如何解决交互式BOM显示不全的BUG AD21如何修改3D板子的厚度 AD21如何快速添加LOGO 如何解决交互式BOM显示不全的BUG【过程讲解】 芯片数据手册中的单词看不懂？英文差？试试这两个工具吧 AD重新定义PCB边框最容易犯错的地方! 如何下载立创EDA的3D封装？ Altium Designer PDN Analyze 利用Altium Designer自带PDN Analyzer对电源平面进行PDN实例仿真分析，超经典！_YIRender的博客-CSDN博客。 原理图对比和 BOM 对比工具 【硬件设计必备】原理图逐页对比工具 (qq.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:9:13","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"4 SCH-PCB 设计规范 本章 PCB 布局布线规范 主要包括 这几大部分：“幼稚园级”、“本科生级”（这两个是最基本的要领，分别讥称为 “幼稚园小朋友” 要会的 和 “本科生大朋友” 要会的，对号入座） 和 下面的 “各类型电路设计规范或要点”（这里分为多个子部分包括 运放、电源、地分割、EMC 等等）。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"幼稚园级 首要参考 “最基本的 PCB 绘制过程” 小节中的 “多层板”、“布局”、“布线” 等部分！ 走线没有锐角和直角拐弯（包括信号线和电源线）；可以走 T 型线，但其直角转角要做缓和的圆角过渡处理。 元件引脚下的焊盘上尽量不要放过孔。 功率线、信号线尽可能短，功率线要足够粗，必要时应开窗加锡，并且大电流线、电源线之间的间隔应大于30mil，内电层不同区域之间的间隔宽度不小于 40mil。 大电流、高功率的走线及其经过的器件应尽量按照能量流动的 “好走” 的路线布局和布线，尽量减少拐弯和跨层，让其一马平川的流动。 线宽和电流能力关系表：（参考：过 2A 至少要 30~40mil（约 1mm） 线宽）（40mil 约为 1mm，20mil 约为 0.5mm）（1mil = 0.0254mm，1OZ = 0.035mm ≈ 1.4mil） 过孔直径和电流能力关系表：（看工程实践一栏；孔径高于 0.5mm（约 20mil） 时，每增加 0.5mm ，电流能力增加 0.5A ） 推荐过孔孔径：（单位 mm） 信号线——0.3过孔 / 0.5外径（8/16mil 过孔），0.84A 电流； 弱电电源线——0.5过孔 / 0.8外径，1A 电流； 大电流(多个)——1过孔 / 1.5外径（30/40mil 过孔），1.5~4A 电流； 大电流（多个）——1.5过孔 / 2外径，2~5A 电流。 PCB走线与电流关系更多参考文档：./额外文档/PCB走线与电流关系.pdf。 多采用星形拓扑结构，少采用菊花链布局，缩短电源的公共回路。 关于电源： 电源变换元器件（如变压器、DC/DC 变换器、三端稳压管等）应该留有足够的散热空间，发热器件底部加一个或多个大孔径的过孔（接地或不接地）；干扰源（DC/DC 变换器、晶振、变压器等）底部不要布线，以免干扰。走线短、粗。 去耦电容（旁路电容）尽量靠近 IC 等器件的电源输入端，滤波电容可以放置在芯片的背面，靠近芯片的电源和地引脚；可选的，每一个去耦/滤波/旁路电容的接地端附近放一个过地孔，让电流顺畅泄放。 去耦电容的大小选择，应能够有效滤除电源轨中的典型纹波频率范围，对于开关电源一般几个大容量滤波电容（10uf ~ 100uf等），对于芯片输入电源的去耦、续流用的电容，一般一大（1uf ~ 10uf）和多个小（0.1uf ~ 1uf），或者从大到小多个容值（10nf ~ 10uf）电容的并联（在更宽的高频频带上对纹波噪声对地形成泄放通路）。电源芯片输入输出的大、小去耦/滤波电容，小的靠近芯片端。 开关节点（MOS 的 输出端）有严重的电场辐射，其铜箔应该最小化，并避开其他敏感电路。 留意差分信号（如 USB 和 CAN 的信号线、运放输入，电流采集的差分电压信号和晶振的差分时钟信号等）要注意线上串阻抗匹配的电阻，或设置差分走线（需要计算和设置 线距、线宽等）。 留意一些大功率的电源类等芯片下方有接地的 PAD（焊盘），不但要开窗裸铜，还要放一个或多个大的过地孔；其它高发热/高功率的器件同理；但要注意芯片地下的焊盘里的过孔孔径不要太大，减少其与芯片管脚短路的风险。 高度较高的两个器件摆放间隔一定距离而不要紧密排列，紧密的话不管 SMT 贴片机 还是 人手工 都不好下手 焊接 和 调试。尽量避免 器件的重叠布局，比如电阻放到数码管地下，返修和测量很不方便，可以在背面。 留下必要的测试点（开窗点），留螺丝孔。 丝印字符方向尽量在两个方向以内，避免人看的时候不断转板子。过孔尽量不要放在丝印上。 用丝印字符和图形 标识出从板子引出的 引脚 功能，接口说明，开关、拨码开关的功能表，LED 指示的功能等。 丝印层画出 LOGO、板子名称、板子版本号 和 防静电（手勿触碰）与高压提醒等标识。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"本科生级 基本绘板过程要点！请看 “最基本的 PCB 绘制过程” 一节的 7、8、9、10、11、12 设计要点，这些是规范的基本步骤！基本！ 一涉及到高速、射频，就要考虑寄生电容、寄生电感等电路板上的分布参数对于信号形状的影响！（比如 I2C 的上拉电阻多大，在数字信号频率较高时候，上拉电阻对寄生电容充电 就 让线路电压上升有一定时间，电阻越大上升越慢 就 改变了波形，这只是抛砖引玉，高速接口，仔细设计，板级电磁仿真，查看眼图，软件对其最大带宽进行压力测试等等 一系列操作） 器件布局相关： “最基本的 PCB 绘制过程” 一节的 “8 元器件布局” 设计要点。 减少一个电路回路所包围的面积，考虑从电源输出正极的电流出去开始一直到回到电源负极的整个路线，要这个路线形成的环所包围的面积尽量小。 对于变压器、扬声器、电感等会产生磁场的元件，布局时应注意减少磁力线对于印制导线的切割，相邻元件磁场方向应相互垂直，减少彼此之间的耦合。 元件的放置要便于调试和维修。大元件边上不能放置小元件；需要调试的元件周围应有足够的空间。 一个芯片的外围阻容元件应尽量靠近芯片，并尽量接近其所要连接的芯片引脚。例如，电源脚去耦电容靠近电源引脚，电源芯片的反馈电阻要靠近其 FB 反馈输入引脚。 晶振、继电器、开关电源等强辐射器件远离单板接口连接器至少 1000mil。 高压元件核线路之间要留有空隙，100V 以内至少留 1mm 间隔，线路和元件 与板边缘同理；若对于 100V 以上并且空间小不够开 大于 1mm 的间隙，那么可以做 1mm 宽的板挖空做隔离。 接口电路的滤波、防护、隔离器件、EMC和整流等应该靠近接口放置；如果接口处既有滤波又有防护电路，应该遵从先防护后滤波的顺序。I/O接口电路及功率驱动电路尽量靠近 PCB 板边缘，即大功率器件尽可能放在电路板边缘。 混合信号PCB布局设计的基本准则_模拟技术-面包板社区 (eet-china.com)。 热设计的几个原则： 器件的摆放要考虑通风散热的方便，要使得空气可以比较顺畅的从一边流向另一边并有效带走主要发热元件（电源芯片、控制器芯片、功率管、测流电阻等）的发热热量。 发热元件尽可能分散布置、均匀的放置，不要使热量堆积在一个小区域内。 热敏感元件（晶振、精密电阻、主控等）要远离发热元件并放置在 “冷” 区域（或发热元件的板面的另一侧），并置于散热气流入口处。 发热源（电源、测流电阻等）要给予散热空间（在 PCB 板上挖空一定区域增加透风，或预留散热器件的安装空间）并摆放在出风口附近等。 发热器件如电源芯片、功率管、测流电阻等，要在其下面加一个或几个大孔径的过孔（接地或不解地）增减散热。发热元件应有足够的空间以利于通风散热；热敏元件应远离发热元件。 多层板相关 时钟频率到 5MHz 或脉冲上升时间小于 5 ns（五五准则），则 PCB 板须采用多层板。 考虑板子尺寸、器件和走线密集程度、成本、抗扰和稳定性等，进行多层板划分，可以参考推荐多层板板层设置（很多 PCB 教程 和 书籍均有提到）。多层板的推荐板层分布图： 这里注意，并不必严格按照上图进行划分多层板的叠层，具体问题具体分析。 我的规范建议： 多层板的 第二层 和 倒数第二层（从上往下数）一般为整个地平面层；地平面层要保证大片的完整性，避免异形。 典型四层板板层分布为（由上到下）： 信号层 - 内电层（GND层） - 电源层 - 信号层（把信号层露在外面是为了好实物修改，也可不这样）； 信号层 - 内电层（GND+VCC层）- 信号层 - 信号层。 少量的层数时候，比如四层板，或者板子尺寸小并且走线密集，少一个电源层，就多一个走线层。但是在走线不太密集时候，两层用于走线够，那么两个内层就可以当作两个内电层分别连接地网络和电源网络（并分割），减小电源走线的阻抗。 每一个信号层视情况，与内电层的地分割同样的位置，加地网络覆铜，并打地网络的缝合孔（贯穿多层板的连接地网络的过孔）。 多层板中有内电层作为整个地平面时，尽量不要破坏 发出干扰的元件和芯片下方的 地平面的完整性，尽量不要有过孔等破坏地平面完整性。 多层板的关键信号层最好位于两个地平面之间，即其电路模块的上下层所对应的区域都用地平面覆盖。 电源平面应相对于其相邻地平面内缩 5H-20H（H 为电源和地平面的距离，若内缩 20H 则可以将 70% 的电场限制在接地边沿内，内缩 1000H 则可以将 98% 的电场限制在内）。内缩1~2mm（40mil 以上)。 相邻布线层的走线应尽量垂直；实在无法实现垂直而必出现平行的应互相远离，或时钟、总线、射频线等关键信号走线和其他同层平行走线应满足 3W 原则，3W 原则：线中心间距不少于 3 倍线宽（70% 的电场不互相干扰），还有更好的 10W 原则（98% 的电场不互相干扰）。小信号走线尽量远离大电流走线，忌平行，相距要 大于等于 2.0mm。 更多参考 详解多层PCB层叠结构 - 知乎 (zhihu.com)。 电源滤波电容的布线： 关于电容的选择可以看 “电阻，电容，电感” 一节。 更多电源内容见 电源规范设计 一节。 每个集成芯片（数字芯片、MCU等等，10MHz 以下的）至少要布置一个 1uf / 0.1uf 的陶瓷电容（MLCC）；对抗噪声能力弱，关断时电源变化大的器件要加高频去耦电容（高频的如数字电路、MCU，10MHz以上的等，可放置 0.01uf）；空间充足还可以在前面加高频去耦电容的情况下再给每个器件芯片加大电容/低频滤波/电源缓冲 的电容比如 10uf / 22uf 等（当然都尽量选择 MLCC 或 固态电容）。 去耦/滤波电容要尽量靠近芯片电源脚，每个芯片电源脚都配置上合理的电容最好；电容之间不要共用过孔；去耦电容引线不能太长。 电源输入端 和 电源输出端 放置大小不同电容的顺序，都是先大后小。 单个电容情况的布线：纹波电流要尽量全部经过电容的引脚。 多个电容情况的布线：纹波电流经过第一个电容产生的热量也比第二个、第三个多，很容易损坏，走线时，尽量让纹波电流均分给每个电容，走线如下图 A、B，也可用图 B 方式走线。 每个滤波、去耦电容的接地端旁边加过地孔（数量视电容容量而定，电源滤波的大容量电容则加一个以上），增加回流通路，减小回流阻抗。 敏感信号线/关键信号线 和 高频信号线/高速信号线 设计的几个原则： 同时也包括 最基本的 PCB 绘制过程 一节的 “8 布线” 设计要点。 各种 高速/差分总线 的阻抗匹配 和 布线 这一块详见 PCB 差分走线设计 和 SI/PI/HS/RF X 一节。 运放相关见 运放设计注意 一节。 1 敏感信号线/关键信号线： 必须保证良好的信号阻抗匹配。单端的信号有模拟和数字的收发端的阻抗匹配，如 AD 采集、数字电路、RF 天线 等，双端的如 差分模拟信号 和 差分数字信号 等 的 发送、传输、接受 三端 的 阻抗匹配。差分线对的阻抗匹配 可以依靠 PCB 上走线时的 线宽和线距的 测算和设置。 高速信号板、小信号板可以上多层板，有资料显示四层板要比双面板的噪声低 20dB。合理的元器件布局和布线也很重要。 关键信号线/高速信号线，走线的折弯越少越好，可用 45° 折现或曲线走弯，不能出现 T 形线。尽量避免信号线形成环路、尽量使环路面积小。 敏感信号线/关键信号线，其周围应放置多个接地过孔（宽度大于 50mil 地线或间距小于 300mil 的地孔）做包围处理，提供电磁笼的屏蔽作用，或叫包地处理。信号线（特别是关键信号线）换层时，应在其换层过孔附近设计地过孔。但同时也要注意高频信号线周围的接地覆铜和接地过孔带来的寄生电容可能影响信号波形/完整性，可以距离高频信号线远一些，至少 3-4w 原则吧。 敏感电路或器件（如复位、看门狗、高速/关键 信号线路等）远离单板各边缘特别是单板接口侧边缘至少 1000mil，或关键信号线距参考平面边沿的距离大于 3H（H 为线距离参考平面的高度）。信号线不能从变压器、散热片、MOS 管脚等中穿过。关键信号线 远离 高频线路/器件。高速/关键 信号线应该 远离 其它任何 线路或器件 至少 10mil 以上。差分信号线组相互之间至少远离 3倍 差分线间距 的距离。 高频元件一侧的 PCB 面上不要走线，应该大面积覆铜并加围圈的过地孔，在 PCB 的另一面可以布线。 除了地线，能用细线的不要用粗线（3W 原则的 W 会比较小，同时 串扰、寄生电容 等都会减小）。 2 高频信号线/高速信号线： 高速通信信号线（比如 USB、PCIe、LVDS 等等）的首要：等时 和 阻抗匹配。尽量减少阻抗不匹配；等长不是目的，等时而保证时序才是，线在过孔、内层、外层的速度都不一样。同组线尽量走同层，在同层绕；尽量保证 3-4w 原则，尽量减少串扰；尽量少过孔，同组线每根上过孔数量尽量相同。 高速信号线可以细一点，减少与地平面产生寄生电容效应 或 与其他线之间的串扰。并排走线之间减少串扰可以通过 增加信号线间距、减小平行长度、不同线组之间加入地线做空间上的分割。对于相邻层的走线同理应减少平行长度，尽量相互垂直走线。这些规则对于普通数据线可能根据实际情况宽松一些，但是高速时钟信号尤甚需要尽量按照这些规则。 过孔可能会引发信号传输线的阻抗突变，因此需要尽量减少信号线上过孔使用的数量，尤其是对于关键信号线，一个过孔大约带来 0.5pF/10pF 的电容效应。高频电路期间管脚间引线的层间交替越少越好。 无论是时钟线、信号线还是电源线，在 PCB上 的走线都应该尽量短，器件紧密排布以减少 PCB 上走线长度；而且时","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB 计算小工具 / 辅助设计小软件 电路\u0026PCB计算本地小工具 详见PCB LOGO-画法集合-PCB工具-规则文件\\SCH\u0026PCB 设计、计算和检查的工具和软件\\里，包括： 电路计算 Excel 表格合集！非常丰富。 PCB走线、过孔的电流计算。 DFM（可制造性设计）PCB检查工具。 SaturnPCBToolkit 工具集。 反激开关电源参数计算。 变压器设计软件 V1.2（用于自绕变压器吧）。 一键删除 AD的History 文件和 Previews 文件和 ProjectLogs 文件的批处理 .bat（将该 .bat 文件 放到 AD PCB 工程文件夹内，双击运行一次可以清理除了工程以外的临时文件）。 等。 零散电路计算工具网页 在线电子单位换算器 - Digi-Key得捷电子 (digikey.cn). 在线计算器_电子工程师在线工具 - 电子工程网 (eechina.com)。 LC电路频率在线计算器 (520101.com)。 合集，包括传函计算、闭环系统计算、运放电路、滤波器、滞回比较器、解方程等：Engineering Design Utilities (okawa-denshi.jp)，其内的滤波器仿真：Filter Design and Analysis (okawa-denshi.jp)。 更多见下面 “4.5 在线/离线 电路仿真计算工具” 章节！ ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"各类型电路设计规范或要点 p.s 电源、运放、EMC 和 高速电路等细分领域，看看那些 芯片大厂 对这些方面出的 文档，其晦暗艰深，每一块儿都能够研究一辈子、吃一辈子饭。 p.s 我看过很多在对电路原理没有学习和认知而只管连通、随意走线的别人的板子，要不是我脾气好，否则止不住骂骂咧咧全都当垃圾对待。我也是从那时候过来的，只是如果用心对待，那种状态不会持续超过2年，如果再长，那就过分了属于现学现卖和混子。 运放设计注意 运放定性和定量分析，熟练模电书！另外可以看 【手撕运放】运放的“第一原理”式定量分析法 - 知乎 (zhihu.com) / 【直达本质讲运放】运放的“第一原理”式定量分析法_Real-Staok的博客-CSDN博客。 运放选型。熟知运放基本参数，详见 “1 最基本的设计理念和器件选型” 一节的 “运放” 小节（去看一下，里面说的参数选择比较全面，光靠记忆不太中）。 下面引自 ADI 2021.12 线下专题讲座 某个 PPT。 注意滤波器仿真，和滤波器的品质因数 Q。仿真工具详见 “4.3 大厂在线/离线电路仿真工具” 一节。 防止输出信号失真：运放/放大电路 的 摆率/带宽 足够，不合适的放大倍数导致输出超过电源电压。 电路设计注意点：原理图 和 PCB 设计 首先是线路尽量短，运放周围阻容等器件尽量靠近运放引脚。反馈路线尽量短防止形成天线效应容易发射电磁波和容易受到外部电磁环境干扰，输入端口的阻容尽量靠近运放引脚，因为其前一级器件作为能量提供端，其发射的信号经过阻容器件的阻抗作用会变弱，因此变弱后的信号应该经过尽量短的路线进入本运放。 实例分析运放7大经典电路 - 知乎 (zhihu.com)。 设计跟随时候要考虑：运放接成同相跟随器时，为何有些电路要在负反馈上增加一个电阻？ - 知乎 (zhihu.com)。 一般增益带宽积越大的运放，对这个电阻的取值也越敏感。 不过有一些放大器，你加上这颗电阻，取值也比较合适的话，反而能改善放大器的稳定性，代价是系统带宽略微降低。 精密些的电路、用心设计的电路，最好放到仿真软件里面 做一做频谱图看看，仿真时候也添加一些寄生电容、电感，真实一些。 运放正负输入端的平衡电阻注意：同相放大器有平衡电阻吗？ - 知乎 (zhihu.com)。 不管同向放大器还是反向放大器，都需要加入平衡电阻，使从运放两输入端看出去的等效电阻相等，这样可以确保运放的输入偏置电流不会产生误差电压。 但是有的运放 看参数 不加也影响不大。 而且：电阻是有电阻热噪声的，这个噪声是电阻的固有属性，只与阻值和温度有关。一个10kΩ的电阻在室温情况下，噪声密度大约12.8nV/√Hz，AD797的输入噪声密度1.2nV/√Hz，OPA209的输入噪声密度2.2nV/√Hz，也就是一个平衡电阻带来的噪声，已经远远高过所选择的运放的输入噪声了。这个噪声在你的电路里有多大影响？噪声对你的电路影响大还是直流误差对你的电路影响大？ 所以这个平衡电阻到底要不要，取决于电路的实际情况。 仪表放大器的PCB布局-运放_ltqshs的博客-CSDN博客。 想要提高差分放大器的共模抑制比，电阻的选择是关键！ (qq.com)。 差分放大器电路中的电阻应仔细选择，其比值应相同 (R2/R1 = R4/R3)。这些比值有任何偏差都将导致不良的共模误差。 运放应用要点：引自 实例分析运放7大经典电路 (qq.com)。 运放应用要点：运放使用的注意事项 (qq.com)。 运放的输出和输入口上不要直接并电容，要先通过电阻再经过电容。 反馈回路的元器件必须要靠近运放，而且 PCB 走线要尽量短，避开干扰源。 运放的电源滤波不容忽视，电源的好坏直接影响输出。特别是对于高速运放，电源纹波对运放输出干扰很大，弄不好就会变成自激振荡。所以最好的运放滤波是在运放的电源脚旁边加一个0.1uF的去耦电容和一个几十uF的钽电容，或者再串接一个小电感或者磁珠，效果会更好。 下面引自 ADI 2021.12 线下专题讲座 某个 PPT。 运放应用要点：运放实际应用中常见的8大问题总结! (qq.com)。 运放噪声问题： 下面引自 ADI 2021.12 线下专题讲座 某个 PPT。 噪声的概念文章：噪声（Noise）-1 - 知乎 (zhihu.com)，噪声（Noise）-2 - 知乎 (zhihu.com)。 功率谱密度的理解：功率谱和频谱的区别_Charles' home-CSDN博客_功率谱和频谱的关系，FFT求频谱图和功率谱密度图_《好好先生》专栏-CSDN博客_功率谱密度图。 引用较详细说明运放噪声计算过程的文章：信号链类——放大器噪声计算 - 知乎 (zhihu.com)，运放噪声如何计算？_TaylorLi421的博客-CSDN博客_运放的噪声计算。 ADI 的 AN-114 介绍了低噪声和噪声计算相关内容：AN-1114_cn.pdf (analog.com)。 电源规范设计 电源绘制规范。基本规则分为三大块，都搞明白了就自然的知道怎么画了： 画 PCB 的基本规范要首先知道：按照信号流向走线、走线尽量短、电容尽量靠近要滤波的端口、走线宽度足够设计电流通过（或开窗加锡）、电流路径尽量一马平川而减少过孔和拐弯，还有本规范的其它相关规范内容； 了解 LDO、BUCK、BOOST 或 正激、反激 等电源拓扑的运行原理；（电源主要分为两大类，线性电源（LDO） 和 开关电源（DC-DC / AC-DC / DC-AC）。开关类电源不可避免会引入高频噪声、纹波相对大一些，但是效率较高、电流能力可以很大；选择 LDO 主要是用其高的 PSRR（电源纹波抑制比，在 10Hz~10MHz 这个完整范围内具有较大的抑制能力）和 低噪声输出。但是 LDO 输出噪声与降压差、电流和输入噪声频率都有关系，PSRR 会随着这些变化，电流影响很大） 了解电源的主要参数（本规范里 “1 最基本设计理念和器件选型” 章的 “电源” 小节）。电源类芯片的数据手册一般均有 PCB 布局布线参考图，在空间允许的范围内还是尽量参照该参考图。需要完整实践几次，从绘制 SCH、PCB 再到焊接、测量主要参数和调试。 电源设计四指标（设计一个好电源，打好整板的 “地基”）： 体积小。 效能高（效率高（轻载、重载情况下均 90% 以上）、低静态电流、热控制好）。 低 EMI。 好的动态响应（负载调整率好，负载快速变化时输出波动（过冲和下降）小且恢复快，输出纹波良好（20mV 左右 可以，10mV 以下优良））。 通用 电源树/电源轨 框图 高价值补充： Layout： 硬件电路设计-开关稳压器Layout指南 (qq.com)。 电源噪声 / 去耦\u0026旁路电容设置： EEVblog #594 - 怎样测量电源纹波和噪声_哔哩哔哩_bilibili、EEVBlog #1116 - 怎样消除电源纹波_哔哩哔哩_bilibili。这篇文章 【实用】看完这篇，轻松掌握开关电源纹波测量和抑制方法 (qq.com) 就是对前面两个视频的总结。 去耦、旁路电容的作用分析：只知道芯片旁边加一个电容是不够的！一个简单的小实验，让你马上明白“去耦电容”和“旁路电容”的工作原理_哔哩哔哩_bilibili。 重要概念 多电容并联滤波原理（为什么滤波电容要并联几个小电容，而非用一个大电容） - 知乎 (zhihu.com)。 图示去耦电容布局 退耦电容布局_newzhpfree的博客-CSDN博客。 比肩 LDO 噪声水平的 DCDC IC 消除误解：大电流开关稳压器IC噪声可以降低到接近LDO的数值 - 电源技术 - 电子工程网 (eechina.com)。 电源测量小贴士，10 个设计阶段：10_Steps_Power_Supply_48C-60180-cn.pdf (tek.com)，文档离线在\\额外文档\\10_Steps_Power_Supply_48C-60180-cn.pdf里。泰克官方。 EMC 环节，PCB Layout： 参考 各种 EMC 标准电路，[protection-circuits/EMC 理论和设计要点 at master · Staok/protection-circuits (github.com)](https://github.com/Staok/protection-circuits/tree/master/EMC 理论和设计要点) / [EMC 理论和设计要点 · 瞰百/protection-circuits - 码云 - 开源中国 (gitee.com)](https://gitee.com/staok/protection-circuits/tree/master/EMC 理论和设计要点)，其它保护电路也参考这个仓库里面的电路。 DCDC PCB Layout 经验。一文将 DCDC 的 Layout 讲的明明白白 (qq.com)。输入环路和输出环路的面积要尽量小，心中有 DCDC 的开 和 关状态时的信号流向。 DC-DC PCB layout经验-含走线宽度和载流量表格_ltqshs的博客-CSDN博客。 阻尼震荡与振铃问题：Buck的振铃实验与分析 (qq.com)、开关电源的阻尼振荡 (qq.com)。 环路相关： 电源-环路补偿的意义 - 知乎 (zhihu.com)。 前馈电容是如何影响buck电路的输出特性的？ (qq.com)。反馈电阻的上电阻并联的前馈电容的作用的理论分析和经验参数。 “合路” 环节，对于低压、小电流用两个二极管来选择即可，对于高压、大电流用第二类","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"SCH \u0026 PCB 检查表\\评审 PCB Check List（PCB 检查表） 比较丰富的 PCB 检查项表格：\\PCB LOGO-画法集合-PCB工具-规则文件\\SCH\u0026PCB 设计、计算和检查的工具和软件\\PCB检查步骤.xls。 丰富的 SCH\u0026PCB 检查表格：\\PCB LOGO-画法集合-PCB工具-规则文件\\SCH\u0026PCB 设计、计算和检查的工具和软件\\电路计算Excel表格合集+检查表CheckList\\电子工程师一版成功必备检查项（SCH\u0026PCB CHECK LIST）V0.9-避坑指南.xlsx（引自 公众号 路飞的电子设计宝藏）。 一整套PCB设计流程和要点，老板再也不怕我出错 - 知乎 (zhihu.com)。 设计方面的检查项，做硬件，想当然，犯大错 (qq.com)，以下： 1、I2C电路都加外部上拉，想当然，某些芯片I2C管脚内部自带上拉。 2、量产过的电路不会有问题，想当然，量可能还不够，问题还未暴露。 3、带横杠标识一端为负极，想当然，钽电容不是。 4、去耦电容是越多越好，想当然，寄生参数也“害人”。 5、电阻阻值随便用，想当然，功耗难解决。 6、SOC不用的GPIO全部悬空，想当然，一堆问题等着你。 7、电容都用小封装，想当然，高容值小封装价值贵死你。 8、选型不考虑价格周期，想当然，买不到货急死你。 9、设计电路不加兼容，想当然，缺货时时有，要防患于未然。 10、省空间，PCB不留测试点，想当然，调试费力不讨好。 11、元器件选型不留余量，想当然，特殊情况“扛不住”。 12、PCB走线越粗越好，想当然，阻抗匹配得考虑。 13、功耗全靠软件调，想当然，硬件设计很关键。 14、PCB走线包地越多越好，想当然，看情况，否则适得其反。 15、图纸不备份，想当然，电脑死机功亏一篑。 设计后期的检查项表格如下图，图源。 自己补充： PCB 至少有一个地平面。 电源线和信号线的路径是否按照原理图设计的流动方向排布；对于信号线，是否正确滤波等。 慢慢补充。 PCB Review（PCB 评审） 下文引自 4 步学会PCB评审 (qq.com)。 步骤一：资料收集和初步验证 在开始审阅之前，请确保所有数据手册，参考设计和叠层信息均可用。 验证原理图设计并签核。 Layout DRC，并消除所有错误 验证每个元件的封装 原理图每个模块分别和PCB对应起来，这样有利于审阅。 确保板尺寸正确，并且安装孔在正确的位置且具有一定的允许公差。 检查是否有板边的信号 步骤二：布局 确保去耦电容尽可能靠近引脚放置。 RFI和EMC滤波器应尽可能靠近输入输出。 提供了足够的空间用于操作和散热器安装。 确保正确遵循各个IC的布局指南。 考虑回流路径，分析模拟和数字电路是否干扰。 这将引起信号完整性问题。 所有有线连接器都放置在电路板的一侧，以保持接地电位尽可能接近。否则可能有天线效应。 放置的方式应尽量减小走线长度和交叉。 步骤三：布线 平面 确保数字和模拟电路的公共端仅在一个位置连接。 每个信号在其下方都有其参考平面。 电源线的宽度应与其承载的电流成比例。 确保电源平面中的插槽尽可能少，接地平面应连续。 任何平面都不应在中间形成空的环路。 确保磁性元件和滤波器下方平面挖空，否则会污染平面。 信号 除非特别强调，否则不要有多余的Trace。 尽量保证SMD器件下无走线 敏感模拟信号需要提供保护环 所有信号到板边距离至少20mils。 高速信号的参考平面中间没有截断 根据制造商提供的叠层信息，确定信号阻抗匹配 步骤四：丝印 确保IC下或焊盘上没丝印。 遵循同向。 LOGO和版本号等。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:10:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"4.5 在线/离线 电路仿真计算工具 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"电路计算小工具 内容丰富，参看 “4 SCH-PCB 设计规范” 章的 “PCB 计算小工具 / 辅助设计小软件” 小节。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"PCB DFM 自动化检查工具 PCB 可制造性分析工具，PCB画好后、打板前的自动化检查工具。 华秋 DFM：一键分析导入的 PCB 文件，检查项有板子尺寸、孔、线、间距、孤铜等等，排除生产难点、设计缺陷，给出优化建议，结合各种生产因素，自动计算或反算阻抗等等，还有 BOM 管理、对比 等工具，比较有用。 PCB反复评审难题，终极解决密码出现了？（资料+福利） - 知乎 (zhihu.com)。 你被 BOM “坑”过吗？珍藏的BOM检查方法你一定要学！ - 知乎 (zhihu.com)。 捷配DFM PCB检查工具。 etc. ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"TI-设计和仿真工具 设计工具和仿真 | 设计资源 | 德州仪器 TI.com.cn。 包括 电源设计工具（开关模式电源、处理器电源（PMIC、FPGA 电源等） 和 用 Power Stage Designer™ 软件工具深入分析电压、电流应力和稳定性）、信号链设计工具（滤波器、模拟电路（运放 和 ADC 设计） 和 时钟树设计） 和 分析和仿真工具（PSpice® for TI 对器件进行热分析等）。 一个 WEBENCH POWER DESIGN 设计工具 教程：【TPS5450开关电源设计】TI官网的WEBENCH POWER DESIGN设计工具非常好用，物联网硬件电子工程师学开关电源从此芯片开始，事倍功半_哔哩哔哩_bilibili。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:3","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"ADI-设计工具与解决方案 ADI-设计工具 设计工具与计算器 | 设计资源 | 亚德诺半导体 (analog.com)。 包括： 电源树/电源轨的设计：LTpowerPlay 和 LTpowerCAD，LTpowerCAD和LTpowerPlanner | 亚德诺半导体 (analog.com)。 教程（可网搜更多，ADI 官网也有教程）： LTpowerPlanner：一种系统级电源架构设计工具-EDN 电子技术设计 (ednchina.com)。 √电源设计工程师福利，LTpowerCAD教学视频来啦！ (qq.com)。 模拟类设计，包括滤波、放大、模拟光电二极管、仪放、ADC/DAC 等：ADI Precision Studio | 亚德诺半导体 (analog.com)。 LTspice 电路仿真：LTspice Simulator | 亚德诺半导体 (analog.com)。 硬件-LTspice仿真 - 知乎 (zhihu.com)。 RF 及相关工具（包括 RF 阻抗匹配设计）：RF及相关工具 | 亚德诺半导体 (analog.com)。 ADI-解决方案 技术解决方案 | 亚德诺半导体 (analog.com)。 参考设计 | 设计资源 | 亚德诺半导体 (analog.com)。 评估硬件与软件 | 设计资源 | 亚德诺半导体 (analog.com)。 精密技术信号链 | ADI公司 | 亚德诺半导体 (analog.com)。 等等。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:4","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"MPS-设计工具 设计工具 - 设计 (monolithicpower.cn)。 包括：DC/DC 设计工具、AC/DC 设计工具 和 磁钢设计工具。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:5","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"村田-设计辅助软件 设计辅助软件 SimSurfing | 设计辅助工具 | 村田制作所 (murata.com)。具有在线版和离线版。 具有的工具和功能： 使用教学视频： 设计支持工具 SimSurfing - SimSurfing - 视频資料库 | 村田制作所 (murata.com)。 电源噪声查不出来？不用上板子，滤波器仿真就能搞定 (bilibili.com)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:6","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"滤波器在线设计 Filter Design and Analysis (okawa-denshi.jp)。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:7","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"Cadence 的 AI 自动化布线 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:11:8","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"5 AD 导出 BOM 表 和 BOM 对比工具 AD 导出 BOM 表 AD10 的教程：Altium Designer（AD）软件导出BOM文件操作步骤-百度经验 (baidu.com)； AD20 的教程（推荐使用，还包含自定义 BOM 表模板）：AD20如何自定义BOM模板?Altium Designer20 实用技巧系列教程（五）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili，其中 BOM 模板文件在 ./PCB LOGO-画法集合-PCB工具-规则文件/AD20 BOM模板/ 里面，这个模板导出的 BOM 表比较常用、整齐，还包含描述、封装、单位价格（可以在导出 Excel 表格后再填入单价，表中的总价格会自动计算；表格最底部有一栏 PCB ，可以填入价格）等，比较实用。注，视频中的模板的位置，在不同版本 AD20 不同，如果按照视频找不到，那么就应该在 /Altium/AD20/Documents/Templates/ 目录下。 BOM 对比工具 在 PCB LOGO-画法集合-PCB工具-规则文件\\BOM对比工具-省时专业 路径里面 提供 BOM 对比工具，可以快速对比 两个 excel 格式 的 BOM 表 里面 器件 的差异。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:12:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"6 AD 生成器件库 和 Gerber 和 钻孔文件 生成器件库 分别在 SCH 和 PCB 页面 的 Design 下 找到 Make SCH/PCB Lib 按钮，会弹出 器件分组 窗口，里面全部不打勾，确定后 分别生成后保存到一个目录即可，不要用 生成集成库，那会重复生成器件。 库可以重新导入到工程，在 Project based 里面 安装库即可，方便其他人打开。 导出 Gerber 和 钻孔文件 用时再学： 嘉立创官方教程 技术指导：Altium Designer输出Gerber文件步骤 (jlc.com)。 【AD小教程】导出Gerber文件和钻孔文件_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 【完结】第26课 Altium Designer20(AD20)+VESC6.4实战教程：调整丝印输出Geber文件并投板（北冥有鱼）完结撒花_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:13:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"7 AD 导入导出配置文件 AD 软件的设置和 PCB Rule 设置，两个配置文件的导入和导出，参考本文件夹这里 ./PCB LOGO-画法集合-PCB工具-规则文件/AD 软件设置和 PCB 规则 Rules 配置文件/。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:14:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"8 使用 KeyShot 10 渲染 PCB 效果图 B站等有很多教程视频，可自行搜，以下只经验之谈。 基本步骤 用 Altium Designer 导出 .step 格式的 3D 模型文件，再导入keyshot，但这个模型不带走线和丝印。 导出表面贴图：在 Altium Deigner 里面使用 “智能PDF” 分别导出正反面的只有 “走线和丝印” 两个层的图，注意颜色可选，然后可以把这个 pdf 使用 PS 简单修一修（比如颜色修改和过孔透明），再导出 .png 格式的图。省事的做法可以直接在 AD 的 3D 视图截图，然后贴到 keyshot 的 PCB 板面上。 PCB 板面添加贴图：然后把贴图添加到 keyshot 中 PCB 模型的板面的材质里面的标签里面。如果板面不加材质，保持原色，则直接在其材质面板下的纹理下的颜色双击添加图片，映射类型选平面，对准选部件，然后点移动纹理调整，调整使这个图像对齐贴合 PCB 板面即可，另一面的图片再在标签里添加。 KeyShot 的几个初级技巧 （毕竟只是看一下效果，不是专业的） 3D 视图下，tools 菜单下的 legacy tools 可以导出带走线的，带丝印的模型，但是文件太大，keshot 会卡，对电脑性能要求很高，我还没测试。 没试 高版本的 AD，可以导出 pdf 3d，没试。 单个模型加材质：单击选中一个模型（出现橘色描边），然后添加材质。或者双击这个模型，右边菜单下面点 “接触链接材质”。 单独删除模型，先模型右击点分离，便可删除单独部件。 右边菜单 什么都不选 全局设置的情况下 有 照明和图像里面很多不错的效果可以调整。 材质和打光：https://www.bilibili.com/video/BV14W411d7Hx。 动画制作：https://www.bilibili.com/video/BV1T741177WU。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:15:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"9 优秀参考/书籍/数模电基础（新人必看） 这里面有 系统入门、学习的 书籍、视频，还有适合零碎时间翻看汲取各种硬件设计中经验技巧的小文章。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:16:0","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"好书/教程推荐 首先精读电路和数模电课本，基本功， 《电路(第五版).邱关源》、《模拟电子技术基础（第四版）童诗白》、《数字电子技术基础（第五版） 阎石》。 《新概念模拟电路》1-5册，杨建国，这个系列的模电书讲的很地道、实用。基本数模电学习和查询推荐。如果上面的课本看不下去，就看这个。 10讲最具代表性模电问题与解答系列视频 #西安交大杨建国—亚德诺半导体_哔哩哔哩_bilibili 模电。 唐老师讲电赛的个人空间_哔哩哔哩_bilibili 系统讲解。 一个电子工程师的杂货箱 - 知乎 (zhihu.com) 杂。 ADI电子书-您绝对值得拥有的电子书 | 亚德诺半导体 (analog.com) 杂且精。 《电子技术讲座四册》，引用网友一个介绍： 建议读一下70年代上海业余工业大学的四本《电子技术讲座》，包括《晶体管整流电路》、《晶体管放大与振荡电路》、《晶体管收音机》和《晶体管开关电路》，就知道什么叫做编写让工农兵都能读懂的书，什么叫做理论与实践相结合。这一套书当年发行量是以百万册计的。 《华为硬件工程师手册》159页，用于补充。 《硬件系统工程师宝典》——EDA精品智汇馆，介绍了硬件系统设计概要、信号完整性、电源完整性、EMC/EMI、原理图和PCB设计详情等，用于补充。 好书推荐，如下，比如《高速数字电路设计与安装技巧》这本里面对于信号阻抗匹配通过画图说明非常形象。 一本比较全的书《印制电路板（PCB）设计技术与实践》，对 PCB 中的走线、叠层、接地、去耦合、电源、数模、高速数字电路等等有实用而丰富的介绍。 《PCB电磁兼容技术——设计与实现》清华大学出版社出版。PCB电磁兼容技术：设计实践_百度百科 (baidu.com)，PCB电磁兼容技术——实践设计 - 百度文库 (baidu.com)。网友推荐，不厚，干货多。 一搏科技赠资料：cadence设计红宝书案例、高速先生原创技术文章、一博历届研讨会课件、Designcon大会17、19、20文章，内容很丰富。 链接：https://pan.baidu.com/s/1NoneuqKxPURPZFoZxCFGzQ?pwd=XHYF 提取码：XHYF –来自百度网盘超级会员V5的分享。 .etc ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:16:1","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"网络优秀参考 p.s 以下有些是作者还没有看到的，均填列其中（有时间的话会看看，再之后都会把其精髓补充在本文）。 刀与沉默 - 知乎 (zhihu.com)，这位的文章对 电源、EMC、运放等等等等总结的比较全面实在！ 你的产品怎样进行抗干扰设计? (qq.com)，这个已经补充到 “4 SCH-PCB 设计规范” 里面了。 嘉立创PCB下单帮助文档-嘉立创PCB打样专业工厂-线路板打样 (jlc.com)，好总结，很多文章。 PCB 基本布线规范与设计原则 by Hank。 Andrew Chu - 知乎 (zhihu.com)，HardwareDesign: 介绍硬件设计的一些内容 - Gitee.com。这其中的一些专题文章已经放到了 正文 对应的章节内，这个内容很丰富，是 经验丰富的/优秀的 硬件工程师 必看的。硬件工程师技能树 - 知乎 (zhihu.com)。 一个PCB设计问答集，内容很实在，离线在 额外文档/PCB设计问答集.pdf。 本条是作者的备注： 本地收集的文章： 《PCB小知识》系列文章，路径：【3 硬件、电路】\\【PCB设计规范】\\ PCB小知识。 有关高速PCB的独立文章，路径：【3 硬件、电路】\\【高级 PCB 设计 SI EMC 高速等】\\ 高速PCB。 ADI 智库文章：《PCB设计秘籍》、《高速电路设计指南》（这个主要针对高速数模转换器件的PCB技巧）、《非隔离式开关电源的PCB布局考虑》、《Power技术问题解答》（这个针对常用 LDO 和 DCDC 的常见问题做梳理）、《电源设计基础知识精选》（对电源方方面面的内容做大梳理）等，具体文章免费在下面链接下载：ADI电子书-您绝对值得拥有的电子书 | 教育 | 亚德诺半导体 (analog.com)，或者在 微信里添加 “ADI智库” 小程序，在小程序里面搜索这些文章的名称，即可下载。 MPS：PCB 布局指南：《电机驱动PCB布局指南》上、下篇、《低EMI DCDC变换器PCB设计》。 TI 的 有关电源的文章。 网上传开的华为的硬件规范。华为内部硬件开发设计流程 (qq.com)。 .. AD 的更多丰富技巧和高速布线： 综合类（高级技巧）： AD官方：Altium Designer 全套最权威教学|【官方PCB设计培训】|Altium 战疫免费云公益课堂 | 共27节|AD20|PCB Layout_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 凡亿：凡亿教育的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili； .. 高速板设计（蛇形线 和 Active route）： AD官方：【官方培训】Altium Designer 高速DDR3模块全流程实战PCB设计 | AD20 教程 | 共5节|PCB Layout_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； AD官方：DDR存储器布局布线设计思路解析_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 凡亿：【PCB自动布线】 6层PCB高速ActiveRoute自动布线 速度就是快 Altium Designer 20_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 文章：AD19如何使用强大的自动布线功能 - 哔哩哔哩专栏 (bilibili.com)； 文章：Altium Designer 的ActiveRoute使用_MrZhanghx的博客-CSDN博客； .. 2T 移动硬盘里面的更多比较全的技巧视频 【电子 学习】\\【Altium.Designer】视频+教材\\Altium 技巧经验 较多。 ","date":"2020-07-30","objectID":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/:16:2","tags":["规范","硬件"],"title":"【规范】SCH \u0026 PCB 设计规范、技巧以及 AD 的使用","uri":"/%E7%A1%AC%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["随机技术情报"],"content":"介绍关于 ARM NN、CMSIS NN 和 K210 等嵌入式端的神经网络算法的部署和实现","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"嵌入式端的神经网络算法部署和实现 介绍关于 ARM NN、CMSIS NN 和 K210 等嵌入式端的神经网络算法的部署和实现。神经网络的调教（训练）还是在 PC 端，神经网络参数训练好之后，在嵌入式端进行部署（本文的中心），经过在嵌入式端部署进去的神经网络算法对给定数据进行计算从而得出结果，实现算法的嵌入式端部署和运行，这么一个过程。 嵌入式 AI 概念： 更多参考 如何将训练好的神经网络部署到嵌入式芯片上，如arduino和树莓派等？ - 知乎 (zhihu.com)。 本文提及的 开源库 和 资料 均放在了 Github/Gitee 仓库内。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:0:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"目录 [TOC] ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:1:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"微控制器 MCU 端 人工智能的下一轮革命？关于TinyML的一切 - 知乎 (zhihu.com)。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"Awesome-Embedded Repository nhivp/Awesome-Embedded 开源项目下的 Machine Learning \u0026 AI on MCU 小节，总结的很好。 nhivp/Awesome-Embedded: A curated list of awesome embedded programming. (github.com)，其源文如下： nnom - A higher-level Neural Network library for microcontrollers. nn4mp Embedded Learning Library (ELL) - Microsoft’s library to deploy intelligent machine-learned models onto resource constrained platforms and small single-board computers. Qualcomm Neural Processing SDK for AI - Libraries to developers run NN models on Snapdragon mobile platforms taking advantage of the CPU, GPU and/or DSP. CMSIS NN - A collection of efficient neural network kernels developed to maximize the performance and minimize the memory footprint of neural networks on Cortex-M processor cores.在后文会介绍到 ARM Compute Library - Set of optimized functions for image processing, computer vision, and machine learning. uTensor - AI inference library based on mbed (an RTOS for ARM chipsets) and TensorFlow. EmbededAI - A library that provides elements of AI to C++ applications. kann - A lightweight C library for artificial neural networks ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:1","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"网友自实现的轮子 这里只是举例网上有很多开源的网友自己实现的玩具轮子，比如这里介绍的 BP 神经网络，可以直接跑在 MCU 上。 BP神经网络的C语言实现-只有三层：BP神经网络及其C语言实现 - 知乎 (zhihu.com)；ThreeClassMrWang/c-bpnn: BP神经网络的C语言实现 (github.com)。 可以运行在STM32的BP算法实现-任意层：(BP神经网络C语言实现_一朝英雄拔剑起的博客-CSDN博客_bp神经网络c语言实现； STM32 运行 三层BP：sertreet/BPNeuralNetwork: STM32F407ZGT6 Run BP Neural Network Handwritten Digit Recognition (github.com)。 etc. 如果链接挂了请告诉我。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:2","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"Kendryte K210 K210 是 RISC-V 64 位双核处理器，集成了可运行神经网络算法的硬件 IP 核，以及其它常用外设。其可直接跑 kmodel 格式模型，此模型可从 TensorFlow 模型转换为 TFlite 模型、TFLite 模型转换为 K210 的 kmodel 模型 而得到。 我的Github 仓库-Awesome-K210收集了关于 K210 的 MaixPy 开发和 SDK IDE 开发等的软、硬件入门资料，帮助初学者快速了解、学习和入门 K210。 这款芯片的生态已经做起来了，相关的开发板、kendryte 官方和 sipeed 官方的资料和例程、各路网友大佬的例程、网络训练以及模型开源等等已经非常丰富。甚至北航高校已经应用部署到无人机产品上了，其项目的描述如下。 该项目是 Kendryte K210 AI芯片应用程序的集合，其中包括面部检测，颜色检测，目标检测和分类，QR码和Apriltag码检测以及与ArduPilot飞行软件的通信。 最后，我们可以将这些应用程序部署到无人机终端，使无人机更加智能。 所实现的应用主要分为两类，第一个是机器视觉应用，该类应用基于openmv机器视觉库；第二类是深度学习应用，该类主要基于Tensorflow和yolov2。详细功能参见用户手册。 本K210项目为Vision_MAV项目的配套项目，Vision_MAV项目旨在设计并实现一个依托深度学习和图像处理技术的基于视觉的微型无人机系统，能够实现在无GPS环境下的自主视觉导航、目标检测与追踪，该项目由北航无人系统研究院李大伟副教授课题组创立并进行研究，并将在项目没有保密需求后进行开源。本仓库的K210项目是Vision_MAV的一个配套项目，基于嘉楠科技公司生产的边缘AI芯片K210，来实现目标检测与追踪，为Vision_MAV项目提供一个可选的视觉解决方案。该项目采用了一块矽速科技公司生产的MAXI DOCK K210评估板，来验证K210芯片的AI计算能力。在本项目中，采用传统机器视觉方法实现了最大色块识别、二维码识别、Apriltag码识别、圆形识别，采用深度学习方法实现了人脸识别、人体识别、口罩识别等，并开发了K210和Ardupilot飞控固件之间的MAVlink通讯接口，来实时的将K210视觉模组解算出的目标位置信息发送给飞控来控制无人机运动。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:3","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"Edge Impulse 可以在线训练各种传感器数据的神经网络模型，处理 图像，语音 or others，然后部署到 自己 MCU 上。 官方文档 Getting Started - Edge Impulse Documentation 第一手资料。 导出模型和库 并部署在自己 MCU 上 C++ library - Edge Impulse Documentation。 API 手册 Edge Impulse API - Edge Impulse API。 自己使用的总结，以 ESP32 为例： 提前准备好 ESP32 的 ESP-IDF 编译环境，并且会用，参考 我的相关仓库 esp8266-esp32-development/ESP-IDF-IDE编程 at master · Staok/esp8266-esp32-development (github.com)，Gitee 地址 ESP-IDF-IDE编程 · 瞰百/esp8266-esp32-development - 码云 - 开源中国 (gitee.com)。 按照官网 Getting Started 手册的步骤，官网注册账户、新建工程、输入数据、构建模型、在线训练、导出 Edge Impulse C++ 库。 参考 On your Espressif ESP-EYE (ESP32) development board - Edge Impulse Documentation，首先做一个最小工程，按照这个链接里面的步骤。 更多详细参考 本仓库下 \\Edge Impulses 文件夹内 说明，可以顺利编译 带 Edge Impulse 库的工程。 一个官方提供的样板工程，可直接编译，edgeimpulse/firmware-espressif-esp32: Edge Impulse firmware for the Espressif ESP-EYE(ESP32) Development board (github.com)。 一些网友教程： 零基础的嵌入式机器学习：Edge Impulse使用教程之训练模型浅析(1)——分类模型_方恪的博客-CSDN博客。 零基础的嵌入式机器学习：Edge Impulse使用教程之训练模型浅析(2)——回归(预测)模型_方恪的博客-CSDN博客。 与常见 MCU 结合： 零基础的嵌入式机器学习：Edge Impulse训练模型移植STM32F407ZGT6实例_方恪的博客-CSDN博客_stm32运行训练好的模型。 使用 Edge Impulse 在 ESP32 上运行机器学习算法 - 知乎 (zhihu.com)。使用 Edge Impulse 在 ESP32 上运行机器学习算法 | 乐鑫科技 (espressif.com.cn)。 但这是生成 Arduino 库，TinyML ESP32-CAM: Edge Image classification with Edge Impulse (survivingwithandroid.com)。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:4","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"ST X-Cube-AI 通过 STM32Cube.AI ，开发人员现在可以将预先训练的神经网络转换为 C 代码，该代码可以调用在 STM32 MCU 上运行的优化库中的函数。这是 ST 公司针对 STM32CubeMX IDE 的一个扩展软件库，下载安装 STM32Cube 后可以在其内下载安装 X-Cube-AI 组件，进而可以进行 神经网络的配置，然后由 STM32CubeMX IDE 产生 STM32 MCU 的 软件开发工程。 用 ST X-Cube-AI 是把 Keras、TF lite、ONNX、Lasagne、Caffe、ConvNetJS 等框架训练的神经网络模型转换为 内存优化的、可在 STM32 上运行的程序/数据结构，建议全程在 CubeMX 软件里面操作，直接生成工程。 特点： 从预先训练的神经网络模型生成 STM32 优化的库； 支持各种深度学习框架，如 Keras、TF lite、ONNX、Lasagne、Caffe、ConvNetJS 等； 通过 STM32Cube™ 集成，可轻松在不同 STM32 微控制器系列实现，并生成软件工程； 允许多个人工神经网络在单个STM32 MCU上运行； 完全支持超低功耗STM32 MCU； 免费，用户友好的许可条款。 相关网页： ST 官网 X-Cube-AI 首页 STM32 solutions for Artificial Neural Networks。 ST 官网 X-CUBE-AI 下载页。推荐不要单独下载，在 STM32CubeMX IDE 中安装组件并直接产生程序工程。 ST Cude.AI 介绍页 (stmcu.com.cn)。 ST 官网 X-CUBE-AI 慕课。 网络教程： STM32CubeMX AI尝尝鲜。 嵌入式MCU也能跑AI？STM32 Cube.AI工具包使用初探。 【嵌入式AI开发】篇四|部署篇：STM32cubeIDE上部署神经网络之模型部署 (qq.com)。 【嵌入式AI开发】篇五|实战篇一：STM32cubeIDE上部署神经网络之pytorch搭建指纹识别模型.onnx (qq.com)。 我在STM32单片机上跑神经网络算法(文章结尾有学习资料和学习群) - 知乎 (zhihu.com)。 在STM32上部署神经网络实现人体活动识别_哔哩哔哩_bilibili。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:5","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"CMSIS-NN CMSIS (Cortex Microcontroller Software Interface Standard) 是针对 Cortex-M MCU 和 Cortex-A5/A7/A9 处理器的一组软件应用框架，是标准化软件组件库，抽离出公共部分组件和启动文件等，简化开发，并提供很多高效的软件实现。下图示意其组成部件。 CMSIS 的 Github 仓库；CMSIS 的使用文档。 其中这里最关心 CMSIS-NN。 介绍 Collection of efficient neural network kernels，Neural networks and machine learning are functions that are being pushed into the end node if IoT applications. The neural network kernels of the CMSIS-NN library help to maximize the performance and minimize the memory footprint of neural networks on Cortex-M processor cores. 提供的函数库 The library is divided into a number of functions each covering a specific category： Convolution Functions； Activation Functions； Fully-connected Layer Functions； Pooling Functions； Softmax Functions； Basic math Functions。 The functions can be classified into two segments： Legacy functions supporting ARM’s internal symmetric quantization(8 bits). Functions that support TensorFlow Lite framework with symmetric quantization(8 bits). The legacy functions can be identified with their suffix of _q7 or _q15 and are no new development is done there. The article in [2] describes in detail how to run a network using the legacy functions. The functions supporting TensorFlow Lite framework is identified by the _s8 suffix and can be invoked from TFL micro. The functions are bit exact to TensorFlow Lite. Refer to the TensorFlow’s documentation in [3] on how to run a TensorFlow Lite model using optimized CMSIS-NN kernels. 源码、手册和例程 CMSIS-NN 官方 Github 仓库，包含手册、例程等。 官方教程集：CMSIS-NN 在 Arm Cortex-M 的应用。 安富莱的 CMSIS-NN 开源教程和例程（暂时还没出）。 总结 这里 CMSIS-NN 是结合 CMSIS DSP库，二者一块完成一些机器学习基本算子函数的库，可以在ARM Cortex M 的 MCU 开发中直接 include 然后调用 API 进行神经网络搭建；还可以使用 CMSIS-NN kernels 来运行 TensorFlow Lite 模型。 CMSIS-DSP 的介绍 CMSIS-DSP: Fast implementation of digital signal processing Developing a real-time digital signal processing (DSP) system is not trivial as the DSP algorithms heavily rely on complex mathematical operations that are even time-critical. CMSIS-DSP library is a rich collection of DSP functions that are optimized by ARM for the various Cortex-M processor cores. CMSIS-DSP is widely used in the industry and enables also optimized C code generation from MATLAB®. The ASN Filter Designer generates CMSIS-DSP code that you can directly use in your application. 关于 CMSIS-DSP 的学习和使用，“安富莱\"进行了不少的摸索和验证，并出了几百页的教程，对于初学者足够够的了。 安富莱的 硬汉嵌入式论坛；安富莱官网；安富莱的 CMSIS-DSP 开源教程和例程；CMSIS-DSP 官方例子（Github）。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:6","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"TensorFlowLite TensorFlowLite 可被用于微控制器（MCU）和其它只有千字节内存的设备。（这里有待补充更多信息和官网网页） 特点： 不需要操作系统支持，可以移植和 “裸机” 运行在 Cortex-M3\\M4 等内核的 MCU 上，20KB ~ 1MB 量级的容量占用。 官方有支持 STM32F746 的 Discover 板等。适用于微控制器的 TensorFlow Lite (google.cn)。 适合嵌入式开发，代码库小，模块化，入门容易，有移植各平台示例。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:7","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"TinyML Projects 网络文章介绍：【嵌入式AI开发】MCUNet: Tiny Deep Learning on IoT Devices-微型机器学习时代已经到来了 (qq.com)。 Tiny Machine Learning 项目主页。 TinyML Projects 分为两个部分： MCUNet (inference, microcontrollers)。 TinyTL (on-device learning, memory-efficient transfer learning)。 论文、PPT、海报和源码等均已开源，商业权被大公司以超超高价买下。 MCUNet 实验结论： ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:2:8","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"微处理器 MPU 端 这里的微处理器 MPU 暂指 ARM Cortex-A 内核的。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:3:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"ARM Compute Library ARM Compute Library 官网介绍主页。 The Arm Compute Library is a collection of low-level machine learning functions optimized for Cortex-A CPU and Mali GPU architectures. The library provides ML acceleration on Cortex-A CPU through Neon, or SVE and acceleration on Mali GPU through Open CL. Key features： Over 100 machine learning functions for CPU and GPU Multiple convolution algorithms (GEMM, Winograd, FFT, and Direct) Support for multiple data types: FP32, FP16, int8, uint8, BFloat16 Micro-architecture optimization for key ML primitives Highly configurable build options Supported Architectures/Technologies： Arm® CPUs: Arm® Cortex®-A processor family using Arm® Neon™ technology Arm® Cortex®-R processor family with Armv8-R AArch64 architecture using Arm® Neon™ technology Arm® Cortex®-X1 processor using Arm® Neon™ technology Arm® Mali™ GPUs: Arm® Mali™-G processor family Arm® Mali™-T processor family 基本的，ARM Compute Library 为 ARM Cortex-A 处理器提供了针对性优化的一打的机器学习算法函数，可以使用这些 API 直接构建起神经网络模型，训练或者运行。 Tutorials: Tutorial: Cartoonifying Images on Raspberry Pi with the Compute Library Tutorial: Running AlexNet on Raspberry Pi with Compute Library Github 仓库 ARM-software/ComputeLibrary: The Compute Library is a set of computer vision and machine learning functions optimised for both Arm CPUs and GPUs using SIMD technologies. (github.com)。 官方手册 Compute Library: Introduction (arm-software.github.io)。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:3:1","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"ARM NN ARM NN 是 ARM Compute Library 的高级封装，ARM Compute Library 提供对 ARM Cortex-A 优化的神经网络基本算子，可以使用 ARM Compute Library 的 API 直接自己搭建神经网络算法，或者使用在这里介绍的 ARM NN，转化主流神经网络框架训练好的模型并使用。ARM NN 是 ARM 公司 在 Cortex-A 嵌入式端 “AI and Machine Learning” 主题的 关键项目。 Github 仓库 ARM-software/armnn: Arm NN ML Software. The code here is a read-only mirror of https://review.mlplatform.org/admin/repos/ml/armnn (github.com)。 The Arm NN SDK is a set of open-source software and tools that enables machine learning workloads on power-efficient devices. It provides a bridge between existing neural network frameworks and power-efficient Cortex-A CPUs, Arm Mali GPUs and Arm Ethos NPUs. Arm NN SDK utilizes the Compute Library to target programmable cores, such as Cortex-A CPUs and Mali GPUs, as efficiently as possible. ARM NN 是 使用C++语言，可以直接载入如 tensorflow lite 框架生成的神经网络模型文件，然后对模型进行分析和优化，使之底层调用适合 ARM 内核的指令或者 NPU 单元 实现运算加速，然后再使用 ARM NN 的 API 载入优化过的模型，进行推理计算，得到结果。 The machine learning platform libraries – Arm NN and Arm Compute Library – bridge the gap between existing neural network (NN) frameworks, such as TensorFlow, TensorFlow Lite, Caffe and ONNX, and the underlying IP. They enable efficient translation of these NN frameworks, allowing them to run efficiently – without modification – across Arm Cortex-A CPUs, Arm Mali GPUs and the Arm ML processor. 官方生态文章和实例： ARM NN 官方的应用文章。 ARM NN 官方的在树莓派上使用。 ARM 官网 - AI and Machine Learning 白皮书 各种应用介绍。 网友实例： 被低估的ArmNN（一）如何编译。 【树莓派/目标检测】(二)armnn编译。 看来目前还不是很多。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:3:2","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"PyArmNN PyArmNN 的 Github 仓库。 PyArmNN 是 ARM NN 的 Python 实现，使用 Python 语言，干的活和 ARM NN 一样。 网友实例： Accelerating ML inference on X-Ray detection at edge using Raspberry Pi with PyArmNN。 看来目前还不是很多。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:3:3","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"MACE zhy520xp/mace-makefile-project: makefile 交叉编译 libmace.a，并能在嵌入式端调用GPU来跑深度学习模型 (github.com). MACE 介绍自搜 libmace_百度搜索 (baidu.com)。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:3:4","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"总结 stm32 这种 ARM Cortex-M 的单片机应该用 CMSIS-NN 去复现（或者运行 TensorFlow Lite）神经网络模型，或者使用 Awesome-Embedded Repository 等小节介绍的轮子； 而到了ARM Cortex-A 系列的运行 Linux 的平台，就使用 ARM NN 这个库，导入 TF 或者 Pytorch 的模型，进行优化加速。 所以都属于转化，主要还是算法设计。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:4:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"其它嵌入式AI算法实现库 uingrd/EmbeddedML: 《AI嵌入式系统——算法优化与实现》软件工具、例程及教学辅助材料 (github.com)。 已经离线在 /uingrd-EmbeddedML 文件夹里面 .etc ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:5:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"其他平台 不太熟悉，只是罗列。 ","date":"2021-04-12","objectID":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/:6:0","tags":["软件","神经网络"],"title":"（大集合）嵌入式端的神经网络算法部署和实现综合","uri":"/4.5%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AB%AF%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%97%E6%B3%95%E9%83%A8%E7%BD%B2%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"介绍 uboot 的基本概念、源码分析和移植步骤","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 移植基础详解 本文系广泛撷取、借鉴和整理（相关的内容在网络上有很多，但很多相互抄，或者是版本太老，或者就是不通用的非常有平台针对性的步骤，碎片化泛滥，甚至就是有待分拣的垃圾厂，当然也有一些好的文章，都会看），经过了细心、耐心、小心、佛心乃至贤者模式、莫生气、开始怀疑、愁然、不畏怯、再到渐入佳境、逐渐明朗的学习过程，再经过了广泛翻阅和对比，边做边写，对主要内容进行了精髓提取。 过于基础的内容不会在此提及，比如 SoC 芯片的启动流程、什么是 bootloader 等等内容，此类背景知识在几乎每一本嵌入式 Linux 书籍都会提及，在此不会赘述；本文专注具体 u-boot 的启动流程、移植和编译等（以百问网的 imx6ull 和 米尔、NXP 的 imx8mm 这两种平台为例），为了区分于网络上碎片碎末、残缺不全、缺斤少两、半斤八两、一个巴掌拍不响的各种文章，本文尽量做到通用化的、全面化的学习记录，并且会说明我是看的什么资料，目的就是在面对新平台时候，可以自主移植、编译和跑起来，融会贯通，而不是把人当作定制化的没有主观能动性的机器。 参考大量文章和教程以及触(连)类(猜)旁(带)通(蒙)的反复测试，记录成功的步骤，而成此文，如有错误恭谢指出！侵删。作者见 “署名” 一节。 注：在 Github 上的原版文章日后可能会更新，在其它位置发的不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:0:0","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 篇 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:0","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"成熟的 bootloader 先说思想，bootloader 是很有用、很方便的一种发明，作为一个 bootloader，本质是一个在 MCU 或者 MPU 首先运行的裸机程序，通过通讯接口（UART、EtherNet、CAN、USB、SD 卡 等等）把编译好的 APP 程序的二进制文件或者镜像首先下载到内存中，或者是从 FLASH 中读取 APP 程序数据放到内存中，并跳转到 APP 程序处开始执行，在内存中跑的程序对于取指等 CPU 操作等待的时间比在 FLASH 中跑的程序快得多；或者通过把从一个接口接收的 APP 程序数据存储到 自己的 FLASH 中，实现自己给自己烧录（自举， IAP），比如把 SD 卡里面的 程序数据读出然后烧入 自己的 FLASH 里面，或者从 USB 接收程序，这些方法方便板子的批量烧录；还可以预先在自己的 FLASH 中存入多个 APP 程序，根据外部指令选择运行哪一个，不用反复烧写便可实现更换程序；说到这里，给 MCU/MPU 加一个 bootloader 后，其灵活性、可操作性就提升了维度。bootloader 要实现这些功能，就当然需要先初始化这些通讯接口和储存设备（DDR / FLASH），还要提供一个人机交互界面（一般为命令行）并实现一些命令，搬运应用程序到内存，准备要跳入操作系统内核的环境并跳转启动该内核，这些即是一个 bootloader 的最小实现。 关于 MCU 的 IAP 更多内容可见我的另一个开源项目 Staok/u-iap: 一个志在实现适用于 MCU 的通用 IAP 程序框架，可以从串口、外部 SPI FLASH、外部 SDIO SD 卡、USB Device MSC 或者 USB HOST MSC等等途径更新 MCU 固件。 (github.com)。 以上说的都是最最基本的，更多 bootloader 的更专业（更官话）的介绍文章如下： 搞嵌入式的，为啥要有uboot？ (qq.com)； 嵌入式系统 Boot Loader 技术内幕_业精于勤,荒于嬉;行成于思,毁于随-CSDN博客； ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:1","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 启动流程 不但知其然，还要知其所以然。如果熟悉《【主线剧情01】ARM IMX6ULL 基础学习记录》里面的内容，那么作为 bootloader 一种的 u-boot 的启动过程，就相当于扩充了、丰富了和复杂了 的那篇文章里所介绍的启动文件 start.s 的过程，主要步骤可以一一对应上。u-boot 启动流程仅作知道一下有这回事，不必深究。 不同版本的 u-boot 以及不同的板子的文件位置和初始化流程会有偏差。以下启动流程为笔者主要用 grep 和 find 命令一点一点看源码梳理出来。 以 i.mx6 为例 以下基于 u-boot 2017.03 的 100ask i.mx6ull 平台： 上电运行 arch/arm/cpu/armv7/start.S，在这里面执行以下： CPU 设为 SVC 模式，关中断（IRQ 和 FIR），关 MMU，关看门狗等； 执行 bl cpu_init_crit，跳到同目录下的lowlevel_init.S，再跳到 同目录/mx6/soc.c的s_init()进行时钟等检查和设置； 执行 bl _main，跳到 arch/arm/lib/crt0.S的_main。 在arch/arm/lib/crt0.S，_main里面执行以下： 设置栈 stack_setup；为 C 环境做准备；清除 BSS 段； 执行 board_init_f，（第一次初始化）基本硬件初始化，如时钟、内存和串口等，这个函数可能位于 board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c 文件里或者位于common/board_f.c文件里，其里面的宏定义在其对应的头文件里 include/configs/\u003c板子名\u003e.h； 调用重定位 relocate_code，源码位于arch/arm/cpu/armv7/start.S，（第一次搬移）u-boot 自搬到内存 ； 执行 board_init_r，（第二次初始化）对外设的初始化，位于 common/board_r.c，初始化 init_sequence_r 列表中的初始化函数，最后调用run_main_loop()，其再调用 common/main.c里的main_loop()。 进入 common/main.c，main_loop()，延迟bootdelay_process()，若无输入则进入自启动 autoboot_command()，若有输入则进入交互模式 cli_secure_boot_cmd()； 根据命令或自启动流程，若要 boot 进入系统，跳到 cmd/bootm.c 的 do_bootm()，再调用同文件的 do_bootm_subcommand()，调用 common/bootm.c 里的 do_bootm_states()，在这里面检测是否有 OS，是什么 OS，如果有 Linux 系统，则下一步； （第二次搬移）搬运 Linux 内核到内存； 然后调用 common/bootm_os.c 里的 boot_selected_os()，其调用 arch/arm/lib/bootm.c 里的 do_bootm_linux()，再调用同文件里的 boot_jump_linux()，跳到内核的起始地址，进入 \u0026 运行内核。 更详细的启动流程介绍可以参看《【正点原子】I.MX6U嵌入式Linux驱动开发指南》的第三十二章节，目前发现的最全面的。 以 i.mx8 为例 以下基于 u-boot 2019.04 的 uboot-imx 中的 imx8mm 平台，这里主要描述各种初始化函数的跳转关系和逻辑： 上电执行arch/arm/cpu/armv8/start.S 后跳转到arch/arm/lib/crt0_64.S的_main里： 首先调用common/board_f.c里面的board_init_f()（第一次初始化），其调用init_sequence_f[]数组里的各个初始化函数，数组中有 board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c中的board_early_init_f()； 然后调用relocate_code（第一次搬运）uboot自搬运到内存； 调用common/board_r.c里面的board_init_r()（第二次初始化），其调用init_sequence_r[]数组里的各个初始化函数，数组中有： board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c中的board_init()； board_early_init_r()，在 imx8 的文件中没有用到； board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c中的board_late_init()； run_main_loop()； 跳入 uboot 的主循环 run_main_loop()之后，等待外部输入命令或超时等待自启动； 进行启动，找到 Linux kernel 镜像，搬运其到内存（第二次搬运），跳转启动。 更多 u-boot 启动过程介绍文章： 更详细的引导内核过程。 u-boot分析 - 蜗窝科技 (wowotech.net)。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:2","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 命令 若设置了 u-boot 启动时等待任意键输入几秒，若有输入，则退出自启动模式而进入命令行模式。 help：显示所有命令及其说明； help 命令：显示命令详细的使用说明； pri：查看所有环境变量，包括开机等待任意输入的时延（秒）、串口波特率（baudrate）、本地 IP 地址（ipaddr）、tftp 服务器端的 IP 地址（serverip）、自启动命令字符串（bootcmd，一般不用动）等等； setenv \u003c环境变量\u003e \u003c要设置的值\u003e：修改某一个环境变量为要设置的值，要设置的值 若是字符串则要加双引号； saveenv：将当前所有设置过的环境变量保存，掉电不丢失； reset：复位； dhcp：执行 DHCP 服务，获取 IP 地址，验证网络功能； setenv my：恢复系统的所有环境变量为默认，即使之前用户重设的环境变量都恢复默认； protext on/off 0~10000：对 Nor Flash 区域 [0x0 ~ 0x10000] 设置为写保护或取消写保护； movi：对 EMMC 进行操作； run bootcmd：，执行 bootcmd ，其是一个环境变量，为一段字符串形式的命令；上电后 u-boot 若处于自启动模式最后执行则执行的多条命令，默认为 下载内核、设备树和运行内核的多个命令，可以根据需要增加命令，以分号分隔。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:3","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 移植要点 要点： 一般厂家直接提供 u-boot 源码，做查看、修改(增加新功能) 或 u-boot 版本升级这三大块的用处；后两种都需要对新板子做适配/移植。 如果没有提供 u-boot 源码，那么就从 u-boot 官方版本中找到一个最相近的板子配置进行移植，这个需要水平较高。 一般把 u-boot 做成对应平台通用的和最小化的，即只保留必要的板级外设初始化代码（如串口、网口和 FLASH 等需要主要做适配，都尽量找能现成使用的），其他更多板级外设初始化在 Linux 移植部分中完成。 如果要深入学习，有以下要点可以参考： 如果芯片公司或者单位提供了移植好的 u-boot，可以用 beyong 软件把移植好的 u-boot 文件夹与 官方原版（版本要一致）进行对比，看一看改动了哪些文件夹和哪些文件，帮助学习。 uboot移植新手入门实践_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili。版本比较新。 正点原子【第三期】手把手教你学Linux之系统移植和跟文件系统构建篇_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili； 韦东山 _ 嵌入式Linux _ 第1期与2期间的衔接课程 _ u-boot编译体验和源码深度分析 _哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 老版本。 【韦东山 】移植U-boot 2012 04 01 到JZ2440_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 老版本。 linux—–uboot和kernel移植 - 灰信网（软件开发博客聚合） (freesion.com)，基本移植过程记录。 Linux驱动开发_嵌入式up笔记的博客-CSDN博客，内容比较丰富。 芯片公司、开发板厂家和用户三者之间的联系： 芯片公司移植的 u-boot 从一开始是基于官方的 u-boot 拿来修改，添加/修改自家的 EVK 评估版的板子型号、相关外设初始化文件，并修改 u-boot 的 Makefile 配置，然后把自家芯片的 EVK 评估版的硬件原理图、u-boot、Linux 和 根文件系统以及使用说明文档等等全部开源，以供下游做应用的公司/厂家和做开发板的公司拿来做修改或直接应用； 做开发板的厂家在拿到了芯片公司提供的芯片评估版 EVK 板子的原理图后，与 SoC 直接相关的比如 PMIC、DDR、FLASH、以太网 PHY 芯片等等不会做大改，一般直接照搬过来画自己的开发板。因为在移植 u-boot 的时候就不用再为新选型的芯片做代码适配，一般没必要做这种费力但效果不大的事情，能直接用的就尽量直接用，能不用改的就尽量不改。然后再拿到芯片公司提供的芯片评估版 EVK 板子对应的 u-boot 源码之后，同样的再添加/修改为自家开发板的型号、添加一点点自己板子的外设初始化代码（这个要求比较高）并修改 Makefile，便得到自家开发板适配的又一个 u-boot； 当用户（比如现在的我）拿到了开发板厂家 或者 芯片公司提供的 u-boot 源码，即所有相关文件和初始化代码都写好了，便可以直接编译进而使用，或者自己再进一步定制化，那么此时此刻间，具体的移植步骤介绍在以下： ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:4","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 配置/移植并编译 注意，网上很多 u-boot 移植教程都是三星的 2440 或者 4412 在 古董级别的 u-boot 上面的移植，不是说不好，而是现在的 u-boot（2019 以后的版本）的 Makefile 结构等等都已变化太大了。 平台相关的目录：arch、board、include 等，平台无关的目录：common、net、fs、drivers 等等。 环境构建 不同的 SoC 需要准备不同的交叉编译器，对于 i.mx 系列，参考其官网手册通过一系列 NXP 提供的自动化脚本生成，以及配置好环境变量，即可使用此专用的交叉编译器编译 u-boot、Linux kernel 和 Linux 驱动/应用。 现以 i.mx8mm 为例，参考从其官网网址下载的嵌入式 Linux 手册包 imx-yocto-L5.4.70_2.3.0.zip 里面的手册来准备编译环境，提前说明，这个步骤是对于 NXP i.mx 系列的独家方法，其中一些编译步骤要花费巨长的时间，读到此的游客了解即可，除非要用，否则可以不用实践一遍。对于买 i.mx 系列开发板的，如果不愿从头做一遍，可以直接使用开发板公司提供的资料里面的环境配置脚本和交叉编译器，就直接跳过这一小节。 以下步骤都在 Linux 主机上进行。 参考 “i.MX_Yocto_Project_User’s_Guide.pdf” 手册： Linux Ubuntu 18.04 主机安装必要包： sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm 新建存放资源的文件夹，这里取名 “nxp_imx”，在里面再建立一个放 bsp 的文件夹取名 “imx-yocto-bsp”； 配置 git 信息： git config --global user.name \"\u003cYour Name\u003e\" git config --global user.email \"\u003cYour Email\u003e\" git config --list 先下载 repo 程序：sudo apt-get install repo ；然后在 imx-yocto-bsp 文件夹下面执行： repo init -u https://source.codeaurora.org/external/imx/imx-manifest -b imx-linux-zeus -m imx-5.4.70-2.3.0.xml repo sync 如果上一条命令执行不成功，先删除目录中的 .repo 文件夹，再试；若还不成功，参考关于使用repo时repo init和repo sync失败的一个解决方案 - 代码的搬运工 - 博客园 (cnblogs.com)，参考这个文章的方法，若遇到 repo 超时错误，尝试用方法2： # 先手动下载 repo git 仓库 git clone https://gerrit-googlesource.lug.ustc.edu.cn/git-repo # 然后用以下命令替代上面第一条不成功的 repo 命令试试，这一句大概率会成功 ./git-repo/repo init -u https://source.codeaurora.org/external/imx/imx-manifest -b imx-linux-zeus -m imx-5.4.70-2.3.0.xml 上一个步骤执行成功结束后，会得到 imx-yocto-bsp/sources 文件夹和其他文件，You can perform repo synchronization, with the command repo sync, periodically to update to the latest code。源文说明：The “sources” directory which contains the recipes used to build one or more build directories, and a set of scripts used to set up the environment.The recipes used to build the project come from both the community and i.MX. The Yocto Project layers are downloaded to thesources directory. This sets up the recipes that are used to build the project. 构建针对 i.mx8mm 的配置，i.MX provides a script, imx-setup-release.sh, that simplifies the setup for i.MX machines. The script sets up a directory andthe configuration files for the specified machine and backend。在imx-yocto-bsp目录需要执行的命令模板： DISTRO=\u003cdistro name\u003e MACHINE=\u003cmachine name\u003e source imx-setup-release.sh -b \u003cbuild dir\u003e 以上命令需要填的空： DISTRO=is the distro, which configures the build environment and it is stored in meta-imx/meta-sdk/conf/distro. 可选：fsl-imx-wayland - Wayland weston graphics 和 fsl-imx-xwayland - Wayland graphics and X11. X11 applications using EGL are not supported，一般就都选这个吧； MACHINE=is the machine name which points to the configuration file in conf/machine in meta-freescale and meta-imx. 要选 meta-imx/meta-bsp/conf/machine/ 目录下的文件名，具体的板级配置文件，这里选 imx8mmddr4evk； -b specifies the name of the build directory created by the imx-setup-release.sh script.这里选-b imx8mmddr4evk_sh； 最终实际执行的命令： DISTRO=fsl-imx-xwayland MACHINE=imx8mmddr4evk source imx-setup-release.sh -b imx8mmddr4evk_sh 上一句完成后会自动进入 ./imx8mmddr4evk_sh 目录，并且执行信息最后面部分有提示，翻译过来就是可以执行 bitbake 命令了。 参考 “i.MX_Porting_Guide.pdf” 手册： 先说，这一步是构建交叉编译工具链，可以参考 “工具链构建的更多方法” 小节的方法构建，基于 yocto 的方法在个人 PC 上所需的时间太漫长了，除非有高性能的服务器。 Generate a development SDK, which includes the tools, toolchain, and small rootfs to compile against to put on the host machine. The same SDK can be used to build a standalone kernel. 在./imx8mmddr4evk_sh 目录要执行的命令模板： DISTRO=Target-Distro MACHINE=Target-Machine bitbake core-image-minimal -c populate_sdk 还是需要填空，实际执行的命令为： DISTRO=fsl-imx-xwayland MACHINE=imx8mmddr4evk bitbake core-image-minimal -c populate_sdk -c populate_sdk选项表示构建应⽤层⼯具链； The populate_sdk generates a script file that sets up a standalone environment without Yocto Project.这一步需要 Linux 主机有至少 150G 的空间，这一步要花很长很长时间，第一次执行 5 ~ 10 个小时是有的…也可能是从外网下载包慢，总之做好准备。 如果这一步漫长的过程中间被中断或者有下载包失败，那么可以在上一级目录中重新执行DI","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:5","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 编译流程 首先编译/$(CPU)/start.S，对于不同的 CPU，还编译cpu/$(CPU)下的其他文件； 然后，对于平台/开发板相关的每个目录、每个通用目录都使用它们各自的 Makefile 生成相应的库； 将前两部分产生的 .o .a 文件根据 u-boot.lds 进行链接；得到最终文件。 更多 u-boot 源码分析等内容看上面 “u-boot 启动流程”、“u-boot 移植要点” 章节内容。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:6","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"u-boot 图形化配置 在 uboot 目录里面先执行make \u003c板名\u003e_defconfig，再执行make menuconfig。方向键移动光标，enter 进入子菜单，空格键打开/关闭一个选项，双击 tab 键返回上一个目录。 执行make \u003c板名\u003e_defconfig之后会把配置信息写入 .config 文件，再执行make menuconfig，menuconfig 通过读取 .config 文件来显示，经过 menuconfig 配置并保存，实际是修改了.config文件，此时执行 make 命令进行编译会用.config文件（在make \u003c板名\u003e_defconfig的基础上再经过 menuconfig 修改之后的最终的配置文件）的配置信息进行编译；如果执行 make distclean 会删除.config文件；所以通过 menuconfig 配置的是临时的，经过清理后就不存在了。 目标 menuconfig 依赖 scripts/kconfig/mconf，后者会调用 uboot 根目录下的 Kconfig 文件开始构建图形化配置界面，此 Kconfig 里面的 mainmenu 就是主菜单，有关此菜单的 Kconfig 语法可以参考《【正点原子】I.MX6U嵌入式Linux驱动开发指南》的 34.2.2 Kconfig 语法简介 一节以及 34.3 添加自定义菜单 一节。 构建图形化配置界面更多参考： Linux内核编译——Uboot_笑傲江湖-CSDN博客； uboot图形化配置浅析 - lzd626 - 博客园 (cnblogs.com)； .. ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:7","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"添加自定初始化代码 以下还是根据 imx8mm_evk 板子而言，不同板子函数的位置会有变动。 接着前文的工作，只需修改board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c文件及其对应的 .h 文件，在其中的 board_early_init_f()、 board_init() 或者 board_late_init() 函数中添加自己要加的驱动代码。尽量只改这两个函数即可，其他初始化函数不用多动。 各个初始化函数的说明（以下是按照执行顺序排列，以下函数都在board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c文件里面）： The board_early_init_f() function is called at the very early phase if you define CONFIG_BOARD_EARLY_INIT_F. You can put the UART/SPI-NOR/NAND IOMUX setup function, which requires to be set up at the very early phase；这个函数被调用在第一次初始化阶段，初始化看门狗、串口时钟等。 The board_init() function is called between board_early_init_f and board_late_init. You can do some general board-level setup here. If you do not define CONFIG_BOARD_EARLY_INIT_F, do not call printf before the UART setup is finished. Otherwise, the system may be down；第二次初始化阶，段推荐在这里改； The board_late_init() function is called later. To debug the initialization code, put the initialization function into it；第二次初始化阶，推荐在这里改。 改变打印板子名： u-boot logo：打开 uboot-imx/tools/Makefile，执行:/LOGO_BMP搜索 “LOGO_BMP”，分析 Makefile 可知 默认使用$(srctree)/$(src)/logos/denx.bmp的图片，如果存在 logos/$(BOARD).bmp 或者 logos/$(VENDOR).bmp 就使用，可以直接在此按需替换。具体的显示 logo 的函数在uboot /board/esd/common/目录下的 lcd.c 文件中，大约在 81 行左右。屏幕的初始化配置在官方源码的\u003cboard name\u003e.c文件里面。因为 uboot 启动的时间很短，一般都使用 Linux 的 logo，所以 uboot 中可以将 logo 图片删掉，或者在\u003cboard name\u003e.c里面将显示有关的代码屏蔽掉。 增加 uboot 额外的版本信息，在 uboot 目录里面先执行make \u003c板名\u003e_defconfig，再执行make menuconfig，在 Console 里面的 Board specific string ... version string里面填入板子名和版本字符串。 对于 imx8mm： 在 arch/arm/dts/imx8mm-ddr4-evk.dts 里面的 model 改板名，板子上电后 uboot 的 Model: 会显示这里的信息；board/board-info.c 里面的show_board_info()会调用读取这个 model； 在 \u003c板名\u003e.c 里的 board_late_init()，有一个设置 uboot 的 board_name 环境变量； 对于其他 imx8 系列： 在 \u003c板子名\u003e.c 中，board_early_init_f()的init_sequence_f[]里面有一个checkboard()函数； 直接一点的方法：delete identify_board_id() inside checkboard() and replace printf(\"Board: \"); with printf(\"Board: i.MX on \u003ccustom board\u003e\\n\");； 间接方法，The identification can be detected and printed by implementing the __print_board_info() function according to the identification method on the custom board，查看一下identify_board_id()和 __print_board_info()这两个函数的内容，进行修改。 调试：在串口初始化之后的程序中可以添加printf()函数打印调试信息，初始化串口函数默认在board_early_init_f()里面。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:8","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"添加自定义命令 u-boot 添加自定义命令。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:9","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"添加命令行菜单界面 UBOOT通用菜单menu的实现_leochen_career的专栏-CSDN博客； uboot中的快捷菜单的制作说明-小超hide-ChinaUnix博客； 如何在U-Boot中添加自定义命令_HowieXue 薛永浩的博客-CSDN博客； … ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:10","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"合成最后的二进制文件 这里还是针对 nxp i.mx8mm 而言，armv8 的 SoC 应该都大同小异。 看 i.MX_Linux_Users_Guide.pdf 手册的 4.1.1 Bootloader 章节：On i.MX 8M SoC, the second program loader (SPL) is enabled in U-Boot. SPL is implemented as the first-level bootloader running on TCML (For i.MX 8M Nano and i.MX 8M Plus, the first-level bootloader runs in OCRAM). It is used to initialize DDR and load U-Boot, U-Boot DTB, Arm trusted firmware, and TEE OS (optional) from the boot device into the memory. After SPL completes loading the images, it jumps to the Arm trusted firmware BL31 directly. The BL31 starts the optional BL32 (TEE OS) and BL33 (U-Boot) for continue booting kernel. In imx-boot, the SPL is packed with DDR Firmware together, so that ROM can load them into Arm Cortex-M4 TCML or OCRAM (only for i.MX 8M Nano and i.MX 8M Plus). The U-Boot, U-Boot DTB, Arm Trusted firmware, and TEE OS (optional) are packed into a FIT image, which is finally built into imx-boot. 看 i.MX_Porting_Guide.pdf 手册 5.3 OP-TEE booting flow 章节：On Arm V8, Arm has a specified preferred way to boot Secure Component with the Arm Trusted Firmware (ATF). The ATF first loads the OP-TEE OS. The OP-TEE OS initializes the secure world. Then, the ATF loads U-Boot that modifies the DTB on the fly to add a specific node to load Linux TEE drivers. Then, the Linux OS is booted. 需要的组件：(U-Boot, Arm Trusted Firmware, DDR firmware) imx-atf（Arm trusted firmware）：ATF 主要负责 Non-secure 环境和 secure 环境的切换（编译后产生所需的一个 bl31.bin 文件）。 imx-uboot： nxp 提供的 适合 imx 系列的 u-boot（编译之后产生 u-boot-nodtb.bin、u-boot-spl.bin 和 设备树 .dtb 三个所需文件）。 system controller firmware：直接提供的一个二进制文件，启动时由 spl 或者 uboot 调用，用以初始化 DDR。 imx-mkimage：生成目标镜像的工具。 简短的说： 编译 u-boot，产生 u-boot-nodtb.bin、spl/u-boot-spl.bin、arch/arm/dts/xxx-imx8mm-base.dtb 文件后，再编译 imx-atf，再利用 imx-mkimage 镜像合成工具把所有编译好的文件连接整合成最后适合 imx8mm 的 u-boot 的二进制文件 flash.bin。然后可在 linux 主机 上使用 dd 命令烧入 sd 卡的存放 u-boot 的分区里面。或者使用根文件生成软件如 buildroot 或 yocto 合成最后的 sd/emmc 镜像文件。 具体步骤：参考 “环境构建” 小节 的第 4 ~ 6 步 “使用 imx-mkimage 链接合成所有文件生成最后二进制文件”。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:11","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"其他补充说明 比较两个文件的异同，可用 diff -yB 文件1 文件2 命令，以显示全部源文和标出不同之处显示。 Makefile 中，obj-y += xx.o xx.o 在编译时，只编译带有 obj-y的；比如 obj-$(CONFIG_MX6) += mx6/，若 CONFIG_MX6 为 y，则会编译 mx6/ 目录下的内容，否则不会。 在哪个目录添加了文件，若想其被编译，就在其所在目录的 Makefile 文件中添加 obj-y += \u003c文件名\u003e.o；COBJS-$(CONFIG_CMD_MMC) += cmd_mmc.o，这种是用变量控制的，若 CONFIG_CMD_MMC 变量为 y，则会添加编译，否则不会。 添加初始化代码： 在 include/configs/\u003c板子名\u003e.h 里面添加初始化代码相关的宏定义； 在 board/\u003c公司名\u003e/\u003c板子名\u003e/\u003c板子名\u003e.c 里，在 board_xxx_init() 函数里面添加对应的初始化函数，比如 board_eth_init() 里面添加 dm9000_initialize() 初始化函数。 增加个串口输出特定内容： 在 /common/board_f.c 中加：\\#include \u003cdebug_uart.h\u003e； 在 void board_init_f(ulong boot_flags) 中加一句 printascii(\"uboot runnig.\\r\\n\");。 不同家的 SoC 和同一家但不同系列的 SoC 的启动流程会不同，有的 SoC 的 DDR 等初始化在 DCD 段，有的在 SPL 段，在用芯片公司提供的 u-boot 编译的时候 会用 mkimage 根据已经提供的默认的 .cfg 文件进行正确的连接组合产生 uboot 镜像/二进制文件，具体还是要多看官方手册，和理解性的看《【主线剧情01】ARM IMX6ULL 基础学习记录》，只看这里是容易迷糊的。 i.mx8m 系列启动 Linux 所需的要素： imx-boot (built by imx-mkimage), which includes SPL, U-Boot, Arm Trusted Firmware, DDR firmware； HDMI firmware (only supported by i.MX 8M Quad)； Linux kernel image； A device tree file (.dtb) for the board being used； A root file system (rootfs) for the particular Linux image。 如何理解曾博所说的“看国外数学教材提高智商”？ - 知乎 (zhihu.com)，其中说到 “国内大学很多教材简直魔幻，是“你只有学会了才看得懂”，然后学生是“需要看教材才学得会”，反复套娃死循环。 “； 写一个操作系统内核有多难？大概的内容、步骤是什么？ - 知乎 (zhihu.com)，其中说到 “人家通俗易懂，很有诚意，比起那些复制粘贴强行装B的书不知道要强多少倍。。。 “； NXP i.MX 8M Mini平台Linux系统启动时间优化 | i2SOM湃兔核； … ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:12","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"署名 编辑整理：Github 页，知乎页 发表时间：始于 2021.5 且无终稿 首发平台：知乎 \u0026 Github 遵循协议：CC-BY-NC-SA 4.0 其他说明： 本文件是“瞰百易”计划的一部分，尽量遵循 “二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明（这中二魂…）！ 本文系广泛撷取、借鉴和整理，适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！ 转载请注明作者及出处。整理不易，请多支持。 ","date":"2021-04-10","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/:1:13","tags":["ARM","Linux","uboot"],"title":"【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8503-nxp-i.mx%E7%B3%BB%E5%88%97%E7%9A%84u-boot%E7%A7%BB%E6%A4%8D%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"categories":["【规范】系列"],"content":"比较详细、精炼的介绍了 C \u0026 MCU 编写规范和很多实用技巧、经验的总结收集","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"C \u0026 MCU 编写规范和技巧（coding style and more） ***p.s 温馨提示：点个 star 收藏一下回头慢慢看；或者下(白)载(嫖)下来，在 Typora 中阅读；[本文知乎地址（不是最新）](https://zhuanlan.zhihu.com/p/350839857) ；一个人整理不易，此文如此丰富不值忘记 star。***\r本文介绍一些 ANSI C 和 GNU C 的基本语法、编写规范，本文系广泛撷取、借鉴和整理，侵删。本文适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！本文已经是长期积累和堆叠而形成一定规模，不必按照从前到后的顺序去看，可以挑感兴趣的章节去看。 本文内容较多，推荐从 4 普适规则（General rules） 一节开始看起。 本文存在对应的 Github/Gitee 仓库地址，本文最新的原文 和 一些源码、备查手册等等 均放在里面。 按 1：引用观视频工作室视频【大师计划·林宝军03】北斗三号总师：我来跟你说说，…里面总师受访时所说的话： 5:48：“…所以我经常讲，要把一个产品做好，其实有三方面，一个是技术，一个是质量，一个是管理，这三方面；技术水平，质量保障能力和管理能力，三条腿哪个都少不了，少一个，这个东西（航天）也做不上去，其实技术只是一方面，…”。 6:44：“…光是技术上去了，不见得能做出一个系统。对我们工程来讲，就是（需要）规范的文化，什么意思呢，比如我们几十年的航天经验，我把这个经验总结成文字，总结成规范，不管是谁做，只要有一定的经验，按这个规范做出来，做得卫星出来，打到天上去就能好用，这就是规范文化。包括匠人文化和规范文化，最后都是按规矩去做，它强调的是解决了怎么做的问题，但它有一个缺点，没强调为什么，其实我认为在做的过程中，加个为什么可能更好。” 按 2：引用 雷军写代码水平如何？ - 知乎 (zhihu.com)。 雷总也在给后辈的寄语中不断强调代码要整洁，逻辑要无懈可击，自己写的代码要达到例程（示范程序）的程度。这一点和《代码整洁之道》的作者 Bob 大叔英雄所见略同了。 Bob 大叔就在《代码整洁之道》提出一种观点：代码质量与其整洁度成正比。 优秀的系统往往有优秀的结构设计，层次清晰，职责单一，模块化，方便拓展和复用。功能的添加往往只是在现有的框架中添加一个个模块和少量代码。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:0:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"O 目录 [TOC] ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:1:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1 日常素养 维护干净整洁的编程环境（保持愉悦的心情，干净整洁的桌面，友好和蔼（或者憨厚）的同事等等）。 身体坐直，按时走走，保证睡眠，计划运动。 要学习或使用新东西，全网搜集到好的手册和资料，就已经成功了一半（所谓好的资料不一定是官方教程或手册，可以是别人总结的入门系列文章或视频，适合自己快速摄入的才是好的）。 循序渐进，由浅入深。对什么也不感兴趣、不深入是浮躁，而且不经过深入全面的了解就硬扛大型项目也是一种浮躁。 习惯去看源代码（熏陶优秀代码风格，有时还能发现新东西）。 先搞清楚需求，再构思，再开发，顺序不能错。 尽量不要重复造轮子，时常逛开源网站，有新想法可以先去找轮子（注意遵守其开源协议），也许比自己写的更好，相信前人的智慧和同行们雪亮的眼光。 关于调试： 编译错误，如果不明白哪错了，直接无脑复制编译器的错误信息扔到搜索引擎框，然后点“搜索”按钮（大部分报错都是语法错误）。 嵌入式十年调Bug经验总结 - 知乎 (zhihu.com)。 关于提问，是一门艺术： 谈谈提问的艺术 | How To Ask Questions The Smart Way。 《提问的艺术：如何快速获得答案》（精读版）。 如何问出一个好问题？| 提问的艺术。 有结对编程，协作开发的意识。 有写文档的习惯（对项目写文档，或者日常写博客，或者没事就画一画流程图梳理想法）（不要在技术文章里写“日记”、写“小说”。），条理清晰，简化描述（Keep it stupid simple），并且一定要写上用例，写上例子，写上实例（重要的事情讲三遍）！ 做好版本管理，有备份的意识（打压缩包写上时间也好，使用 git 工具 也好，放到 U 盘 里也好，传到 个人 NAS 也好）。 时常看书，时常看看同行的文章，常读常新。 不止技术，不想当将军的士兵不是好士兵（有的人领导能力强，有的人能开发有竞争力的产品，有的人能把知识讲地透彻，有的人理论功底强），时常把视角拉远看一看。 对于我自己尽量做到：早起去吃饭，偶尔跑跑步，早睡想疲劳（睡觉的时候如若不易入睡，则想着自己身体和大脑很疲劳，就容易入困） ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:2:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"时常参考优秀设计 在方案设计完之后准备开始实施/实现，不论软硬件，先 全网找优秀的实例、原理图、代码、项目、库来参考实现，不要一上来就自己吭哧做。 广泛借鉴、引入第三方解决方案，或事半功倍。 计算机教育中缺失的一课 · the missing semester of your cs education (missing-semester-cn.github.io)，为什么大学c语言课不顺便教一下Linux，Makefile，git，gdb等配套工具链呢? - 知乎 (zhihu.com)。强 烈 烈 烈 烈 推荐看一遍！ EmbedSummary: 嵌入式大杂烩资源汇总 (gitee.com)。 programthink/opensource: 【编程随想】收藏的开源项目清单 (github.com)。 jobbole/awesome-c-cn: C 资源大全中文版，包括了：构建系统、编译器、数据库、加密、初中高的教程/指南、书籍、库等。 (github.com)。 github 上面的 各种 Awesome 系列 汇总仓库。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:2:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"规范参考 本文正文中参考的内容 见后面 “11 本文参考源” 一节。 更多参考强烈推荐阅读 C 语言编程规范 ~ Murphy’s Blog。基于 Markdown 的中文文档排版规范 ~ Murphy’s Blog。 嵌入式面试题，不断更新 - 知乎 (zhihu.com)，嵌入式面试题（二），不断更新 - 知乎 (zhihu.com)。 嵌入式软件工程师笔试面试指南-C/C++ - 知乎 (zhihu.com)。 C/C++ 代码风格和规范_路过的小熊~的博客-CSDN博客。代码整洁之道（一）最佳实践小结-阿里云开发者社区 (aliyun.com)。 .etc ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:2:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"2 程序框架要点 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"首要地重中之重 首要 清晰、明确需求 并 全面调研、收集资源 和 参考精华。如时间允许，开始具体任务开发之前，进行充分调研！包括：1、对要使用的 平台、框架 所提供的 功能、机制 和 能力 做全面的调研，撷取其中适合本任务的场景的部分 做组合 和 在其基础上开发；2、全人脉/全网 搜索相关设计 并 参考优秀设计，分析研究其这么做的原因、思路，对各个设计取其精华。 顶层设计 和 细化设计 阶段。理清整系统设计，首先对软硬件做良好的顶层设计/架构设计，详细的画出框图，细化设计保证可以实施、在设计上保证尽量减少可能发生的错误。画好框图、清晰的道明复杂系统机制也是一种难得的能力！ 层次化 和 标准化 的输出。软件工程结构的分层思想永不灭；标准化、通用化和可靠性设计高于功能设计。 你是为了使用而学习，那就快速整起来；你是为了调研/考试而学习，那就全面一些。你不要也不是书呆子。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"一些方面的提醒 时间、空间复杂度 的 取舍 和 有意识优化 时间复杂度表示一个算法内执行语句的数量在最坏的情况下随着循环次数 n 的增加而增长的数量级。一个算法内语句的使用次数（频度）表示为 f(n)，n 为算法内循环语句的循环数，n 的变化直接改变 整个算法的语句使用次数；时间复杂度 O(g(n)) 的定义为，对于一个算法，当且仅当存在正整数 c 和 n0，使得 f(n) ≤ cg(n) 对于所有 n ≥ n0 成立，则该算法的渐进时间复杂度为 f(n) = O(g(n))，g(n) 为 n 的函数。 各个时间复杂度的语句频度的增长速度比较：O(log2n) ＜ O(n) ＜ O(nlog2n) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!)，前三个很好，最后两个不可接受，剩余的强差人意。 程序的执行时间不仅依赖于问题规模，还可能随着数据的状态不同而变化，即其时间复杂度会变化，一般评价算法时候取最坏的情况的时间复杂度。 空间复杂度大同小异。 “低耦合，可重用，参数化，注释全” 划分好文件、功能函数和所需变量。函数 “低耦合，可重用，参数化，注释全”，变量尽量用结构体打包；可重用意味着直接复制代码或者直接复制文件到另一个项目上直接就用。 功能增加裁剪的灵活性：做好预编译设置。方便于切换调试版本和执行版本，方便于切换行为模式，方便于剪裁功能块；功能剪裁用一个名字带 “_config” 的文件集中管理，供用户修改各种剪裁用的宏定义，就像总控台。 参数化设计的适应性：对比如协议解析、模块/功能数量增减、数据范围的变化适应等地方尽量写的通用，通过参数设定来改变运行时/编译时的功能灵活变化。 设计高效、方便的数据存储的数据结构，设计高效、方便的算法来操作这些数据。 关于 MCU 的编写框架，我目前大抵就认我自己的开源项目 “stm32_framework” 的吧，规范都对齐这个项目。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"嵌入式 相关提醒 p.s 这里长期更新。 嵌入式 编程 的一些规范 项目 “stm32_framework” 编写时形成的一些经验和规范 更多具体的还以此项目的源码和架构为准！ 本文章 “C 编写规范” 的全部规则都适用。 尽量利用硬件资源和外设资源，减少 cpu 负担。 系统外设功能的启用与否均用宏定义 SYSTEM_SUPPORT_XX 来管理剪裁。 RTOS 任务函数均使用 os_task_xx_xx() 命名，属于\"os_task\"。 中断优先级分组选用分组 4，即 16 级抢占优先级，不用 0 级响应优先级。 IO 的低电平为有效电平，高电平截止或者无效；按键IO尽量都使用外部中断。 至少用一个定时器提供 1ms 或者 10ms 的时基，再用软件分频为 50ms/100ms/300ms/1s 等。 外设（Periph）和设备（Devices）分别初始化，外设的启停成对编写，命名统一。 通讯外设的发送和接收都使用中断，并尽量使用上 DMA，以串口为例如下： 接收：（依时间间隔区分帧为例） 接收中断 -\u003e 打接收标志位，记当前时间（定时器计数器），比较上次接收的时间，启动 DMA -\u003e 接收缓冲区（足够大，大于2帧） -\u003e 送解析函数。 发送：（类 lwip 的 tcp 的发送逻辑，事件驱动） 要发送的串放入 发送缓冲区，检查发送启动标志位是否就绪，若就绪就打 发送启动标志位 -\u003e 发送中断中，检测发送启动标志位，判断是否发送 发送缓冲区 的串，发完清此标志位，即设为就绪态。 等等等等。 引自网络的好文章 / 规范经验分享 单片机STM32有什么推荐的裸机编程架构么，或者推荐的思路也行，谢谢？ - 知乎 (zhihu.com)： 正常的做法应该是剥离硬件相关部分,把逻辑代码剥离出来在PC上架一个虚拟环境来调试,,等做的比较稳定后,再对接实际的硬件直接接口往下层MCU上移植,好处很多,一个是可以充分使用Visual studio强大的调试和性能分析功能,找bug什么的会比直接mcu上调快几倍几十倍,二是要换平台换MCU也很方便,直接改改底层就能用了,是减少项目库鲁西的一个好办法。 .etc 状态机与分级/并发状态机 多任务、复杂流程的整机功能要使用状态机方法来表达、建模和实现。可以多用状态机来完成各种任务，大到整个程序的状态、模式控制，小到具体模块内部的工作实现。 多任务、复杂流程的整机功能要使用状态机方法来表达、建模和实现；益于：思路清楚、维护方便、扩展性好；不用状态机编程比较难得到这几个优点。 设计状态机要根据需求画状态图，再着手实现。要点：关键是画好状态图、不能进入死循环、不能进入非预知状态、穷举所有可能的分支。 在系统的状态划分时，如果细分出的状态特别多，那么要考虑分级状态机或并发状态机（参考书 《基于状态机的嵌入式系统开发》，该书比较老了，思想进行提取）。两种状态机以下分别说。 分级状态机属于上下级划分，而并发状态机属于多个状态机没有从属关系而一同运行（并发不等同于并行）。 这里介绍两种状态机构建模板/方法，一种是 “一个状态对应一个函数” 的模板，另一种是 “switch-case” 方式。前者为作者自实现的，比较易懂好用，其核心代码开源在 “stm32_framework” 仓库中 F4 里的 \\USER\\USER\\fsm 路径内；后者的例子见 额外文档/fsm-switch-case实现例子.pdf。 分级状态机 系统的顶层状态机一般设计有包括 初始化（init）、运行（run）、待机/空闲（standby）和停机（halt）状态 等这几个最基本的状态，在每个基本状态下又可细分多个状态组成子层状态机。 在这里，顶层状态机使用 “一个状态对应一个函数” 的模板来实现，子层状态机使用 “switch-case” 来实现。 并发状态机 一个系统物理上可以分为若干个同级别的大块，而每一个大块在信号连接上与其他大块之间有少量联系。如果若干是指 10，此时就可以设计 10 个状态机，每个状态机里有若干状态，而某个状态机里的某个状态的转移条件有其他状态机里的事件发生。 意义，比如系统可以划分为 10 个状态机，每个状态机有 3 个状态，如若合成一个状态机，那么将会有 3^10 那么多个系统状态。 多个平级的同时运行的状态机（并发状态机）可以任选用上述两种模板/方法构建。 嵌入式 通讯协议 的一些设计要点 通讯尽量使用成熟的协议来封装数据。 以打包、解包形式进行通讯。鉴于见识有限，协议选择还需要广泛调研和商榷，以下仅为举例： 串口 的 应用层 通讯协议 可以上 Modbus。 CAN 的 应用层 通讯协议 可以上 CANOpen。 TCP 的 应用层 通讯协议 还有待确定，需要选择一个支持大带宽的，可以再加上一层 TLS/SSL。可以用 json 格式封装数据。 如果要自定串口等接口的通信协议，要考虑的点： 数据帧格式规定： 自定义数据帧（数据打包）的一般格式为：帧头 — 命令/数据类型枚举 — 数据区长度 — 数据区 — 校验区。 这是一般做法，可以有效避免数据区出现帧头打断接收或解析等等问题；帧头可占一个字节，类型枚举可占两个字节，数据区长度可占四个字节，校验区可占两个字节（可选算法：0xFFFF - 该帧前面的所有字节加和）。 如果数据区内有多个数据块，每一块可以按照此一般格式合成：该数据块类型枚举（1个字节） — 该数据块数据长度（1或2个字节） — 该数据块的数据。 一帧有确定的长度；如果按照上面的帧格式，可以没有帧尾，也可以加上；帧头和帧尾必须是确定的，帧头和帧尾的选取尽量避免与数据区重合。 保证一帧尽量连续传输，没有中断； 在有限确定的时间内完成发送； 数据的发送接收相关的函数与数据的打包和解析的相关函数，编写规范上应相互解耦，可重用； 接收完成标志位的置位大抵有 两种/三种 方式：一个是判断有帧头和等待帧尾来判断为一帧，一个是从接收字节开始计时并在一定时间间隔没有接收数据后判断为一帧。但是当一帧数据的格式是确定的时候，就每次都连续接收一帧数据若超时则取消该帧，即前两种方式并用的方式。 参考 最适合单片机的通信协议，如何设计？ (qq.com)。 这篇提到 通讯协议设计中，一帧消息的结构：Head——Type——DataSize——Data——SUM——Tail。 其 强烈建议您采用 “状态机” 来解析 UART 数据帧，并且把解析工作放在 ISR（中断服务程序）完成，根据 DataSize 确定要连续的接收数据的长度，再进行 SUM 和 判断 Tail，再将整个数据帧提交给进程处理。 只要设计得当，每次进中断只执行 “比较接收数据 -\u003e 更新状态变量 -\u003e 存储接收数据” 这三个处理动作，设计其处理的快速而高效就可以。 重传机制。如果检测到通讯数据发生了错误，则要有重传机制重新发送出错的帧。 嵌入式 编程 的鲁棒性相关内容！ 嵌入式开发中的防御性C语言编程 (qq.com)，下面对该文中内容进行简练提要，再加一点自己的内容。 函数的传入参数的合法性检查；防止数据的类型越界，用 #include \u003climits.h\u003e 里面的一些类型极限值宏比较来确定；防止指针、数组的越界；返回标准的错误值。 尽量用上 硬件 看门狗；要尽可能早的开启看门狗；不要在中断中喂狗，除非有其他联动措施；喂狗间隔跟产品需求有关，并非特定的时间。当然也不能一味的用 看门狗 去解决 系统 “跑飞”、卡死 等问题，应该思考和解决其根源，软硬件都有可能出问题；调试时候可以不加看门狗，调试稳定之后的正式版/稳定版上可以加上看门狗。 关键数据储存多个备份，取数据采用“表决法”。比如，一个关键变量可以分别定义三份（多处备份），并分别指定到三个不连续的 RAM 区中，并在定义时按照原码、反码、0xAA的异或码进行初始化。 uint32 plc_pc=0; // 原码 __attribute__((section(\"MY_BK1\"))) uint32 plc_pc_not=~0x0; // 反码 __attribute__((section(\"MY_BK2\"))) uint32 plc_pc_xor=0x0^0xAAAAAAAA; // 异或码 当需要写这个变量时，这三个位置都要更新；读取变量时，读取三个值做判断，取至少有两个相同的那个值。 对非易失性存储器进行备份存储。非易失性存储器包括但不限于Flash、EEPROM、铁电。仅仅将写入非易失性存储器中的数据再读出校验是不够的。强干扰情况下可能导致非易失性存储器内的数据错误，在写非易失性存储器的期间系统掉电将导致数据丢失。 一种可靠的办法是将非易失性存储器分成多个区，每个数据都将按照不同的形式写入到这些分区中，需要进行读取时，同时读出多份数据并进行表决，取相同数目较多的那个值。 软件锁。用于保证 各个函数按照一定顺序被执行，或者 多个变量 按照一定顺序、环环相扣的 被初始化、读写等。举例：写 FLASH 函数内，先判断一个特定设置的安全锁标志ProgStart，只有这个标志符合设定值，才会执行编程Flash操作。如果因为意外程序跑飞到该函数，由于ProgStart标志不正确，是不会对Flash进行编程的。 输入开关量容易受到尖脉冲干扰，如果不进行滤除，可能会造成误动作。一般情况下，需要对开关量输入信号进行多次采样，并进行逻辑判断直到确认信号无误为止。输出开关信号，简单的一次输出是不安全的，干扰信号可能会翻转开关量输出的状态。采取 重复/周期性 刷新输出可以有效防止电平的误干扰的翻转。 寄存器里面的值容易变化，而 FLASH ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:3","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"优化程序执行性能 相关提醒 可以总结为三大方向上去优化： 硬件（硬件决定了最高性能，软件实现去逼近。尽量多的利用硬件提供的）。 软件编码实现（完成关键任务代码本身的执行效率提升，包括数据结构与算法的精良设计，包括对驱动提供的机制、操作系统提供的机制等等的高效利用）。 编译器（理解编译器对代码的编译和优化，让编译器的编译、优化结果达成你想要的）。 具体的里面的道道、经验很多需要慢慢内化、积累。 通用优化策略 引自 《深入理解计算机系统》读书笔记 \u0026 要点总结\u003c中\u003e | 浅墨的部落格 (0xffffff.org)。 编写高效程序需要几类活动：第一，我们必须选择一组合适的算法和数据结构；第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。对于第二点，理解编译器的优化能力和局限性是很重要的。编写程序的方式中看似只是一点点的变动，都会引起编译器优化方式上很大的变化；第三项技术针对处理运算量特别大的计算，讲一个任务分为多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算。 尽管做了广泛的变化，但还是要维护代码一定程度的简洁和可读性。 程序员必须编写容易优化的代码，以帮助编译器。主要包括：消除循环的低效率，减少过程调用和消除不必要的存储器引用。 在实际的处理器中，是同时对多条指令求值，这个现象叫做指令级并行。特别地，当一系列操作必须严格按照顺序执行时，就会遇到延迟界限（latency bound），因为下一条指令开始之间，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限会限制程序性能。吞吐量界限（throughput bound）刻画了处理器单元的原始计算能力。这个界限是程序性能的终极限制。 没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计的这些方面仍然是程序员主要关心的。 提高代码运行效率，9个提高代码运行效率的小技巧你知道几个？ - 知乎 (zhihu.com)。 C语言编程之运行速度优化方法汇总（转载）_automan2019的博客-CSDN博客_c语言常用的运行速度优化方法，C语言编程之运行速度优化方法汇总 - 腾讯云开发者社区-腾讯云 (tencent.com)。 etc。 嵌入式 编程 提高 CPU利用效率、降低CPU占用举措列举 尽量利用CPU硬件、外设、提供的机制来完成相关任务。比如： 乘除法尽量用上FPU和DSP相关的指令。 外设数据和内存数据之间的转移尽量使用 DMA（首选） 或 收发中断。 收发数据的外设带有 FIFO 则会减少 CPU占用，比如没有 FIFO 则每次来数据都会中断 CPU，而带 FIFO 则会只在其满一次或半满一次的时候才会中断 CPU 来一次性处理一整个大块的数据，大大提高效率。 软件编程上需要大块数据转移、传递的时候尽量只传递其指针，即尽量使用内存映射的思路，尽量减少数据的拷贝。 优化算法，尽量降低具体模块的运行的时间复杂度。合并计算式，在数学上化简计算至最简再写入程序。合理范围内去减少 CPU 运行的 无效/无用的代码。 浅谈嵌入式MCU软件开发之代码风格与代码优化 (qq.com)。 .etc 可移植性 相关提醒 编写可移植C/C++程序的要点-面包板社区 (eet-china.com)。 1、分层设计，隔离平台相关的代码。 2、事先熟悉各目标平台，合理抽象底层功能。 3、尽量使用标准C/C++函数。 **4、尽量不要使用C/C++新标准里出现的特性。**就是说不要太激进。 5、尽量不要使用C/C++标准里没有明确规定的特性。 6、尽量不要使用准标准函数。 **7、注意标准函数的细节。**注意不同平台下相同 API 的微小差异。 8、小心数据标准数据类型。 9、最好不要使用平台独有的特性。 **10、最好不要使用编译器特有的特性。**即少用编译器的特有扩展关键字。 11、注意平台的特性。 个人补充，除非程序本身将来没有移植的打算，那就可以根据平台、工具链等提供的机制 深度地、特制地、独占性地 优化程序。 .etc ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:4","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"生成静态库、动态库 p.s 用时现查，再整理到这里。 Unix 环境高级编程（一）：开发环境_屋外下着猫和狗的博客-CSDN博客_unix环境高级编程——四、静态库。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:3:5","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"IT 学习路线 C语言基础（看书、B站等均可） → C语言三剑客：《C和指针》、《C陷阱与缺陷》和《C专家编程》，经典永流传 → 数据结构与算法（线性表/树/图/哈希 + 排序/搜索/规划等等等 按需学） → 计算机专业学科看。《计算机组成原理》/《计算机体系结构》；《计算机操作系统》/《现代操作系统》/《深入理解计算机系统》；可选《编译原理》、《深入分析GCC》；网络协议如《计算机网络》、《TCP-IP详解卷一/卷二/卷三》等 → 可选 《CPU自制入门》 → 走向：嵌入式 Linux 方向、FPGA / 芯片设计 / 验证方向、具体某算法方向（如 CV、ML、DL）等等。 更多可详细参考 rd2coding/Road2Coding: 编程之路 (github.com) 的总结，比较全面了。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:4:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"相关坚韧大厚书 没给出链接的 网搜名字即可。 哪本《数据结构与算法》最好？ - 知乎 (zhihu.com) 该回答列举了一些不错的数据结构与算法方面的书籍。 《算法导论》（经典）是计算机学科的算法入门书。 《计算机体系结构》（经典），《计算机操作系统》/《现代操作系统》/《深入理解计算机系统》。 《编码的奥秘》，相关介绍/推荐 想练习《编码的奥秘》里面的知识，有什么软件有帮助？ - 知乎 (zhihu.com)。《编译原理》（经典），《深入分析GCC》。 网络协议如《计算机网络》、《TCP-IP详解卷一/卷二/卷三》，想深入了解 HTTP 协议，有哪些值得推荐的书籍？ - 知乎 (zhihu.com)。 嵌入式应用相关：《GNU Make》，《Debugging with GDB》，《Linux 高级程序开发》，《POSIX 多线程程序设计》，《嵌入式Linux基础教程》，《嵌入式Linxu应用开发完全手册》，《嵌入式Linxu应用程序开发详解》。 嵌入式底层相关：内核相关：《深入理解Linux内核》，《Linux内核源代码情景分析》，《Linux内核设计与实现》；驱动相关：《Linux设备驱动程序》，《Linux设备驱动开发详解》，《Linux驱动开发入门与实践》。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:5:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"相关有趣/耐看书或视频 学习心得介绍 | 小林coding (xiaolincoding.com)。介绍 | 小林coding (xiaolincoding.com)。 13 万字 C 语言从入门到精通保姆级教程2021 年版_极客江南的博客-CSDN博客。 tangtangcoding/C-CppLearning: C语言与C++学习 (github.com)，内容超多。 图解系统 小林，笔记：图解系统（小林coding）_NiXGo的博客-CSDN博客，推荐。 图解网络 小林，推荐。 趣谈网络协议。 手绘图解 HTTP。30张图解HTTP常见面试题。 TCP/IP 教程 | 菜鸟教程 (runoob.com)。HTTP 教程 | 菜鸟教程 (runoob.com)。 《嵌入式C语言的自我修养》 从沙子讲到 CPU，从编辑器讲到编译器，从高阶 C 语言讲到内存管理，从 GNU 讲到多任务编程。 （完结）（小甲鱼）数据结构和算法_ 哔哩哔哩 _bilibili。 国嵌唐老师主讲【数据结构与算法C语言】（非常犀利）_ 哔哩哔哩 _bilibili 讲的慢。 《算法新解》开源书，我为什么加下划线？，《啊哈！算法》。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:6:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"3 大厂规范和名设计模式 以下强烈建议空闲时认真学一学。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"大厂 / 名家规范 Google 开源项目风格指南——中文版 — Google 开源项目风格指南 (zh-google-styleguide.readthedocs.io)。 华为 C语言编程规范 华为C语言编程规范（精华总结）。 C语言编程规范（一）（华为标准要求）。 C语言编程规范（二）（华为标准要求）。 Qihoo360/safe-rules: 详细的C/C++编程规范指南，由360质量工程部编著，适用于桌面、服务端及嵌入式软件系统。 (github.com)。 MISRA C Coding Standard。 [Linux CodingStyle] Linux 内核源代码目录下的 Documentation/CodingStyle 文件。中文：Linux 内核代码风格 — The Linux Kernel documentation。 嵌入式软件编程规范 (qq.com)，对文件架构、函数、变量等的规范均有涉及。 《航天软件C安全子集-GJB5369标准规范》，离线在本地 \\额外文档 里。 《最强安全关键C代码规则实战手册》，离线在本地 \\额外文档 里。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"设计定律、原则和模式 总结性的： guanguans/design-patterns-for-humans-cn: 设计模式超简单的解释。 (github.com)。 nusr/hacker-laws-zh 对开发人员有用的定律、理论、原则和模式。 为了写好代码，你坚持了哪些好习惯？ - 知乎 (zhihu.com)。 比较优雅地编码（良好的命名，清晰的结构和不差的算法）。 如何正确地使用设计模式？ - 知乎 (zhihu.com)。 C语言和设计模式（总结篇）_平凡的程序员-CSDN博客_c设计模式。 23种设计模式全解析_CodeAllen的博客-CSDN博客。 架构与设计 之一 C 嵌入式设计模式（Design Patterns for Embedded Systems in C）的学习记录_itexp-CSDN博客。 书籍推荐《调试九法-软硬件错误的排查之道》 - lumang - 博客园 (cnblogs.com)。 etc. 细分性的： 观察者模式与订阅发布模式的区别 - 一像素 - 博客园 (cnblogs.com)。 etc. ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:7:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"4 普适规则（General rules） p.s 以下所有章节中示例代码均以 32 / 64 位机为运行环境，即 int 占 4 字节。 p.s 下文 会出现 遵循 \"属什么 _ 是什么 _ 做什么\" 的命名形式 的规范，但是也推荐反过来，遵循 “做什么 _ 是什么 _ 属什么” 的命名形式。 第一条，请您重视编写规范！可以有代码洁癖。 参考 “10 大厂规范和名设计模式” 一节里面的更全面的规范总结，这里只点到有限的部分。 使用 C99 标准（某些仅支持 C98 的 IDE 除外）。 一个 tab 四个空格（对于 Vscode、Notepad、Eclipse、Vim 和 MDK/Keil、IAR 等编辑器，都应该设置按一下 tab 为输入四个空格，这样文本样式在不同编辑器里打开尽量不会乱）。 运算符前后空一格，给函数传递的多个变量之间在逗号后空一格，一元操作符后不要加空格，例子如下。 for(i = 0 , tempNum += 3; i \u003c 6; ++i) /* i，j，k 永远滴神 */ /* for(i = 0; i \u003c 6; ++i) 这么写是循环 6 次，可以记住 */ tempNum = tempNum + 3, tempNum += 3; int32_t tempNum = sys_example_sum(4, 3); sys_example_func(\u0026time_data_struct, !(++is_time_show)); 注释里，字母和数字的两边空一格，尽量用/* ……… */注释，而非//...，例子如下。对于注释遵循 Doxygen（详见关于注释的形式（Comments）一节） 等规则的除外。 /* 用 3 这个数字代替洋文 three 了解了吗 */ 关于命名。 文件统一采用小写命名。 变量和函数的命名都只用小写（尽量），宏定义使用全大写（尽量），并遵循 “属什么 _ 是什么 _ 做什么” 的命名形式，如：sys_irq_disable()，该 API 属于 sys 级别函数，是 irq 管理，做 dsiable 的功能。不要用晦涩的英文缩写甚至拼音就不用讲了吧。 具有互斥意义的变量或者动作相反的函数应该是用互斥词组命名，例子如下。 add/remove begin/end create/destroy insert/delete first/last get/release increment/decrement put/get add/delete lock/unlock open/close min/max old/new start/stop next/previous source/target show/hide send/receive source/destination copy/paste up/down 不要使用单字节命名变量，但是允许使用 i， j， k 这样的作为局部循环变量。 关于函数、变量、宏定义等的命名看 5 具体各部分的规范形式章节。 控制语句总加括号（即使分支执行语句只有一句），成对的括号要在竖方向上对齐，用 tab 把层次分地清清楚楚，例子如下（为了节省空间，下面示例用横向写~）。 if( ) for (i = 0; i \u003c 6; ++i) do switch (check()) { { { { case 0: }else if( ) } }while( ); fsm_do_a(); { break; case 1: }else fsm_do_b(); { break; default: } break; } 对于多个条件的 “与”、“或” 等操作，应该将每一个条件都用括号括起来，层次分明，如：if ( ( (c == ' ') || (c== '\\n') ) \u0026\u0026 (b == '\\t') ){;}。 分支控制语句要写明所有分支情况，每一个条件都有明确的去向，对于 if 必带 else，对于 switch 必带 default，诸如此类。 无限循环尽量用 for(;;) 替代 while(1) 等；条件循环语句用后者。 层次分明，多用 tab 划分层次关系（预编译部分代码也不例外），例子如下。 #ifdef _DEBUG #define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_) #else #define DEBUGMSG(msg,date) #endif 长运算语句尽量多的用括号（每一步运算都用括号括起来），并做好空格增加可读性，例子如下。 temp = ( 0x7F \u003c\u003c ((xByte - 1) * 8) ); #define MAX( x, y ) ( ((x) \u003e (y)) ? (x) : (y) ) 用 if (check_func()) { ... } 代替 if (check_func() == 1)，判断是否为 ‘0’ 可以用后者的写法（即check_func() == 0 或 NULL，或者用 !check_func()），判断 ‘1’ 用前者写法。 判断指针是否为空只用 “NULL”，即 void *ptr0, *ptr1; if ( (ptr0 == NULL) || (ptr1 != NULL) ) { ... }。 不用变长数组，用内存 分配/释放 函数 malloc() 和 free()。 大块内存请使用内存管理。 尽量减少数据传输过程中的拷贝，对于全局变量的字符串、数组和结构体等，采用传递指针的方式。 文件操作中 open 和 close 成对使用，内存管理 malloc 和 free 成对使用。 关于源文件、头文件和变量作用域等。头文件里的大学问，C语言需要注意这些原则… (qq.com)。 变量、API 的作用域要明确：定义时带有 static 修饰符的变量（无论是声明在在某个函数里还是函数外）是 只在该文件具有作用域的，其他文件不能够访问到。一个文件的变量声明都放在 .h 里面，公有变量声明时 加 extern 修饰符 以供其他文件调用，私有变量声明时不加 extern 修饰符。明确好所有变量和函数在工程中的调用范围，由此来控制其作用域的 缩小 / 尽量最小化，减少不必要的 调用 / 引用，对编译时间和管理都有好处。 非必要的不引用：在 .c 文件中 include 自己对应的 .h 文件和需要用到的 .h 文件，不要引用多余的 .h 文件；.h 文件中同样只引用用到的头文件；头文件尽量写成无依赖的；尽量减少依赖，这就考验整个系统的规划和设计。 不一定 一个 .h 文件对应 一个 .c 文件：如果 一个模块 包含了多个 .c 源文件来实现，那么将它们放入同一个文件夹并用模块名命名，然后只用一个 .h 头文件声明 该模块的 接口。 关于开源协议:Every file (header or source) must include license (opening comment includes single asterisk as this must be ignored by doxygen). Use the same license as already used by project/library. 对于 .h 文件，其基本格式如下。每一个文件在最后留有至少一个空行。 #ifndef TEMPLATE_H #define TEMPLATE_H #include \u003cstdint.h\u003e#include \"all_other_custom_file.h\" /* 当 C 和 C++ 代码混合编译的时候，在下面 extern \"C\" 内的 两个括号 中间放 C 部分的声明代码 */ #ifdef __cplusplus extern \"C\" { #endif /* __cplusplus */ /* C 部分的声明代码 */ #ifdef __cplusplus } #endif /* __cplusplus */ #endif /* TEMPLATE_H */ /* 区分 C 区 和 C++ 区也可以这样写 */ #ifdef __cplusplus cout \u003c\u003c \"c++\"; #else printf(\"c\"); #endif /* 文件结尾至少留有空行 */ 理论上讲，任何递归算法都可以通过循环等方法实现，尽量不用递归，不好查阅和容易栈溢出。 更多网友总结的杂类细节规范、规则： 学C/C++语言，32个必备修养！ (qq.com)。 etc… ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:8:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"5 具体各部分的规范形式 参考 “10 大厂规范和名设计模式” 一节里面的更全面的规范总结，这里只点到有限的部分。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于函数定义形式（Functions） 小写；星号 * 靠近类型名一端；用\" _ “分割语义；对齐以保持良好阅读性。 命名遵循 属什么 _ 是什么 _ 做什么 的形式，例子如下。 void sys_example_init(void); const char* sys_string_generater(void); my_struct_t* sys_example_hello(int32_t para1, int32_t para2); void fsm_state_set(int32_t fsm_ID); my_type_t fsm_state_get(void); my_ptr_t* menu_get_current_ptr(void); 函数的局部变量数量最好不超过 5 - 10 个，即不要占用太多的内存/栈资源。 一个函数尽量只做一件事，否则划分为多个更小的函数；不要重复，保持各个代码块的独特性。 低耦合，可重用，参数化，注释全！ 对函数的传入的实参做合法性检查。检查指针（ptr == NULL 就 return -1）；检查变量范围，变量有大小限制的，在注释里写明；在其他地方调用此变量的时候要进行检查或限幅，例子如下。 /* 幅值系数，范围 0~1 */ float wave_point_A = 0.8; /* 检查：*/ if( wave_point_A \u003e 1 ) wave_point_A = 1.0f; if( wave_point_A \u003c 0 ) wave_point_A = 0; /* 限幅：*/ wave_point_A \u003e 1 ? 1.0f : wave_point_A; wave_point_A \u003c 0 ? 0 : wave_point_A; 如果函数传入参数（形参）的数量过多（超过 5 个），那么要考虑精简或者用其他办法，即可以将参数打包为全局的 数组 或 结构体 等 然后传递其指针；函数形参为一个指针变量则用 int* i形式，形参为一个数组应写为 int i[]（并且另一个形参要传入数组的最大长度，因函数内无法获知，字符串除外，因其结尾会被补充 \\0），在此时应做区分而避免混用；对于返回多个值同理；字符串指针 和 结构体指针 等在定义时若未初始化，则使用前要用 malloc() 为其申请空间，否则就是野指针，对其赋值将直接导致 “宕机”（so weak）。 对于函数可能传入的参数是不定的任意类型，对于指针类型定义形参用 void* x ，对于变量用void x。函数明确 没有/不能 传入/返回 参数时要在形参处用 void 指明，如上面的void sys_example_init(void);。 对函数的错误返回要做全面的处理；一般 返回 0 表示 正确 或 运行正常终止，返回其他表示错误，具体的值表示错误代号，可用定义了所有错误类型的枚举变量作为函数返回值类型，或者返回值 0 表示成功，正数表示失败，此正数可以表示错误代码；并设计专门的机制对错误标识做处理。 函数的嵌套不要过多，一般控制在最多 4 层。不要用递归这种反阅读便利的写法（并且控制不好易栈溢出），用循环语句实现。 关于 指针函数 和 函数指针。 指针函数即指 返回值带指针变量的函数，使用情景参看上面。 函数指针即指 函数类型的指针，定义的形式和使用情景如下，函数指针名加后缀 “_ fn”，函数指针类型定义名再追加后缀 “_ t”。 TODO：有待吸收的 C语言函数指针的六个高级应用场景 (qq.com)。 /* 函数指针定义写法和用法举例 */ unsigned char (*sys_print_compile_time_fn)(unsigned char); typedef unsigned char (*sys_print_compile_time_fn_t)(unsigned char); unsigned char print_compile_time(unsigned char is_print) { if(is_print) { printf(\"%s\\n\",__TIME__); return 0; } return 1; } unsigned char print_compile_date(unsigned char is_print) { if(is_print) { printf(\"%s\\n\",__DATE__); return 0; } return 1; } int main() { /* 用法1，给函数指针赋值 */ sys_print_compile_time_fn = print_compile_time; /* 用法2，定义一个函数指针变量，并赋值 */ sys_print_compile_time_fn_t print_compile_time_fn; print_compile_time_fn = print_compile_time; /* 调用 */ (*sys_print_compile_time_fn)(1); (*print_compile_time_fn)(1); /* 改变函数指针指向的函数，再调用 */ print_compile_time_fn = print_compile_date; (*print_compile_time_fn)(1); } /* 再举一个例子，引自 《C程序设计语言》 */ /* 一些声明 */ char *lineptr[500]; int numcmp0(char *, char *); /* API 声明时形参可以不带变量名 */ int strcmp0(char* stri1,char* str2); void qsort(void *lineptr[], int left, int right, int (*comp)(void *, void *)) { ... if ((*comp)(v[i], v[left]) \u003c 0) {...} ... } /* 调用，三段式写法来选择传入哪个API，再强转为一个函数指针类型 (int (*)(void*,void*)) */ qsort((void**) lineptr, 0, nlines-1, (int (*)(void*,void*))(numeric ? numcmp : strcmp)); 内联函数。可以将 频繁被调用的、代码量较少的 函数用 inline 关键字修饰为内联函数，编译器将 该函数内容直接复制到 被调用的地方，减少频繁进出函数的处理器开销，但如果调用的地方极多则整体代码量急速膨胀。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于变量定义形式（Variables） 小写，对齐以保持良好阅读性。 同类型的变量声明放在一行，变量定义时避免用函数返回值。 命名中 用下划线 _ 分割语义，命名遵循 “属什么 _ 是什么 _ 做什么” 的形式，要意义明确。命名开头以两个下划线或一个下划线的约定俗成保留给系统，因此普通应用中应避免。 避免使用 stdbool.h 里的 “true” 或 “false”，用 “1” 或 “0” 代替。 变量类型，除了char* 、float 和 double，都使用 stdint.h 库（对于不同位数的机器，使用这个文件里面的类型定义，可以明确每个类型的长度）里面的，统一起来。整文件或整工程中变量定义处的变量关键字修改，可以用 批量替换 来完成，如 统一的将 INT8 修改为 char。 /* signed int 和 unsigned int 区别很大，前者是可以表达正负数的源码，后者是从 0 开始的正数或是一串参与逻辑运算的二进制 */ /* 定义一些常用的数据类型短关键字，为兼容性附加，可选 */ typedef int32_t s32; typedef int16_t s16; typedef int8_t s8; typedef uint32_t u32; typedef uint16_t u16; typedef uint8_t u8; typedef const int32_t sc32; typedef const int16_t sc16; typedef const int8_t sc8; typedef const uint32_t uc32; typedef const uint16_t uc16; typedef const uint8_t uc8; /* 以上 12 个的左边的关键字 来自 对于 32 位机的 stdint.h */ /* 以下定义要随着平台的切换而有可能切换， 比如 8 位机的 8051 MCU 中 int 为两个字节，Nios II 处理器 中 int 为 两个字节 32 位机（如 STM32）中 int 为四个字节， 64 位机同 32 位机 */ /* 这里针对的是 32位/64位 机器而言，即 int/float 为 4 字节 */ typedef unsigned char uint8; /* 8 bits */ typedef unsigned short int uint16; /* 16 bits */ typedef unsigned int uint32; /* 32 bits ,long int 也为 32 bits */ typedef signed char int8; /* 8 bits */ typedef short int int16; /* 16 bits */ typedef int int32; /* 32 bits */ typedef volatile int8 vint8; /* 8 bits */ typedef volatile int16 vint16; /* 16 bits */ typedef volatile int32 vint32; /* 32 bits */ typedef volatile uint8 vuint8; /* 8 bits */ typedef volatile uint16 vuint16; /* 16 bits */ typedef volatile uint32 vuint32; /* 32 bits */ typedef float float32; /* 32 bits */ typedef double float64; /* 64 bits */ typedef unsigned char boolean; /* 8-bit*/ 变量 定义/声明 时 应 合理的、常用 / 尽可能使用 const “修饰”，防止 变量 或 指针 在层层传递过程中 被无意篡改，例子如下。 const unsigned char xByte; /* xByte 的内容不能变 */ const char *p; char const *p; /* 二者一样，都是 p 所指向的内容不能变 */ char* const p; /* const 修饰的是 p ， p 不能修改，即地址不能修改，其指向的内容可以修改 */ const void* const p; /* p 所指向的内容和 p 地址本身都不能改变 */ /* 若变量是 const 修饰的，则其地址 也不能赋值给其它指针，以防止通过该指针修改其值；const 修饰的 数组 也将不能 取其地址 来给别的指针 赋值 */ /* p.s 对于单独定义一个指针并且不赋初值的情况，char* c; 与 char * c; 与 char *c; 没有任何区别。 */ 更多补充 C/C++里 const int* 与 int const* 有什么区别？ - 知乎 (zhihu.com) 其中写到： const 默认作用于其左边的东西，否则作用于其右边的东西。 定义变量 int i = ‘0’;，注意 int* i_ptr = \u0026i; 与 char *i_ptr = \u0026i; 的区别，前者是将 i 的地址赋给 int 类型 指针变量 i_ptr，后者是 将 i 的地址赋给 整形变量 *i_ptr，注意 C 编译器并不认为 该 二者的不同，都是 将 i 的地址赋给 int 类型指针变量 i_ptr ，只是对于人从惯用语法来讲会觉得不同。因此对于写法规范，定义指针的三种写法 int* i_ptr; 、unsigned int * i_ptr; 、 int *i_ptr, *l_ptr, *a_ptr;，分清这三种场合，第一个 单独定义一个指针（把 * 靠近类型名），第二个 指针类型名 超过一个单词（则把 * 写在中间），第三个 多个指针定义（把 * 靠近变量名）。（我怎么感觉我在讲 “茴” 的几种写法，，搞编程嘛，这里需要细致一些） 指针变量在 定义 的时候就 尽量 给确定的地址变量 而 防止 其成为 野指针 的可能；尽量避免野指针。 关于指针相关灵活用法更多详见 实用技巧 一节里的 指针专题 部分。 防止 指针、数组越界，要清楚其所知内存空间的大小，即其可操作的范围。 明确全局变量的初始化顺序，系统启动阶段，使用全局变量前，要考虑到全局变量该在什么地方初始化，使用全局变量和初始化全局变量之间的时序关系一定要分析清楚。 明确变量的作用域，防止在预想的作用域外能够调用到具体的某个变量，降低模块间耦合度。对于函数内的局部变量，不希望在函数跳出后局部变量数据丢失那么加上 static 修饰符（指示该变量具有所在函数的作用域），static 修饰符的变量若定义在一个文件内当作 “全局变量”，其是 只在该文件具有作用域的，其他文件不能够访问到。 为防止编译器优化程序中一些 关键/重要 的变量的给值顺序等，可在变量定义时加 volatile 声明，即不要优化掉这里，中断或其它线程公用一个变量 或 这个变量是寄存器相关的东西（寄存器地址或寄存器值） 的时候，就应该加。 玩一下，比较极端的情况，一个完整的变量声明形式：extern static volatile const unsigned long int * const temp_reg[sizeof(int)];。 变量如果是低有效，变量名加尾缀 “_n”，比如使能 en 是低有效（en 上面有一横），则命名为 “en_n”。 尽量减少不必要的数据类型转换，即 “类型强转”。关于 “类型强转”，要先看位数，低位数类型可以向高位数类型强转，而这个过程反过来的时候，高位数类型直接转换为低位数类型则高位会被丢弃，因此对于高位数类型的数值应该先取 低 八位/十六位/三十二 等 位，再强转，这样是比较安全和方便阅读的做法。参考 实用技巧 一节里 “巧用 按位 与/或/非 来 组合想要的二进制序列” 的示例代码。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于结构体、枚举和类型定义形式（Structures, enumerations, typedefs） 适用 “关于变量定义形式（Variables）” 一节里面的内容。 枚举定义形式有直接定义、类型定义、指针和数组等，枚举内可以嵌套定义结构体，结构体内也可以嵌套定义枚举。 结构体和枚举可以用 typedef 修饰。 结构体里的成员小写，枚举里的所有成员大写。 结构体应尽量不作为函数的形参或返回值等，而是用其指针替代，减少数据拷贝。 结构体定义后加“_ struct”尾缀，对于类型定义后再追加 “_ t”，对于枚举同理，例子如下。 /************************* 枚举定义 *************************/ enum errType_enum { RETURN_OK = 0, RETURN_ERR_1, RETURN_ERR_2, RETURN_LAST /* 值为 3，同时也是所在枚举定义的枚举数量 */ }; typedef enum { MY_ENUM_OK = 0, MY_ENUM_TESTA, MY_ENUM_TESTB, MY_ENUM_LAST }my_enum_t; /* 定义一个函数，使用两种枚举，一个作为形参，一个作为返回值 */ enum errType_enum sys_process_hello(my_enum_t my_para); /************************* 结构体定义 *************************/ struct simple_struct struct /* 只用一次的结构体 */ typedef struct { { { int a; int a; int a; char b; char b; char b; double c; double c; double c; }simple, *simple_p; }abc; }simple_struct_t; /* 使用 sizeof() 获取结构体大小（字节为单位），而实际存储占用长度会因字节对齐而不确定 可以使用 gcc 扩展关键字 pack() 来将结构体或其它数据结构 按字节/按四字节 等方式 对齐 */ struct simple_struct simple0; struct simple_struct* simple0_p = \u0026simple0; /* 定义结构体变量和其指针一对，并给指针赋值 */ simple0_p-\u003ea = simple0.b; /* 取值，赋值 */ struct simple_struct simple1[10] = /* 结构体数组定义，并赋值 */ { {1, 2, 3}, {3, 2, 1}, ... }; /************************* 位段 *************************/ /* 结构体内还可以对成员声明位段（有的地方也叫 位域），即声明每个成员占用的 bit 数。 不多见，位域（bit fields）在不同编译器之间是不可移植的，同时也保证代码是不可重用的。 */ /* 成员必须为无符号整型 */ struct mybitfields { unsigned short a :4; unsigned short b :5; unsigned short c :7; }test; /* 幅值 */ test.a = 2; test.b = 31; test.c = 0; /* 赋值后 的实际情形 16bit 的实际值： 0000 0001 1111 0010 16bit 的 abc 占用位置： ccc ccccb bbbb aaaa */ struct date_struct { unsigned char day :5; unsigned char month :4; unsigned short year :14; }date; /* 0 | 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | 0 0 0 0 | 0 0 0 0 0 | |--------- year --------------|- month -|---- day ---| */ 结构体的实例化尽量用 “表格” 形式，并在每列头部写好注释，例子如下。 struct fsm_states_struct fsm_XXX1_state[XXX1_State_MAX] = /*定义描述名为‘fsm_XXX1’的状态机的状态图*/ { /*跳转条件都初始化为0*/ /* 状态 执行函数 跳转条件数量 各个条件跳转后的状态（注：根据跳转条件的优先级从高到低往下写）*/ {(unsigned int)XXX1_State_1, fsm_XXX1_state_1_Fun, 2,{ {0,(unsigned int)XXX1_State_5 }, {0,(unsigned int)XXX1_State_2 }, }}, {(unsigned int)XXX1_State_4, fsm_XXX1_state_4_Fun, 1,{ {0,(unsigned int)XXX1_State_5 }, }}, }; /* 或者 */ simple_struct_t simple = { .a = 65530, .b = 125, .c = 1.0 }; 关于结构体的内存对齐在 GNU C 扩展语法 一节内有讲。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:3","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于联合和其类型的定义形式（union） 联合的长度为其中最大一个变量/数组的长度，定义形式同样有直接定义、类型定义、指针和数组等，联合内可以嵌套定义结构体，结构体内也可以嵌套定义联合；定义枚举类型要加 “_union” 尾缀，其它尾缀依上面所说类推。 联合应尽量不作为函数的形参或返回值等，而是用其指针替代，减少数据拷贝。 联合的定义和应用情景举例如下。 /************************* 一、四字节整形可以直接取每一个字节 *************************/ /* 举例 1 */ union simple_union { int var_int; char var_char[4]; } union simple_union four_bits.var_int = 0xaabbccdd; /* 即 var_char[0] 为 0xaa，var_char[1] 为 0xbb，以此类推，按数组从左到右增长的方式排列对齐 */ /* 举例 2 */ union { int i; /* 占四字节 */ struct /*在联合中定义一个结构*/ { char first; char second; }half; /* 占俩字节，与 四字节的 i 低位对齐 */ }number; number.i = 0x44434241; /* 联合成员赋值 */ /* number.i 的低俩字节给了 half 结构体，即 number.half.first 为 0x42，以此类推 */ /* 通过上面两个举例可以看出，在字节 拼接 和 检出 时使用 联合 非常方便 */ /************************* 二、两个 程序/线程 要以不同的最小单位访问同一块内存 *************************/ typedef struct{ int ram_full_flag; int ram_store_flag; int ad_channels_en; union{ u8 ram_store_data[8][512]; u16 ram_send_data[8][256]; }_ram; }_RAM_FORMAT; _RAM_FORMAT RAM_Format; /* 可以看出 结构体里面的枚举，同一块区域内分别以 8 位和 16 位划分， 以 8 位为最小单位接收，以 16 位为最小单位发送 */ /************************* 三、联合 和 结构体 + 位域 结合，可以访问一个字节的每一个 bit *************************/ typedef union { char Val; struct __packed /* __packed 修饰，结构体字节对齐 */ { char b0:1; char b1:1; char b2:1; char b3:1; char b4:1; char b5:1; char b6:1; char b7:1; } bits; }BYTE_VAL, BYTE_BITS; ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:4","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于宏定义和预编译指令定义形式（Macros and preprocessor directives） 宏定义使用全大写（尽量），并遵循 “属什么 _ 是什么 _ 做什么” 的命名形式。 尽量把常数数字用宏定义代替；常量建议使用 const 定义来代替宏；前面这两句话实际是矛盾的，因地制宜吧，优化速度用前者，优化空间用后者。 对宏定义中的所有输入和输出（整个结果语句）用括号保护起来，举例如下，长句用 do{...}while(0)。 #define MY_MACRO(x) ((x) * (x)) #define MIN(x, y) ((x) \u003c (y) ? (x) : (y)) #define SET_POINT(p, x, y) do{ (p)-\u003epx = (x); (p)-\u003epy = (y); }while(0) /*或者下句更好：*/ #define SET_POINT(p, x, y) do{ \\ /* Backslash indicates statement continues in new line */ (p)-\u003epx = (x); \\ (p)-\u003epy = (y); \\ }while(0) /* 2 statements. No semicolon after while loop */ 预编译指令语句使用 tab 标识好层次，举例如下。 #if defined(XYZ) /* Do when XYZ defined */ #if defined(ABC) /* do when ABC defined */ #endif #else /* Do when XYZ not defined */ #endif 更多实用的宏定义见 6 常用宏定义 一节。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:5","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于注释的形式（Comments） 注释里尽量写为什么，而不是把重点放在做了什么，虽然后者也很重要。 尽量使用 Doxygen 的注释语法，然后可以使用 Doxygen 这个软件从源码工程的注释中自动化生成软件工程的说明文档，注释写的全（包括文件和API等的描述等等）那么生成的文档也会很全。Documented code allows doxygen to parse and general html/pdf/latex output, thus it is very important to do it properly。目测目前我见过的用源文件产生手册的大型项目有：LWIP、FreeRTOS、ST HAL、CMSIS等，关于 ST HAL 库里面的注释形式的详细情况请看 “8 ST HAL 的编写形式” 章节！ Doxygen 的注释语法规范。网上很多，这里列举几个： Doxygen 注释语法规范 - 黄树超 - 博客园 (cnblogs.com)。 C语言中的Doxygen注释模板_胡图图-CSDN博客_c语言函数注释模板。 需要注意的是，Doxygen 并不处理所有的注释，其重点关注与程序结构有关的注释，比如：文件、类、结构、函数、全局变量、宏等注释，而忽略函数内局部变量、代码等的注释。先从文件开始注释，然后是所在文件的全局函数、结构体、枚举变量、命名空间→命名空间中的类→成员函数和成员变量。 使用 Doxygen 生成文档的教程（这几个教程里面也包含有 Doxygen 的语法介绍）： Doxygen给C程序生成注释文档 - on_the_road - 博客园 (cnblogs.com)。 Doxygen生成注释文档_destiny的专栏-CSDN博客_doxygen生成文档。 代码注释规范之Doxygen - silencehuan - 博客园 (cnblogs.com)。 Vs Code 的 Doxygen 格式注释生成插件： Doxygen Documentation Generator - Visual Studio Marketplace，用这个，官方比较全。或者在 VScode 扩展里 安装 C/C++ Extension Pack，里面包含了许多 C/C++ 实用扩展，包括 Doxygen Documentation Generator。 Vs code自动生成Doxygen格式注释_wang0huan的博客-CSDN博客。 p.s 关于 Doxygen 文档的更多具体写法用时再详看进行手写，或者使用生成插件 下面列举几种花哨的，其中有我自己“创造”的。函数定义的注释，主任务函数的注释，用于显眼！ /*__________函数简述_____________*/ /******************************** * 描述：函数详细描述 * 参数： 1、第一个形参名 描述 2、第二个形参名 描述 ... * 返回： 返回值类型 描述 ********************************/ /*____________运行错误提示和打印______________________________*/ /************************************************************ * 描述：表示某步骤运行有问题，串口提示，灯提示，声提示 * 参数： 1、errmsg 错误或者警告信息 2、errid 故障代号 3、err_flag 错误类别（可选flag_Fault或flag_Warning） * 返回： NULL ************************************************************/ /*************\\ * Multi-line * * comment * \\*************/ /*************\\ ************************************* Multi-line ***************************************************** * comment * \\*************/ /*______________________\\\\\\ ///__________________________* *___________________________________外设初始化函数_______________________________________* *_______________________/// \\\\\\__________________________*/ 文件说明注释： /************************************************* 开头这里放开源协议的描述源文 Copyright © xxx Co., Ltd. 1998-2018. All rights reserved. File name: 文件名 Author： 作者 Version: 版本号 Description: 用于详细说明此程序文件完成的主要功能，与其他模块 或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系 Others: 其它内容的说明 Log: 修改日志，包括修改内容，日期，修改人等 *************************************************/ // Doxygen 格式 /** * @file main.c * @author your name (you@domain.com) * @version 0.1 * @date 2021-06-30 * @license GNU General Public License (GPL) * @brief * @attention * */ 程序文件开头的版权信息写法列举： 引用自软件中声明版权的写法-专业指导文档类资源-CSDN下载，侵删。 正确的格式应该是：Copyright [dates] by [author/owner] © 通常可以代替Copyright, 但是不可以用(c)。 All Rights Reserved 在某些国家曾经是必须的，但是现在在大多数国家，都不是法律上必须有的字样。 参见下面几个正确的格式： ©1995-2004 Macromedia, Inc. All rights reserved. ©2004 Microsoft Corporation. All rights reserved. Copyright © 2004 Adobe Systems Incorporated. All rights reserved. ©1995-2004 Eric A. and Kathryn S. Meyer. All Rights Reserved. 请注意标点符号和大小写的用法，这也是专业精神的一种体现。 现在流行some rights reserved：creativecommons.org some rights reserved 和copyright 本身并不矛盾，但是其中的界限更多是一个道德问题，真正的保留一部分权力，是指给浏览者fair use 的权利，fair use的界定也决不是随便乱用，或者抄袭。 甚至说，除了copyright, 还有copyleft,它的定义是为了程序员开发能够共享源代码的一个方式，英文里free, 并不仅仅是免费。 而且这种的源码公开免费使用，和版权也一点都不冲突。请大家不要误解。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:6","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"关于代码格式化工具列举（Code formatter） p.s 针对较乱的\"祖传代码\"做初步治疗使用。代码格式化工具还可以把代码中的 tab 符变成四个空格，这样，当代码在不同的编辑器中打开时不会产生格式错误，所以可以用 AStyle 自己定制一份配置文件，在每次码完代码之后顺手运行一下 AStyle 即可。 (TODO)下面部分条目尚未补全。 (TODO)查一查astyle配置文件的用法，按照自己的规范形式，写一个配置文件 通用工具 AStyle： ​ 配置文件： c-code-style仓库中的 astyle-code-format.cfg 文件 ​ AStyle官网：AStyle官网 ​ AStyle is a great piece of software that can help with formatting the code based on input configuration. ​ This repository contains astyle-code-format.cfg file which can be used with AStyle software as command line below. astyle --options=\"astyle-code-format.cfg\" \"input_path/*.c,*.h\" \"input_path2/*.c,*.h\" VS Code：在 VS Code 中搜索 AStyle 插件 即可。或者 Beautify 插件，代码格式化，都还没试过。 MDK：关于“把代码中的 tab 符变成四个空格”，在 MDK 的 Edit 的 Configuration 中，把 “Insert spaces for tab” 都勾上即可。 IAR： Eclipse： ​ 配置文件： c-code-style仓库中的 eclipse-ext-kr-format.xml ​ Repository contains eclipse-ext-kr-format.xml file that can be used with eclipse-based toolchains to set formatter options. ​ It is based on K\u0026R formatter with modifications to respect above rules. ​ You can import it within eclipse settings, Preferences -\u003e LANGUAGE -\u003e Code Style -\u003e Formatter tab. Source Insight： Notepad：关于“把代码中的 tab 符变成四个空格”，在 Notepad 的 设置 的 语言 中，把制表符框的 “替换为空格” 勾上即可。 一些网友开源项目： mysterywolf/formatting: 源码格式自动化调整工具 (github.com)。 【】。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:9:7","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"6 常用宏定义 p.s 以下有一些在 C 标准库里有实现，资源紧张可以用下面的宏定义，不紧张推荐全部使用标准库。 p.s 宏定义、或者引用头文件等，都是以 “#” 开头，都是属于编译器的预处理命令。编译器实际进行的是 “原样替换” 操作，字面意思，这个要有意识。 p.s 下面的宏定义大都摘自网络。 /* 宏定义的形式规范 宏定义使用全大写（尽量），并遵循 \"属什么 _ 是什么 _ 做什么\" 的命名形式； 尽量把常数数字用宏定义代替； 对 宏定义函数，其中的所有输入和输出（整个结果语句）用括号保护起来，长句用 do{ }while(0); */ /* 打印一个变量名及其值 */ #define PRINT_HEX_VAR(var) printf(\"%s: 0x%08X\\n\", #var, var); unsigned int program_flag = 0xAABBCCDD; PRINT_HEX_VAR(program_flag); /* 返回数组元素的个数 */ #define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) ) /* 打印一个数组 */ #define ARR_SIZE(arr) (sizeof(arr)/sizeof(*arr)) // 返回数组元素的个数 #define PRINT_DIGIT_ARR(arr) do{ \\ printf(\"%s: \", #arr); \\ for(int i=0; i \u003c ARR_SIZE(arr); i++) \\ printf(\"%d \", arr[i]); \\ printf(\"\\n\"); \\ }while(0) int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; PRINT_DIGIT_ARR(arr); /* 定义变量。__typeof__(x) 用于获取变量 x 的类型 */ #define var(left, right) __typeof__(right) left = (right) var(s, 1LL); /* 用法举例，这里相当于 long long s = 1LL; */ /* 获取大于 a 的最近的 2^n 倍的且是 size 的整数倍的值，可计算申请内存时要对齐的某字节数 */ #define ROUNDUP(a, size) (((a) \u0026 ((size)-1)) ? (1+((a) | ((size)-1))) : (a)) /* 获取大于 size 的最近的且是 val_size 倍数的值，可用于 Flas h的 page 大小对齐的时候 */ #define VAL_ROUNDUP(size, val_size) (((size)+val_size-1)/val_size*val_size) /* 得到指定地址上的 一个字节 或 short 类型大小的值 */ #define MEM_B( x ) ( *( (unsigned char*) (x) ) ) #define MEM_W( x ) ( *( (unsigned short*) (x) ) ) /* 求最大值和最小值 */ #define MAX( x, y ) ( ((x) \u003e (y)) ? (x) : (y) ) #define MIN( x, y ) ( ((x) \u003c (y)) ? (x) : (y) ) /* 但是上句还是有可能错，比如： double xx = 1.0; double yy = MIN(xx++, 1.5); printf(\"xx=%f, yy=%f\\n\",xx,yy); MIN(++ia，++ib) 会展开为 ((++ia) \u003c (++ib) ? (++ia) : (++ib))，传入宏的“参数”自增两次，因此不能这么用 以下放大招了，看看 GNU 的实现...用下面这句就不会出错，那当然了...（但实际有这么用的吗？） #define MIN(A,B) ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a \u003c __b ? __a : __b; }) */ /* 得到一个 field 在 结构体(struct) 中的偏移量 */ #define FPOS( type, field ) ( (unsigned long) \u0026(( type *) 0)-\u003e field ) /* 得到一个结构体中 field 所占用的字节数 */ #define FSIZ( type, field ) sizeof( ((type *) 0)-\u003efield ) /* 按照LSB格式把两个字节转化为一个 unsigned short */ #define FLIPW( ray ) ( (((unsigned short) (ray)[0]) * 256) + (ray)[1] ) /* 按照LSB格式把一个 unsigned short 的 val 转化为两个字节 ray[0] 和 ray[1] */ #define FLOPW( ray, val ) \\ (ray)[0] = ((val) / 256); \\ (ray)[1] = ((val) \u0026 0xFF) /* 得到一个字（这里以16位为例）的高位和低位字节 */ #define WORD_LO(xxx) ((unsigned char) ((unsigned short)(xxx) \u0026 0xff)) #define WORD_HI(xxx) ((unsigned char) ((unsigned short)(xxx) \u003e\u003e 8)) /* 返回一个比X大的最接近8的倍数的数 */ #define RND8( x ) ((((x) + 7) / 8 ) * 8 ) /* 将一个字母转换为大写 */ #define UPCASE( c ) ( ((c) \u003e= 'a' \u0026\u0026 (c) \u003c= 'z') ? ((c) - 0x20) : (c) ) /* 判断一个字符是不是10进制的数字字符 */ #define DECCHK( c ) ((c) \u003e= '0' \u0026\u0026 (c) \u003c= '9') /* 判断一个字符是不是16进制的数字字符 */ #define HEXCHK( c ) ( ((c) \u003e= '0' \u0026\u0026 (c) \u003c= '9') ||\\ ((c) \u003e= 'A' \u0026\u0026 (c) \u003c= 'F') ||\\ ((c) \u003e= 'a' \u0026\u0026 (c) \u003c= 'f') ) /* 数值自加一，并带防止溢出 */ #define INC_SAT( val ) (val = ((val) + 1 \u003e (val)) ? (val) + 1 : (val)) /* 圆周率 */ #define M_PI 3.14159265358979323846f /* 本文作者整个活，背个圆周率100位 3.1415926 5358 9793 23846 26433 83279 502 884 1971 693 9937510 582 0974944 592 3078164 062 8620899 86280 3482534 2117067 9 */ /* 在编译时就能够进行条件检查的断言，而不是在运行时进行。下面是个 Linux Kernel 中的例子 */ #define BUILD_BUG_ON_ZERO(e) (sizeof(struct{int : -!!(e);})) #define BUILD_BUG_ON_NULL(e) ((void*)sizeof(struct{int : -!!(e);})) /* Force a compilation error if condition is true */ #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2 * !!(condition)])) /* 检测 a 和 b 是不是同一类型，不是同一类型编译不过 */ (void) (\u0026a == \u0026b) /* 引自 Author: MaxwellXyao */ #define BIT(n) (1 \u003c\u003c (n)) // 位mask #define bit_SetTrue(x,mask) ((x) |= (mask)) // 该位设置为真 #define bit_SetFalse(x,mask) ((x) \u0026= ~(mask)) // 该位设置为假 #define bit_Toggle(x,mask) ((x) ^= (mask)) // 位切换 #define bit_IsTrue(x,mask) (((x) \u0026 (mask)) != 0) // 该位是否真 #define bit_IsFalse(x,mask) (((x) \u0026 (mask)) == 0) // 该位是否假 /* 编译时一些信息的字符串，用内建宏调试 __FILE__ 表示当前所在文件名的字符串 __LINE__ 表示当前所在行的整形数字 __FUNCTION__ 表当前所在函数的函数名字字符串，或用 __func__ __DATE__ 表示编译时的 月/日/年 字符串信息 __TIME__ 表示编译时的 时:分:秒 字符串信息 __STDC__ 如果实现是标准的，则是十进制常量1，否则为其他 如下面，Debug 时输出文件名、行号、函数名等 */ #ifdef _DEBUG #define DEBUGM","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:10:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"7 C 标准库的使用 p.s 资源不紧张推荐全部使用标准库（除了 malloc 和 free） 关于各个标准库的使用，详见 额外文档\\各种C标准库详解和用例\\ 里面，已经整理比较全。 最常用的： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cctype.h\u003e#include \u003cstring.h\u003e#include \u003cmath.h\u003e 参考这几个地方齐活了： C标准库函数新编手册: C语言标准库函数API使用手册中文版 (gitee.com)。 上面的 gitee 仓库很优秀，已经离线到了本地./额外文档/各种C标准库详解和用例/中。 C语言常用标准库解读_张巧龙的博客-CSDN博客。 C 标准库 – 参考手册 | 菜鸟教程 (runoob.com)。 可能会用到的： #include \u003ctime.h\u003e // 提供储存时间的结构体和计算时间差等函数#include \u003cstdint.h\u003e // 类型重定义，按照所占位数命名，方便阅读，以及各个类型的最大、最小值等#include \u003climits.h\u003e // 这两个库包含了各种变量类型的最大、最小值等信息#include \u003cfloat.h\u003e // 浮点数 类型的一些最大、最小值等信息 不常用的： #include \u003cstdarg.h\u003e // 用于函数定义变长形参#include \u003cassert.h\u003e // 提供了一个名为 assert 的宏，仅在 debug 模式有效，判断一个表达式是否为 FALSE(即 0)，如果是则报告错误并终止程序#include \u003cerrno.h\u003e // 被其他库文件调用，提供一些返回值定义#include \u003clocale.h\u003e // 定义了特定地域的设置，比如日期格式和货币符号#include \u003csetjmp.h\u003e#include \u003csignal.h\u003e#include \u003cstddef.h\u003e ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:11:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"8 C 实用技巧、黑魔法和高阶实现（不定期更新） 将一些常用的并且技巧性、灵活性较高的或者少见的写法进行罗列。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"实用技巧 更多 见后面 “更多奇技淫巧” 一节。 前言 · C语言开发心得 (crifan.org)，crifan/c_lang_dev_summary: C语言开发心得 (github.com)。 快速范围判断：再来一种新写法 - 知乎 (zhihu.com)。 大小端区分。引 xiaowenxia/embedded-notes: 嵌入式linux软件开发、嵌入式linux驱动开发、c语言、单片机开发、IOT开发等面试要点记录 (github.com)。 union data { int a; char b; }endian; int main(int argc, char **argv) { endian.a = 0x12345678; printf(\"%#02x\\n\", endian.b); return 0; } /*打印 0x78 说明是小端（低字节存放在低地址，高字节存放在高地址）， 0x12 说明是大端 */ 输入一行数字，以空格分割，如 -1 0 1 2 3\\n 这样。 unsigned int temp_cnt = 0; char res[10] = {0}; do { scanf(\"%d\",\u0026res[temp_cnt++]); }while(getchar() != '\\n'); for(unsigned int i = 0;i \u003c temp_cnt;i++) { printf(\"%d \",res[i]); } 巧用 按位 与/或/非 来 组合想要的二进制序列。 /* 取出 CANid 的 第 28—26 3位 给 temp */ unsigned int temp, CANid; temp = ((CANid \u0026 0x1C000000) \u003e\u003e 26) \u0026 0x00000007; //0x1C000000 = 0001 1100 0000 0000 0000 0000 0000 0000 // 注意，如果不是为了进行 2 的倍数的乘除运算，移位的对象尽量为无符号类型（unsigned），无符号类型左、右移均补 0；而有符号型左移补 0，右移补 符号位。 /* 讲某一变量中的某几位 的二进制 比特 合成到 另一个变量的某个位置 */ enum deviceType_enum deviceType = Magnetic_unit; enum sourceAddress_enum sourceAddr = Source_unit9; temp = (((unsigned int)(deviceType)) \u0026 0x00000007) \u003c\u003c 23; /* 将 枚举类型的 deviceType 变量的低三位 摆放到到 一定的位置 给 temp */ CANid |= temp; temp = 0; ... temp = (((unsigned int)(csem_ptc-\u003esourceAddr)) \u0026 0x0000000F) \u003c\u003c 19; CANid |= temp; temp = 0; ... /* 某一 12位 DAC 的输出寄存器为 16 位， 低 12位 为设定输出值，第 14 位必须为 1，按照该要求写健壮的合成二进制代码*/ /* set_current_val 为设定输出的变量，其范围为 0~200 */ unsigned int temp = (((set_current_val \u003e 200 ? 200 : set_current_val ) * (4095/200)) \u0026 0x0FFF ) | 0x4000; /* 上式为方便查阅的写，可以为了提高运算效率，将其中的某些项进行预先计算和合并，而减少每次输出 DAC 时候的计算量 */ 置位和清位，常用于嵌入式开发。 static volatile unsigned int * reg_temp = (volatile unsigned int *)(0x20E0084); /* 置位的标准写法 */ /* 下句表示把 内存中 0x20E0084 位置的 第 1、2、5、14 位进行置 1，其他位不变 */ *reg_temp |= ( (1 \u003c\u003c 14) | (1 \u003c\u003c 5) | (1 \u003c\u003c 2) | (1 \u003c\u003c 1) ); /* 清位的标准写法 */ /* 下句表示把 内存中 0x20E0084 位置的 第 0、3 位进行清 0，其他位不变 */ *reg_temp \u0026= ( ~( (1 \u003c\u003c 3) | (1 \u003c\u003c 0) ) ); /* 读寄存器 */ volatile unsigned int val = *reg_temp; 创建内存地址上连续区域的结构体，常用于嵌入式开发。 typedef struct { volatile unsigned int URXD; /**\u003c UART Receiver Register, offset: 0x00 */ volatile unsigned char RESERVED_0[60]; volatile unsigned int UTXD; /**\u003c UART Transmitter Register, offset: 0x40 */ volatile unsigned int UCR1; /**\u003c UART Transmitter Register, offset: 0x44 */ } Periph_x_Type; /* Periph_x 这个外设的寄存器的基地址为 0x2020000 */ #define Periph_x_BASE (0x2020000u) /* 设置结构体 Periph_x 的地址为 Periph_x_BASE */ #define Periph_x ((Periph_x_Type *)Periph_x_BASE) /* 读取和设置寄存器（这里以置位举例） */ Periph_x-\u003eUCR1 |= (1 \u003c\u003c 2); 使用 结构体 的 位带 来直接对 bit 进行操作。引自 推荐一种超简单的硬件位带bitband操作方法，让变量，寄存器控制，IO访问更便捷，无需用户计算位置 (qq.com)。《安富莱嵌入式周报》第243期：2021.12.06–2021.12.12 (qq.com) 里面 3 硬件位带 小节有订正。 typedef struct { uint16_t ODR0 : 1; uint16_t ODR1 : 1; uint16_t ODR2 : 1; ... uint16_t Reserved : 16; } GPIO_ORD __attribute__((bitband)); GPIO_ORD * GPIOA_ODR = (GPIO_ORD *)(\u0026GPIOA-\u003eODR); /* 这两种写法 */ GPIO_ORD GPIOA_ODR __attribute__((at(0x40020014))); /* */ 关于连接符 “#” 和 “##” 的使用说明，这两个都是预处理命令。 /* ## 左右语句原样连接符（concatenator） hello##world 就是 helloworld，直接原样拼接，这并不是字符串，而是预编译时候的程序的字符的替换和拼接 */ /* 例1： */ #define A(x) T_##x int A(1) = 10; /* 等效于int T_1 = 10; */ /* 拼接 字符串（字符串变量 或者 程序的字符） */ #define COMB(str1,str2) str1##str2 printf(\"%s\\n\", COMB(UART, 1)); /* # 转字符串符，字符串化操作（Stringfication），即将跟在 # 后面的 参数 转成一个 字符串常量 */ /* 例2： */ #define WARN_IF(EXP) \\ do{ \\ printf(\"Waring:\"#EXP\"\\n\"); \\ }while(0) WARN_IF(int devide = 0;); /* 会打印：Waring:int devide = 0; */ #define STR(s) #s printf(\"%s\\n\", STR(3.1415)); /* 例3： */ #define paster( n ) printf( \"token\" #n \" = %d\", token##n ) paster( 9 ) /* 即 printf( \"token\" \"9\" \" = %d\", token9 ); */ /* 字符串连接，多个双引号的字符串放在一块就是了 */ printf( \"token\" \"9\" \" = %d\", token9 ); fd = open( PATH \"/file\",flags ); 更多 C 语言 #、##、VA_ARGS、#VA_ARGS、##VA_ARGS ~ Murphy’s Blog。 变长参数函数定义的使用说明。变长参数函数性能比较低而且难维护，非必要不建议使用。 /* 参考 https://blog.csdn.net/ericbar/article/details/79558827 */ #include \u003cstdarg.h\u003e /* 用于支持变长参数函数 */#include \u003cstdio.h\u003e /* 定义的函数必须至少有一个固定参数。这个函数包含了两个固定参数，和指示变长参数开始的省略号 */ void variable_argument(int fix_argument1, int fix_argument2, ...) { /* 先定","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"指针专题 若要修改一函数的局部变量的值那么请用一级指针，若要修改一局部变量一级指针的值那么用二级指针，以此类推。 /* 修改一函数的局部变量的值那么请用一级指针，这个好理解，举例 */ void set_to_five(int* val) { *val = 5; } int main(void) { int value = 10; /* 要修改 main() 函数的局部变量 value */ printf(\"before - value = %d\\n\",value); set_to_five(\u0026value); /* 修改值，要传入其地址 */ printf(\"after - value = %d\\n\",value); } /* 依上面类推，传递入地址才能修改值，因此修改一局部变量一级指针的值那么用二级指针，举例 */ int ten = 10; int five = 5; void set_to_five(int** val) { *val = \u0026five; } int main(void) { int* value = \u0026ten; printf(\"before - *value = %d\\n\",*value); test4(\u0026value); /* 修改值，要传入其地址 */ printf(\"after - *value = %d\\n\",*value); } /* 再一个例子，引用自：https://blog.csdn.net/c243311364/article/details/109619361 */ void GetMemery(int** p) /* 修改外面的一个局部变量 *P，需要外面传入该局部变量的指针 即 **P */ { /*申请1024个int大小*/ *p = malloc(sizeof(int)*1024); if(NULL == *p) { printf(\"malloc failed\\n\"); } } int main(void) { int* p = NULL; /* 定义一个 局部变量 的 空指针（野指针） */ GetMemery(\u0026p); /* 为其申请空间，即让其他函数修改 本函数中的局部变量的值，注意是传入 指针 p 的指针 */ printf(\"address of p is %p\\n\",p); free(p); return 0; } /* 上面这种将一局部指针变量在另一个函数内为其赋值，当然应该传入的是其指针，即 \u0026p */ /* 但，在任何地方申请空间后作为返回值 进行赋值 可以，因为申请空间的地址是 堆区，是全局变量，例子如下 */ int* GetMemery(int n) { int* iptr = malloc(sizeof(int) * n); /* 申请 n 个 int 大小 */ if(NULL == iptr) { printf(\"malloc failed\\n\"); return NULL; }else { return iptr; } } int main(void) { int* p = GetMemery(1024); printf(\"address of p is %p\\n\",p); free(p); return 0; } 一阶指针花样不多，下面是各种二次指针总结。 二阶指针的理解用 二维数组 或者 字符串数组 比较直观。对于 长度不一样的 多个 一维数组 常用 指针数组 定义，如 char *str[]定义缺省值个不等长的字符串，int *var[6]定义 6 个（6 行）不等长的整数数组，要么在定义时初始化其值，要么定义时不初始化然后在用的时候使用 malloc() 为其申请空间再赋值。初始化可以每一行不同长度，实际存储时候是 最大列数 对齐的，而非 初始化的数据 每一行 紧密排列。对于字符串 \"...\"，编译会给每个字符串的尾部添加 \\0。 /* 这里介绍一种 字符串数组 的定义方法，引自 https://mp.weixin.qq.com/s/TqNTMAY2gPUcoxlEYijBUw */ #define EINVAL 1 #define ENOMEM 2 #define EFAULT 3 /* 这些量 或可使用枚举 */ #define E2BIG 7 #define EBUSY 8 #define ECHILD 12 char *err_strings[] = { [0] = \"Success\", [EINVAL] = \"Invalid argument\", [ENOMEM] = \"Not enough memory\", [EFAULT] = \"Bad address\", /* ... */ [E2BIG ] = \"Argument list too long\", [EBUSY ] = \"Device or resource busy\", /* ... */ [ECHILD] = \"No child processes\" /* ... */ }; /* 引用某一个字符串可以直接这样：err_strings[EFAULT] */ 各种二次指针（二维数组、指针数组 与 数组指针、二阶指针）的传递总结： /* 参考：https://blog.csdn.net/u013684730/article/details/46565577 实参 传递→ 所匹配的形参 数组的数组 char x[3][4]; char (*p1)[4]; 数组指针 数组指针(行指针) char (*p1)[4]; char (*p1)[4]; 自身类型 指针数组 char *p2[3]; char **p3; 指针的指针 指针的指针 char **p3; char **p3; 自身类型 */ /* 二维数组，实参 x[3][4]，可以传递的/所匹配的形参为 数组的指针 int (*p1)[4]; 即可以给 p1 */ int x[3][4] = /* 3 行 4 列，编译器实际分配了 12 个 int 类型的空间 */ { /* x[n] 或 *(x + n) 为第 n 行头字节的指针，*(*(x + 2) + 3) 与 x[2][3] 等价 */ {1, 3, 5, 7}, /* 值得一提，x、\u0026x[0]、x[0]、\u0026x[0][0] 是同一个地址，因此 *(*(x + 2) + 3) 与 x[2][3] 等价，均可用于索引 */ {9, 11, 2, 4}, {6, 8, 10, 12} }; /* 数组的指针，实参为 int (*p1)[4]，可以传递的/所匹配的形参为 数组的指针 int (*p1)[4]; 即只可以传递给相同类型的 */ int (*p1)[4] = x; /* 包含 4 个 int 型 数组 的指针，即 p1 指向 一个包含 4 个 int 值的数组 */ /* 有的说可以写为 int p1[][4] = x，可读性更强 */ /* 该初始化或写为 int (*p1)[4]; p1 = x; */ /* 加深对 数组的指针 的理解 short int tell[10]; tell 与 \u0026tell 在数字上来说相同，但从 概念上/编译器上 来看来，二者不同 tell 或 \u0026tell[0] 是 2 字节 为单位 的内存块的地址，cell 是 short* 类型，tell++ 则指针移动 2 个字节 \u0026tell 是 20 字节 为单位 的内存块的地址，\u0026cell 是指向 包含 10 个 short 类型的数组的地址， 这个表示为 short(*)[10]，\u0026tell++ 则指针移动 20 个字节 因此 有 short (*pas)[10] = \u0026tell; tell 的 类型为 short*，而 \u0026tell 和 pas 的类型叫 short(*)[10] *pas 与 tell 等价，(*pas)[0] 即 tell[0] */ /* 补充，因二维数组在存储空间中是对其每一行数据紧密排列串在一维地址索引的存储空间里， 因此可以用一阶指针承接二维数组 x：int* p0 = x[0]; 此后索引二维数组 x 用 p0[n]，是一维的，用地址偏移索引， 比如 *(p0 + i*4 + j) 等价于 p0[i*4 + j] 等价于 x[i][j] （4 是 数组 x 的列数） */ /* 指针数组，实参为 int *p2[3]，可以传递的/所匹配的形参为 二阶指针 int **p3;，即可以给 p3 */ int *p2[3] = {x[0], x[1], x[2]}; /* 3 个 int* 类型的变量组成的数组；取 二维数组 x 的每一行的头地址 幅值给 指针数组 */ /* 或写为 int *p2[3]; for(int i = 0;i \u003c 3;i++) p2[i] = x[i]; */ /* 指向指针的指针，二阶指针 或叫 二维指针，实参为 int **p3，可以传递的/所匹配的形参为 二阶指针 int **p3; 即只可以传递给相同类型的 */ int **p3 = p2; /* 实际上 int **p3 和 *p3[] 是等价的 */ /* 或写为 int **p3 = \u0026p2[0]; 或写为 int **p3; p3 = p2; */ int k, m; for(m = 0, k = 1; m \u003c 3; m++, k++) { printf(\"p1[%d][%d] = %d\\t\",m,k,p1[m][k]); printf(\"*(*(p1 + %d) + %d) = %","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"黑魔法 OS Kernel，游戏引擎，编译器之类的，会用到不少 C 语言的黑魔法。你会惊叹于各种人类智慧的精华！！！前方高能预警！！！ 从结构体成员的地址获取结构体地址。 /* 引自 https://blog.csdn.net/c243311364/article/details/110129208 ，其中有详解 */ /* 示例程序 */ #include \u003cstdio.h\u003e /* offsetof，获取结构体元素 MEMBER 在 结构体 TYPE 中的偏移量，字节为单位 */ #define offsetof(TYPE, MEMBER) ((size_t) \u0026((TYPE *)0)-\u003eMEMBER) /** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */ #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u003emember ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) struct test_struct { int num; char ch; float f1; }; int main(void) { struct test_struct *test_struct; struct test_struct init_struct ={12,'a',12.3}; char *ptr_ch = \u0026init_struct.ch; test_struct = container_of(ptr_ch,struct test_struct,ch); printf(\"test_struct-\u003enum =%d\\n\",test_struct-\u003enum); printf(\"test_struct-\u003ech =%c\\n\",test_struct-\u003ech); printf(\"test_struct-\u003ech =%f\\n\",test_struct-\u003ef1); return 0; } 执行结果： test_struct-\u003enum =12 test_struct-\u003ech =a test_struct-\u003ech =12.300000 /* 引用 https://blog.csdn.net/Sunnyside_/article/details/119616976 假设存在一个虚拟地址 0，将该地址强制转换成为该结构体指针类型（struct stru_name*）0。那么地址 0 开始到 sizeof(stru_name) - 1 长度的内存区域就可以视为一个结构体的内存。这样结构体中任何一个元素都可以通过对该结构体指针解引用得到。由于该结构体的起始地址为 0， 因此任何一个成员的地址应该等于其相对于结构体起始地址的偏移，这也就是计算 结构体 某个成员 element 相对于 结构体起始地址的 偏移量的方法： (unsigned long)\u0026((struct stru_name*)0) -\u003e element。 假设 struct stru_name 结构体 里面有 变量成员 element，且 element_addr = bf81b82c offset = 12， element_addr 为 成员 element 在内存中的绝对地址，offset 即 element 相对于 结构体 struct stru_name 起始地址的偏移 那么 结构体的 绝对地址 就是 (element_typc *)element_addr - offset */ 代码增殖（黑魔法，慎用）（也更能帮助你理解 #define 的 “原样替换” 的含义）。 /* 源文：https://github.com/geekan/cowry/blob/master/code/c/darkmagic/x_macro_simple.c */ /* 它定义了一个字段 OFPACT(...)，然后再通过宏 OFPACTS 来批量生成此字段，替换其中每个输入，狂拽酷炫！ */ /* 引用网友一句：学名叫做x macro，是节省冗余代码利器，好处是非常好用，跟机关枪一样；坏处是懂的人不多，大家看到一个没有被索引的 ofpact_get_GROUP 很容易就进入痴呆状态。 */ #define OFPACTS \\ /* Output. */\\ OFPACT(OUTPUT, ofpact_output, ofpact, \"output\") \\ OFPACT(GROUP, ofpact_group, ofpact, \"group\") #define OFPACT(ENUM, STRUCT, MEMBER, NAME) \\ BUILD_ASSERT_DECL(offsetof(struct STRUCT, ofpact) == 0); \\ \\ enum { OFPACT_##ENUM##_RAW_SIZE \\ = (offsetof(struct STRUCT, MEMBER) \\ ? offsetof(struct STRUCT, MEMBER) \\ : sizeof(struct STRUCT)) }; \\ \\ static inline struct STRUCT * \\ ofpact_get_##ENUM(const struct ofpact *ofpact) \\ { \\ ovs_assert(ofpact-\u003etype == OFPACT_##ENUM); \\ return ALIGNED_CAST(struct STRUCT *, ofpact); \\ } OFPACTS #undef OFPACT 达夫设备（Duff’s Device）。 /* void send(char *to, char *from, int count) 即将 from 位置的 count 数量的 字节数据 拷贝到 to 处 */ /* 这个回答 https://www.zhihu.com/question/27417946/answer/36572141 如是说到： 看以为不能通过编译，后来以为是滥用编译器，但其实是完全符合C标准的，而且真实项目里有用。Google 上搜“duff's device filetype:c”和“duff's device filetype:h”都能找到很多。LLVM 还专门有个用例测试对 Duff's device 的支持：SingleSource/Regression/C/DuffsDevice.c，还很开心哒地说“Guess what, it does. :)” 另有：https://blog.csdn.net/kingmax26/article/details/5252657 达夫设备（Duff's Device）的详细说明 这篇文章内说，达夫设备的拷贝数据运行效率的编译体积虽大，但是比循环拷贝写法效率高的多（至少 8 倍）。 */ void send(char *to, char *from, int count) { int n = (count + 7 ) / 8; switch (count % 8) { case 0 : do{ * to ++ = * from ++; case 7 : * to ++ = * from ++; case 6 : * to ++ = * from ++; case 5 : * to ++ = * from ++; case 4 : * to ++ = * from ++; case 3 : * to ++ = * from ++; case 2 : * to ++ = * from ++; case 1 : * to ++ = * from ++; }while(--n \u003e 0); } } 用字符画表述 16 进制二维数组的 “图像”，C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)，要注意在最后加上三句 undef，再也用不到的宏定义要及时清理。 #define X )*2+1 #define _ )*2 #define s ((((((((((((((((0 /* For building glyphs 16 bits wide */ static unsigned short stopwatch[] = { s _ _ _ _ _ X X X X X _ _ _ X X _ , s _ _ _ X X X X X X X X X _ X X X , ... s _ _ _ _ _ X X X X X _ _ _ _ _ _ , s _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ }; #undef X #undef _ #undef s 大段数据单独放一个文件，用预编译命令引用。 /* 引自 https://www.zhihu.com/question/27417946/answer/37339776 */ #include \u003cst","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:3","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"GNU C 扩展语法 下面的例子均使用 GNU C，在 64 位 PC 测试，如使用其它 编译器 可能有不同的结果。 在使用 gcc 编译 C 程序的时候，如果使用 “-ansi–pedantic” 编译选项，则会告诉编译器不使用 GNU 扩展语法，若程序中使用 GNU 扩展语法则会报警。 参考： Linux GNU C对标准C语言的扩展与增强 - 知乎 (zhihu.com)。 .etc pack 关键字定义内存对齐 以结构体的编译器自然内存对齐机制来说明： 引自 pack 与字节对齐_knight_yzzz的博客-CSDN博客_pack 对齐。 字节对齐的细节和编译器实现相关，但一般而言，满足三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节（trailing padding）。 /* 举例 */ struct naturalalign { char a; short b int c; }; /* sizeof(struct naturalalign) 为 8 */ struct natural { char a; int b; char c; }; /* sizeof(struct natural) 为 12 */ 使用 pack 关键字 强制按照某个数整倍数进行字节对齐： #pragma pack(N); // 从这句话往下的程序，按照 N 个字节进行对齐 #pragma pack(); // 取消指定对齐 /* 举例 */ #pragma pack(N) struct natural { char a; int b; char c; }; #pragma pack(); /* 当 N 为 4、8、16 时，其对齐方式是一样的，sizeof（natural）都为 12； 当 N 为 2 时，sizeof（natural）为 8； 当 N 为 1 时，sizeof（natural）为 6 */ 代码片段_“#pragma pack”和“__attribute __（（aligned））”之间的区别是什么？ (cha138.com)。 零长度数组 不分配内存空间，但可以通过索引数组的方式索引其所在以及其后的内存的数据。 struct test_struct { unsigned char test_struct_data[0]; unsigned char a; unsigned char b; unsigned char c; unsigned char d; unsigned int e; }test = {NULL,2,3,4,5,0x0a0b0c0d}; /* 这样初始化的时候，从 2 开始 给 a、b...，并且会报错 warning: excess elements in array initializer， 也就是说，test_struct_data 不能赋值，因此不应该 这么写，而应该用下面 test1 这种初始化的写法 */ struct test_struct test1 = { .a = 2, .b = 3, .c = 4, .d = 5, .e = 0x0a0b0c0d }; for(unsigned int i = 0;i \u003c sizeof(struct test_struct);i++) printf(\"%d\\t\",test.test_struct_data[i]); for(unsigned int i = 0;i \u003c sizeof(struct test_struct);i++) printf(\"%d\\t\",test1.test_struct_data[i]); 二者都打印： 2 3 4 5 13 12 11 10 a b c d e[0] e[1] e[2] e[3] 因为是大端模式，因此 e[0] 为 0x0d e[0] 即 *(((unsigned char*)(\u0026(test1.e))) + 0) 另外，GNU C 中也可以使用 变量定义数组长度：unsigned int n = argc; int nums[n]; // 但是变长度数组不能在定义时初始化数据。 case 一个范围 switch (ch) { case '0'... '9': c -= '0'; break; case 'a'... 'f': c -= 'a' - 10; break; case 'A'... 'F': c -= 'A' - 10; break; } /* 代码中的case'0'...'9'等价于标准C中的： case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': */ 可变参数宏 #define pr_debug(fmt, arg...) \\ printk(fmt, ##arg) /* 这里 arg 表示其余的参数，可以有零个或多个参数，这些参数以及参数之间的逗号构成 arg 的值，在宏扩展时替换 arg */ P_DEBUG_ARG(msg, arg...) printf(\"DEBUG:\"msg\"\\n\", ##arg); 特殊属性声明 GNU C允许声明函数、变量和类型的特殊属性，以便手动优化代码和定制代码检查的方法。要指定一个声明的 属性，只需要在声明后添加__attribute__（（ATTRIBUTE））。其中ATTRIBUTE为属性说明，如果存在多个属 性，则以逗号分隔。GNU C支持noreturn、format、section、aligned、packed等十多个属性。 内容很多，只举例： /* 可用于对齐 */ struct example_struct { char a; int b; long c; } __attribute__((aligned(4))); /* 在嵌入式 MCU 中可用于 声明/设定 变量的内存地址 */ // 见 stm32_framework 仓库 的 malloc.h 里面定义的数组，声明在 fsmc 地址中，即让数据存于 外部 大容量的 sram 中。 内建函数 GNU C提供了大量内建函数，其中大部分是标准C库函数的GNU C编译器内建版本，例如memcpy（）等，它们与对应的标准C库函数功能相同。 不属于库函数的其他内建函数的命名通常以__builtin开始，如下所示。 内建函数 __builtin_return_address(LEVEL) 返回当前函数或其调用者的返回地址，参数LEVEL指定调用栈的级数，如0表示当前函数的返回地址，1表示当前函数的调用者的返回地址。 内建函数 __builtin_constant_p(EXP) 用于判断一个值是否为编译时常数，如果参数EXP的值是常数，函数返回1，否则返回0。 内建函数 __builtin_expect(EXP，C) 用于为编译器提供分支预测信息，其返回值是整数表达式EXP的值，C的 值必须是编译时常数。Linux内核编程时常用的 likely() 和 unlikely() 底层调用的 likely_notrace()、unlikely_notrace() 就是基于 __builtin_expect(EXP，C) 实现的。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:4","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"更多奇技淫巧 没有写明 “实用” 的大概率仅为图个新鲜： gurugio/book_cprogramming: Framework and Plugin design in C (github.com)，总结 C 技巧，大概比较实用。 C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)，特殊写法实现一些计算加速，比较实用。 一个“蝇量级” C 语言协程库 | 酷 壳 - CoolShell，介绍 Adam 的 protothreads 这个协程库，用 switch 实现 yield 语义。 C PUZZLES, Some interesting C problems (gowrikumar.com)，C programming questions/puzzles，做了这些题，会学到很多的奇技。 code (uguu.org)，可编译的源码为字符画形式的程序；C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)，源码字符画 CP。 不使用 sizeof，求int占用的字节数： #define MySizeof(Value) (char *)(\u0026value+1)-(char*)\u0026value int i ; double f; double *q; printf(\"%d\\r\\n\",MySizeof(i)); printf(\"%d\\r\\n\",MySizeof(f)); printf(\"%d\\r\\n\",MySizeof(q)); 输出： 4 8 4 etc. ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:5","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"C 语言面向对象实现 lw_oopc（C语言的面向对象） - robert_cai - 博客园 (cnblogs.com)，作者做了大量的工作实现了 c 语言的封装、多态、继承这三种面向对象特征，还实现了所谓的虚函数。OOPC-C面向对象 - 知乎 (zhihu.com)。 C语言的高级用法，面向对象 (qq.com)。 iota/OO-in-C.md at main · niltok/iota (github.com)。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:6","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"用 C 实现高阶特性 将 C 语言变成支持动态类型的函数式编程语言，Cello • High Level C (libcello.org)。 Github 页：orangeduck/Cello: Higher level programming in C (github.com)。 受 Python 等高级语言的启发，实现了通用数据结构/动态函数/类等等，比较全和丰富。 C 语言有什么奇技淫巧？ - 知乎 (zhihu.com)，介绍 Morn 库，用 C 实现 “函数重载” 和 “泛型”。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:7","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"字符画生产工具/注释的图形化描述 字符画生成/集子 Asciiworld.com : Pictures of Ascii Art !。 在线生成ascii字符画网站字符图案在线生成工具_JaneYork的博客-CSDN博客_字符画生成器。 根据文字生成字符画： http://patorjk.com/software/taag。可以生成超多的类型的文字字符画。我的 这个项目 的 README 的开头标题字符画就是在这里生成的。 http://www.network-science.de/ascii/。 根据图片生成字符画： http://www.degraeve.com/img2txt.php。 http://life.chacuo.net/convertphoto2char。 图片转字符画软件 ASCIIGenerator。可调节图片明暗和对比度等等，可以自定义生成字符画的字符，可以导出彩色字符画，可以导出字符画 文本或图片，可以批量导出！这个视频 字符画BAD APPLE-洛天依_哔哩哔哩_bilibili 就是用这个软件 批量转字符画 做的 :） 注释的图形化描述 下面几个网站的展示在这里 自动生成代码注释的工具，用上头了！ (qq.com)。 JavE JavE - Java Ascii Versatile Editor。插画字符画。 AACircuit AACircuit - Willkommen bei www.tech-chat.de (josoansi.de)。原理图字符画。 CodePlotter CodePlotter 1.6 - Add and edit diagrams in your code with this ‘Visio-like’ tool - CodeProject。 ASCIIFlow。手画生成字符画。 比如生成下面状态图的字符画，用于清晰的展现状态机的状态图设计。引自 我的这个项目 里面 fsm.c 文件里的注释。 /*状态图示例： +-------------------+ | |e v b d + 1+------.2+------.3 + + ^ | |c |g |a v f + | 4+------.5 | ^ | | +-------------------+ */ ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:12:8","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"9 C 组件收集-学习或实用 Github \u0026 Gitee 等 上面 有很多 “轮子”。但要注意开源协议！ tezc/sc: Common libraries and data structures for C. (github.com)。 有哪些值得推荐的小型 C 语言开源项目？ - 知乎 (zhihu.com)。 C 语言内存 dump 函数 ~ Murphy’s Blog，引到下面： #define __is_print(ch) ((unsigned int)((ch) - ' ') \u003c 127u - ' ') /** * dump_hex * * @brief dump data in hex format * * @param buf: User buffer * @param size: Dump data size * @param number: The number of outputs per line * * @return void */ void dump_hex(const uint8_t *buf, uint32_t size, uint32_t number) { int i, j; for (i = 0; i \u003c size; i += number) { printf(\"%08X: \", i); for (j = 0; j \u003c number; j++) { if (j % 8 == 0) { printf(\" \"); } if (i + j \u003c size) printf(\"%02X \", buf[i + j]); else printf(\" \"); } printf(\" \"); for (j = 0; j \u003c number; j++) { if (i + j \u003c size) { printf(\"%c\", __is_print(buf[i + j]) ? buf[i + j] : '.'); } } printf(\"\\n\"); } } /* 测试代码 */ int main(void) { uint8_t i, buff[128]; for (i = 0; i \u003c sizeof(buff); i++) { buff[i] = i; } dump_hex((const uint8_t *)buff, sizeof(buff), 16); return 0; } /* 测试效果 */ 00000000: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ................ 00000010: 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F ................ 00000020: 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F !\"#$%\u0026'()*+,-./ 00000030: 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 0123456789:;\u003c=\u003e? 00000040: 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F @ABCDEFGHIJKLMNO 00000050: 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F PQRSTUVWXYZ[\\]^_ 00000060: 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F `abcdefghijklmno 00000070: 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F pqrstuvwxyz{|}~. .etc ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:13:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"10 ST HAL 库的编写形式 相关文章： STM32 注释风格参考：STM32注释风格参考_wanshiyingg的专栏-CSDN博客。 ST HAL 的各个文件编写风格非常一致，下面以 F4 SPI 为例： .h 文件： ——————————————————————————开头—————————————————————————— /** ****************************************************************************** * @file stm32f4xx_hal_spi.h * @author MCD Application Team * @brief Header file of SPI HAL module. ****************************************************************************** * @attention ...一大段版权说明和开源协议说明 * ****************************************************************************** */ /* Define to prevent recursive inclusion -------------------------------------*/ #ifndef STM32F4xx_HAL_SPI_H #define STM32F4xx_HAL_SPI_H #ifdef __cplusplus extern \"C\" { #endif ——————————————————————————中间部分，挑重点—————————————————————————— /* Includes ------------------------------------------------------------------*/ #include \"stm32f4xx_hal_def.h\"这添加各种 Includes 这里所有 @addtogroup 的部分省略，这是添加分组，为了 Doxygen 组织文档层级结构 其格式： /** @addtogroup STM32F2xx_StdPeriph_Driver * @{ */ ... /** * @} */ /* Exported types ------------------------------------------------------------*/ 这定义各种结构体、枚举和数据类型定义，都符合 Doxygen 形式，定义开头注释，每一个成员注释 /* Exported constants --------------------------------------------------------*/ 这添加各种常量，宏定义 #define 以上结构体应填入的选项名 /* Exported macros -----------------------------------------------------------*/ 这添加个各种宏定义，控制模块和各个子模块启停、 得到标志置位和清除标志位等等的宏定义等等，启动和停止成对出现 /* Exported variables --------------------------------------------------------*/ 共有变量 /* Exported functions --------------------------------------------------------*/ 这添加给其他文件和用户调用的API声明 /* Private types -------------------------------------------------------------*/ /* Private variables ---------------------------------------------------------*/ /* Private constants ---------------------------------------------------------*/ /* Private macros ------------------------------------------------------------*/ 这添加.c文件的API内部使用的私有宏定义，其他文件和用户不得调用 /* Private functions ---------------------------------------------------------*/ ——————————————————————————结尾—————————————————————————— #ifdef __cplusplus } #endif #endif /* STM32F4xx_HAL_SPI_H *//************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 最后加一个 COPYRIGHT .c 文件： ——————————————————————————开头—————————————————————————— /** ****************************************************************************** * @file stm32f4xx_hal_spi.c * @author MCD Application Team * @brief SPI HAL module driver. ...一大段本文件简述 * @verbatim ============================================================================== ##### How to use this driver ##### ============================================================================== ...很长的一段使用说明 @endverbatim ...很长的一段附录表格和几个@note ****************************************************************************** * @attention ...一大段版权说明和开源协议说明 * ****************************************************************************** */ ——————————————————————————中间部分，挑重点—————————————————————————— /* Includes ------------------------------------------------------------------*/ 这里所有 @addtogroup 的部分省略，这是添加分组，为了 Doxygen 组织文档层级结构 #ifdef HAL_SPI_MODULE_ENABLED 模块预编译控制，方便工程剪裁 /* Private typedef -----------------------------------------------------------*/ 私有类型定义 /* Private defines -----------------------------------------------------------*/ 私有常数宏定义 /* Private macros ------------------------------------------------------------*/ 私有宏定义 /* Private variables ---------------------------------------------------------*/ 私有变量 /* Private function prototypes -----------------------------------------------*/ /* Private functions ---------------------------------------------------------*/ 私有API，仅本文件内部调用，外部文件和用户不可调用 /* Exported functions --------------------------------------------------------*/ 共有API，供外部文件和用户调用 #endif /* HAL_SPI_MODULE_ENABLED */ ——————————————————————————结尾—————————————————————————— /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 最后加一个 COPYRI","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:14:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"11 本文参考源 c-code-style，受此启发，而积此文。 不计其数的众多网络文章资料（大块的引用的已经在文中标出出处）。 一些 C 相关的书籍。 20个成熟软件中常用的宏定义。ST HAL。知乎问题页：程序员们有什么好的编程习惯？。 《【正点原子】嵌入式Linux C代码规范化》手册。 本文作者长期摸索的经验。 很多 引用 的源头难考（或 中文互联网 低质量的抄来抄去的 有些根本就不可考源头）就没有写引用，侵删。 其他。 这是 ZLG致远电子 在2018年的一篇肺腑文章： p.s 本 C 规范系广泛约取而成，参考并非照搬。 p.s 正文中部分小的内容段落的引用源有在其旁边有标注，这里列出正文的其余引用原。 p.s 此文件系业余整理而成，远不及\"Google C/C++编程规范”、“华为编程规范\"等文件的专业程度。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:15:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"12 尾记 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:16:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"开光保护 佛祖保佑永无BUG 神兽护体 代码注释(各种版本)。 厉害了word程序猿，进寺庙给服务器开光保永不宕机。 获取更多字符画 / 定制字符画 可见 字符画生产工具/注释的图形化描述 一节。 以下是效果图。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:16:1","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"现代信息社会的基 所有的可以归结为算法的问题都可以通过 运算+赋值+顺序+分支+循环 等基本要素完成，支持做到这样的机器可以被称为图灵完备的，由数字电路中的与或非门的组合组成组合逻辑电路和用其所组成的触发器单元再组合成时序逻辑电路就可以形成这样的机器，按照冯诺依曼计算机结构来设计一个带有输入、输出、存储和计算单元等的通用的一个机器，可以称之为 CPU，其中计算单元将大部分问题的解决步骤分为了有限的、少量的基本运算比如锁存（幅值）、加法、位移等等，调用这些运算的称之为指令，在机器中提前规定特定的 0/1 组合来表示这些指令，被称之为机器码，再规定一些汇编语句与这些机器码一一对应，当编好汇编码再由一些手段转化为机器码之后，CPU 读取这些机器码识别到要对哪些数据进行哪些基本运算，对于 CPU 来说眼里只有这点事，在此基础上构建高级语言再通过某些手段转化为汇编即可，对人类而言可以靠其用编程来解决能算法化的问题。 好，每当多一个人理解了这个现代计算机的底层精髓后，当末日降临之后新人类靠这些密语重新构建电子信息社会的几率就大一点（逃）。 我甚至想写一篇《从沙子到操作系统》的综合多学科交叉的科普性文章，也是计算机的简史，大纲如下： 上等的沙子。 单晶硅。 掺杂得 p、n 结。 二极管。 BJT。 MOS。 组成基本与或非门。 组合逻辑电路。 SR 锁存器。 主从结构得 D 触发器。 时序逻辑电路。 模 n 计数器。 状态机。 ALU。 存储 RAM ROM。 再联合输入输出+控制电路等等，组成通用处理器 CPU，可以执行机器码。 支持顺序、分支和循环（图灵完备）。 冯诺依曼结构、哈佛结构。 设计指令集。 汇编助记符替代机器码。 用汇编写个 C 语言编译器。 再用 C 语言重新编译器。 写驱动、写算法，写写写。 CPU 演化：流水线、Cache 分级、分支预测、乱序执行、SIMD、单发射/多发射、超线程。 不断扩充指令集。 不断产生 FPU、VPU、GPU、NPU 等等（26 英文字母 + PU）。 上操作系统：多任务管理、任务间通讯与同步、资源管理、设备驱动标准化等等。 等等等等。 才有了现代信息社会。 （太多了不想写，就这么发了吧） ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:16:2","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"花式点灯 娱乐一把： 写流水灯。 写一个状态机，实现任意模式的流水灯。 写一个实时操作系统，充分利用汇编实现高效调度算法，然后点灯。 在 FPGA 上实现一个 cpu 软核，在核内运行我写的实时操作系统，然后点灯。 使用 RSIC-V 架构实现一个 cpu，其外部总线连着 FPGA，内核跑我写的操作系统，通过总线控制 FPGA 实现时序逻辑状态机，然后点灯。 设计一套包含前后端的物联网系统，视觉识别马路上的行人姿态，当有人摔倒时，然后点灯。 把旧安卓手机的 cpu 从主板上吹下来，再吹焊到我设计的 8 层板上，跑个安卓系统，然后点灯。 这个世界的目的就是点灯，与 烧开水 的重要程度并列（癫狂ing）！ ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:16:3","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"署名 编辑整理：Github 页，知乎页。 发表时间：始于 2021.2 且无终稿。 首发平台：https://zhuanlan.zhihu.com/p/350839857 and https://github.com/Staok/coding-style-and-more。 遵循协议：CC BY-NC-SA 4.0。 其他说明： 本文件是“瞰百易”计划的一部分，尽量遵循 “二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明（这中二魂…）！ 本文系广泛撷取、借鉴和整理，侵删。本文适合刚入门的人阅读和遵守，也适合已经有较多编程经验的人参看。如有错误恭谢指出！ 转载请注明作者及出处。整理不易，请多支持。 ","date":"2021-02-10","objectID":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/:17:0","tags":["规范","软件"],"title":"【规范】C \u0026 MCU 编写规范和技巧","uri":"/%E8%BD%AF%E4%BB%B6%E8%A7%84%E8%8C%83/"},{"categories":["随机技术情报"],"content":"一个名叫“巧克力板”的开源电源介绍","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"一个实现大功率可调的开关电源，附带多路多种输出和实用功能；本项目是“瞰百易”计划的一部分。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:0:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"本项目的 GitHub仓库 Staok/PowerBar: 一个实现大功率可调的开关电源，附带多路多种输出和实用功能 (github.com). 该项目早在2020.7开始在github上更新了，中间停隔了半年多，又于近日开始完成了 V2 版。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:1:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"开源内容 设计规划文件； 原理图pdf文件； 被选型的芯片包； multisim 模拟文件，包含CC-CV、恒流源、基准和过压保护； 渲染效果图原图。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:2:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"输入规格 3S航模锂电池直接供电，或者12V\\24V开关电源模块供电。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:3:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"主输出规格 主输出：DCDC升降压BUCK，外置MOS，至少10A，20A以上最好，最大可以30V左右(由电阻限制)，恒流、恒压分别可调。 主输出可借鉴的芯片列表：LTC3789（外置MOS）；CSD18540Q5B（100V 70A），贴片的占地小。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:4:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"副输出规格 固定5V（5A BUCK）; 3.3V（0.5A LDO）; 一路5A BUCK可调等； 可调负电压； TL431+三极管做的一路可调恒流源。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:5:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"其他模块 SG3525提供一组带死区的互补输出的高性能的PWM输出； 提供一路硬件正交波形解码； 提供一组 XKT412 方案无线输电； 提供一组 IP5306 方案的备份电源； 提供一组 TL431 方案的可调基准源。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:6:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"其他要求 原理图和PCB尽量遵循 SCH \u0026 PCB 设计规范 ； 滤波、地划分隔离、保护措施等尽量遵循 Staok/protection-circuits； 输出接口丰富多样； 等等。 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:7:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"电源路径 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:8:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["随机技术情报"],"content":"渲染效果图 ","date":"2020-07-01","objectID":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/:9:0","tags":["硬件","电源"],"title":"【开源电源】巧克力板","uri":"/4%E5%BC%80%E6%BA%90%E7%94%B5%E6%BA%90-%E5%B7%A7%E5%85%8B%E5%8A%9B%E6%9D%BF/"},{"categories":["【主线剧情】Linux 系列"],"content":"介绍设备树","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"设备树详解 本文 续接 《【主线剧情03】NXP i.MX 系列 u-boot 移植基础详解》 一文中移植过程小节中有关设备树的内容。 编辑整理 By Staok，如有错误恭谢指出，侵删。CC-BY-NC-SA 4.0。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:0:0","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"零 参考 工欲善其事，必先利其器。 比较全面的文章： devicetree-org-devicetree-specification-github.com 官方语法描述； Specifications - DeviceTree 设备树组织官网发布的设备树标准； Device Tree What It Is - eLinux.org eLinux 网站的设备树介绍； Device Tree Usage - eLinux.org eLinux 网站的设备树使用，循序渐进，推荐看； 设备树_To_run_away的博客-CSDN博客 比较全面，共 30 篇文章； 网友总结的零散文章： Linux设备树语法详解 - Abnor - 博客园 (cnblogs.com)，部分细节介绍比较详细； Linux 设备树详解 - 程序员大本营 (pianshen.com)，该文介绍 Linux 内核解析 .dtb 文件，本文不涉及此内容； 【Linux笔记】设备树基础知识 - 知乎 (zhihu.com)，部分细节介绍比较详细； 统一设备模型 - 蜗窝科技 (wowotech.net)，很强但文章写不通顺，得读好几遍； Device Tree（一）：背景介绍 (wowotech.net)； Device Tree（二）：基本概念 (wowotech.net)； Device Tree（三）：代码分析 (wowotech.net)，该文介绍 Linux 内核解析 .dtb 文件，本文不涉及此内容； Device Tree（四）：文件结构解析 (wowotech.net)，设备树经过编译后的二进制文件的结构，以及 Linux 如何解析，本文不涉及此内容； 【Linux驱动开发】Linux设备树 - 程序员大本营 (pianshen.com)； 致驱动工程师的一封信 (wowotech.net)，扩展阅读； u-boot FIT image介绍 (wowotech.net)，扩展阅读； 【野火】《i.MX Linux开发实战指南》； 【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.5.1。 本文部分内容引自上述链接。上述有些文章的描述不清等问题，本文形成时梳理了一下；有些文章中英文混写的问题，在引用的基础上简单的修一下格式，并补充中文说明。上述有些文章还会在结尾突然说“点到为止，不多讲”，嗯，你很强，同时我也可以理解为不会简练表达，或者吝惜自己宝贵的时间不愿多敲几个字，但是那篇中有一句话说得很对“我只是给你指条明路，剩下的就需要自己去走。最后说一句，代码不会骗你，还会告诉你别人不能告诉你的”。 又要批判一番了，总感觉概念一大堆： 为了描述编译行为，另造一套 Makefile 语法； 为了描述让命令行适应编程行为，另造一套 Shell 语法； 为了描述编译后的各个文件如何链接起来，另造一套链接文件 .lds 语法； 为了描述 SoC 上电自己初始化的行为，另造一套行为描述语法，比如 DCD 段； 为了描述 SoC 硬件外设，另造一套设备树语法，我觉得这语法和 json 差不多。等等等等。 为什么光另造规则，不多想一些可重用的方法；正如英文单词，数量已经超过 100 万个了，恨不得给宇宙中所有事物都单独取名？ 也许原因之一是以上概念出现的很早，在那个混元初开的年代，还没有形成业内比较统一的、惯例的数据结构存储方法，所以百花齐放自造语法盛行。现在趋向于归一了，数据存储常用 json 或者 xml 语法，命令行编程常常趋近于兼容 shell 语法。挺好，越来越规范、归一，都这样的话不但提高来者的学习效率，也适合让机器去识别，早日实现全流程高度自动化。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:1:0","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"一 记录 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:0","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"设备树基本概念 Device Tree 是一种 适合人类阅读的（或者叫适合有智能的生物阅读的） 描述 SoC 硬件外设的数据结构（以文本的形式），硬件的细节可以直接通过它传递给 Linux（Bootloader 会将这棵树传递给内核，然后内核可以识别这棵树），内核会将这些硬件资源和自己的相应的设备原型绑定，进而可以控制实际的硬件外设，实现 板级信息 和 内核 的分离；Device Tree 由一系列被命名的 结点（node）（结点本身可包含子结点，即 总分 的结构）和 属性（property）（成对出现的 name 和 value ）组成。 通常由 .dts 文件以文本方式对系统设备树进行描述，经过 Device Tree Compiler (dtc) 将 .dts 文件转换成二进制文件 binary device tree blob (dtb)，.dtb 文件可由 Linux 内核解析（ .dtb 文件是一种可以被 kernel 和 uboot 识别的二进制文件），Linux 解析后把设备节点信息存储在 device_node 结构体里面，然后与 Linux 内核中的设备原型结构体 platform_device 进行绑定，即注册设备信息，Linux 系统下的设备大多都是挂载在平台总线下的，所有的子节点将被作为设备注册到该设备总线上。 除了描述设备，还可以描述 IO 动作用于外设的必要初始化，例如一个设备树的节点设备的 IO 描述为如下： device { rst-gpio = \u003c\u0026gpioc_ctl 10 OF_GPIO_ACTIVE_LOW\u003e; irq-gpio = \u003c\u0026gpioc_ctl 11 0\u003e; interrupts-extended = \u003c\u0026vic 11 IRQF_TRIGGER_RISING\u003e; }; 然后在 Linux 内核或者 uboot 中会解析这个结构并根据其中的设定进行动作，如下示例解析和动作： int device_probe(struct platform_device *pdev) { rst_gpio = of_get_named_gpio_flags(np, \"rst-gpio\", 0, \u0026flags); if (flags \u0026 OF_GPIO_ACTIVE_LOW) { struct gpio_desc *desc; desc = gpio_to_desc(rst_gpio); set_bit(FLAG_ACTIVE_LOW, \u0026desc-\u003eflags); } irq = of_irq_get(np, 0); trigger_type = irq_get_trigger_type(irq); request_threaded_irq(irq, NULL, irq_handler, trigger_type, \"irq\", NULL); } 所以，如果修改中断触发类型或者电平有效状态只需要修改 .dts 文件，再编译重新装载即可。 有了device tree 就可以在不改动 Linux 内核的情况下，对不同的平台实现无差异的支持，只需更换相应的 .dts 文件即可，硬件有变动时不需要重新编译内核或驱动程序，只需要提供不一样的 .dtb 文件。 Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler 安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。 在描述Device Tree的结构之前，我们先问一个基础问题：是否Device Tree要描述系统中的所有硬件信息？答案是否定的。基本上，那些可以动态探测到的设备是不需要描述的，例如USB device。不过对于SOC上的usb host controller，它是无法动态识别的，需要在device tree中描述。同样的道理，在computer system中，PCI device可以被动态探测到，不需要在device tree中描述，但是PCI bridge如果不能被探测，那么就需要描述之。 我们可以将公共部分抽取出来，一般为一个系列的 SoC 共有的硬件外设，写成 \u003cSoC\u003e.dtsi（i 表示 include ），方便大家在 具体的板级的 .dts 文件中 include。这样每个 .dts 就只有自己差异的部分，公有的部分只需要 include 相应的 .dtsi 文件, 这样就使整个设备树的管理更加有序。 在 Device Tree 中，可描述的信息包括（CPU、GPIO、时钟、中断、内存等）： CPU 的数量和类别； 内存基地址和大小； 总线和桥； 外设连接； 中断控制器和中断使用情况； GPIO 控制器和 GPIO 使用情况； Clock 控制器和 Clock 使用情况。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:1","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"设备树基本语法 设备树 .dts 文件描述硬件的基本结构，在 .dts 文件中，一个 node 被定义成： [label:] node-name[@unit-address] { [properties definitions] [child nodes] } 方括号 [] 里面的为可选项 Device Tree 中的节点信息 示意图： 上图细说如下： device tree 的基本单元是 node。这些 node 被组织成树状结构，除了root node，每个 node 都只有一个 parent，即父级节点。一个 device tree 文件中只能有一个 root node，即根节点，必须是/。 root 结点下面含一系列子结点，本例中为 “node@0” 和 “node@1” ；结点 “node@0” 下又含有一系列子结点，本例中为 “child-node@0”； 各结点都有一系列属性。属性（property）值标识了设备的特性，它的值（value）是多种多样的： 可能是空，也就是没有值的定义。例如上图中的 an-cmpty-property ，这个属性没有赋值； 可能是一个 u32、u64 的数值，用尖括号表示（值得一提的是 cell 这个术语，在 Device Tree 表示有几个 32bit 的信息，一个 cell 就是一个u32）。例如#address-cells = \u003c1\u003e 。当然，可能是一个数组。例如\u003c0x00000000 0x00000000 0x00000000 0x20000000\u003e，“#”是number的意思； 属性值是 binary data，用方括号表示。例如 binary-property = [0x01 0x23 0x45 0x67]； 可能是一个字符串，用双引号表示。例如device_type = \"memory\" ，当然也可能是一个 string list。例如\"PowerPC,970\"。 节点名字的格式是 node-name@unit-address，其中 node-name 就是设备名，最长可以是31个字符长度；unit_address 一般是设备地址，用来唯一标识一个节点；如果设备有 reg 属性，则 unit-address 就是寄存器地址，否则是用于区分的 编号。同级别的设备树下（相同级别的子节点）节点名唯一 。 可以通过 \u0026lable 的形式访问一个带 lable 的 node，这种引用是通过 phandle（pointer handle）进行的。例如，上图中的 node1 就是一个 lable，node@0 的子节点 child-node@0 通过 \u0026node1 引用 node@1 节点。经编译后，每一个 phandle 都是一个独一无二的整型值，在后续 kernel 中通过这个特殊的数字间接找到引用的节点。引用节点或者可用使用 full path（绝对路径），但一般不用，例如/node-name-1/node-name-2/node-name-N。 所以，一个设备树的基本框架可以写成下面这个样子。一般来说，/表示板子，它的子节点 node1 表示 SoC 上的某个 硬件外设/控制器，硬件外设/控制器 中的子节点 node2 表示挂接在这个控制器上的设备(们)。注释规则与 c 相同，用 //... 和 /* ... */。 /{ // 根节点 每个设备树文件都有一个根节点，每个设备都是一个节点 node1{ // node1 是节点名，是 / 的子节点 key=value; // node1 的属性 每个设备的属性都用一组 key-value 对(键值对)来描述 // 每个属性的描述用;结束 ... node2{ // node2 是 node1 的子节点 节点间可以嵌套，形成父子关系，这样就可以方便的描述设备间的关系 key=value; // node2 的属性 ... } } // node1 的描述到此为止 node3{ key=value; ... } } Device Tree中的节点信息 实例图： ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:2","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"设备树常用节点 根节点，用 / 标识根节点；CPU节点，一般不需要我们设置，在 .dtsi 文件中都定义好了； aliases 节点的作用就是为其他节点起一个别名。以 can0 = \u0026flexcan1; 为例。“flexcan1”是一个节点的名字，设置别名后我们可以使用“can0”来指代 flexcan1节点，与节点标签类似。 在驱动中如果要查找一个节点，通常情况下我们可以使用“节点路径”一步步找到节点。也可以使用别名“一步到位”找到节点。 memory 节点：芯片厂家不可能事先确定你的板子使用多大的内存，所以 memory 节点需要板厂设置，比如： memory { reg = \u003c0x80000000 0x20000000\u003e; }; chosen 节点：我们可以通过设备树文件给内核传入一些参数，例如下面在chosen节点中设置bootargs属性： chosen { bootargs = \"noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200\"; }; 这个节点用作 uboot 向 linux 内核传递配置参数的“通道”，我们在 Uboot 中设置的参数就是通过这个节点传递到内核的。 节点名、引用、修改和追加： 如果引用节点后编写的属性在之前已经有，则属性值会覆盖之前的，如果没有，则为追加属性。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:3","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"设备树标准属性 标准属性。在设备树中，有一些特定的属性。Linux 设备树语法中定义了一些具有规范意义的属性，包括：compatible, address, interrupt 等，这些信息能够在内核初始化找到节点的时候，自动解析生成相应的设备信息。此外，还有一些Linux内核定义好的，一类设备通用的有默认意义的属性，这些属性一般不能被内核自动解析生成相应的设备信息，但是内核已经编写的相应的解析提取函数，常见的有 “mac_addr”，“gpio”，“clock”，“power”。“regulator” 等等。 compatible：Linux 驱动中可以通过设备节点中的 “compatible” 这个属性查找设备节点，即根据这个属性的字符串描述的芯片的公司和驱动文件的字符串索引到驱动文件。例如系统初始化时会初始化 platform 总线上的设备时，根据设备节点”compatible”属性和驱动中 of_match_table 对应的值，匹配了就加载对应的驱动。 address： #address-cells，用来描述子节点的\"reg\"属性的地址表中用来描述首地址的cell的数量； #size-cells， 用来描述子节点的\"reg\"属性的地址表中用来描述地址长度的cell的数量。 若 reg 中的数值数量多于以上两个属性值的和，那么reg 属性里的数据是“地址”、“长度”交替的。 有了这两个属性，子节点中的 “reg” 就可以描述一块连续的地址区域。下例中，父节点中指定了#address-cells = \u003c2\u003e;#size-cells = \u003c1\u003e;，则子节点 dev-bootscs 中的 reg 中的前两个数表示一个地址，即 MBUS_ID(0xf0, 0x01) 和 0x1045C，然后有一个数表示从首地址开始要访问到的寄存器的长度，即 0x4 ，单位为 cell。 soc { #address-cel1s = \u003c2\u003e; #size-cells = \u003c1\u003e; controller = \u003c\u0026mbusc\u003e; devbus_bootcs:devbus-bootcs { compatible = \"marvell,orion-devbus\"; reg = \u003cMBUS_ID(OxfO,0x01) 0X1046C 0x4\u003e; ranges = \u003c0 MBUS_ID(0x01,0x0f) 0 Oxffffffff\u003e; #address-cells = \u003c1\u003e; #size-cells = \u003c1\u003e; clocks = \u003c\u0026core_clk 0\u003e; status = \"disabled\"; }; ... }; gpio：gpio也是最常见的IO口，常用的属性有 “gpio-controller”，用来说明该节点描述的是一个gpio控制器； “#gpio-cells”，用来描述gpio使用节点的属性一个cell的内容； 描述 IO 行为，IO名 = \u003c\u0026引用GPIO节点别名 GPIO标号 工作模式\u003e。 interrupts：引自Linux设备树语法详解 - Abnor - 博客园 (cnblogs.com)。 标准属性 描述 compatible 属性 compatible 属性也叫做“兼容性”属性。用于将设备和驱动绑定起来。值是一个字符串列表，用于选择设备所要使用的驱动程序。 model 属性 值是字符串，一般描述设备模块信息，例如名字。 status 属性 值是字符串，设备的状态信息。 #address-cells #size-cells 属性 值是无符号 32 位整形。可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。#address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)，#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。 reg 属性 值一般是(address，length)对。用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息 ranges 属性 ranges 是一个地址映射/转换表，ranges 属性每个项目由子地址、父地址和地址空间长度 这三部分组成。如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。该属性提供了子节点地址空间和父地址空间的映射（转换）方法，常见格式是 ranges = \u003c 子地址, 父地址, 转\u003cbr/\u003e换长度 \u003e。 比如对于 #address-cells 和 #size-cells 都为 1 的话，以 ranges=\u003c0x0 0x10 0x20\u003e 为例，表示将子地址的从 0x0~(0x0+ 0x20) 的地址空间映射到父地址的 0x10~(0x10 + 0x20)。 name 属性 值是字符串，name 属性用于记录节点名字。name 属性已经被弃用，不推荐使用 name 属性，一些老的设备树文件可能会使用此属性。 device_type 属性 值是字符串，IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设 备树没有 FCode，所以此属性也被抛弃了。此属性只能用于 cpu 节点或者 memory 节点。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:4","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"设备树加深理解 看这里加深一下理解，Device Tree 中的节点信息 实例图：引自Linux dts 设备树详解(二) 动手编写设备树dts_GREYWALL-CSDN博客_设备树编写。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:5","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"二 其他 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:0","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"Uboot 中有关 dtb 的内容 uboot] （番外篇）uboot之fdt介绍_ooonebook的博客-CSDN博客； uboot 使用fdt命令查看设备树_兔兔里个花兔的博客-CSDN博客； u-boot中fdt命令的使用_voice_shen的专栏-CSDN博客_fdt命令； uboot处理dtb - zongzi10010 - 博客园 (cnblogs.com)； 一下有关 linxu 的小节会在以后放到【07-08】 linux 驱动/应用 的文章里面。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:1","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 中设备树操作函数 Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”（“open firmware”即开放固件。 ），所以在很多资料里面也被叫做 OF 函数。 device_node 结构体，它保存着设备节点的信息 其内容简述： name： 节点中属性为 name 的值； type： 节点中属性为 device_type 的值； full_name： 节点的名字，在 device_node 结构体后面放一个字符串， full_name 指向它； properties： 链表，连接该节点的所有属性； parent： 指向父节点； child： 指向子节点； sibling： 指向兄弟节点。 得到 device_node 结构体之后我们就可以使用其他 of 函数获取节点的详细信息。 of 函数更多内容可参：（网上很多，以后用的时候整理补充在这里） 【Linux笔记】设备树基础知识 - 知乎 (zhihu.com)。 【野火】《i.MX Linux开发实战指南》的 103.3 如何获取设备树节点信息 一节，讲了节点寻找、属性值获取和内存映射三大块 API。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:2","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【主线剧情】Linux 系列"],"content":"用设备树建立和控制设备实例 从设备树拿信息控制 IO 和 使用 platform_device 控制 IO 的介绍和对比：【Linux笔记】设备树实例分析 - 知乎 (zhihu.com)。 linux 驱动开发之平台设备驱动设备树 led字符驱动的开发(详细注释)_myz348的博客-CSDN博客。 【野火】《i.MX Linux开发实战指南》的103.4 向设备树中添加设备节点实验一节。 【野火】《i.MX Linux开发实战指南》的 104 章节 使用设备树实现 RGB 灯驱动。 【野火】《i.MX Linux开发实战指南》的 105 章节 使用设备树插件实现 RGB 灯驱动。 ","date":"2021-05-23","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:3","tags":["ARM","Linux","dts"],"title":"【主线剧情 番外02】设备树详解","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85-%E7%95%AA%E5%A4%9602-%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["【规范】系列"],"content":"比较详细的介绍了 HDL \u0026 FPGA 学习、规范和一些实用技巧","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"HDL \u0026 FPGA 学习、规范和技巧（HDL-\u0026-FPGA- study） ***p.s 温馨提示：点个 star 收藏一下回头慢慢看；或者下(白)载(嫖)下来，在 Typora 中阅读；[本文知乎地址（不是最新）](https://zhuanlan.zhihu.com/p/356856108) ；整理不易，请多支持。*** 编辑整理 by Staok，始于 2021.2 且无终稿。转载请注明作者及出处。 本文件是“瞰百易”计划的一部分，尽量遵循“二项玻”定则，致力于与网络上碎片化严重的现象泾渭分明！ 本文系广泛撷取、借鉴和整理，适合刚入门的人阅读和遵守，已经有较多经验的人看一看图个乐，如有错误恭谢指出！本文已经是长期积累和堆叠而形成一定规模，不必按照从前到后的顺序去看，可以挑感兴趣的章节去看。 本文为简述风格，本意即记录要点和便于快速拾起。 本文对应的 Github/Gitee 仓库地址，本文最新的原文 和 一些源码、备查手册等等 均放在里面。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:0:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"O 目录 [TOC] ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:1:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"O.0 值得跟着的学习网站 强烈推荐看下面分享链接里收集整理的教程（永久有效）： 链接：https://pan.baidu.com/s/1cWzZQZlS9OUVvuDy7VFTsw?pwd=XHYS 提取码：XHYS 真的强烈推荐里面的几个教程文档，看了就会，嘎嘎高效： 【Quartus \u0026 Qsys 教程文档 \\ QuartusII的奇幻漂流_v1.0.pdf。 【Quartus \u0026 Qsys 教程文档 \\ NiosII的奇幻漂流-v2.0.pdf。 【Verilog 语言和规范 \\。 ———————————————— 下面这些看看就好，主要看上面的。 学习路线总结文章： 如何学习FPGA，FPGA学习教程学习经验 - 知乎 (zhihu.com)。 FPGA简介 - 知乎 (zhihu.com)。 Verilog知识大全 - 知乎 (zhihu.com)。 .etc 入门 \u0026 学习： SOC FPGA 和 FPGA 等各种开发板开源资料（网上可以找到全套资料）：如 正点原子、野火、黑金 等开发板（考验资料搜集能力的时候到了）。推荐这种学习方式。 小梅哥 B站视频（Verilog \u0026 FPGA基础，SOPC，SOC以及其他常用协议 缺点：视频太~长了。 LeiWang1999/FPGA: 帮助大家进行FPGA的入门，分享FPGA相关的优秀文章，优秀项目 (github.com) 记录比较全面，内容丰富可反复看。 文档形式的教程： Verilog 教程 | 菜鸟教程 (runoob.com)。 Quartus II的奇幻漂流V1.0——手把手教你使用Quartus II 推荐。 Nios II的奇幻漂流V2.0——基于Qsys的Nios II设计教程 推荐。 这两个链接可能失效，但文档已经下载并分享（永久有效）： 链接：https://pan.baidu.com/s/1cWzZQZlS9OUVvuDy7VFTsw?pwd=XHYS 提取码：XHYS Nios II入门实验。小梅哥 FPGA资料专区。小梅哥 - 博客园。比较杂。 HDL \u0026 FPGA 学习和规范（HDL-\u0026-FPGA- study） 就是本文。 FPGA 的 时序分析 和 时序约束 的资料参考： FPGA 高级设计：时序分析和收敛。 小梅哥概述时序约束和分析相关知识 视频。 小梅哥FPGA时序分析和约束实例演练课程 视频。 基于TimeQuest Timing Analyzer的时序分析笔记（一） - 程序员大本营 (pianshen.com) 网络系列文章。 《深入浅出玩转FPGA第三版》 时序分析章节 书。 《通向FPGA之路—七天玩转Altera之时序篇V1.0》书。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:2:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"0.25 开源 \u0026 学习 FPGA 开发板 以下 FPGA 开发板提供了完善的 软硬件资料，参考意义极大。 正点原子FPGA开发板 — 正点原子资料下载中心 1.0.0 文档 (openedv.com)。 FPGA系列产品 — 野火产品资料下载中心 文档 (embedfire.com)。 黑金 FPGA 开发板 - 芯驿电子科技(上海)有限公司 (alinx.cn)。 Xilinx FPGA板卡 - 米尔科技 (myir-tech.com)。 Terasic - DE 系列母板，terasIC 开源其开发板的原理图和例程，作为参考设计很不错。 STEP FPGA开源社区]，目前开源好几款 FPGA 开发板和各种参考案例、教程，比较丰富。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:3:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"0.5 FPGA 相关好文杂文存放 如何从零开始将神经网络移植到FPGA(ZYNQ7020)加速_Jarvis码员的博客-CSDN博客_将神经网络部署到fpga上。 .etc ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:4:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1 HDL \u0026 FPGA 值得注意的 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"Altera FPGA 基本要素 p.s 过于基础的概念不提，这不是入门帖。入门可以跳到 “O.0 值得跟着的学习网站” 章节进行摄入。 p.s 以下以 Cyclone IV E 系列 FPGA 为例。 FPGA基础资源选择：逻辑单元（LE）数量，内嵌存储器（M9K）数量（总 RAM Bits 数），乘法器数量，PLL 数量，I/O 数量，全局时钟网络数量等。 板级电路组成：电源，时钟，复位，JTAG，固化配置信息 FLASH，外设。具体连接形式参考一些开发板和开源板子的原理图和 PCB。 电源：核心电源（标识 VCCINT，低压版本 1.0V，非低压 1.2V），IO BANK（标识 VCCIOx（x = 1 到 8），电压 1.2V 到 3.3V），PLL（模拟 PLL 标识 VCCAx（x = 1、2 或 4），其地标识 GNDAx（x 同前），电压 2.5V；数字 PLL 标识 VCCD_PLLx（x = 1、2 或 4），电压 1.2V），外设供电。不同系列 FPGA 的供电措施不同，具体要看电器参数等手册，尽量使用推荐值。 复位：上电后，FPGA 器件开始加载外部 FLASH 芯片的固化信息，加载完毕之后（最多 0.3s）再进行复位（低电平有效），阻容 RC 复位电路可选：R = 47kΩ，C = 10uF，3.3V 的 IO 标准下，充电到 1.7V 时间为 340ms。 全局时钟网络：专用时钟网络走线，同一时钟到达不同寄存器的时间差可以被控制到很小的范围内。外部输入时钟信号要连接到 “全局时钟专用引脚” 上。FPGA 的综合工具会自动识别和分配。 I/O：输入和输出时钟信号尽量分配到专用引脚上。差分信号对儿必须分配到支持差分的专用引脚上。高速信号分配到支持高速传输的专用引脚上（如 DDR 的专用 IO 接口）。一些硬核使用的引脚可能是固定的要注意。总线信号尽量分配到同一个 BANK。一些产生噪声干扰的信号（如时钟信号）尽量远离器件的配置喜欢和其它敏感的信号。 调试和固化： 更多详细参考： FPGA配置方式。 FPGA的各种功能管脚。 Altera特殊管脚的使用。 官方手册里是最全的、最准的，多看！ 具体看官网手册 “Cyclone IV Device Handbook Volume 1” 的 “Configuration Process” 章节和 “Configuring Altera FPGAs.pdf” 手册。 调试为通过 JTAG 接口用 Blaster 下载器把编译生成的 .sof 文件下载到 FPGA 内掉电易失的 SRAM 中。 固化是通过 JTAG 接口用 Blaster 下载器把编译并转化生成的 .jic 文件下载到 FPGA 对于的外部 FLASH 器件中。FPGA 上电从 FLASH 中获取配置信息，分为几种不同的配置模式，根据 [3:0]MSEL 四个引脚上电时的电平状态确定，而具体的 [3:0]MSEL 与 启动方式的关系 看对应 FPGA 芯片系列型号的手册。配置模式分为以下几种： AS（主动串行），适用于小容量。由 FPGA 器件引导配置过程，EPCS 系列 FLASH 专供 AS 模式。一般用此模式。 AP（主动并行），速度快，占 I/O 更多，适用于大容量 FPGA 器件。EPC 系列 FLASH 用于此。 PS（被动串行），需要外部 MCU 或 CPLD（如 MAX II 系列）控制 FLASH 的数据打入 FPGA，此方式最灵活，对于多个 FPGA 或者要自动更换固件用此模式。 等其他。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:1","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"FPGA 开发流程和适用范围 开发流程：需求分析，模块划分，实现，前仿真，分配 IO，时钟信号约束 + 其他信号时序分析和约束，后仿真，下载验证和调试，固化代码（注意是有顺序的）。1.4 Verilog 设计方法 | 菜鸟教程 (runoob.com)。 FPGA 固有灵活性和并行性。FPGA 应用领域列举：逻辑粘合，实时控制，高速信号采集和处理，协议实现，仿真验证系统，片上系统 SoC。 处理器和 FPGA 分工：MCU、MPU 适合做管理、协调，FPGA 的数字逻辑适合做专用的、复杂的、结构和功能固定下来的算法实现。 推荐多去读读 FPGA 原厂（Altera 或 Xilinx）的官方文档，在它们的一些文档手册中有各种常见的电路的参考实现实例和代码风格。 板级 PCB 走线遵循 “PCB走线规范”。 … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:2","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"设计和实施规范 这里的规范仅为初级，另有 “HuaWei Verilog 规范” 等规范可供参考。 顶层设计的要点 单个模块尽量使用一个时钟源；对于多个模块要认真、清楚的划分时钟域；跨时钟域的信号一定做同步处理（D触发器同步）；片内的 PLL / DLL 资源尽量利用起来；至少要对所有时钟信号加上简单的时序约束，不能没有。 数据传递的两边速率不一致要在中间加 缓存机制，常见的如 FIFO 和 乒乓缓存，后者详见 “设计技巧” 小节里的 “乒乓操作” 部分。 复杂逻辑/时序逻辑要使用 FSM （有限状态机）方式来写，在下面的 “模块收集” 里面有状态机的例子。 条件逻辑/状态图等一定要遍历所有状态，一定，防止不可预料的错误综合结果，对于 if 要有 else，对于 case 要有 default。 对于仿真：先对每一个单个模块仿真，要求代码覆盖率、条件分支覆盖率、表达式覆盖率必须达到 100%，这三个可以通过 Modelsim 查看；子系统仿真，将多个模块组合在一起进行仿真，覆盖率尽量高；系统级仿真，软硬件整板联调。仔细设计仿真激励文件。 通常采用自顶向下的设计方式。先确定系统有哪些输入和输出，把系统划分成多个子功能模块（框图模块），每个功能模块再划分下一层的子模块（HDL 意义上的模块），最后的每个模块的设计对应一个 module ，可以一个 module 设计成一个 verilog HDL 文件。 在 FPGA 逻辑全编译之前，尽量将全部 顶层 IO 分配给 实体芯片的引脚 而 不要空置，没用到的输入信号也要 assign 到 确定的 0 或 1，这样不但保证 确定的逻辑行为，而且如果不做那么全编译时 Timing 时序 无法保证 从而 亮红。 工程文件夹划分规范：prj 为工程文件存放目录； rtl 为 verilog 可综合代码存放目录； testbench 为测试文件存放目录； img 为设计相关图片存放目录； doc 为设计相关文档存放目录； prj 文件夹下还建立了子文件夹 ip，用于存放 Quartus Prime 中生成的 IP 核文件。 Verilog HDL 语法规范 No.1，层次化设计，IP 化设计。自写小 IP 尽量参数化、可重用，方便日后搭建数字积木。 顶层文件名与顶层模块名一致。 模块的定义名加尾缀\"_ module\"，输入输出的信号名各加后缀\"_ in\"和\"_ out\"，低电平有效的信号加尾缀\"_ n\"或“#”，时钟信号使用\"clk _“或\"Clk _“前缀，复位信号使用\"rst _“前缀，使能信号使用\"en\"或者\"Enable\"标识等。 定义模块的时候，定义输入输出信号时就带好 “input”/“in” 、 “output”/“out” 和 “reg” 等的标识修饰。 一个 tab 四个空格。 用 tab 划分清晰的语句层次，用 tab 对齐多行同层次语句等。 begin 和 end 语句块修饰词在竖方向对齐。 操作符等前后用一个空格做间隔。 注释齐全，对自己和别人负责。 以下用一例子包含 verilog 常用语法。 /* 这里是注释 */ // 还是注释 /* Verilog 保留字 always and assign begin buf bufif0 bufif1 case casex casez cmos deassign default defparam disable edge else end endcase endmodule endfunction endprimitive endspecify endtable endtask event for force forever fork function highz0 highz1 if ifnone initial inout input integer join large macrmodule medium module nand negedge nmos nor not notif0 notif1 or output parameter pmos posedge primitive pull0 pull1 pullup pulldown rcmos real realtime reg release repeat rnmos rpmos rtran rtranif0 rtranif1 scalared small specify specparam strong0 strong1 supply0 supply1 table task time trantranif0 tranif1 tri tri0 tri1 triand trior trireg vectored wait wand weak0 weak1 while wire wor xnor xor */ /* 引用自 https://blog.csdn.net/luxinwylive/article/details/99827766 （1）所有综合工具都支持的结构：always，assign，begin，end，case，wire，tri，aupply0，supply1，reg，integer，default，for，function，and，nand，or，nor，xor，xnor，buf，not，bufif0，bufif1，notif0，notif1，if，inout，input，instantitation，module，negedge，posedge，operators，output，parameter。 （2）所有综合工具都不支持的结构：time，defparam，$finish，fork，join，initial，delays，UDP，wait。 （3）有些工具支持有些工具不支持的结构：casex，casez，wand，triand，wor，trior，real，disable，forever，arrays，memories，repeat，task，while。 */ /* wire 类型变量定义物理连线，不保存东西，reg 类型变量定义寄存器，用于保存东西 */ /* 引自 https://zhuanlan.zhihu.com/p/72012739 wire 用法总结 1.wire可以在Verilog中表示任意宽度的单线/总线 2.wire可以用于模块的输入和输出端口以及一些其他元素并在实际模块声明中 3.wire不能存储值（无状态），并且不能在always @ 块内赋值（=或\u003c=）左侧使用。 4.wire是assign语句左侧唯一的合法类型（assign 后面跟着的必须是一个 wire 类型） 5.wire只能用于组合逻辑 reg 用法总结 1. 声明寄存器，可以存储信息（有内存，有状态）允许连接到模块的输入端口，但不能连接到一个模块的实例化的输出 2. 在模块声明中，reg可以用作输出，但不能用作输入 3. 在always@(......)语句块内，= 或者 \u003c= 赋值语句的左边必须是是reg变量 在initial语句块内，= 赋值语句的左边必须是是reg变量 4. Reg不能用于assign赋值语句的左侧 5. 当与@（posedge clock）块一起使用时，reg可用于创建寄存器 6. reg可用于组合逻辑和时序逻辑 */ /* 连续赋值语句（assign）用于对线型变量（wire）的赋值，不能够出现在任何一个过程块（begin ... end）中；连续赋值语句（assign）定义组合逻辑，声明物理逻辑的关系；线型变量一旦被连续赋值语句赋值后，赋值语句右端表达式中的信号有任何变化，都将实时地反映到左端的线型变量中 */ /* 过程赋值语句（= 和 \u003c=）完成对寄存器变量（reg）的赋值，只能在过程块语句中被赋值；过程赋值语句只有在语句被执行到时，赋值过程才能够进行一次，而且赋值过程的具体执行时间还受到各种因素的影响 */ /* 数据类型： 5'o37 5 位八进制数，二进制为 11111 10'o37 右对齐，高位补 0 10'bx0x1 左边补 x，完整即 x x x x x x x 0 x 1，x 表示未知状态 4'b1x_01 4 位二进制数，为 1 x 0 1，下划线方便阅读 4'hz 4 位z(扩展的z) , 即 zzzz，z 表高阻状态 parameter SEC_TIME = 48_000_000; 十进制数 位长不能够为变量表达式，可以为预编译、parameter 的表达式 verilog 中 整形、浮点型等变量的 定义字 相当于 define 或者 parameter 的作用，这里只用 后二者即可了 字符串 reg [8*14 : 1]Message = \"INTERNAL ERROR\"; I 为第 1 位，N 为 第 2 位，依此类推 数组 reg [wordsize : 0]my_memory[arraysize : 0]; 引用数组某个数的某个位 my_memory_1 = my_memory[1]; my_memory_1_bit0 = my_memory_1[0]; verilog 不支持 数组作为 模块的输入或输出，systemVerilog 支持 运算; 算术运算符(+，-，x，/,%) 赋值运算符(=,\u003c=) 关系运算符(\u003e,\u003c,\u003e=,\u003c=) 逻辑运算符(\u0026\u0026,||,!) 条件运算符(?;) 位运算符 (~,|,^,\u0026,^~) 对于 \u0026 运算用法之一：assign max_avl_address = \u0026avl_address;","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:3","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"更多小技巧教程文章 关于Quartus II工程综合时间过长问题的解决。 四步搞定NiosII工程路径改变。 PIO时序混乱问题解决（遇到再看）。 NIOS知识 和 各种错误解决。 你问我FIFO有多深？ 结论：在SDRAM的应用中，我们通常使用的读写FIFO是突发长度的2倍，比如突发长度为256，那FIFO的深度设置为512，使得FIFO始终保持半满的状态。可以保证数据的传输。 【小梅哥FPGA进阶教程】MC8051软核在FPGA上的使用。 （教程基于小梅哥）FPGA配置MC8051IP软核。 NingHeChuan 网友个人博客 有许多 FPGA 分享。 … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:4","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"更多好设计规范总结 Verilog HDL语言入门（一）_newzhpfree的博客-CSDN博客。 Verilog HDL语言入门（二）_newzhpfree的博客-CSDN博客。 —— 硬件原理图设计规范(一)_newzhpfree的博客-CSDN博客。 硬件原理图设计规范（二）_newzhpfree的博客-CSDN博客。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:5:5","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"1.1 Avlon 总线 Intel FPGA Avalon 总线，其灵活特点有： 时钟同步的；分主、从信号线和时序，主外设能发起传输；多主多从； 主、从时钟频率可不同，位宽可不同； 专用的地址总线、数据总线和控制总线，支持高达 1024 位的数据宽度、不是 2 的偶数幂的数据宽度； 高性能，易实现，占用资源少，开放使用。 多种模式，时延和时序可调整，定制外设 IP 核超级灵活。 若只使用 Quartus II 的 Qsys 自带的定制的 Avalon 总线外设构建 SOPC 系统，不需了解 Avalon 总线，因为这些自带外设的接口都已经写好了 Avalon 总线，在图形化连接总线时，就是在把各个外设的从 Avalon 接口挂载到 Nios II 的主 Avalon 总线上；若采用用户定制外设构建 SOPC 系统，所开发外设必须符合 Avalon 总线规范，需要熟悉 Avalon 总线。下图为典型 Avalon 架构。下图最右面上下两个外设框分别为用户自定义主端口和用户自定义从端口。 Avalon 主端口发起对 Avalon 总线的传输，Avalon 从端口响应来自 Avalon 总线的传输。主从端口对即在某次数据传输过程中，通过 Avalon 总线连接起来的主端口和从端口。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:6:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"定制 外设 IP 核的框架 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:6:1","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"从端口传输 从端口信号类型 *p.s 其中前九个（标粗体的）最常用；不带 “_ n” 后缀的都是高电平有效；还有流水线信号、突发信号、三态信号和流控信号等，没有列出。* p.s 不带任何读写功能的、最基本信号：clk、reset_n、chipselect、address 四个，即下表中的前四个。 p.s address 地址的信号宽度最好都设置为 32 位宽，地址对齐的时候一一对应，最简便。 p.s Avalon 接口规范没有对 Avalon 外设的信号指定命名规则；Avalon 外设的信号的名字可以与信号类型名相同，也可以遵循 用户 / 系统级的命名规则。 p.s 下表只列基本信号，其它如流水线信号、突发信号、流控制信号、三态信号等不予列出。 信号类型 信号宽度 方向 功能和使用描述 clk 1 IN Avalon从端口的同步时钟，所有信号必须与clk同步，异步外设可以忽略clk信号。 reset_n 1 IN 从外设复位信号。该信号有效时，从外设进入确定的复位状态。 chipselect 1 IN Avalon从端口的片选信号。 address 1~32 IN Avalon从端口的地址线，指定了从外设地址空间的字的地址偏移，要访问外设寄存器的地址，从0x00开始。 read 1 IN 读从端口的请求信号。若使用了该信号，则必须使用readdata或data信号。 readdata 1~1024 OUT 读传输时，输出到Avalon总线的数据线。若使用了该信号，则data信号不能使用。 write 1 IN 写从端口的请求信号。若使用了该信号，必须使用writedata或data信号，writebyteenable信号不能使用。 writedata 1~1024 IN 写传输时，来自Avalon总线的数据线。若使用了该信号，data信号不能使用。 waitrequest 1 OUT 若从端口不能立即响应Avalon总线，用该信号来暂停Avalon总线。用于可变等待周期模式。 irq_n 1 OUT 从外设的中断请求信号。 byteenable 2,4,6,8,16,32,64,128 IN 按字节寻址访问使能信号。在对宽度大于8位的存储器进行写传输时，该信号用于选择特定的字节段。若使用了该信号，writedata信号必须使用，writebyteenable信号不能使用。 writebyteenable 2,4,6,8,16,32,64,128 IN 该信号是byteenable信号和write信号的逻辑与操作。write和byteenable信号不能使用。 Begin transfer 1 IN 在每次传输的第一个周期内有效，使用用法取决于具体外设。 32 位从端口的 byteenable 信号功能定义表如下。 byteenable[3..0] 写操作 1111 全 32 位写操作 0011 2 个低字节的写操作 1100 2 个高字节的写操作 0001 字节 0 的写操作 0010 字节 1 的写操作 0100 字节 2 的写操作 1000 字节 3 的写操作 IN （输入）类型的信号都是 Avalon 总线进行置位，从端口不能对其操作，从端口只能操作 OUT （输出）类型的信号。 主端口信号类型表略。 从端口传输模式列举 基本单周期读写时序传输。固定等待周期的读写传输。可变等待周期的读写传输（个人推荐常用）。（只对从端口有） 具有建立时间和保持时间的固定等待周期的读写传输（用于异步外设，了解）。（只对从端口有） 流水线读传输（带固定延迟和可变延迟）。 流控制时序传输。 三态时序传输。 突发时序传输。 下面分别列举时序图。可以看时序图直接上手编写逻辑，但提醒还是先多参考参考，熟悉广泛使用的成熟的编写架构和思路。 基本单周期读写传输 读时序： A 沿为主端口发起 读传输，E 沿 为主端口取走要读的数据；在 E 沿之前从端口的外设必须提前在 readdata 数据线上准备好数据。 基本读传输适用于异步从外设，只要外设被选中或地址发生变化，外设就立刻返回数据。readdata 须在下一个时钟上升沿之前保持稳定。 从端口通常在 clk 下降沿 检测 chipselect 和 read 两个信号同时为高时，就认为一次读传输。 写时序： A 沿为主端口发起 写传输，D 沿为主端口准备好要写的数据，在此沿从端口外设要取走数据。基本写传输适用于片内同步外设。 从端口通常在 clk 下降沿 检测 chipselect 和 write 两个信号同时为高时，就认为一次读传输。从端口可以在 D 沿取走数据。 基本写传输适用于片内同步外设。 固定等待周期的读写传输 读传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和/或返回有效 readdata，等待周期会影响从端口的吞吐量。 写传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和 writedata，等待周期会影响从端口的吞吐量。 用于同步外设访问，读传输等待周期是必须的，写传输非必须。 在 Qsys 中导入定制 IP 核时，可设要等待的固定周期，读和写时序的等待周期是一样的；可以在 clk 上升沿检测主端口的 读/写 传输。 读时序： 写时序： 固定等待周期写传输的一个例子： OLED 定制外设 IP 的部分源码，从端口的写传输实现，VHDL；第二个图是软件设置固定等待周期数，要与源码中的一致。 可变等待周期的读写传输（推荐） 读传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和/或返回有效readdata，等待周期会影响从端口的吞吐量。 写传输：等待周期允许从端口使用一个或多个时钟周期来捕获地址和writedata，等待周期会影响从端口的吞吐量。 可变等待周期采用 waitrequest 信号实现，看时序图就容易明白。从端口必须在第一个总线时钟周期内设置 waitrequest 有效，直到从端口处理好数据再置 waitrequest 信号无效，然后总线在下一个时钟上升沿捕获数据，结束本次传输。 读时序： 写时序： 可变等待周期写传输的一个例子： OLED 定制外设 IP 的部分源码，从端口的写传输实现，VHDL。 具有建立时间和保持时间读写传输 具有建立时间和保持时间的固定等待周期的读写传输，用于异步外设，了解。 具有建立时间和固定等待周期的从端口读传输，对于片外从端口异步外设，在主端口发出 read 有效信号之前，需要地址和 chipselect 等信号先稳定一段时间，然后将 read 信号置位有效，这样异步外设可以在 read 上升沿开始根据其他信号做出反应，而不会引起冒险竞争，因为在 read 上升沿时其他信号均已稳定。可以设置固定等待周期。即具有建立时间、固定等待周期的读传输（建立时间和可变等待周期不能同时采用）。下图中，上面的时序图，Tsu 即建立时间。 具有建立时间和保持时间的从端口写传输，对于片外从端口异步外设，在主端口发出 write 有效信号之前，需要 address、byteenable、writedata 和 chipselect 信号保持几个周期的稳定时间。即具有建立时间、固定等待周期、保持时间的写传输。下图中，下面的时序图，C 沿到 E 沿 之间的时间 即建立时间，E 沿到 F 沿 之间的时间 即保持时间。 端口读传输和写传输的建立时间必须相同。 对于一些 ram 等芯片的时序，设置的当可以把 Avalon 总线 直连 此类芯片的总线接口，即该从端口时序通常用于片外外设。 “建立时间、固定等待周期和保持时间” 属性在 Qsys 中设置；端口读传输和写传输的建立时间必须相同；建立时间和可变等待周期不能同时采用。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:6:2","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"主端口传输 主端口信号类型 p.s Avalon 主端口必须有三个信号：clk、address、waitrequest。 p.s 下表只列基本信号，其它如流水线信号、突发信号、流控制信号、三态信号等不予列出。 信号类型 信号宽度 方向 必需 功能及使用描述 clk 1 In Yes Avalon主端口的同步时钟， 所有的信号必须与clk同步。 waitrequest 1 In Yes 迫使主端口等待， 直到Avalon总线准备好处理传输。 address 1~32 Out Yes 从Avalon主端口到Avalon总线的地址线。 表示的是一个字节的地址， 主端口只发出字边界的地址。 read 1 Out No 主端口的读请求信号。 主端口不执行读传输时不需要该信号。 若使用了该信号，readdata或data信号线必须使用。 readdata 8,16,32,64,128,256,512,1024 In No 读传输时，来自Avalon总线的数据线。 当主端口不执行读传输时，不需要该信号。 若使用了该信号，read信号必须使用，data信号不能使用。 write 1 Out No 主端口的写请求信号，不执行写传输时不需要该信号。使用该信号，writedata或data信号必须使用。 writedata 8,16,32,64,128,256,512,1024 Out No 写传输时，到Avalon交换架构的数据线。当主端口不执行写传输时，不需要该信号。使用该信号，write信号必须使用，data信号不能使用。 byteenable 2,4,6,8,16,32,64,128 Out No 字节使能信号。在对宽度大于8位的存储器进行写传输时，该信号用于选择特定的字节段。读传输时，主端口必须置所有的byteenable信号线有效。 Irq 1,32 In No 中断请求信号。 如果Irq信号是一个32位的矢量信号，那么它的每一位直接对应一个从端口上的中断信号；如果Irq是一个单比特信号，那么它是所有从外设的Irq信号的逻辑或，中断优先级irqnumber信号确定。 irqnumber 6 In No 在irq信号为单比特信号时，使用irqnumber信号来确定外设的中断优先级。 Irqnumber的值越小，所代表的中断优先级越高。 reset 1 In No 全局复位信号。实现跟外设相关。 resetrequest 1 Out No 允许外设将整个Avalon系统复位。 主端口传输模式列举与参数说明 主端口传输模式列举： 单 / 可变等待周期 的读写传输。 流水线读传输（带可变延迟）。 流控制时序传输； 三态时序传输； 突发时序传输。 主端口的等待周期、建立时间、保持时间属性： 等待周期：主端口使用 waitrequest 信号接受 Avalon 总线的不确定等待周期。主端口被动地支持可变等待周期，不支持固定等待周期。 建立时间和保持时间：主端口不使用建立和保持时间属性。若一个目标从外设有建立 和/或 保持时间属性，Avalon 总线管理主从端口对的信号时序的转换。 主端口 单/可变周期 的读传输 主端口 单等待周期 的读传输 主端口在 clk 上升沿后紧接着 设置目标外设地址 address 和 置 read 有效，等待 waitrequst 信号失效 便可从 readdata 取数据。 主端口 可变等待周期 的读传输 主端口 单/可变周期 的写传输 主端口 单等待周期 的写传输 主端口 可变等待周期 的写传输 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:6:3","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"其它 Avalon 传输模式 这里略。 流水线读传输。 流控制时序传输； 三态时序传输； 突发时序传输。 中断与复位，地址对齐等内容。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:6:4","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"2 模块收集（不定期更新） p.s 以下为列举日常项目中用到的可以开源的部分模块源码（Verilog or VHDL）或者实现思想（就是留个坑，但还没写）。 Github 上有哪些优秀的 Verilog/FPGA 项目？ 有很多好的推荐项目和回答！ WangXuan95 (WangXuan95) / Repositories (github.com) 开源了许多 Verilog IP。 Alex Forencich 的 GitHub 主页 开源了许多 Verilog IP，Verilog IP cores - Alex Forencich。 FreeCores (github.com) A home for open source hardware cores。 pConst / basic_verilog 的常用代码。 文件位置：./pConst 的 basic_verilog-master.zip Analog Devices, Inc。 OpenCores。在这个网站上可以看到各种经过工程师验证过的内核，比如8051、OpenRisc、AVR、MIPS32等。 李锐博恩 Verilog编程实例。 NingHeChuan 的 ip_lib ——构建自己的IP库，搭建起你的数字积木。 文件位置：./FPGA学习和规范 的参考源码/NingHeChuan 的 ip_lib/ 类MCU的时间片轮询实现，晶振时钟通过PLL IP得到准确时钟，每个PLL有五个输出，分别分频得到运行周期为 10MHz、5MHz、1MHz、1KHz、100Hz的程序的入口，把不同功能的程序直接放在想要按照某个周期运行的程序入口即可。这个直接写到模板的Top文件即可，不用作为一个模块。 根据寄存器或者外部引脚的电平组合等信息，可以在运行时任设或者有限改动FPGA内部逻辑的输出引脚，就像STM32的外设引脚切换或者K10的FPIOA一样允许用户将255个内部功能映射到芯片外围的48个自由IO上。 按键消抖 思想：当“按键可以检测标志位”有效时，按下的边沿触发启动一计数器，同时标记“按键可以检测标志位”失效，当计数器计数到一定值后，再检测按键是否处于按下状态，如果是则标记“按键有效”标志位做输出，如果不是则停止计数，同时标记“按键可以检测标志位”有效，同时清空计数值。 sopc 读取外部按键设计思路，引脚输入后先在FPGA的逻辑上先实现一个去抖，然后把无毛刺的稳定的信号传给 nios ii 输入脚，然后 nios ii 里面实现一个外部引脚沿中断。 文件位置：./FPGA学习和规范 的参考源码/按键消抖/ 特定序列检测与发送 思想：用 case 语句实现简单的一段状态机即可。 PWM信号产生 思想：占空比值与一个向上计数器计数值比较，当占空比值比计数值大时输出高电平，小时输出低电平。 参考“小梅哥 AC620V2开发板配套资料”的无源蜂鸣器章节和例程。 I2C模块 小梅哥 FPGA进阶 第十六章 IIC协议详解+UART串口读写EEPROM SPI模块 择时更新，交流可催更 UART模块 看《FPGA设计-实战演练（逻辑篇）》 吴厚航 的随书源码。（@TODO 不过这个程序的最外层还不够明朗，需要再整理简化使用） 状态机 注意点： 关键是画好状态图； 状态完备； 组合逻辑条件完备； 不能进入死循环； 不能进入非预知状态。 需要穷举所有状态对应的输出动作，或者使用 default 来定义未定义状态动作。 推荐都使用三段式状态机。 参考： 文件位置：./FPGA学习和规范 的参考源码/fsm/ 三种状态机 基于FPGA的有限状态机浅析 三段式状态机 万物基于状态机——状态机大法好 三段式状态机 【BUG记录】三段式状态机编写问题及三段式状态机各部分功能分析 … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:7:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"2.5 数字电路设计实用技术 《硬件架构的艺术：数字电路的设计方法与技术》，该书的译者序：“…实用且有效…作者系统打造出一栋由实用技术组成的大厦……一切从解决问题出发，解释怎么做，并给出原理图和代码，以及解决方案……本书主要内容涉及时钟和复位、多时钟域设计、时钟分频器、低功耗设计技术、流水线技术、字写顺序、消抖技术和电磁兼容性等内容”。该书针对以上方面给出了很多设计策略和实用方法，或者说对很多模块的设计给出了推荐的 HDL 和电路，适合当作工具书手办阅读。该书罗列了很多应该避免的有隐患的（甚至仿真的时候不容易发现而实际运行时候容易出问题的种种情况）综合后的数字逻辑电路，并由此给出了很多应该避免的 HDL 写法，以及查看综合后电路是否有已知的隐患；并也给出了推荐的数字电路形式。该书在网上容易下载到电子版。 ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:8:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["【规范】系列"],"content":"3 参考 p.s 本文一部分来自自己总结的经验，一部分来自参考。参考不是照搬，是选择我认为的精髓，每个人不同，所以推荐看一下这些参考，TA们都提供了很好的技巧。当然也许还有很多更好的资料，可以留言推荐。 p.s 正文中某些段落内容的旁边已经加注了参考和引用源，这里列出剩下的引用源。 《FPGA设计-实战演练（逻辑篇）》 吴厚航 在“资源下载”栏可下载随书课件和源码。 知乎 硅农。 Verilog设计的原则和技巧和IP核的使用。 《基于FPGA的嵌入式开发与应用（徐光辉 程东旭 等编著）》。 还可以参考但还没看的： 《FPGA设计-实战演练（高级技巧篇）》王敏志。 … … ","date":"2021-02-15","objectID":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/:9:0","tags":["规范","FPGA"],"title":"【规范】HDL \u0026 FPGA 学习、规范和技巧","uri":"/fpga%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E8%8C%83/"},{"categories":["人与世人的关系"],"content":"记录导师的话","date":"2020-12-21","objectID":"/5%E5%B8%88%E4%B9%8B%E4%BC%A0%E8%BE%BE/","tags":["杂谈"],"title":"【杂谈】师之传达","uri":"/5%E5%B8%88%E4%B9%8B%E4%BC%A0%E8%BE%BE/"},{"categories":["人与世人的关系"],"content":"记录导师、老师话语。本文非原话，是把日常聊天和开会听到的话的意思记录下。不只是用于科研，放之很多地方都有道理。（始于 2020.12） 可靠性，靠的是这1、2、3、4、5具体的点，来支持的，才有人信。通过广泛查阅和思索。 严格的可靠性，包含执行一步后，检查反馈这一步确实动作后，再执行下一步。 原型机先在软硬件上留一定的灵活性，预先多考虑、多设计。硬件原理图模块，软件模块，以后直接用起。 关于学术分工听到的：本科生学中做；研究生做中学（围绕做的事补不会的）；博士生探和学；研究生做不成熟的，做新的东西，成熟的交给企业；研究所、研究院专精标准、产品和工程。提个醒：多想才能少做优做（寻找规律，整理思绪，做好规划）；做难的事，多交流（表达和做事）。 本科、硕士，培养的目的，是面对问题，有一套解决问题的思路，解决问题的能力，通过不断做事，能力内化成自己的。工具的专业使用应当是专科生等专门来做。 研究生复试面试，若老师们问“你会什么啊”、“干过什么啊”、“做成了什么设计”等诸如此类问题，并不是你干的事有多重要、你对工具有多熟练，其实是问你，对学习的态度，对自己做的事的把握，有多少考虑，有多认真的对待，有多有效的学习（这是芸芸人群中，难能可贵的）。 说看几本书、一些论文和文献，就开始开题，写proposal等，大概率比较浅，如若要做的像模像样，应是找一些在业内年数多、经验多的老师，从业多年的业内人士等聊聊，问一问遇到了什么问题等，从而在开展自己的事情时，提出的问题深刻一些；然后深刻的问题说准啦，方法原理说清啦，验证时的具体现象抓到啦，就比较好。 “硕士阶段，知识是老师教出来的吗？这不现实，自己看专业知识资料，你能看的比老师还明白，老师做/指导大方向、前进路线、科研基础技能、做事的规范、组织专家做研讨会和合作等”；“避免作坊式的做事，包括软硬件，先打基础，学规范”。 自动生成报表，自动测试。可以自己写一些自动化工具软件替代重复性工作，多做通用性工作。 莫把途径当目的。 硕士出去第一份工作要当读博士来找，想着提升自己，三五年后，要让这个企业离不开你，这个行业离不开你，而不是让企业养着你。三五年后人就基本定型了，得不到锻炼的工作就荒废了自己的专业和能力，对未来风险很大。 研究生培养出去是要带团队的，除了底层、细节处理要锻炼好，除了有良好的团队合作、独立科研等的能力，更重要的是培养设计能力，顶层设计能力，上层的搭建和故事要理清、讲好，细节可以让下边来干。 讨论问题时候可以不分上下级来群策群力，但是在一个有限的特定情景和空间里，需要有人拍板、指挥调度的时候，就要有所划分，需要明确听谁的之类的问题。 … （最后编辑 2021-12-11） ","date":"2020-12-21","objectID":"/5%E5%B8%88%E4%B9%8B%E4%BC%A0%E8%BE%BE/:0:0","tags":["杂谈"],"title":"【杂谈】师之传达","uri":"/5%E5%B8%88%E4%B9%8B%E4%BC%A0%E8%BE%BE/"},{"categories":["【主线剧情】Linux 系列"],"content":"对收集到的比较丰富的 Linux 学习相关的资料进行整理","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 学习资源大综合 对收集到的比较丰富的 Linux 学习相关的资料进行整理。注，如果链接挂了请告诉我，如果链接里的内容被删了那么直接搜文章名字试试也许会搜出来很多转载的 “备份”。 注：在 Github 上的原版文章日后可能会更新，在其它位置发的不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:0:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"O 目录 [TOC] ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:1:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"1 尝鲜 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:2:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"前置基础 C语言基础（可选的 数据结构与算法）。相关文章： C语言基础 【规范】C \u0026 MCU 编写规范和技巧，CSDN。 数据结构与算法 （大集合）数据结构与算法简述和CS综合，CSDN。 单片机使用和理解的经验（对数模电、计算机结构 / 原理 / 总线 和 网络通讯 等 有认识）。（可选的）接触过 单片机平台的 小型实时操作系统（如 FreeRTOS、RTT、ucos 等）。相关文章： 模电里的运放分析 【手撕运放】运放的“第一原理”式定量分析法 - 知乎 (zhihu.com)，CSDN。 嵌入式方向学习的基本路线 【目录贴】软硬件规范化 - 知乎 (zhihu.com)，CSDN。 单片机如何学习 超快 STM32 系统入门指南 - 知乎 (zhihu.com)，CSDN。 对 ARM Cortex-A 系列处理器的概念了解 【主线剧情 番外01】ARM \u0026 SOC 系列快速鸟瞰 - 知乎 (zhihu.com)。 （选看）ARM Cortex-A 系列处理器的 裸机编程 【主线剧情01】ARM IMX6ULL 基础学习记录，【主线剧情01】ARM \u0026 i.MX6ULL 基础学习记录 - 知乎 (zhihu.com)，CSDN，Gitee仓库。 Linux 系统的概念、使用，常用命令、Vim、GCC、Make、包管理等，基本的 编译工具链获取，应用、内核等的编译的概念。相关文章： 【主线剧情02】ARM Linux 基础学习记录，【主线剧情02】ARM \u0026 Linux 基础学习记录 - 知乎 (zhihu.com)，CSDN，Gitee仓库。 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:2:1","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"计算机组成原理 计算机组成原理 - 知乎 (zhihu.com)。 一文搞懂CPU的工作原理 - 知乎 (zhihu.com)。 一文搞懂cpu cache工作原理 - 知乎 (zhihu.com)。 一文搞懂Cortex-A77（ARMv8架构）工作原理 - 知乎 (zhihu.com)。 一文搞懂GICv3中断控制器的工作原理 - 知乎 (zhihu.com)。 ARM的Cortex-M3和M4里的main stack和process stack是个什么概念？ - 知乎 (zhihu.com) 详解了 M3 内核 的异常处理过程。 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:2:2","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"路线的内容 总的来说（按顺序） 前置基础打牢（参考 前面的 “前置基础” 一节）。 Linux 应用编程（文件IO、内存管理、多任务编程（进程和线程）、网络编程 和 图形界面QT 等）。细节内容见 “Linux 应用编程内容补充” 一节。 Linux 驱动编程（字符设备、块设备、网络设备、总线设备 等）。细节内容见 “Linux 驱动编程内容补充” 一节。 深入层面 内核研读。 音频，视频子系统。 Linux 移植（uboot + kernel + rootfs 的 配置和编译 等）。比较深而且由于工作的细分工可能用的不多。 等等。 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:2:3","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"2 网络资料收集整理 图片都有水印，侵删。 路线相关 0、 韦东山：6000字长文告诉你如何学习linux (qq.com)。 Linux系统编程和网络编程的参考书籍 (0xffffff.org)。 1、清华远见教程的路线图。 2、一张网图（侵删）。 3、一张超大图，非常丰富的内容罗列：嵌入式：我不是针对谁，我是说在座的Javaer都是弟弟，尤其程序羊 (qq.com)，原图在 Github 仓库里 rd2coding/Road2Coding: 编程之路 (github.com)。 下面是概略截图，高清原图看上面的链接。 4、一些介绍 学习路线 的 杂网文。 ARM+LINUX嵌入式学习路线 (qq.com)。 学技术不难，重要的是怎么规划，给嵌入式开发的你一个目标 (qq.com)。 17000字嵌入式系统基础知识总结，太全啦！ - 知乎 (zhihu.com)。 成为一名嵌入式高手，必备的技能清单和升级线路图_Linux (sohu.com)。 嵌入式Linux+Android学习路线图 (qq.com)。 正点原子左忠凯的Linux学习之路_ 哔哩哔哩 _bilibili。 !学习来源! 下面仅为个人见到的选择的推荐，欢迎补充！ 最推荐的就是 “入手开发板，跟着教程学” 的方式即可~ 韦东山 的 系列教程，靠谱而较全面，跟着走就成。 Linux 学习 B 站视频。 百问网 资源下载站。推荐 跟着这个开发板学 🎫100ASK_IMX6ULL_PRO开发板。 百问网论坛。 正点原子/野火 的 Linux 系列教程，靠谱而较全面，跟着走就成。 正点原子 Linux 学习 B 站视频，正点原子 资源下载站，论坛。 野火 Linux 学习 B站视频，野火 资源下载站，论坛。 买书（驱动和应用），参考 下面 “书籍推荐” 一节。 其它 嵌入式 Linux 开发板 和 资料 的提供商，他们都提供了开发板配套的较完整的 SDK 和 硬件方案，对于开发的参考价值极大。 百问网 Linux 板 产品页 \u0026 米尔 Linux 板 产品页。 Firefly | 让科技更简单，让生活更智能 (t-firefly.com)。 Orange Pi PC - 香橙派。 看官方 doc：怎样成为一名优秀的Linux驱动设备工程师？ - 知乎 (zhihu.com)。 Linux内核文档：The Linux Kernel documentation — The Linux Kernel documentation。 Linux设备驱动程序开发指南：Driver implementer’s API guide — The Linux Kernel documentation。 Linux内核api：Core API Documentation — The Linux Kernel documentation。 非官方的推荐\u003cLinux 内核模块编程指南\u003e：The Linux Kernel Module Programming Guide (sysprog21.github.io)。 就这些，我不会列成吨的资料骑脸。。 书籍推荐 注，书一般都是大厚书，要 入门学习 推荐参考上面 “！！！学习来源！！！” 一节里的，看书一般是 复习知识、查漏补缺 和 用时现查 用的。 1、网络推荐 2、引自 coding-style-and-more: C 编写规范和其他。CC-BY-NC-SA 4.0。 (gitee.com)。这些又都是典型的大厚书。 引自网络，侵删。 算法和数据结构：数组、链表、二叉树、堆栈、排序算法、B+/B-树、DP（动态规划）等； 操作系统：IO、存储器、多线程/多进程、同步机制、处理器调度及死锁、设备管理、通道等； 计算机组成原理：冯诺依曼计算机组成、计算机层次结构、计算机性能指标等； 网络底层：HTTP、HTTPS、DNS、ARP、TCP、IP、ICMP、UDP、FTP、SMTP、的实现底层； 多进程/多线程编程：进程通信的方式（共享内存、pipe、Socket编程等）、同步、死锁及解决方案、线程池的实现、进程/线程的操作系统实现原理、进程的状态及切换和调度等。 《嵌入式C语言的自我修养》 从沙子讲到CPU，从编辑器讲到编译器，从高阶C语言讲到内存管理，从GNU讲到多任务编程。 《计算机体系结构》（经典），《计算机操作系统》/《现代操作系统》/《深入理解计算机系统》。 《编码的奥秘》，相关介绍/推荐 想练习《编码的奥秘》里面的知识，有什么软件有帮助？ - 知乎 (zhihu.com)。《编译原理》（经典），《深入分析GCC》。 网络协议如《计算机网络》、《TCP-IP详解卷一/卷二/卷三》，想深入了解 HTTP 协议，有哪些值得推荐的书籍？ - 知乎 (zhihu.com)。 嵌入式应用相关：《GNU Make》，《Debugging with GDB》，《Linux 高级程序开发》，《POSIX 多线程程序设计》，《嵌入式Linux基础教程》，《嵌入式Linxu应用开发完全手册》，《嵌入式Linxu应用程序开发详解》。 嵌入式底层相关：内核相关：《深入理解Linux内核》，《Linux内核源代码情景分析》，《Linux内核设计与实现》；驱动相关：《Linux设备驱动程序》，《Linux设备驱动开发详解》，《Linux驱动开发入门与实践》。 3、Linux 驱动开发相关书籍 linux内核和驱动开发，有什么经典的书籍推荐吗？ - 知乎 (zhihu.com)。 想成为 Linux 驱动工程师，需要读些什么书？ - 知乎 (zhihu.com) 嵌入式软件开发必看书籍推荐（C/C++/linux/软件） - 知乎 (zhihu.com)。 大家都一下推荐成吨的书，这么多书中，总得选一两个，个人觉得目前有口碑、属经典、比较常见的是这两个：经典的 LDD《Linux Device Drivers》和 有国内有口碑的 《Linux设备驱动开发详解-宋宝华》。 面经相关 部分引自 coding-style-and-more: C 编写规范和其他。CC-BY-NC-SA 4.0。 (gitee.com)。 嵌入式相关 EmbeddedSoftwareEngineerInterview：ZhongYi-LinuxDriverDev/EmbeddedSoftwareEngineerInterview: 嵌入式软件工程师笔试面试指南，主要收录笔试面试八股文。包括C/C++，计算机基础，操作系统，Linux驱动，Arm体系与架构，网络编程，大厂笔试面试题等。持续更新中~~有问题可以加我微信，LinuxDriverDev (github.com)。 embedded-notes：xiaowenxia/embedded-notes: 嵌入式linux软件开发、嵌入式linux驱动开发、c语言、单片机开发、IOT开发等面试要点记录 (github.com)。 一些文章 从事嵌入式行业的你，现在年薪多少，有什么经历想和大家分享？ - 知乎 (zhihu.com)。 嵌入式面试题，不断更新 - 知乎 (zhihu.com)。 嵌入式软件工程师笔试面试指南 - 知乎 (zhihu.com)。 2020年嵌入式软件秋招的一点经验和对嵌入式软件未来的一点思考 - 知乎 (zhihu.com)。 算法相关 hello-algorithm 基础、刷题、面经和汇总 geekxh/hello-algorithm: 🌍 针对小白的算法训练 | 包括四部分：①.算法基础 ②.力扣图解 ③.大厂面经 ④.CS_汇总 | 附：1、千本开源电子书 2、百张技术思维导图（项目花了上百小时，希望可以点 star 支持，🌹感谢~） (github.com)。网站版 小浩算法 (geekxh.com)。 CS-Notes 算法和刷题、操作系统、网络、数据库、系统设计等 CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计 (github.com)。网站版 CS-Notes (cyc2018.xyz)。 LeetCode C++ 题解：soulmachine/leetcode: LeetCode题解，151道题完整版 (github.com)。 内核研读 一些基础概念 Linux内核的五大模块_~青萍之末~的博客-CSDN博客_linux内核模块，进程调度，进程间通信模块（包括管道、命名管道、消息队列、信号量和共享内存等），内存管理模块，文件系统模块，网络接口模块。Linux内核四大核心框架 - 知乎 (zhihu.com)。 Linux系统相关的基础问题（空间、内存、库、链接、环境变量）_~青萍之末~的博客-CSDN博客。Linux系统调用_~青萍之末~的博客-CSDN博客_linux系统调用。 Linux调度系统全景指南(终结篇) (qq.com)。 Linux与SoC - 知乎 (zhihu.com)。 《Linux内核设计与实现》读书笔记 - 目录 （完结） - wang_yb - 博客园 (cnblogs.com)。《Linux内核设计与实现》读书笔记 - 知乎 (zhihu.com)。 深入研读 linux_kernel_wiki：Linux 内核知识体系与面试题 0voice/linux_kernel_wiki: linux内核学习资料：200+经典内核文章，100+内核论文，50+内核项目，500+内核面试题，80+内核视频 (github.com)。 l","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:3:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 应用编程内容补充 基本： 韦东山、正点原子、野火 等 的 Linux 学习文档。 综合： 百问网-优秀学员-嵌入式开发学习笔记汇总。 Linux C编程一站式学习 (akaedu.github.io)。 亚嵌教育 (akaedu.github.io)。 I/O编程： Linux应用开发_Top嵌入式的博客-CSDN博客。 深入理解 Linux I/O 系统 (qq.com)。 misc： 清华远见-嵌入式Linux应用程序开发详解。 Linux系统编程_ 中文版 _ by _哈工大。 POSIX多线程程序设计。 宅学部落的个人空间_哔哩哔哩_bilibili。 下面引自 《主线剧情08-Linux应用编程-学习总结备查》： 这里就是日常用到的 API 的积累和整理，最详细、全面的 API 参考 见 上面 通过手册的 API 详细描述参考 一节。 日常用到的 标准 API 富集 单独放在了 【Linux 通用应用开发】 （仓库地址 Github、Gitee）文件夹 里面，包括： 文件 IO、字符流收发 和 字符串处理相关的 API 收集积累。 一些 Shell 命令 API 收集积累。 输入设备框架，读取驱动程序按照 input event 框架上传的信息。 文件 IO 读写的基本四种机制（阻塞、非阻塞、poll/select 和 异步通知（通过信号机制））。 Socket TCP / UDP 编程。 进程 和 线程 的设计和编程。包括 进程和线程的分配策略、进程和线程的 API 用法 等： 进程 相关 API（fork()、exec、wait() 等等）。 进程间通讯（管道、命名管道、信号、信号量、消息队列、共享内存、内存映射 和 套接字）。 pthread 线程编程库 相关 POSIX API（pthread_create()、（后面省略 “pthread_”）exit / cancel 和 join / tryjoin_np、self()、attr_setxxx() / attr_getxxx()、）。 线程间通讯、同步的机制（锁机制（互斥锁、读写锁 和 自旋锁）、信号量机制、条件变量机制 和 信号（与 IPC 的信号使用上有区别））。 串口收发编程、I2C编程。 实质上就是对各种设备驱动文件 进行 open/read/write/ioctl/close 来配置和读写，有一些标准接口有标准的信息结构，因此有专门的 库，通过这些库来间接的 配置 和 读写设备驱动文件，比如 tslib、i2ctool 等等。 等等其它，用时补充。比如 进程高级编程、内存管理、Linux 高并发编程 epoll 等等。 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:4:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 驱动编程内容补充 基本： 韦东山、正点原子、野火 等 的 Linux 学习文档。 韦东山-嵌入式Linux驱动难？到底难在哪？ - 百问网嵌入式问答社区 (100ask.net)。 【第5篇】嵌入式Linux驱动开发基础知识_ 哔哩哔哩 _bilibili 新视频。 韦东山嵌入式Linux驱动入门_ 字符设备驱动详解_ 哔哩哔哩_bilibili 老视频。 前面 “书籍推荐” 一节 里面的推荐。 宅学部落的个人空间_哔哩哔哩_bilibili。 备查： Linux内核API|极客笔记 (deepinout.com) 比较全-备查。 综合例子： Linux设备模型_导航篇 - 知乎 (zhihu.com)。我的Linux设备驱动修炼之路V1 - 知乎 (zhihu.com)。 linux驱动编程_wangdapao12138的博客-CSDN博客。 #Linux 驱动 (qq.com)。 gatieme/LDD-LinuxDeviceDrivers: Linux内核与设备驱动程序学习笔记 (github.com)。 Linux各子系统： linux进程管理 - 知乎 (zhihu.com)。 linux内存管理 - 知乎 (zhihu.com)。 linux功耗管理 - 知乎 (zhihu.com)。 Linux驱动具体是指什么？引自 Linux驱动具体是指什么？ (qq.com)。 驱动的具体分类？ 1、驱动分类 (1)分3类：字符设备驱动、块设备驱动、网络设备驱动 (2)分类原则：设备本身读写操作的特征差异 时刻要注意一点，我们的驱动本质上是不分类的，因为我们的硬件是不同的，有不同的读写特性，所以的硬件是分类的，所以我们的驱动也就要跟着分类了。 2、三类驱动程序详细对比分析 (1)字符设备，准确的说应该叫“字节设备”，软件操作设备时是以字节为单位进行的。典型的如LCD、串口、LED、蜂鸣器、触摸屏······ (2)块设备，块设备是相对于字符设备定义的，块设备被软件操作时是以块（多个字节构成的一个单位）为单位的。设备的块大小是设备本身设计时定义好的，软件是不能去更 改的，不同设备的块大小可以不一样。常见的块设备都是存储类设备，如：硬盘、NandFlash、iNand、SD····操作块设备时，我们必须以块单位进行操作，将一块的 数据读取到内存中去，然后在内存中找到相应的那个字节数据修改之后再以一块的数据写入到我们的块设备中去。 (3)网络设备，网络设备是专为网卡设计的驱动模型，linux中网络设备驱动主要目的是为了支持API中socket相关的那些函数工作。 驱动的设计思想？ 1: 分离、分层思想 2: 驱动的上面是系统调用API 3: 驱动的下面是硬件 4: 驱动本身的实现也是基于分离、分层的思想 驱动和内核的关系？ 驱动已经成为内核中最庞大的组成部分 内核会直接以函数调用的方式调用驱动代码 驱动的动态安装和卸载都会“更改”内核 驱动程序崩溃甚至会导致内核崩溃 驱动的效率会影响内核的整体效率 驱动的漏洞会造成内核安全漏洞 下面摘自网络，侵删。 　1. 学会写简单的makefile 2. 编一应用程序，可以用makefile跑起来 3. 学会写驱动的makefile 4. 写一简单char驱动，makefile编译通过，可以insmod, lsmod, rmmod. 在驱动的init函数里打印hello world, insmod后应该能够通过dmesg看到输出。 5. 写一完整驱动， 加上read, write, ioctl, polling等各种函数的驱动实现。 在ioctl里完成从用户空间向内核空间传递结构体的实现。 6. 写一block驱动， 加上read,write,ioctl,poll等各种函数实现。 7. 简单学习下内存管理， 这个是最难的，明白各种memory alloc的函数实现细节。这是linux开发的基本功。 8. 学习锁机制的应用，这个不是最难的但是最容易犯错的，涉及到很多同步和并发的问题。 9. 看内核中实际应用的驱动代码。 你会发现最基本的你已经知道了， 大的框架都是一样的， 无非是read, write, ioctl等函数的实现， 但里面包含了很多很多细小的实现细节是之前不知道的。 这时候就要考虑到很多别的问题而不仅仅是基本功能的实现。 推荐您看2.6.20中integrated的一个驱动 kvm， 记得是在driver/lguest下，很好玩的， 就是linux下的虚拟机驱动， 代码不长，但功能强大。有能力的可以自己写一操作系统按照要求做成磁盘镜像加载到虚拟机中， 然后客户机可以有自己的4G虚拟地址空间。 10. 看完驱动欢迎您进入Linux kernel学习中来。 最简单的方法，跟着ldd(linux devive driver)做一遍。 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:5:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["【主线剧情】Linux 系列"],"content":"全栈之路 p.s 只是总结着玩的 自动控制原理\u0026信号与系统\u0026英语。 电路、数模电基础。 各类电路拓扑，各类电源、各类电机、各类接口、各类保护。 原理图\u0026PCB绘制\u0026绘制规范和技巧。 高速信号\u0026信号完整性\u0026电源完整性\u0026EMC\u0026射频天线。 C/C++语言基础\u0026编程规范\u0026开发模式。 MCU编程（各类外设，通讯接口，总线，USB）。 RTOS编程\u0026LWIP网络编程。 数据结构与算法（堆、栈、链、树、图；串匹配、排序、搜索、动态规划.etc）。 计算机体系结构，计算机操作系统，计算机网络，编译原理。 Vim、GCC、Make、Git、APT。 uboot、kernel、rootfs 的 编辑配置、移植、编译 和 源码研读。 Linux驱动（字符设备、块设备、网络设备、总线设备 等）。 Linux应用（文件IO、内存管理、多任务编程、网络编程 和 图形界面QT 等）。 音频应用，视频应用，摄像头，总线开发（每一块都是专家）。 机器学习，深度学习。 上位机。 前端/后端。 安全。 p.s 术业有专攻 ","date":"2022-03-24","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/:6:0","tags":["ARM","Linux"],"title":"【主线剧情0.0】Linux 学习资源大综合","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%850.0-linux%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E7%BB%BC%E5%90%88/"},{"categories":["随机技术情报"],"content":"PCIe接口及其衍生接口大总结","date":"2021-05-24","objectID":"/6pcie%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E6%8E%A5%E5%8F%A3%E5%A4%A7%E6%80%BB%E7%BB%93/","tags":["硬件","PCIe"],"title":"PCIe接口及其衍生接口大总结","uri":"/6pcie%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E6%8E%A5%E5%8F%A3%E5%A4%A7%E6%80%BB%E7%BB%93/"},{"categories":["随机技术情报"],"content":"注，相关的介绍网上有很多，这里是一个总结文（用时再查），不是科普文。 参考： 搜索标准接口定义的网站：https://pinouts.ru/。 一个视频讲的很精彩【硬件科普】硬盘的SATA M.2 NGFF NVME是什么意思，详解硬盘的总线协议与接口_哔哩哔哩_bilibili，推荐从13：13看起。 SATA M.2 NGFF PCIE AHCI NVME SSD固态硬盘的接口、总线和协议区分_Mark_md的博客-CSDN博客。 开局一张鸟瞰图（水印表示出处） PCIe 引脚定义 PCI Express 1x, 4x, 8x, 16x bus pinout diagram @ pinouts.ru。 SATA 引脚定义 SATA pinout diagram @ pinoutguide.com。 mSATA 引脚定义 Mini-SATA (mSATA) connector pinout diagram @ pinoutguide.com。 M.2（NGFF）引脚定义 M.2 (NGFF) connector pinout diagram @ pinoutguide.com。 传统艺能，一言（图）以蔽之。 别看此文字少，这一张图我做了半天，可以点击查看原图（2.9MB）看清细节。引用材料均非商业用途，侵删。 ","date":"2021-05-24","objectID":"/6pcie%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E6%8E%A5%E5%8F%A3%E5%A4%A7%E6%80%BB%E7%BB%93/:0:0","tags":["硬件","PCIe"],"title":"PCIe接口及其衍生接口大总结","uri":"/6pcie%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E6%8E%A5%E5%8F%A3%E5%A4%A7%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"记 Linux 应用 相关的基本概念和流程，便于 备查 / 复习","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 应用编程- 学习总结备查 记 Linux 应用 相关的基本概念和流程，便于 备查 / 复习。p.s Linux 系统性的入门与学习的 路线和途径 推荐去看 【主线剧情 0.0】Linux 学习资源大综合 - 知乎 (zhihu.com)（CSDN 链接） 里面的 !学习来源! 、 书籍推荐 和 Linux 应用编程内容补充这几节！。 注：在 Github 上的原版文章日后可能会更新，但这里不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 地基 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:0:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"① Linux 开发 基本工具的使用 代码编辑：Vim、gedit（ubuntu 下）。编译工具：gcc，make，cmake（生成 makefile），gdb。项目管理：git。文本编辑：Windows 端的如 source insight、Notepad、VsCode 等；Linux 端的如 gedit（Ubuntu 端）、VsCode 等。 引 主线剧情02-ARM-Linux基础学习记录_Real-Staok的博客-CSDN博客 里面的 Linux 下的开发 一节的内容。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:1:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"② 编译 / 交叉编译 工具的获取 引 主线剧情02-ARM-Linux基础学习记录_Real-Staok的博客-CSDN博客 里面的 获取交叉编译工具链 一节的内容。其中 举出三个方法：用开发板厂家提供的 SDK 里的工具链、ARM 官网下载 合适的工具链、使用 Linaro GCC 编译器。 另外，在构建 rootfs 时候使用 buildroot 或 yocto 时候可以构建 交叉编译器。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:2:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"③ Linux 系统调用（各层调用关系） Linux系统相关的基础问题（空间、内存、库、链接、环境变量）_~青萍之末~的博客-CSDN博客。 Linux系统调用_~青萍之末~的博客-CSDN博客_linux系统调用。【第4篇】嵌入式Linux应用开发基础知识_哔哩哔哩_bilibili，其中 4-2_ 文件IO _系统接口 这一个节讲解 系统调用怎么进入内核。 Linux内核的五大模块_~青萍之末~的博客-CSDN博客_linux内核模块，进程调度，进程间通信模块（包括管道、命名管道、消息队列、信号量和共享内存等），内存管理模块，文件系统模块，网络接口模块。 etc. ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:3:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"④ Linux 一般开发流程 引 主线剧情02-ARM-Linux基础学习记录_Real-Staok的博客-CSDN博客 里面的 Linux 一般开发步骤 一节的内容： Bootloader、Linux 内核、根文件系统、APP 等等软件，需要在 Ubuntu 中编译；但是阅读、修改这些源码时，在 Windows 下会比较方便。 所以工作日常开发流程如下： PC 端，使用 source insight 编、改源码 —\u003e传—\u003e Ubuntu 端，对修改好的源码进行编译、制作 —\u003e下载—\u003e 嵌入式板端，在 Linux 板子上运行、测试。 分步来说就是： 在 Windows 上阅读、研究、修改，修改后，上传（推荐 FileZilla）到 Ubuntu ； 在 Ubuntu 上编译、制作（推荐使用 MobaXterm 通过 SSH 远程登陆 Ubuntu）； 把制作好的可执行程序下载到开发板上运行、测试。 u-boot、Linux内核，在 Windows 和 Ubuntu 各存一份。根文件系统使用 buildroot （或 Busybox 或 Yocto）制作，它无需放在 Windows 上。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"⑤ 主机端 与 嵌入式 Linux 板端 相互传文件 引 [主线剧情02-ARM-Linux基础学习记录_Real-Staok的博客-CSDN博客]((40条消息) 主线剧情02-ARM-Linux基础学习记录_Real-Staok的博客-CSDN博客) 里面的 PC 与 嵌入式板 传输文件的方式汇总 一节的内容。这一块内容会只在 Github/Gitee 仓库内更新： 网络传输：ETH / WiFi。通过 SSH、NFS、TFTP 等。 USB 传输：U 盘拷贝，芯片官方 配套的 USB 传输 / 烧写 工具。 串口传输：rz / sz 命令。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"⑥ 期待美好发生 这儿的能力是靠 多做项目、多积累经验，量变出质变。 开发 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"参考源 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"通过手册的 查看 API 详细描述参考 引 【规范】万字集大成的C编写规范_Real-Staok的博客-CSDN博客 中的 7 C 标准库的使用 一节内容，即 各种C标准库详解和用例，其中包括了 C/C++ 的常用标准库 的 API 使用的详细描述，还包括 Linux_C（glibc_man_cn）、POSIX-C 等的 API 的完整描述文档（包括中文），便于速查，其 仓库在 额外文档/各种C标准库详解和用例 · 瞰百/coding-style-and-more - 码云 - 开源中国 (gitee.com)（Gituhb 仓库地址）。 其中包括文件如：C语言标准函数库速查.pdf、C语言函数大全语法着色版.pdf、Linux函数大全.chm、POSIX-C函数速查.chm 等等。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:1","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"通过命令行的 查看命令、API 描述参考 help、man 和 info 命令。 help 只能用于查看某个命令的用法。 man 命令既可以查看命令的用法，还可以查看函数的详细介绍等等。 （引自 百问网） 比如想查看 open() 函数的用法时，可以直接执行 man open ，发现这不是想要内容时再执行 man 2 open。 在 man 命令中可以及时按“h”查看帮助信息了解快捷键。常用的快捷键是： f 往前翻一页。 b 往后翻一页。 /\u003cpatten\u003e 往前搜 patten 字符。 ?\u003cpatten\u003e 往后搜。 info 命令会显示最全面的信息，一般 man 命令就够了，故 info 命令介绍 暂时略。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:2","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 应用开发 / 学习 / 备查 参考源 【主线剧情 0.0】Linux 学习资源大综合 - 知乎 (zhihu.com)（CSDN 链接） 里面的 !学习来源! 一节！ 【主线剧情 0.0】Linux 学习资源大综合 - 知乎 (zhihu.com)（CSDN 链接） 里面的 书籍推荐 一节。 【主线剧情 0.0】Linux 学习资源大综合 - 知乎 (zhihu.com)（CSDN 链接） 里面的 Linux 应用编程内容补充 一节。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:7:3","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"标准 API 富集 这里就是日常用到的 API 的积累和整理，最详细、全面的 API 参考 见 上面 通过手册的 API 详细描述参考 一节。 日常用到的 标准 API 富集 单独放在了 【Linux 通用应用开发】 （仓库地址 Github、Gitee）文件夹 里面，包括： 文件 IO、字符流收发 和 字符串处理相关的 API 收集积累。 一些 Shell 命令 API 收集积累。 输入设备框架，读取驱动程序按照 input event 框架上传的信息。 文件 IO 读写的基本四种机制（阻塞、非阻塞、poll/select 和 异步通知（通过信号机制））。 Socket TCP / UDP 编程。 进程 和 线程 的设计和编程。包括 进程和线程的分配策略、进程和线程的 API 用法 等： 进程 相关 API（fork()、exec、wait() 等等）。 进程间通讯（管道、命名管道、信号、信号量、消息队列、共享内存、内存映射 和 套接字）。 pthread 线程编程库 相关 POSIX API（pthread_create()、（后面省略 “pthread_”）exit / cancel 和 join / tryjoin_np、self()、attr_setxxx() / attr_getxxx()、）。 线程间通讯、同步的机制（锁机制（互斥锁、读写锁 和 自旋锁）、信号量机制、条件变量机制 和 信号（与 IPC 的信号使用上有区别））。 串口收发编程、I2C编程。 实质上就是对各种设备驱动文件 进行 open/read/write/ioctl/close 来配置和读写，有一些标准接口有标准的信息结构，因此有专门的 库，通过这些库来间接的 配置 和 读写设备驱动文件，比如 tslib、i2ctool 等等。 等等其它，用时补充。比如 进程高级编程、内存管理、Linux 高并发编程 epoll 等等。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:8:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 应用的基本编程思想 大的思想就是，主要对设备文件使用 read/write/ioctl 和 mmap，以下举例： uart（ttyxxx）/i2c/spi设备文件，先用ioctl读出信息和写入配置，然后用read/write来接收和发送（涉及到四种机制：阻塞、非阻塞、poll/select、异步通知）。 屏幕，名为fb的设备，通常用帧缓冲，mmap之后，对一块内存用指针直接进行读写，就是读屏和写屏。 对于摄像头/图像/视频设备，名为videoxxx的设备，read就是读一帧图像/截图。 音频设备，同样是read来录音，write就是播放（如果支持的话）。 对于不同的设备，read 和 write 的使用比较符合直觉，清楚这个编程模式后面看程序，思路就比较清晰。 再有就是各种高级编程，包括进程/线程以及其间的通讯/同步（需要大量实验和经验），网络编程，内存管理，高并发 epoll 等等。 ","date":"2022-03-25","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:9:0","tags":["ARM","Linux"],"title":"【主线剧情08】Linux 应用编程-学习总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8508-linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["人与世人的关系"],"content":"本科时期小剪影","date":"2021-07-01","objectID":"/7%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F/","tags":["杂谈"],"title":"【杂谈】过往时期","uri":"/7%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F/"},{"categories":["人与世人的关系"],"content":"我发现了一篇本科时候的在2017.6写的《自动化导论》作业，那时还比较懵懂，觉得写的有几分意思，撷取几段，再补一点旁白。最后再加上一个本科毕业临走的时候“写给学校的几个小建议”。 《自动化导论——浅谈自动化专业的学习、实践以及行业应用》 自从转入自动化专业以后，接触一些电路和自动控制方面的知识，使我揭开电气控制神秘的面纱，亲身体会控制电路和机器带来的乐趣和满足感，希望我能把这个专业学好并且越走越远，这和我以前的经历有关。转入自动化并非他人意志而是我自己决定。我还在初中的时候就对电路表现出了浓厚的兴趣，我爸爸也很支持，便给我买了电烙铁、一些电子元件和一些简单的入门书籍，开始我就尝试搭一些简单的电路，比如用三极管和电容搭的闪光灯电路，还有一些可以调节频率的发声电路等等，那时候用的都是分立元件，而且做完也不是太懂，从现在看来，那时候做的工作都是一些初级的探索，到了高中由于学业问题，不得不把我的爱好放手一下，在高三毕业的那个暑假，了解到我的一个同班同学在学51单片机，并且他说家里人要求他报自动化专业，我便追问了一些问题，从淘宝上入手了一个单片机开发版开始学习，把单片机的硬件和编程语言一块就学了，后来我才意识到我已经开始使用芯片了，而且相比较前面固定模式的分立元件电路，单片机可以由写程序改变功能，这强大的自由灵活给我开启了新世界。 从大一开始便加入了电子科技创新实验室和创客空间实验室，参加了校级电子设计大赛获得了一等奖，后面又参加了更多的比赛，现在在准备飞思卡尔恩智浦杯智能车比赛和全国大学生电子设计大赛，加入了创新平台的机器人实验室。实验室老师不断强调的是控制算法，我通过不断上网查阅资料和学长的耳闻目染，大概对自动化才开始有了一个初步的认识。这一切的见识应该和自身努力离不开，和我并肩作战的实验室的十几个队友们也是如此。 在自动化导论课上，我听见了两个熟悉的名词，卡尔曼滤波和倒立摆，应该是实验室的学习和学业和比赛等事情让我没有对这两个东西进行深度的探索，而且四旋翼飞行器也是自动化方面的研究，四旋翼飞行器在实验室有人做过，但是很遗憾我也没开始接触，赶上现在学业紧比赛多，这些研究应该都要放到大三了。 首先值得一提的是，自动化专业是和实际应用联系非常强的一门专业，而且一个不受控的机器加入自动化理论会自己调节不需要人为控制是一件非常有意思的事情，在实验室的人感受到了但是大部分人只能通过课堂和课本，感受不深。自动化专业是一门应用场合非常多知识需求门类杂的专业，兴趣的引导缺乏和教育深度的浅显，所以接触起来让很多人一开始摸不着头脑。 ……. 本科一些图片。 旁白 1：在大三结束之前，我参加的不少竞赛，获奖有国一（俩）、国二、省一、省二、省三和校一等，巧的是，正好填补了每一个“段位”。 旁白 2：“人的正确思想是从那里来的？是从天上掉下来的吗？不是。是自己头脑里固有的吗？不是。人的正确思想，只能从社会实践中来，只能从社会的生产斗争，阶级斗争和科学实验这三项实践中来。…无数客观外界的表象，通过人们的眼耳鼻舌身这五个官能反映到自己的头脑中来，开始是感性认识。这种感性认识的材料积累多了，就会产生一个飞跃，变成了理性认识，这就是思想。”——《人的正确思想是从那里来的？》。人的正确思想是从社会实践中来的，实践的重要性在于其是正确思想的来源和验证，但是，让人们投入实践中去，实事求是的来做，很重要的一点是，要有趣，这是行之有效的路线之一，我觉得这个道理很简单但也很难达到，兴趣会指引人们自发的走向实践并求索认知这个世界，所以兴趣是如何产生的，我久前观察过，一个办法是让人们知道意义，讲好意义、传达意义，并且这个意义生动活泼，切中到个人自身，兴趣也许会出现。而做不好表述意义，事情就会变得枯燥，就如同一些人面对专业课的课堂的那种枯燥、无味、乃至厌倦、好感尽失。 本科毕业临走的时候“写给学校的几个小建议”： 1、做实验太过流程化，检验也太简单使学生很容易应付，学生很少真正从实验课学到东西。 2、指导员不关注学生学习和课外实践，只关注纪律卫生等相对不重要的，导致学生很不主动，应当从所有教职工上，多鼓励学生多实践搞探究。 3、创业方面，学生做服务型的很多，科技类型的创业很少，有科技类型的也存在复制照搬、过于简单等问题，就是要求水准我觉得应该提高一下，应当多鼓励科技研究。 4、每年有几千份大创项目，我觉得问题有两个，一是在评选时候没法知道这个学生能不能做出来，导致能做的学生没被选上，选上项目的学生不去做现象，二是最终验收之后，没有下文，除了发论文，每年几千个大创好像再也没有留下什么，我曾经提议要组织几个传承项目组，围绕一个产品传承着多做几年，可上级表示这个提议很好，然后就没有声音了。 没啦。 ","date":"2021-07-01","objectID":"/7%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F/:0:0","tags":["杂谈"],"title":"【杂谈】过往时期","uri":"/7%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F/"},{"categories":["【主线剧情】Linux 系列"],"content":"记 Linux 驱动 相关的基本概念和流程，便于 备查 / 复习","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 驱动编程 - 基本字符设备和设备树维护 教程可参考 100ask的 《嵌入式Linux应用开发完全手册V4.0_韦东山全系列视频文档-IMX6ULL开发板》 手册 和 配套视频，或其它家的（比如原子、野火等等），这里不是教程。文字 和 图片 来自 100ask，侵删。这里以 i.mx6ull 的 IO 操作为例。 本文系学习 100ask 手册而做的备查笔记，我优化了一些逻辑，循序渐进，并扩展了一些，适合复习、备查来看，而非新学来看。 在 Github 上的原版文章日后可能会更新，但这里不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 本文 和 本文对应的源代码 的仓库：仓库地址 Github、Gitee 里面的【Linux 通用驱动开发】\\基本字符设备驱动程序-输出。本文较多引用 100ask，侵删。 文件树如下： ├─led_drv_simple ├─进化1_外设操作和驱动程序分离 ├─进化2_支持多种板子 ├─进化3_外设资源和外设操作分离 ├─进化4_总线设备驱动模型 └─进化5_由设备树定义外设资源 └─主线剧情07.1-Linux驱动编程-基本字符设备和设备树维护.md ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:0:0","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"名词说明 （注，下文的描述是 严格使用 下面的名词来写的） 注册设备和创建设备：通过 register_chrdev() 注册的设备 在 proc/devices/xxx 里面显示，这是 设备名；通过 device_create() 创建的设备 在 dev/xxx0,1... 里面显示，这是 设备文件名。 驱动程序：led_drv.c，即填充 基本 文件 IO 操作 API 结构体 struct file_operations 和 编写模块加载、卸载函数 的文件，驱动的顶层文件，一般要写的简约、漂亮，支持多种板子和外设。 外设资源文件：提供和指定有哪些设备资源，一般独立出来作为 “device” 的文件，提供 “device” 的资源 resource，供给 “driver” 使用。对应 “设备树” 和 “platform_device” 的作用。 外设操作文件：比如直接操作芯片寄存器来控制外设，一般独立出来作为 “driver” 的文件，通过 “外设资源文件” 获取到 “device” 的资源 resource，然后将自己的外设操作API提供给 “驱动程序”。对应 “platform_driver” 的作用。 ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:1:0","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"显示内核打印信息 在 shell 中显示内核驱动使用 printk() 打印的信息： echo \"7 4 1 7\" \u003e /proc/sys/kernel/printk // 打开内核的打印信息，有些板子默认打开了 ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:2:0","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"文件夹说明 ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:0","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"led_drv_simple 为基本的驱动程序，填充 基本 文件 IO 操作 API 结构体 struct file_operations 和 编写 模块加载、卸载函数。 参考的 100ask 的 00_led_drv_simple。 ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:1","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"进化1_外设操作和驱动程序分离 参照 struct file_operations 面向对象的思想，将外设操作 API 也都填充到一个结构体里面，供 驱动程序 调用，保持 驱动程序 的通用、简洁。 设备的初始化、反初始化、控制等等，都在另一个文件 做。定义一个外设的初始化、操作等的结构体 struct led_operations；对于同一个板子来说，使外设操作 API 都聚集在 另外创建的 外设操作文件 里面，然后将这些 API 填充进这个结构体，驱动程序只管调用这个结构体里面的函数成员。 程序补充说明： 设备类（device_class） 通常对应于一种（是某一种类，不是某一接口）外设（比如 IO 外设，如 设备文件： /dev/100ask_led），通过 设备类（device_class）的名字的字符串 来区分；这个类下面可以有多个子设备（比如 IO 外设中 的具体的 哪一个/一些 IO，如设备文件： /dev/100ask_led0,1,...），子设备一般都是相同的 设备类（device_class）和 主设备号 而通过 次设备号 的不同来区分。 因此 模块加载的时候 可能 会根据设定 来创建多个 设备/子设备，即多个 驱动文件（属于一个设备类，主设备号相同，次设备号不同）。 本例程就是 在一个设备类里面创建了多个子设备。即 下面这段，创建了一个设备类下面的多个子设备/驱动文件。 for (i = 0; i \u003c LED_NUM; i++) device_create(led_class, NULL, MKDEV(major, i), NULL, \"100ask_led%d\", i); /* /dev/100ask_led0,1,... */ 在 xxx_write() 和 xxx_read() 函数里面，实际控制一个设备类下面的哪一个设备，根据子设备号，获取通过 file_inode() 根据 file 句柄 得到文件的 inode，再用 iminor() 根据 文件的 inode 得到该 设备文件的 子设备号。 在 xxx_open() 和 xxx_close() 里面 可以根据 int minor = iminor(node); 直接获得 子设备号（或者说是 这一个外设的哪一个具体接口）。 参考的 100ask 的 01_led_drv_template。 ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:2","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"进化2_支持多种板子 还是用 进化1 里面的外设操作API结构体 struct led_operations，然后 各个不同的板子的驱动 API 的接口都统一，即 不同的板子的外设操作 API 的函数 编写的时候都按照这个结构体成员的格式。一个板子一个 .c 文件，里面去实现外设的操作并将操作 API 填充进这个结构体，供 驱动程序 调用即可。 编译时候，选择用哪个板子，就是在 makefile 文件里面的 100ask_led-y := leddrv.o board_100ask_imx6ull-qemu.o 来区分，到底编译哪一个板子对应的驱动程序。 参考的 10ask 的 02_led_drv_for_boards。 在这里，我觉得，STM32 的 HAL 库就是很好的底层驱动框架，可以类似去写操作芯片寄存器的驱动代码，形成 HAL 库，然后在驱动程序里面就调用一些这个 HAL 库的 API，多好！！！（但是，这种给 SoC 建立 HAL库 相比于 后面 设备资源与外设操作分离的建模思想 就显得疲软了） ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:3","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"进化3_外设资源和外设操作分离 外设资源文件：外设资源由 board_A_led.c 和 led_resource.h 提供，里面描述了 用哪些 资源，比如哪个引脚、如何初始化 等等，然后提供给 外设操作文件。 static struct led_resource board_A_led = { /* 例程中，在这里面描述了用哪一个引脚 */ .pin = GROUP_PIN(3,1), }; 外设操作文件：外设操作由 chip_demo_gpio.c 和 led_opr.h 提供（这里与 进化1 保持类似），里面仍然是 定义外设的初始化、操作等的结构体 struct led_operations，然后根据 外设资源文件 提供的外设描述信息（用哪些东西、怎么初始化，还有寄存器的具体地址 等等）来 真正操作 寄存器 来操控外设 进行 初始化、设置外设、读写外设 等等操作。外设操作文件 里面所用到的资源（包括寄存器地址）都是 外设资源文件 给到的，这样保持 外设操作文件 的通用性。 static struct led_operations board_demo_led_opr = { /* 例程中，在这里将 外设操作 API 填充进 struct led_operations 结构体，供 驱动程序 调用 */ .init = board_demo_led_init, .ctl = board_demo_led_ctl, }; 参考的 10ask 的 03_led_drv_template_seperate。 ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:4","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"进化4_总线设备驱动模型 **使用 内核提供的、标准的 platform_device / platform_driver 结构体来分别替代 进化3 中的 struct led_resource 和 struct led_operations，同样是 外设资源和外设操作分离 思想。**因此主要就是 填充结构体 struct platform_device 并注册，填充 结构体 struct platform_driver 并注册。 关于 总线设备驱动模型 的更多解释：总线设备驱动框架1_欧阳海宾的博客-CSDN博客，Linux Platform驱动模型(一) _设备信息_Neilo_chen的博客-CSDN博客。 程序额外说明： board_A_led.c（外设资源文件）里面，填充 结构体 struct platform_device 并用 platform_device_register() 注册。 chip_demo_gpio.c（外设操作文件） 里面，填充 结构体 struct platform_driver 并用 platform_driver_register() 注册，并给驱动程序提供 外设操作 API 结构体。 因此 编译出来的 borad_A_led.ko 对应 platform_device，这就是提供设备资源的；chip_demo_gpio.ko 对应 platform_driver，这就是提供设备操作的。这样说比较分得清。 platform_device / platform_driver 在注册进内核时候，内核会根据 name 进行相互匹配。platform_device 有 唯一的 name 成员（还有一个 driver_override，匹配的优先级最高，具体比较看下图），platform_driver 有 唯一的 name 成员 和 一个 id_table 里面的多个 name 成员。匹配时候 比较三次 如下图。因此 platform_driver 可能对应多个 platform_device，而 platform_device 只对应一个 platform_driver。内核中有很多现成的 platform_driver。 当 platform_device 与 platform_driver 匹配成功的时候会调用 platform_driver 里面的 probe 成员指定的函数，在这里面 获取设备资源、记录资源（不用在需要操作设备资源的时候再临时获取），然后创建 设备/子设备 device_create（且程序上写的是，在 设备资源 platform_device 里面 定义了几个设备 就创建几个 设备）如下图。（在创建 设备 之前应先创建好设备类 class_create，这个写在了 leddrv.c 里面，因此要设计 chip_demo_gpio.c（这里面创建设备） 依赖 leddrv.c（这里面创建类），因此才能保证 加载模块的时候 应该先加载 驱动程序 leddrv.ko 再加载 外设操作模块 chip_demo_gpio.ko 的顺序，最后加载 设备资源模块 borad_A_led.ko。100ask 的例子是这样做的，或许可以用其它的方式来做也达到这样的顺序）。 对于 struct platform_device，程序中还提供了一个空函数 led_dev_release，这个函数在用 platform_device_unregister 卸载 platform_device 时会被调用，如果不提供的话内核会打印警告信息。 总结一下： leddrv.c 里面 填充 struct file_operations 和 编写 模块加载、卸载函数。其中 模块加载函数里面：注册字符设备 register_chrdev、创建设备类 class_create。 board_A_led.c（外设资源文件）里面，填充结构体 struct platform_device 并注册 platform_device_register()。其中 在 struct resource 结构体里面 描述 子设备 的资源。 chip_demo_gpio.c（外设操作文件） 里面，填充 结构体 struct platform_driver 并注册 platform_driver_register()，并给驱动程序提供 外设操作 API 结构体 struct led_operations。其中 当 platform_device 与 platform_driver 匹配成功的时候会调用 platform_driver 里面的 probe 成员指定的函数，在这里面 获取设备资源 platform_get_resource()、记录资源，然后创建 设备/子设备 device_create。 其它的与 进化3 类似。 一般加载模块 insmod 的时候，先加载 驱动程序的模块 leddrv.ko，再加载 driver 的模块 做好驱动的准备，最后加载 device 的模块 这时才创建了设备文件。这个顺序可以自行用 程序的依赖关系 或者 有意识的按照循序操作 来保证。 参考的 10ask 的 04_led_drv_template_bus_dev_drv。 （虽然 100ask 的文件命名不够清晰和规范、教程例子都是临时搓出来的，但是循序渐进的教程思想还是可以的） ","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:5","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["【主线剧情】Linux 系列"],"content":"进化5_由设备树定义外设资源 引入设备树（使用设备树的前提是有对应的驱动程序，即 platform_driver）来指定 外设资源，内核解析设备树，并自动的构造出 platform_device 再注册进内核。即 platform_device 这部分工作由 设备树 替代了，下图描述，左边。 本节例子 进化5_由设备树定义外设资源， 参考的 10ask 的 05_led_drv_template_device_tree。视频讲解 读取设备树提供的资源—【第5篇】嵌入式Linux驱动开发基础知识_哔哩哔哩_bilibili。 因此 本例程中 board_A_led.c（外设资源文件）和 led_resource.h 就用不上了，因为用 设备树 替代了，Makefile 中就可以去掉 board_A_led 了。 设备树参考教程 【1 设备树资料】\\100ask对设备树的简明教程和各种操作API介绍.docx。 主线剧情-番外02-设备树详解_Real-Staok的博客-CSDN博客。 Device Tree: DTS/DTB/FDT (biscuitos.github.io)——良心！ Linux DTS (Device Tree Source)设备树源码_Arrow的博客-CSDN博客_linux 设备树源码——比较全。 板子上查看设备树、平台设备和平台驱动 可以在 shell 中查看当前已经装载的设备树：/sys/firmware/devicetree 目录下是以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件。这些属性的值如果是字符串，可以使用cat命令把它打印出来；对于数值，可以用hexdump把它打印出来。（一个单板启动时，u-boot先运行，它的作用是启动内核。U-boot会把内核和设备树文件都读入内存，然后启动内核。在启动内核时会把设备树在内存中的地址告诉内核。） platform_device 的信息：/sys/devices/platform 目录含有注册进内核的所有 platform_device。一个设备对应一个目录，进入某个目录后，如果它有 “driver” 子目录，就表示这个platform_device跟某个platform_driver配对了。设备树被系统解析后生成的 platform_device 可以在这里面找到。 platform_driver 的信息：/sys/bus/platform/drivers 目录含有注册进内核的所有 platform_driver。一个driver对应一个目录，进入某个目录后，如果它有配对的设备，可以直接看到（一个平台设备只能配对一个平台驱动，一个平台驱动可以配对多个平台设备）。在装载 驱动程序中的 driver 的模块 之后就可以在 这个目录看到对应的 driver。 板子更新设备树 更新设备树： 首先编译：根据开发板，设置 ARCH、CROSS_COMPILE、PATH 这三个环境变量后，进入 ubuntu 上板子内核源码的目录，执行如下命令即可编译 dtb文件：make dtbs，编译出的设备树文件是：内核源码目录中 arch/arm/boot/dts/imx6ull-14x14-ebf.dtb（这里以 野火 imx6ull-pro 为例）。 然后替换：板子启动后，在里面更换这个文件：/boot/imx6ull-14x14-ebf.dtb，板子重启一下 系统便重新装载和解析了新的设备树。 设备树的解析、构造 device 和 匹配 driver 设备树的解析 构造 device_node、platform_device 过程如下： ① dts在PC机上被编译为dtb文件。 ② u-boot把dtb文件传给内核。 ③ 内核解析dtb文件，把每一个节点都转换为device_node结构体。 ④ 对于某些device_node结构体，会被转换为platform_device结构体。 设备树中的节点有些能被转换为内核里的platform_device，有些不能： A. 根节点下含有compatile属性的子节点，会转换为platform_device B. 含有特定compatile属性的节点的子节点，会转换为platform_device。如果一个节点的compatile属性，它的值是这4者之一：“simple-bus”,“simple-mfd”,“isa”,“arm,amba-bus”，那么它的子结点(需含compatile属性)也可以转换为platform_device。 C. 总线I2C、SPI节点下的子节点：不转换为platform_device，而是专门的结构体，如设备树中 i2c 设备节点 被转换为 i2c_client 结构体，spi 设备节点 被转换为 spi_device 结构体。 某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device。 支持设备树的 platform_device 和 支持设备树的 platform_driver 的匹配： 比较 platform_device.dev.of_node 和 platform_driver.driver.of_match_table。这两个 结构体的成员介绍看 驱动例子中的API总结说明.md 里面的 总线平台驱动相关 一节。 具体来说，支持设备树的 platform_device 的 struct device dev 成员的 struct device_node *of_node 中的 struct property *properties 含有 compatible 属性，用于匹配 支持设备树的 driver。 具体来说，支持设备树的 platform_driver 的 struct device_driver driver 成员的 const struct of_device_id *of_match_table 里面的 compatible 成员，用于匹配支持设备树的 device。 使用设备树信息来判断dev和drv是否配对时： 首先，如果of_match_table中含有compatible值，就跟dev的compatile属性比较，若一致则成功，否则返回失败； 其次，如果of_match_table中含有type值，就跟dev的device_type属性比较，若一致则成功，否则返回失败； 最后，如果of_match_table中含有name值，就跟dev的name属性比较，若一致则成功，否则返回失败。 而设备树中建议不再使用devcie_type和name属性，所以基本上只使用设备节点的compatible属性来寻找匹配的platform_driver。 另外还有三次匹配，是前面讲到的：platform_device / platform_driver 在注册进内核时候，内核会根据 name 成员 进行相互匹配。platform_device 有 唯一的 name 成员，platform_driver 有 唯一的 name 成员 和 一个 id_table 里面的多个 name 成员。匹配时候 比较三次。再加上上面说的设备树节点的匹配，因此现在讲了共有四次匹配。 从由设备树转换来的 platform_device 里面获取资源 device_node 怎么转换为 platform_device 结构体的： A. platform_device 中含有 resource 数组，它来自 device_node 的 reg、interrupts 属性。这些是标准的，可以使用 platform_get_resource() 来获取资源。 比如 对于设备树节点中的 reg 属性，它对应 IORESOURCE_MEM 类型的资源；对于设备树节点中的 interrupts 属性，它对应 IORESOURCE_IRQ 类型的资源。 B. platform_device.dev.of_node 指向 device_node，可以通过它获得其他属性。这些对于那些非标准的资源，看下一节，通过 device_node 从节点获取资源。 从没有转换为 platform_device 的设备树节点获取资源 内核源码中 include/linux/ 目录下有很多 of 开头的头文件，使用这些 API。 设备树的处理过程是：dtb -\u003e device_node -\u003e platform_device。 设备树中的每一个节点，在内核里都有一个 device_node。（可以使用 device_node 去找到对应的 platform_device）。 现在我们是不通过 platform_device 而是通过 device_node 来获取节点上的资源。任意驱动程序里，都可以直接访问设备树。 根据 platform_device 来找：struct platform_device 下面的 dev.of_node 就是这个 device 对应 设备树节点的 struct device_node。 首先是找到节点：在 of.h 里 of_find_node_by_path，根据路径字符串 返回 节点结构体 struct device_node。 of_find_compatible_node，根据 compatible 属性，节点如果定义了 compatible 属性，传入 compatible 属性值 字符串 来找到 节点。 of_fin","date":"2022-04-17","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/:3:6","tags":["ARM","Linux"],"title":"【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.1-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%A0%91%E7%BB%B4%E6%8A%A4/"},{"categories":["人与世人的关系"],"content":"给本科实验室的分享PPT","date":"2021-07-23","objectID":"/8%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt/","tags":["杂谈"],"title":"【杂谈】给本科实验室的分享PPT-21.7.23","uri":"/8%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt/"},{"categories":["人与世人的关系"],"content":"谢邀。讨论一些学习、兴趣和人生。该分享主要面向实验室的大一、大二同学。时间 2021.7.23。 ","date":"2021-07-23","objectID":"/8%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt/:0:0","tags":["杂谈"],"title":"【杂谈】给本科实验室的分享PPT-21.7.23","uri":"/8%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt/"},{"categories":["【主线剧情】Linux 系列"],"content":"记 Linux 驱动 相关的基本概念和流程，便于 备查 / 复习","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 驱动编程 - 各种内核机制总结 本文系学习 100ask 手册而做的备查笔记，我优化了一些逻辑，循序渐进，并扩展了一些，适合复习、备查来看，而非新学来看。 在 Github 上的原版文章日后可能会更新，但这里不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 本文 和 本文对应的源代码 的仓库：仓库地址 Github、Gitee 里面的。本文较多引用 100ask，侵删。 本文 始写于 22.4.20 ，之后暂时搁置剩下了的 定时器、mmap 和 中断上下半部 等内容，这几块内容在 23.3.29-31 补充了（所以你能看见 ChatGPT 的字眼嘿嘿），以及还有其它地方修缮。 仓库中给出的不同程序之间的变化，尤其是 【Linux 通用驱动开发】\\基本字符设备驱动程序-输入-各种内核机制总结 里面的各个例程的演化，可以用 对比工具 查看增减的内容，抓住核心，比如 notepad– 自带的 对比文件 工具。 本目录文件树如下： ├─assets ├─gpio_and_pinctrl ├─中断下半部-tasklet-workqueue-threadedirq │ ├─08_read_key_irq_poll_fasync_block_timer_tasklet │ ├─09_read_key_irq_poll_fasync_block_timer_tasklet_workqueue │ └─10_read_key_irq_poll_fasync_block_timer_tasklet_workqueue_threadedirq ├─中断方式+Poll机制 ├─中断方式+休眠-唤醒 │ ├─simple │ │ ├─just_for_test │ │ ├─设备树修改-修改部分独立在dtsi文件 │ │ └─设备树修改-直接在源文件修改 │ └─休眠-唤醒机制 │ ├─read_key_irq_wait │ └─read_key_irq_wqit-circle_buffer ├─中断方式+异步通知机制 └─查询方式-非阻塞 └─主线剧情07.2-Linux驱动编程-各种内核机制总结.md ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:0:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"概念 应用程序 APP 的读取驱动程序的四种基本方式：阻塞、非阻塞、poll 和 异步通知（注册SIGIO信号回调函数。信号之于应用程序，相当于中断之于驱动程序）。这部分详见 【Linux 应用开发】\\1-文件io读写的基本四种机制 里的介绍和例子。 相应的 驱动程序 也类似的提供这四种基本的 读取和上报应用程序的 编写模式。 因此驱动程序支持这四种的哪一种方式或多种，应用程序才能使用哪一种或多种方式进行数据获取，应用程序的写法是与驱动程序所提供的功能紧密相关的。 驱动程序提供能力，不提供策略 我们的驱动程序可以实现下述4种提供按键的方法，但是驱动程序不应该限制APP使用哪种方法。 这就是驱动设计的一个原理：提供能力，不提供策略。就是说，你想用哪种方法都行，驱动程序都可以提供；但是驱动程序不能限制你使用哪种方法。 驱动程序程序“只提供功能，不提供策略”。就是说驱动程序可以提供休眠唤醒、查询等等各种方式，，驱动程序只提供这些能力，怎么用由APP决定。 查询（相当于应用程序的 非阻塞方式获取）： 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read函数。APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚。APP调用read时，导致驱动中对应的read函数被调用，它读取寄存器，把引脚状态直接返回给APP。 休眠-唤醒（相当于应用程序的 阻塞方式获取）： 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read函数。 APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。 APP调用read时，导致驱动中对应的read函数被调用，如果有按键数据则直接返回给APP；否则APP在内核态休眠。 当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的APP。 APP被唤醒后继续在内核态运行，即继续执行驱动代码，把按键数据返回给APP(的用户空间)。 poll 方式（相当于应用程序的 poll方式获取）： 使用休眠-唤醒的方式等待某个事件发生时，有一个缺点：等待的时间可能很久。我们可以加上一个超时时间，这时就可以使用poll机制。 ① APP不知道驱动程序中是否有数据，可以先调用poll函数查询一下，poll函数可以传入超时时间； ② APP进入内核态，调用到驱动程序的poll函数，如果有数据的话立刻返回； ③ 如果发现没有数据时就休眠一段时间； ④ 当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒APP； ⑤ 当超时时间到了之后，内核也会唤醒APP； ⑥ APP根据poll函数的返回值就可以知道是否有数据，如果有数据就调用read得到数据 异步通知 方式（相当于应用程序的 异步通知方式获取）： 异步通知的实现原理是：内核给APP发信号。信号有很多种，这里发的是SIGIO。 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read,fasync函数。 APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。 APP给信号SIGIO注册自己的处理函数：my_signal_fun。 APP调用fcntl函数，把驱动程序的flag改为FASYNC，这会导致驱动程序的fasync函数被调用，它只是简单记录进程PID。 当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程PID发送SIGIO信号。 APP收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用read函数读取按键值。信号处理函数返回后，APP会继续执行原先被打断的代码。 应用程序注册信号回调函数的例子见：【Linux 应用开发】\\1-文件io读写的基本四种机制\\例程-来自百问网\\05_input_read_fasync.c。 关于 信号（signal）详解可见 （真正全）Linux进程和线程的基本编程、通讯和例程【杂记】_Real-Staok的博客-CSDN博客 里的 信号（Signal）一节。 在 shell 中给进程发信号： 假定应用程序叫 signal。 ./signal \u0026 // 后台运行 ps -A | grep signal // 查看进程ID，假设是 9527 kill -SIGIO 9527 // 给这个进程发名为 SIGIO 的信号 注意：所有 应用程序 与 驱动程序 相互收发的机制，包括 read/write/ioctl，还有 poll、异步通知、mmap 等，都要在 设备文件 被打开 的状态 下去执行，否则啥也得不到。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:1:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"查询方式-非阻塞 本节的源码路径：查询方式-非阻塞\\。 我们的目的写出一个容易扩展到各种芯片、各种板子的按键驱动程序，所以驱动程序分为上下两层： ① button_drv.c分配/设置/注册file_operations结构体 起承上启下的作用，向上提供button_open,button_read供APP调用。 而这2个函数又会调用底层硬件提供的p_button_opr中的init、read函数操作硬件。 ② board_xxx.c分配/设置/注册button_operations结构体 这个结构体是我们自己抽象出来的，里面定义单板xxx的按键操作函数。 这样的结构易于扩展，对于不同的单板，只需要替换board_xxx.c提供自己的button_operations结构体即可。 这里的程序结构与 【Linux 驱动开发】\\基本字符设备驱动程序-输出\\进化1_外设操作和驱动程序分离 和 【Linux 驱动开发】\\基本字符设备驱动程序-输出\\进化2_支持多种板子 一致，都是驱动程序单独出来，外设资源和外设操作 都放在另一个文件里面，外设操作（如初始化、读、写等）的 函数API 都打包放进 一个结构体 struct button_operations，然后 驱动程序 调用这个结构体里面的操作函数来操作硬件即可。 两个文件分别编译为两个模块，先加载驱动程序的模块，再才能加载 外设操作程序的模块。外设操作程序的模块在被加载的时候 才会调用 创建设备 （device_create），该模块卸载时候 再删除设备 （device_destroy）。 非阻塞方式 写的要点： 在驱动程序的 read()、write() 还有 ioctl() 等等里面 不要加任何阻塞的函数，只运行一遍立马退出，这么写，就是非阻塞， 应用程序 open 时候 传入 O_NONBLOCK 标志（因此驱动程序写的时候应该保证 不要有任何阻塞的语句），应用程序 read 的时候，驱动程序里面 read 没有阻塞的相关东西，运行一遍然后返回直接返回结果。 几个注意： APP调用open函数时，传入 O_NONBLOCK，就表示要使用非阻塞方式；默认是阻塞方式。 open时设置： int fd = open(“/dev/xxx”, O_RDWR | O_NONBLOCK); /* 非阻塞方式 */ int fd = open(“/dev/xxx”, O_RDWR ); /* 阻塞方式 */ 对于普通文件、块设备文件，O_NONBLOCK不起作用。 对于字符设备文件，O_NONBLOCK 起作用的前提是驱动程序针对O_NONBLOCK做了处理。 在 open之后，也可以通过 fcntl 修改为阻塞或非阻塞： open之后设置： int flags = fcntl(fd, F_GETFL); fcntl(fd, F_SETFL, flags | O_NONBLOCK); /* 非阻塞方式 */ fcntl(fd, F_SETFL, flags \u0026 ~O_NONBLOCK); /* 阻塞方式 */ 模块装载完毕之后，进行测试 01_button_drv_template： ls /dev/100ask_button* -l // 查看设备节点 返回： crw------- 1 root root 236, 0 Jan 18 08:57 /dev/100ask_button0 crw------- 1 root root 236, 1 Jan 18 08:57 /dev/100ask_button1 ./button_test /dev/100ask_button0 // 读按键 返回： [450.886180] /home/book/source/04_button_drv/01_button_drv_template/board_xxx.c board_xxx_button_init_gpio 28, init gpio for button 0 [450.910915] /home/book/source/04_button_drv/01_button_drv_template/board_xxx.c board_xxx_button_read_gpio 33, read gpio for button 0 get button : 1 // 得到数据 参考 100ask 的 04_button_drv。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:2:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"ioctl 的使用 可以参考： Linux驱动学习6（ioctl的实现） - 灰信网（软件开发博客聚合） (freesion.com)。 （八）linux驱动之ioctl的使用 - 灰信网（软件开发博客聚合） (freesion.com)。 linux驱动开发(四)：ioctl()函数_精致的螺旋线的博客-CSDN博客_ioctl函数linux。 例子： /* ioctl 命令定义 */ #define CMD_IOC_MAGIC 'x' #define CMD_IOC_SET_STATE _IOW(CMD_IOC_MAGIC, 1, sizeof(unsigned int)) #define CMD_IOC_READ_INIT_STATE _IOR(CMD_IOC_MAGIC, 2, sizeof(drv_is_inited)) #define CMD_IOC_READ_BUF_SIZE _IOR(CMD_IOC_MAGIC, 3, sizeof(buf_size)) static int mic_arr_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg) { int err = -1; int minor = iminor(inode); /* VFS inode 转 子设备号 */ // int major = imajor(inode); /* 转 主设备号 */ printk(\"%s %s line %d\", __FILE__, __FUNCTION__, __LINE__); if(_IOC_TYPE(cmd) != CMD_IOC_MAGIC) { printk(\"invalid ioctl cmd\"); return -EINVAL; } switch (cmd) { case CMD_IOC_READ_INIT_STATE: { err = copy_to_user((unsigned int*)arg, \u0026drv_is_inited, sizeof(drv_is_inited)); err 的判断 和 处理 printk(\"drv push drv init state:%d\",drv_is_inited); } break; default: printk(\"undefined ioctl cmd\"); return -1; break; } return 0; } ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:3:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"GPIO、Pinctrl 子系统的使用 本节的源码路径：gpio_and_pinctrl\\ 文件夹下。 教程 可看 100ask 手册 嵌入式Linux应用开发完全手册V5_IMX6ULL_Pro开发板.pdf 中的 第16章 GPIO和 Pinctrl子系统的使用 一章， 或 视频 Pinctrl子系统重要概念-【第5篇】嵌入式Linux驱动开发基础知识_哔哩哔哩_bilibili 以及这个视频后面的几个视频连着看。 例子 【Linux 通用驱动开发】\\基本字符设备驱动程序-输入\\gpio_and_pinctrl，引自 100ask 05_gpio_and_pinctrl。 （后面的几段话是理解之后的描述，没学应该先去看教程） 后面的例子使用到 GPIO、Pinctrl 子系统。GPIO、Pinctrl 子系统 即 按照一定规则编写设备树的某些节点的属性和值，然后内核提供一些专用的 API 在驱动程序中来读取这些节点的属性，进而来方便的设置 IO 的 方向、值 等等。Pinctrl 用于引脚配置（配置为 GPIO 还是 复用为 I2C 等其它外设的引脚），GPIO 子系统就用于标记出要使用哪些 IO 、配置引脚方向 和 把引脚配置为输入、输出等简单的功能（供驱动程序获取），注意：一个是相当于设置 IO 的 IOMUX，另一个是 使用 IO，要用到某一个 IO 时候这两处都要在设备树中设置一下。当驱动 drive 与 设备树 中的 设备节点 匹配之后，会自动根据里面的值去配置 IO，包括 default 状态和 sleep 状态，是内核自动完成的。 实现的效果就是：修改设备树，驱动里面调用 gpiod_xxx() 等相关的 API 来获取该 GPIO 并控制其 方向、值 等等，就这样。 要操作GPIO引脚，先把所用引脚配置为GPIO功能，这通过Pinctrl子系统来实现。 然后就可以根据设置引脚方向(输入还是输出)、读值──获得电平状态，写值──输出高低电平。 以前我们通过寄存器来操作GPIO引脚，即使LED驱动程序，对于不同的板子它的代码也完全不同。 当BSP工程师实现了GPIO子系统后，我们就可以： a. 在设备树里指定GPIO引脚 b. 在驱动代码中： 使用GPIO子系统的标准函数获得GPIO、设置GPIO方向、读取/设置GPIO值。 这样的驱动代码，将是单板无关的。 对于使用来讲：对于 Pinctrl 子系统，是在 设备树中相应的 子节点下 要先有 pinctrl 的子节点，在里面写好各个 IO 配置为某个功能（①这个一般芯片厂家会提供，看看 公板/评估板 的 BSP 里面的 设备树，这个里面的 pinctrl 子节点 是 BSP工程师写好提供的，②会有工具软件来生成（如 imx 的 Pins_Tool_for_i.MX...工具），主要用于用户自己用到一些 IO，③如果没有生成工具就自己参考着来了，参考提供的文档或设备树源码），然后在自己的板子的设备树中去定义自己这个设备的节点（如果是用户自定IO，即 设备树里面没有要用的 pinctrl 的子节点，那么就按照前面 的方法来自己加上），在里面调用前面的 pinctrl 的子节点来设置板子上的 IO 功能，即设置 pinctrl-name = \"default\", \"sleep\", ...; pinctrl-0 = \u003c\u0026...\u003e; 等这类属性。对于 GPIO 子系统，即在自己板子的设备树的该节点（自己这个设备的节点） 里 继续写 xxx-gpios = \u003c\u0026... ... GPIO_ACTIVE_HIGH/LOW\u003e;等这种属性，驱动在与设备匹配（通过 compatible 属性等）之后 自动解析这些设备树节点和属性 并据此 配置指定的 IO，然后驱动可以调用 gpiod_xxx() 等相关的 API 来控制 IO 的 方向、值 等等。 一个设备树中方使用 GPIO、Pinctrl 的例子： 对上图说明：其中在 自己板子的设备树的 最外层 定义一个 IO 的节点（左边），pinctrl-0 引用 生成的 IO MUX 配置信息节点（右上），然后在左边可以直接继续写 xxx-gpios = \u003c\u0026... ... GPIO_ACTIVE_HIGH/LOW\u003e; 或者再定义一个子节点然后在里面写。然后就可以在驱动程序中的 probe 函数中 获取 该 IO、配置方向 和 读写了。还要确定该引脚没有其它节点使用，直接搜索 xxx-gpios = \u003c\u0026... ... GPIO_ACTIVE_HIGH/LOW\u003e; 的 \u003c \u003e 里面的内容找到其它用到 该 GPIO 的节点，然后可以在其中添加 status = \"disabled\"; 即可将其禁用。注意这个例子是 imx6ull 的，不同 SoC 设备树的写法会有变化，多变通。 引入 这两个子系统后，对于板子的区分 就依靠 设备树，驱动程序里面可以根据设备树里面指定的资源来编写 外设操作相关的程序，如果驱动程序编写的好，那么更换板子的时候驱动程序几乎不用更改，只修改设备树，那么这就是做的很漂亮、很优雅的活儿。 参考 100ask 的 05_gpio_and_pinctrl。 最后补充： pin controller 相当于软件设置 gpio 进行 mux，其节点的格式，没有统一的标准，包括 group、function 关键字也不一定有，每家芯片都不一样，但是概念是通用的。Linux 内核提供 读 pin controller 节点信息 的函数，这是 BSP 工程师 做好的事情，用户只用 pinctrl-name = \"default\", \"sleep\", ...; pinctrl-0 = \u003c\u0026...\u003e; 来调用。具体看 100ask对GPIO和Pinctrl子系统简明介绍.docx 的 “16.1.4 代码中怎么引用pinctrl” 有简单介绍。 gpio-controller 相当于软件设置 gpio 进行设置方向、读写等，其节点格式都比较类似，是 BSP 工程师 做好的事情，用户只用 [\u003cname\u003e-]gpios = \u003c\u0026... ... GPIO_ACTIVE_HIGH/LOW\u003e; 来调用。 GPIO子系统有两套接口：基于描述符的(descriptor-based)、老的(legacy)。前者的函数都有前缀“gpiod _”，它使用gpio_desc结构体来表示一个引脚；后者的函数都有前缀“gpio _”，它使用一个整数来表示一个引脚。 要操作一个引脚，首先要get引脚，然后设置方向，读值、写值。 头文件 #include \u003clinux/gpio/consumer.h\u003e // descriptor-based 或 #include \u003clinux/gpio.h\u003e // legacy。 下表列出常用的函数： descriptor-based legacy 获得GPIO gpiod_get gpio_request gpiod_get_index gpiod_get_array gpio_request_array devm_gpiod_get devm_gpiod_get_index devm_gpiod_get_array 设置方向 gpiod_direction_input gpio_direction_input gpiod_direction_output gpio_direction_output 读值、写值 gpiod_get_value gpio_get_value gpiod_set_value gpio_set_value 释放GPIO gpio_free gpio_free gpiod_put gpio_free_array gpiod_put_array devm_gpiod_put devm_gpiod_put_array “gpio” 后面带有 “d” 的是基于 gpio_desc 结构体来确定 哪一个 gpio 的，而不带 “d” 的是 基于 gpio 号 的。 有前缀“devm_”的含义是“设备资源管理”(Managed Device Resource)，这是一种自动释放资源的机制。它的思想是“资源是属于设备的，设备不存在时资源就可以自动释放”。比如在Linux开发过程中，先申请了GPIO，再申请内存；如果内存申请失败，那么在返回之前就需要先释放GPIO资源。如果使用devm的相关函数，在内存申请失败时可以直接返回：设备的销毁函数会自动地释放已经申请了的GPIO资源。 建议使用“devm_”版本的相关函数。 去看 gpio_and_pinctrl 文件夹里的例子 就好理解了。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:4:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"GPIO 相关 API 详细介绍 一文讲清楚 Linux内核GPIO子系统分析_奔跑的码仔的博客-CSDN博客 好文。 Linux驱动编程操作GPIO的简要说明_平仄散人的博客-CSDN博客_of_get_gpio_flags。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:5:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"中断方式 + 休眠-唤醒 现在新出的 ARM SoC 都使用 中断控制器 (Generic Interrupt Controller，GIC) 来统一接管所有外设的中断信号，当有一个或一些外设向 CPU 发出中断信号时 GIC 根据其优先级选出一路中断信号 送达 CPU，然后 CPU 跳转到 异常向量表中的 中断处理函数（这些都是硬件完成的），然后进行现场保护、跳转到处理函数，从中断中退出后 进行现场恢复（这些都是软件完成的）。关于 ARM SoC 处理器架构、启动文件 和 GIC 结构的更多 可参考 (主线剧情01-ARM-IMX6ULL基础学习记录_Real-Staok的博客-CSDN博客，主线剧情-番外01-ARM系列快速鸟瞰_Real-Staok的博客-CSDN博客，看一看会更佳的了解系统。 GIC v3/v4用于 ARMv8 架构，即64位ARM芯片。 而GIC v2用于ARMv7和其他更低的架构。 注意：如果想深入理解ARM处理器架构，应该从裸机开始学习。注意：如果为了加快学习速度，从实践角度入手，建议先不看裸机。 对硬件中断的处理的原则 对硬件中断的处理 有 原则：不能嵌套，越快越好。 不能嵌套：为了防止中断嵌套时候栈空间猛增等原因，也是为了简单化中断的处理，在Linux系统上中断无法嵌套：即当前中断A没处理完之前，不会响应另一个中断B(即使它的优先级更高)。 越快越好：在中断的处理过程中，该CPU是不能进行进程调度的，所以中断的处理要越快越好，尽早让其他中断能被处理──进程调度靠定时器中断来实现。在单芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。在SMP系统中，假设中断处理很慢，那么正在处理这个中断的CPU上的其他线程也无法执行。 Linux 中断系统的重要数据结构 看 Linux中断系统的重要数据结构——【第5篇】嵌入式Linux驱动开发基础知识_哔哩哔哩_bilibili， 或详看 中断方式+休眠-唤醒 文件夹里面的 100ask 的 Linux中断系统中的重要数据结构简明介绍 文档和图片。 看一下有助于对中断过程中内核处理的逻辑和过程的了解。 Linux 内核的中断处理机制，源码详细分析：Linux中断管理 (1)Linux中断管理机制 - ArnoldLu - 博客园 (cnblogs.com)。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:6:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"基本设置设备树、申请中断 在设备树中定义中断 首先，定义 interrupt-controller 节点一般是 BSP 的设备树 写好的，其次，在自己的板子的设备树中定义要用那个 io 作为 irq，则在自己设备节点中使用 interrupt-parent = \u003c\u0026哪一个外设\u003e; 引用即可，然后用 interrupt = \u003c信号脚 RISING/FALLING/BOTH\u003e; 声明这个外设的具体哪个信号线和是什么电平触发，最后，用某个 io 作为中断，设备树中一般 用在 自己定义的某个 通讯接口的 设备节点里，比如 spi设备节点、i2c设备节点等 里面，而如果是单独定义一个独立的 io 作为中断（不是在 某个 spi/i2c等的设备节点里面），那就不用 定义 interrupt-parent 和 interrupt 属性，因为所有 gpio 在芯片硬件和软件 BSP 里面都可以作为中断，都做好了。 // 设备树定义形式 interrupt-parent = \u003c\u0026哪一个外设\u003e; /* 指定哪一个外设 */ interrupt = \u003c信号脚 RISING/FALLING/BOTH\u003e; /* 指定这个外设的哪一个信号脚（硬件上的） */ // 一个实例 // 比如 GPIO1 的 引脚 5，它表示要使用 gpio1 里的第 5号中断，hwirq 就是 5 interrupt-parent = \u003c\u0026gpio1\u003e; interrupts = \u003c5 IRQ_TYPE_EDGE_RISING\u003e; // 触发电平类型可选：include/linux/irq.h IRQ_TYPE_EDGE_RISING = 0x00000001 IRQ_TYPE_EDGE_FALLING = 0x00000002 IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING) IRQ_TYPE_LEVEL_HIGH = 0x00000004 IRQ_TYPE_LEVEL_LOW = 0x00000008 在 spi/i2c 设备节点里面定义中断的例子： 引自 100ask imx6ull pro 的设备树 \u0026ecspi3 { pinctrl-names = \"default\"; pinctrl-0 = \u003c\u0026pinctrl_ecspi3\u003e; cs-gpios = \u003c\u0026gpio1 20 GPIO_ACTIVE_LOW\u003e; status = \"okay\"; spidev: icm20608@0{ compatible = \"invensense,icm20608\"; interrupt-parent = \u003c\u0026gpio1\u003e; /* 这是一个 spi 设备节点 里面定义的中断 */ interrupts = \u003c1 1\u003e; spi-max-frequency = \u003c8000000\u003e; reg = \u003c0\u003e; }; }; \u0026i2c2 { clock_frequency = \u003c100000\u003e; pinctrl-names = \"default\"; pinctrl-0 = \u003c\u0026pinctrl_i2c2\u003e; status = \"okay\"; sii902x: sii902x@39 { compatible = \"SiI,sii902x\"; pinctrl-names = \"default\"; reset-names=\"sii902x\"; pinctrl-0 = \u003c\u0026pinctrl_sii902x\u003e; resets = \u003c\u0026sii902x_reset\u003e; interrupt-parent = \u003c\u0026gpio1\u003e; /* 这是一个 i2c 设备节点 里面定义的中断 */ interrupts = \u003c18 IRQ_TYPE_EDGE_FALLING\u003e; mode_str =\"1280x720M@60\"; bits-per-pixel = \u003c16\u003e; reg = \u003c0x39\u003e; status = \"okay\"; }; gt9xx@5d { compatible = \"goodix,gt9xx\"; reg = \u003c0x5d\u003e; status = \"okay\"; interrupt-parent = \u003c\u0026gpio1\u003e; /* 这是一个 i2c 设备节点 里面定义的中断 */ interrupts = \u003c5 IRQ_TYPE_EDGE_FALLING\u003e; pinctrl-names = \"default\"; pinctrl-0 = \u003c\u0026pinctrl_tsc_reset \u0026pinctrl_touchscreen_int\u003e; /*pinctrl-1 = \u003c\u0026pinctrl_tsc_irq\u003e;*/ ... }; }; 引自 设备树中的中断节点以及相关函数-28_杨斌并的博客-CSDN博客。 比如，对于GPI0来说，GPI0的节点也可以作为中断控制器，在 imxbull.dtsi 文件中 GPI01的节点内容如下所示： 这是 定义 interrupt-controller，是 BSP 中写好的 gpio1: gpio@e209ceee { compatible = \"fsl,imx6ul-gpio\",\"fs1,imx35-gpio\"; reg = \u003cex0209ce0e ex4000\u003e; interrupts = \u003cGIC_SPI 66 IRQ_TYPE_LEVEL_HIGH\u003e, \u003cGIC_SPI 67 IRQ_TYPE_LEVEL_HIGH\u003e; gpio-controller; #gpio-cells = \u003c2\u003e; interrupt-controller; #interrupt-cells =\u003c2\u003e; }; 在我们自己的设备树里面描述一个外设的中断节点， key { #address-cells = \u003c1\u003e; #size-cells =\u003c1\u003e; compatible = \"key\"; // 用于匹配 driver pinctrl-names = \"default\"; // pinctrl 子系统 pinctrl-0 =\u003c\u0026pinctrl_key\u003e; // 把管脚设置为 gpio 功能（而不是用于其它外设的引脚） key-gpio = \u003c\u0026gpio1 18 GPIO_ACTIVE_LOW\u003e; // gpio 子系统 // 使用 interrupt-parent 和 interrupts 属性来描述中断 （其实不写这里 软件里也可以设置中断 interrupt-parent = \u003c\u0026gpio1\u003e; // 指示用到的 interrupt 控制器，设置的是中断源 interrupts = \u003c18 IRQ_TYPE_EDGE_BOTH\u003e; // 指示用到的 interrupt 控制器下面的哪一个 信号脚 和 触发电平 status =\"okay\"; // 表示启用，写 disabled 表示不用/禁用 } 新写法：一个 “interrupts-extended” 属性就可以既指定 “interrupt-parent”，也指定 “interrupts”，比如： interrupts-extended = \u003c\u0026intc1 5 1\u003e, \u003c\u0026intc2 1 0\u003e; // 这是定义了两个 IO 的中断 内核解析设备树后，将该设备节点 转化为 platform_device，并通过相关函数将 硬件中断号 hwirq 映射为（虚拟）中断号 irq，并保存在 platform_device 结构体里面，使用 request_irq 注册 中断处理函数 的时候 就用到这个 中断号 irq。 得到中断号 irq 一个节点能被转换为 platform_device，如果它的设备树里指定了中断属性，那么可以使用 platform_device 获得“中断资源”，可以使用下列函数获得 IORESOURCE_IRQ 资源，即中断号：struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num);。 对于I2C设备、SPI设备：在 driver 与 device 匹配之后，调用 内核的 i2c/spi 相关的函数 xxx_probe 来将 i2c/spi 设备 platform_device 转化为 i2c_client 和 spi_device，并且使用 of_irq_get() 取出中断号 irq 赋值给 结构体里面的 irq 成员。 一个 I2C 设备会被转换为一个 i2c_client 结构体，中断号会保存在 i2c_client 的 irq 成员里。 一个 SPI 设备会被转换为一个 spi_device 结构体，中断号会保存在 spi_device 的 irq 成员里。 如果你的设备节点既不能转换为 platform_device，它也不是I2C设备，不是SPI设备，那么在驱动程序中可以自行调用 of_irq_get 函数去解析设备树，得到中断号。 通过设备节点 struct device_node 返回中断号 irq 的函数 unsigned int irq of_parse_and_map(struct device_node *dev,int index)。 通过设备节点 struct device_node 返回 gpio 号 使用 of_get_gpio_flags 或 of_get_named_gpio_flags，再用 g","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:6:1","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"休眠-唤醒 机制 - 且同时支持阻塞和非阻塞 当应用程序必须等待某个事件发生，比如必须等待按键被按下时，可以使用“休眠-唤醒”机制： ① APP调用read等函数试图读取数据，比如读取按键； ② APP进入内核态，也就是调用驱动中的对应函数，发现有数据则复制到用户空间并马上返回； ③ 如果APP在内核态，也就是在驱动程序中发现没有数据，则APP休眠；所谓休眠就是把自己的状态改为非RUNNING，这样内核的调度器就不会让它运行。 ④ 当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒APP；唤醒就是把程序的状态改为RUNNING，这样内核的调度器有合适的时间就会让它运行。 ⑤ APP继续运行它的内核态代码，也就是驱动程序中的函数，复制数据到用户空间并马上返回。 在中断处理函数中，不能休眠，也就不能调用会导致休眠的函数。 休眠函数 参考内核源码：include\\linux\\wait.h。 函数 说明 wait_event_interruptible(wq, condition) 休眠，直到condition为真； 休眠期间是可被打断的，可以被信号打断 wait_event(wq, condition) 休眠，直到condition为真； 退出的唯一条件是condition为真，信号也不能打断 wait_event_interruptible_timeout(wq, condition, timeout) 休眠，直到condition为真或超时； 休眠期间是可被打断的，可以被信号打断 wait_event_timeout(wq, condition, timeout) 休眠，直到condition为真或超时； 退出的唯一条件是condition为真，信号也不好使 比较重要的参数就是： ① wq：waitqueue，等待队列 休眠时除了把程序状态改为非RUNNING之外，还要把进程/进程放入wq 中，以后中断服务程序要从wq中把它取出来唤醒。 ② condition 这可以是一个变量，也可以是任何表达式。表示“一直等待，直到condition为真”。 唤醒函数 参考内核源码：include\\linux\\wait.h。 函数 说明 wake_up_interruptible(x) 唤醒x队列中状态为“TASK_INTERRUPTIBLE”的线程，只唤醒其中的一个线程 wake_up_interruptible_nr(x, nr) 唤醒x队列中状态为“TASK_INTERRUPTIBLE”的线程，只唤醒其中的nr个线程 wake_up_interruptible_all(x) 唤醒x队列中状态为“TASK_INTERRUPTIBLE”的线程，唤醒其中的所有线程 wake_up(x) 唤醒x队列中状态为“TASK_INTERRUPTIBLE”或“TASK_UNINTERRUPTIBLE”的线程，只唤醒其中的一个线程 wake_up_nr(x, nr) 唤醒x队列中状态为“TASK_INTERRUPTIBLE”或“TASK_UNINTERRUPTIBLE”的线程，只唤醒其中nr个线程 wake_up_all(x) 唤醒x队列中状态为“TASK_INTERRUPTIBLE”或“TASK_UNINTERRUPTIBLE”的线程，唤醒其中的所有线程 做法就是： 初始化 wq 队列 static DECLARE_WAIT_QUEUE_HEAD(wq);。 在驱动的 read 函数中，调用 wait_event_interruptible(wq, event);，它会判断 event 是否为 FALSE，如果为 FASLE 则休眠。 在中断服务程序里，读取摁键的值，若被摁下，则设置 event 为 TRUE，并调用 wake_up_interruptible(wq); 唤醒线程（只调用 wake_up_interruptible() 还不行，必须还得先将 等待条件/event 设为真）。 本节程序例子 基本字符设备驱动程序-输入\\中断方式+休眠-唤醒\\休眠-唤醒机制\\read_key_irq_wait。 read_key_irq_wqit-circle_buffer 这个例子是使用环形队列来 存储和取出 按键的值。本例子 需要修改设备树，设备树的修改已经写到了 read_key_irq_wait 例子里 驱动程序开头 的注释里。例子引自 100ask 的 02_read_key_irq 和 03_read_key_irq_circle_buffer 。 驱动程序，挑出核心的 static DECLARE_WAIT_QUEUE_HEAD(gpio_key_wait); static ssize_t gpio_key_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { int err; wait_event_interruptible(gpio_key_wait, g_key); 在这里休眠，等待条件变真和被唤醒 err = copy_to_user(buf, \u0026g_key, 4); g_key = 0; return 4; } static irqreturn_t gpio_key_isr(int irq, void *dev_id) { struct gpio_key *gpio_key = dev_id; int val; val = gpiod_get_value(gpio_key-\u003egpiod); printk(\"key %d %d\\n\", gpio_key-\u003egpio, val); g_key = (gpio_key-\u003egpio \u003c\u003c 8) | val; 条件设置为真 wake_up_interruptible(\u0026gpio_key_wait); 唤醒 return IRQ_HANDLED; } 应用程序，挑出核心的 fd = open(argv[1], O_RDWR); if (fd == -1) { printf(\"can not open file %s\\n\", argv[1]); return -1; } while (1) { /* 3. 读文件 */ read(fd, \u0026val, 4); printf(\"get button : 0x%x\\n\", val); } close(fd); 上面 驱动里面 read() 是 不管有没有 O_NONBLOCK 标志，只要应用调用 驱动的 read()，在 没有数据/没有唤醒 的时候 就会阻塞住！ 回顾上面 ”查询方式-非阻塞“ 一节的这个内容： 几个注意： APP调用open函数时，传入 O_NONBLOCK，就表示要使用非阻塞方式；默认是阻塞方式。 open时设置： int fd = open(“/dev/xxx”, O_RDWR | O_NONBLOCK); /* 非阻塞方式 */ int fd = open(“/dev/xxx”, O_RDWR ); /* 阻塞方式 */ 对于普通文件、块设备文件，O_NONBLOCK不起作用。 对于字符设备文件，O_NONBLOCK 起作用的前提是驱动程序针对O_NONBLOCK做了处理。 在 open之后，也可以通过 fcntl 修改为阻塞或非阻塞： open之后设置： int flags = fcntl(fd, F_GETFL); fcntl(fd, F_SETFL, flags | O_NONBLOCK); /* 非阻塞方式 */ fcntl(fd, F_SETFL, flags \u0026 ~O_NONBLOCK); /* 阻塞方式 */ 下面让驱动程序 根据 O_NONBLOCK 标志位 同时支持 阻塞和非阻塞，就是让 O_NONBLOCK 这个标志位起作用~： 驱动里面 核心的 read() 改动的地方 拿过来： static ssize_t gpio_key_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { //printk(\"%s %s line %d\\n\", __FILE__, __FUNCTION__, __LINE__); int err; int key; if (is_key_buf_empty() \u0026\u0026 (file-\u003ef_flags \u0026 O_NONBLOCK)) 添加了这里，就是 在应用传入 O_NONBLOCK 标志时候，驱动程序就不阻塞 return -EAGAIN; 反之就是支持阻塞~！ wait_event_interruptible(gpio_key_wait, !is_key_buf_empty()); key = get_key(); err = copy_to_user(buf, \u0026key, 4); return 4; } 引自 100ask 手册：从驱动代码也可以看出来，当 APP 打开某个驱动时，在内核中会有一个struct file 结构体对应这个驱动，这个结构体中有 f_flags，就是打开文件时的标记位；可以设置 f_flasgs的O_NONBLOCK位，表示非阻塞；也可以清除这个位表示阻塞。 驱动程序要根据这个标记位决定事件未就绪时是休眠和还是立刻返回。 驱动程序程序“只提供功能，不提供策略”。就是说驱动程序可以提供休眠唤醒、查询等等各种方式，，驱动程序只提供这些能力，怎么用由 APP决定。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:6:2","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"中断方式 + Poll 机制 使用 poll 机制 加上一个等待时间，超时 或 有数据 都会返回，根据返回值来区分，若为 有数据的 情况，则直接 read() 即可。相当于 阻塞 + 一个超时时间 的机制。 流程示意图 函数执行流程如上图①～⑧所示，重点从③开始看。假设一开始无按键数据： ③ APP调用poll之后，进入内核态； ④ 导致驱动程序的drv_poll被调用： 注意，drv_poll要把自己这个线程挂入等待队列wq中；假设不放入队列里，那以后发生中断时，中断服务程序去哪里找到你嘛？ drv_poll还会判断一下：有没有数据啊？返回这个状态。 ⑤ 假设当前没有数据，则休眠一会； ⑥ 在休眠过程中，按下了按键，发生了中断： 在中断服务程序里记录了按键值，并且从wq中把线程唤醒了。 ⑦ 线程从休眠中被唤醒，继续执行for循环，再次调用drv_poll： drv_poll返回数据状态 ⑧ 哦，你有数据，那从内核态返回到应用态吧 ⑨ APP调用read函数读数据 如果一直没有数据，调用流程也是类似的，重点从③开始看，如下： ③ APP调用poll之后，进入内核态； ④ 导致驱动程序的drv_poll被调用： 注意，drv_poll要把自己这个线程挂入等待队列wq中；假设不放入队列里，那以后发生中断时，中断服务程序去哪里找到你嘛？ drv_poll还会判断一下：有没有数据啊？返回这个状态。 ⑤ 假设当前没有数据，则休眠一会； ⑥ 在休眠过程中，一直没有按下了按键，超时时间到：内核把这个线程唤醒； ⑦ 线程从休眠中被唤醒，继续执行for循环，再次调用drv_poll： drv_poll返回数据状态 ⑧ 哦，你还是没有数据，但是超时时间到了，那从内核态返回到应用态吧 ⑨ APP不能调用read函数读数据 程序例子见 “中断方式+Poll机制” 文件夹下。引自 100ask 的 04_read_key_irq_poll。 使用poll机制时，驱动程序的核心就是提供对应的drv_poll函数。 在drv_poll函数中要做2件事： ① 把当前线程挂入队列wq：poll_wait APP调用一次poll，可能导致drv_poll被调用2次（或多次），但是我们并不需要把当前线程挂入队列2次。 可以使用内核的函数poll_wait把线程挂入队列，如果线程已经在队列里了，它就不会再次挂入。 ② 返回设备状态： APP调用poll函数时，有可能是查询“有没有数据可以读”：POLLIN，也有可能是查询“你有没有空间给我写数据”：POLLOUT。 所以drv_poll要返回自己的当前状态：(POLLIN | POLLRDNORM) 或 (POLLOUT | POLLWRNORM)。 POLLRDNORM等同于POLLIN，为了兼容某些APP把它们一起返回。 POLLWRNORM等同于POLLOUT ，为了兼容某些APP把它们一起返回。 驱动程序，挑重点 static DECLARE_WAIT_QUEUE_HEAD(gpio_key_wait); static ssize_t gpio_key_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { int err; int key; wait_event_interruptible(gpio_key_wait, !is_key_buf_empty()); 阻塞住 key = get_key(); err = copy_to_user(buf, \u0026key, 4); return 4; } static unsigned int gpio_key_drv_poll(struct file *fp, poll_table * wait) { printk(\"%s %s line %d\\n\", __FILE__, __FUNCTION__, __LINE__); poll_wait(fp, \u0026gpio_key_wait, wait); poll_wait 阻塞住 return is_key_buf_empty() ? 0 : POLLIN | POLLRDNORM; } static irqreturn_t gpio_key_isr(int irq, void *dev_id) { struct gpio_key *gpio_key = dev_id; int val; int key; val = gpiod_get_value(gpio_key-\u003egpiod); printk(\"key %d %d\\n\", gpio_key-\u003egpio, val); key = (gpio_key-\u003egpio \u003c\u003c 8) | val; put_key(key); 设置等待条件 !is_key_buf_empty() 为真 wake_up_interruptible(\u0026gpio_key_wait); 唤醒 return IRQ_HANDLED; } 应用程序，挑重点 打开文件之后 fds[0].fd = fd; fds[0].events = POLLIN; while (1) { /* 3. 读文件 */ ret = poll(fds, 1, timeout_ms); if ((ret == 1) \u0026\u0026 (fds[0].revents \u0026 POLLIN)) { read(fd, \u0026val, 4); printf(\"get button : 0x%x\\n\", val); } else { printf(\"timeout\\n\"); } } 更具体的应用程序可看 “1-文件io读写的基本四种机制” 里面的 “文件io读写的基本四种机制.md” 里面的 “poll/select（设置阻塞事件和时间）” 一节。 注意几点： ① drv_poll要把线程挂入队列wq，但是并不是在drv_poll中进入休眠，而是在调用drv_poll之后休眠 ② drv_poll要返回数据状态 ③ APP调用一次poll，有可能会导致drv_poll被调用2次 ④ 线程被唤醒的原因有2：中断发生了去队列wq中把它唤醒，超时时间到了内核把它唤醒 ⑤ APP要判断poll返回的原因：有数据，还是超时。有数据时再去调用read函数。 关于 poll 更详细的说明 / 更多好的参考： poll函数详解_青季的博客-CSDN博客_poll函数。 struct pollfd_wocjj的博客-CSDN博客_pollfd。 linux基础——linux下多路IO复用接口之select/poll_yexz的博客-CSDN博客。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:7:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"中断方式 + 异步通知 机制 主要是使用信号机制。 app 向 一个具体的驱动程序 注册 异步IO事件（SIGIO）的 信号（signal） 和 处理/回调/钩子/handler 函数，并告知自己的进程号，并使能 异步通知。 一个具体的驱动程序 在 特定 情况下 通过 内核提供的 API 向 APP 发 异步IO事件（SIGIO）信号。 则此时 APP 自动去 调用 并 执行 处理/回调/钩子/handler 函数。 流程示意图 重点从②开始： ② APP给SIGIO这个信号注册信号处理函数func，以后APP收到SIGIO信号时，这个函数会被自动调用； ③ 把APP的PID(进程ID)告诉驱动程序，这个调用不涉及驱动程序，在内核的文件系统层次记录PID； ④ 读取驱动程序文件Flag； ⑤ 设置Flag里面的FASYNC位为1：当FASYNC位发生变化时，会导致驱动程序的fasync被调用； ⑥⑦ 调用faync_helper，它会根据FAYSNC的值决定是否设置button_async-\u003efa_file=驱动文件filp： 驱动文件filp结构体里面含有之前设置的PID。 ⑧ APP可以做其他事； ⑨⑩ 按下按键，发生中断，驱动程序的中断服务程序被调用，里面调用kill_fasync发信号； ⑪⑫⑬ APP收到信号后，它的信号处理函数被自动调用，可以在里面调用read函数读取按键。 核心是： ① 提供对应的 drv_fasync 函数。 drv_fasync 函数很简单，里面就调用 fasync_helper 函数 去处理相关的东西 就可以，如下： static struct fasync_struct *button_async; static int drv_fasync(int fd, struct file *filp, int on) { return fasync_helper (fd, filp, on, \u0026button_async); 或者这样写 if (fasync_helper(fd, file, on, \u0026buf_fasync) \u003e= 0) return 0; else return -EIO; } fasync_helper函数会分配、构造一个fasync_struct结构体button_async： ① 驱动文件的flag被设置为FAYNC时： button_async-\u003efa_file = filp; filp表示驱动程序文件，里面含有之前设置的PID ② 驱动文件被设置为非FASYNC时： button_async-\u003efa_file = NULL; 以后想发送信号时，使用button_async作为参数就可以，如果 app 告知了 驱动 自己的 pid，那么它里面含有 app 的 PID。 ② 并在合适的时机发信号。这里的例子是在中断里发信号。 kill_fasync(\u0026button_async, SIGIO, POLL_IN); 第1个参数：button_async-\u003efa_file非空时，可以从中得到PID，表示发给哪一个APP； 第2个参数表示发什么信号：SIGIO； 第3个参数表示为什么发信号：POLL_IN，有数据可以读了。(APP用不到这个参数) 对应的应用程序： ① 编写信号处理函数： static void sig_func(int sig) { int val; read(fd, \u0026val, 4); printf(\"get button : 0x%x\\n\", val); } ② 注册信号处理函数： signal(SIGIO, sig_func); ③ 打开驱动： fd = open(argv[1], O_RDWR); ④ 把进程ID告诉驱动： fcntl(fd, F_SETOWN, getpid()); ⑤ 使能驱动的FASYNC功能： flags = fcntl(fd, F_GETFL); fcntl(fd, F_SETFL, flags | FASYNC); 具体的驱动程序见 “中断方式+Poll机制” 文件夹里面。引自 100ask 的 05_read_key_irq_poll_fasync。 详细具体的应用程序看 应用编程里面 “1-文件io读写的基本四种机制” 里面的 “文件io读写的基本四种机制.md” 里面的 “异步通知（捕获信号 SIGIO）” 一节。 更多： fasync和kill_fasync机制分析_来自大山的孩子的博客-CSDN博客。 Linux异步通知—fasync_helper()、kill_fasync()函数介绍与使用_面朝大海0902的博客-CSDN博客_linux 异步通知。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:8:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"内核中定时器的使用 timer ！较全的参考 Linux内核API 定时机制|极客笔记 (deepinout.com)。 内核中 include\\linux\\timer.h 的 相关 API： setup_timer(timer, fn, data)： 设置定时器，主要是初始化 timer_list 结构体，设置其中的函数、参数。 void setup_timer(struct timer_list *timer, void (*function)(unsigned long), unsigned long data); function 参数: 定时器到期的处理函数指针，类型为void (*function)(unsigned long)，通常为设备或组件的中断处理函数，对定时器到期后执行的处理进行回调。注意：回调函数需要被安排在进程上下文或独立中断线程上下文中，避免在上层代码直接执行，引起内核的问题。 data 参数：函数调用回调函数时需要传递的参数，是一个无符号长整型。 void add_timer(struct timer_list *timer)： 向内核添加定时器。timer-\u003eexpires表示超时时间。 当 超 时 时 间 到 达 ， 内 核 就 会 调 用 这 个 函 数 ：timer-\u003efunction(timer-\u003edata)。 int mod_timer(struct timer_list *timer, unsigned long expires): 修改定时器的超时时间， 它等同于： del_timer(timer); timer-\u003eexpires = expires; add_timer(timer); 但是更加高效。 int del_timer(struct timer_list *timer)： 删除定时器。 定时器 定时的变量，是内核中 全局变量 jiffies， 内核源码根目录下 一个隐藏的内核配置文件里面，CONFIG_HZ=100，表示每个滴答是10ms，每发生一次 tick 中断，全局变量 jiffies 就会累加 1。 修改超时时间： 在add_timer 之前，直接修改： timer.expires = jiffies + xxx; // xxx表示多少个滴答后超时，也就是 xxx*10ms timer.expires = jiffies + 2*HZ; // HZ等于 CONFIG_HZ，2*HZ就相当于 2秒 在add_timer 之后，使用 mod_timer 修改： mod_timer(\u0026timer, jiffies + xxx); // xxx表示多少个滴答后超时，也就是 xxx*10ms mod_timer(\u0026timer, jiffies + 2*HZ); // HZ等于 CONFIG_HZ，2*HZ就相当于 2秒 驱动内使用例子，引自 100ask 的，只放核心部分：这里是 按键中断中 延时 消抖 struct timer_list key_timer; 这里是 注册平台驱动 的 probe 和 remove 的 回调函数 static int gpio_key_probe(struct platform_device *pdev) { ... setup_timer(\u0026key_timer, key_timer_expire, \u0026gpio_keys_100ask[i]); 初始化 和 添加 定时器 key_timer.expires = ~0; 注意这里，不希望开启定时器后就超时，这里设置超时时间为最大 add_timer(\u0026key_timer); ... } static int gpio_key_remove(struct platform_device *pdev) { ... del_timer(\u0026key_timer); 删除定时器 ... } static irqreturn_t gpio_key_isr(int irq, void *dev_id) { struct gpio_key *gpio_key = dev_id; printk(\"gpio_key_isr key %d irq happened\\n\", gpio_key-\u003egpio); mod_timer(\u0026key_timer, jiffies + HZ/5); 在按键中断回调函数里面， return IRQ_HANDLED; 修改定时器超时时间，为 1/5 秒，即 200ms } static void key_timer_expire(unsigned long data) 定时器超时函数，即 按键平稳 不抖 之后 执行这里， { 唤醒啊之类的，替代没用定时器之前 中断回调函数里面的内容 /* data ==\u003e gpio */ struct gpio_key *gpio_key = data; int val; int key; val = gpiod_get_value(gpio_key-\u003egpiod); printk(\"key_timer_expire key %d %d\\n\", gpio_key-\u003egpio, val); key = (gpio_key-\u003egpio \u003c\u003c 8) | val; put_key(key); wake_up_interruptible(\u0026gpio_key_wait); kill_fasync(\u0026button_fasync, SIGIO, POLL_IN); } 加餐：引自 linux驱动之内核定时器_from_timer_未燃机智鱼的博客-CSDN博客。 Linux内核提供了几个 jiffies和 ms、us、ns之间的转换函数 // 将毫秒、微秒、纳秒转换为 jiffies类型。 long msecs_to_jiffies(const unsigned int m) long usecs_to_jiffies(const unsigned int u) unsigned long nsecs_to_jiffies(u64 n) //将 jiffies类型的参数 j分别转换为对应的毫秒、微秒、纳秒。 int jiffies_to_msecs(const unsigned long j) int jiffies_to_usecs(const unsigned long j) u64 jiffies_to_nsecs(const unsigned long j) 纳秒、微秒和毫秒延时函数。不建议使用 void ndelay(unsigned long nsecs) void udelay(unsigned long usecs) void mdelay(unsigned long mseces) 至于原理，当发生硬件中断时，硬件中断处理完后，内核会调用软件中断的处理函数。 定时器就是通过软件中断来实现的，它属于 TIMER_SOFTIRQ软中断。 简单地说，add_timer函数会把timer放入内核里某个链表； 在TIMER_SOFTIRQ的处理函数中，会从链表中把这些超时的timer取出来，执行其中的函数。 对于 jiffies 大于或等于 timer-\u003eexpires 的 定时器，timer 就超时。 内核中有很多timer，如果高效地找到超时的timer？这是比较复杂的，可以看看这文章： https://blog.csdn.net/tianmohust/article/details/8707162 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:9:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"mmap 内存映射的使用 严重注意：基础而且很重要知识 如 内存页、cache / buffer， 还有 几种映射机制 以及其 适用场景： Non-cached, non-buffered (NCNB) Non-cached buffered (NCB) Cached, write-through mode (WT) Cached, write-back mode (WB) 这些基础概念，可以看 100ask 的手册 嵌入式Linux应用开发完全手册V5_IMX6ULL_Pro开发板 中 第19章 驱动程序基石 的 mmap 一节，里面讲的很多！ 驱动程序例子： static int drv_open(struct inode *node, struct file *file) { // int err = -1; // int minor = iminor(node); /* VFS inode 转 子设备号 */ // int major = imajor(node); /* 转 主设备号 */ /* 为 内存池 申请空间 */ // drv_buf_ptr = (unsigned char *)kzalloc(drv_buf_size, GFP_KERNEL); /* 用这个，地址连续，限制 128KB */ drv_buf_ptr = (unsigned char *)vmalloc_user(drv_buf_size); 申请内存 /* 注意这里不确定 能否用 vmalloc 申请的内存 用于 mmap， 需要测试 不行就还需要 寻找大内存的 申请和 mmap 的解决办法 并记录到 主线剧情07.3-Linux驱动编程-内核态API总结备查.md 里面 */ /* 填充随机数 */ get_random_bytes(drv_buf_ptr, drv_buf_size); return 0; } static int drv_close(struct inode *node, struct file *file) { // int err = -1; // int minor = iminor(node); /* VFS inode 转 子设备号 */ // int major = imajor(node); /* 转 主设备号 */ /* 为 内存池 释放空间 */ // kfree(drv_buf_ptr); vfree(drv_buf_ptr); 释放内存 return 0; } static int drv_mmap(struct file *file, struct vm_area_struct *vma) { /* 获得物理地址 */ unsigned long phy = virt_to_phys(drv_buf_ptr); /* 设置属性: cache, buffer */ vma-\u003evm_page_prot = pgprot_writecombine(vma-\u003evm_page_prot); /* 映射，map */ if (remap_pfn_range(vma, vma-\u003evm_start, phy \u003e\u003e PAGE_SHIFT, vma-\u003evm_end - vma-\u003evm_start, vma-\u003evm_page_prot)) { printk(\"mmap remap_pfn_range failed\\n\"); return -ENOBUFS; } /* 或者下面这样写，上下二者区别在于 remap_pfn_range() 最后一个参数 */ int ret = 0; unsigned long page; // 获取映射区段的长度 unsigned long size = vma-\u003evm_end - vma-\u003evm_start; // 检查映射区段是否太长或太短 if (size \u003e PAGE_SIZE) return -EINVAL; // 获取映射区段的起始位置 page = virt_to_phys(vmalloc_area) \u003e\u003e PAGE_SHIFT; // 映射内存段 ret = remap_pfn_range(vma, vma-\u003evm_start, page, size, PAGE_SHARED); if(ret \u003c 0) { pr_err(\"remap_pfn_range failed: %d\\n\", ret); return ret; } return 0; } 应用程序例子： int data_in_fd = open(rate_test_drv_path, O_RDONLY | O_NONBLOCK); unsigned char *data_in_base = (unsigned char *)mmap(NULL , drv_buf_file_size, PROT_READ, MAP_SHARED, data_in_fd, 0); mmap() 应用层使用说明：引自 【Linux 通用应用开发】\\0-用到的API-收集积累\\文件IO、字符流收发和字符串处理相关的API收集积累.c 函数原型： void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 函数说明： ① addr 表示指定映射的內存起始地址，通常设为 NULL 表示让系统自动选定地址，在成功映射后返回该地址； ② length 表示将文件 fd 中多大的内容映射到内存中； ③ prot 表示映射区域的保护方式，可以为以下 4 种方式的组合 a. PROT_EXEC 映射区域 *addr 可被执行 b. PROT_READ 映射区域可被读出 c. PROT_WRITE 映射区域可被写入 d. PROT_NONE 映射区域不能存取 ④ Flags 表示影响映射区域的不同特性，常用的有以下两种 a. MAP_SHARED 表示对映射区域 *addr 写入的数据会复制回文件 fd 内，原来的文件 fd 会改变； 而且允许其他映射该文件的进程共享。 b. MAP_PRIVATE 表示对映射区域的操作会产生一个映射文件的复制，对此区域的任何修改都不会写回原来的文件内容中。 也就是，每一个进程 对一个被 mmap 的文件的内容 独占，各自读写各自的，互相独立的 ⑤ fd 为被映射的文件。 ⑥ offset 文件映射的偏移量，通常为 0。 返回值：若成功映射，将返回指向映射的区域的指针，失败将返回-1。 例子： static unsigned char *fb_base = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, 0); ... munmap(fb_base , screen_size); 头文件： #include \u003csys/mman.h\u003e #include \u003cunistd.h\u003e 用完后，取消 内存重映射 int munmap(void *start, size_t length); start 是内存起始地址，length 是大小 使用 mmap 来对一个文件（实体文件或块设备驱动文件）重映射到一块内存（虚拟内存）， 从而让访问该文件内容时候就像读写内存一样（指针移动和读写）， 常用在文件内容的搬运、屏幕的 Framebuffer（将屏幕驱动文件重映射到一块内存，然后读写内存就是读写屏幕）。 内存映射，就是将内核空间的一段内存区域映射到用户空间，映射成功后， 用户对这段内存区域的修改可以直接反映到内核空间， 相反，内核空间对这段区域的修改也直接反映用户空间。 那么对于内核空间和用户空间两者之间需要大量数据传输等操作的时候效率是非常高的。 详解mmap原理：https://zhuanlan.zhihu.com/p/465336136 映射方式，使用 pgprot_ 族函数选择： 用搜索引擎找半天没有对口的直接回答，用 GPT3.5 回答如下（23.3.29），同时揉进了 100ask 手册的相关内容，可以说很通俗易懂了。https://chat8.io/。 再揉进了 100ask 的手册 嵌入式Linux应用开发完全手册V5_IMX6ULL_Pro开发板 中 第19章 驱动程序基石 的 mmap 一节 的内容！ pgprot_noncached()：用于生成一个表示不应缓存页面的保护标志。适用于需要禁用页面缓存的场景，例如一些特殊设备的访问（如FrameBuffer设备）。 不使用 cache，不使用 buffer Non-cached, non-buffered (NCNB) 读、写都直达外设硬件。 这适合寄存器的读写。这种方式可以保证在进行一些特殊设备访问（如FrameBuffer设备）时不会因为缓存的存在而出现访问错误或数据失真问题。 pgprot_writecombine()：生成一个表示可写结合内存操作（Write-Combining Memory）的保护标志。适用于需要进行大量内存写操作的场景，例如显存访问。 不使用 cache，使用 buffer Non-cached buffered (NCB) 读、写都直达外设硬件； 写操作通过 buffer实现，CPU不等待写操作完成，CPU会马上执行下一条指令。 写数据时会用 buffer进行优化，可能会有“写合并”，这适合显存的操作。因为对显存很少有读操作，基本","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:10:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"中断上下半部 这部分内容参考 100ask 手册 《嵌入式Linux应用开发完全手册V5_IMX6ULL_Pro开发板》的 18.2.4、18.2.5 和 19.6 中断下半部tasklet、19.7 工作队列 等部分。 这部分 三种 中断下半部机制 的例程 直接取自 100ask 教程的配套程序 01_all_series_quickstart\\05_嵌入式Linux驱动开发基础知识\\source\\06_gpio_irq\\，放到了 本仓库的 \\【Linux 通用驱动开发】\\基本字符设备驱动程序-输入-各种内核机制总结\\中断下半部-tasklet-workqueue-threadedirq。 Linux系统把中断的意义扩展了，软件中断 和 硬件中断。 对于按键中断等硬件产生的中断，称之为“硬件中断”(hard irq)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断的处理函数肯定不一样。当发生A中断时，对应的irq_function_A函数被调用。硬件导致该函数被调用。 还可以人为地制造中断：软件中断(soft irq) a. 软件中断何时生产？由软件决定，对于X号软件中断，只需要把它的flag设置为1就表示发生了该中断。 b. 软件中断何时处理？ 软中断的 flag 标志位 是在每一次 硬件中断 里面最后检查一下，在处理完硬件中断后，再去处理软件中断。Linux系统中，各种硬件中断频繁发生，至少定时器中断每 10ms（CONFIG_HZ=100） 发生一次。 怎么设置软件中断？最核心的函数是 raise_softirq（这个函数由内核调用），这个函数简单地理解就是设置softirq_req[nr]的标记位。 设置软件中断的处理函数：extern void open_softirq(int nr, void (*action) (struct soft_action*));。 软中断（softirq）机制_tiangwan2011的博客-CSDN博客_raise_softirq。 中断下半部 tasklet 就是使用软件中断实现的。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:11:0","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"概念：拆分为上半部、下半部 中断处理的过程中其它中断和进程都无法被处理，中断中要处理的事情实在太多，因此将处理任务拆分为上、下半两个部分，上本部分在 中断处理函数 handler 只处理紧急的事务，然后退出中断，让系统得以正常运行，然后启动下半部分用来处理那些不紧急的事。 在中断上半部中是原子操作（系统自动在处理前和处理后失能中断和使能中断），不能被其它任何中断打断（其它进程不会执行，系统也不能调度（调度是在另一个定时器中断里面进行的）），中断下半部不是原子操作，执行中可以被其它中断打断（可能会被打断多次）。 中断的上半部是 内核驱动程序中 的 中断回调函数里（是原子操作，此时系统其它中断和调度都是停掉的）执行 紧急的、不耗时的（比如就设置相关标志位、变量等），下半部 主要思想是 用 软中断（软中断回调函数里面~）（即 tasklet(小任务)） 或 内核线程（放到一个内核线程的执行队列里（即 work queue(工作队列)），或 每个中断下半部单独开一个内核线程（即 threaded irq(线程化中断)）） 去执行剩余的耗时的、不紧急的任务（比如根据上半部中设置的标志位、变量等 去执行任务），可以被中断打断。 中断下半部的实现有很多种方法，几种主要的：tasklet(小任务)、work queue(工作队列)、threaded irq(线程化中断)。 tasklet(小任务)：软中断回调函数里面，但要注意，下面介绍的几种情况，处理不好会有问题。 work queue(工作队列)：放到一个内核线程的执行队列里，有多个中断下半部的时候，这一个内核线程挨个去处理。 threaded irq(线程化中断)：每个中断单独开一个内核线程去处理，多个中断下半部互相独立处理，多个内核线程可以充分利用多个CPU核心，较高效~ 下半部要做的事情耗时不是太长：tasklet 当下半部比较耗时但是能忍受，并且它的处理比较简单时，可以用tasklet来处理下半部。tasklet 是使用软件中断来实现。 两种情况：注意这里 使用 tasklet 的特殊问题 对于同一个中断，当执行下半部的时候（下半部还没执行完毕的期间内），如果又发生了一次或多次同一个这个中断，那么中断发生几次，上半部就执行几次（比如 n 次），但是下半部只执行 1 次（不会重复执行），直到下半部完全执行完毕，因此要注意这个 n : 1 的关系，中断一次就必须要做一次的事情（比如重要的指示信号）就必须放到上半部，其它的不紧急的事务就放到下半部再做处理。 对于 中断A 在执行 下半部的时候 B 中断 发生，这种情况，A 和 B 的上半部都各执行了一次，因此如果 A 和 B 的下半部都是用软件中断来做的，即都是用 tasklet，那么这个情况和过程中 A 和 B 的下半部也相当于各执行了一次（具体分析看 源码里的 preempt_count 计数机制，100ask 手册的 18.2.5 下半部要做的事情耗时不是太长：tasklet 一节）。 这里说的可能是： 执行多次中断上半部，即执行了多次添加同一个 tasklet 的任务到 队列的操作，如果一次也没有被执行过，那么就只添加了一次，即只会执行一次。 tasklet_schedule 调度 tasklet 时，其中的函数并不会立刻执行，而只是把tasklet 放入队列； 如果tasklet 的函数尚未执行，多次调用 tasklet_schedule 也是无效的，只会放入队列一次。 如果 中断A 早于 中断B，但是 执行中断下半部的时候，A 和 B 的有可能是紧挨着执行的~注意中断下半部不保证即时/实时性。 前面讲的定时器、下半部 tasklet，它们都是在中断上下文中执行，它们无法休眠。当要处理更复杂的事情时，往往更耗时。这些更耗时的工作放在定时器或是下半部中，会使得系统很卡；并且循环等待某件事情完成也太浪费 CPU资源了。 如果使用线程来处理这些耗时的工作，那就可以解决系统卡顿的问题：因为线程可以休眠。 work queue 和 threaded irq 就是使用 内核线程 去处理 中断下半部。 下半部要做的事情太多并且很复杂：work queue 假设下半部要执行1、2分钟，在这1、2分钟里APP都是无法响应的。 所以，如果中断要做的事情实在太耗时，那就不能用软件中断来做，而应该用内核线程来做。内核线程和APP都一样竞争执行，APP有机会执行，系统不会卡顿。 就是说下半部实在太长了，就使用内核线程来执行下半部。做法就是在中断的上半部中 将一个执行下半部任务的函数放入 work 结构体里面，然后 将这个 work 放入 work queue 队列里面，后续 kworker 内核线程 会依次执行 work queue 队列里面 work 里面的函数，也就是下半部。缺点就是 一个 kworker 内核线程只运行在一个 CPU 中，放入它的 work queue 队列里面的函数也都在这一个 CPU 中运行，无法利用多核来分担负载，下面的 threaded irq（线程化中断）可以解决该问题。 应用层的 进程（process）和 系统级线程（pthread） 是基于 内核线程 的抽象，在 Linux 内核中，进程 和 系统级线程 都可以被看作是最小的调度单位。 中断的上、下半部 更多参考 中断的上下半部_天糊土的博客-CSDN博客_中断上下半部。 中断处理“下半部”机制_Arrow的博客-CSDN博客_中断下半部。 Linux的中断处理机制 [一] - 数据结构(1) - 知乎 (zhihu.com)。 Linux的中断处理机制 [二] - 数据结构(2) - 知乎 (zhihu.com)。 Linux的中断处理机制 [三] - hardirq - 知乎 (zhihu.com)。 Linux的中断处理机制 [四] - softirq(1) - 知乎 (zhihu.com)。 Linux的中断处理机制 [五] - softirq(2) - 知乎 (zhihu.com)。 Linux中的中断处理机制 [六] - 从tasklet到中断线程化 - 知乎 (zhihu.com)。 下面具体内容，其例程 引自 100ask，放在了 本仓库的 \\【Linux 通用驱动开发】\\基本字符设备驱动程序-输入-各种内核机制总结\\中断下半部-tasklet-workqueue-threadedirq。 下面主要是使用方法介绍，更具体的 实现原理 可以看 100ask 手册，或者网搜文章，或者问 ChatGPT。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:11:1","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"tasklet：内核线程 处理中断下半部 API： 使用宏 初始化 结构体 struct tasklet_struct 多个 中断下半部 或者 多个其它 “触发-执行一次” 这种任务执行的需求，可以创建多个 tasklet 结构体 做区分， 然后适时用 tasklet_schedule() 函数加入到 软中断 执行队列~ #define DECLARE_TASKLET(name, func, data) \\ struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data } 使用函数 初始化 tasklet 结构体，一般 模块加载 或者 platform_driver 的 probe 里面使用 那就需要先 声明 tasklet 结构体，再取其地址放入 下面 t 参数 void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data); 使能/禁止 tasklet static inline void tasklet_enable(struct tasklet_struct *t); static inline void tasklet_disable(struct tasklet_struct *t); 调度 tasklet，即 把 tasklet 的 任务函数 func（就是中断下半部） 放入执行队列链表，每一次内核软中断时候就 挨个 取出执行 一般在 中断上半部里面使用这个，来添加 tasklet 任务 当使用定时器对按键消抖处理的情况，就是放到 定时器 超时函数里面 static inline void tasklet_schedule(struct tasklet_struct *t); kill tasklet，一般卸载驱动模块的时候使用 extern void tasklet_kill(struct tasklet_struct *t); 注意之处： tasklet_schedule 调度 tasklet 时，其中的函数并不会立刻执行，而只是把tasklet 放入队列； 调用一次tasklet_schedule，只会导致tasklnet 的函数被执行一次； （意识是说，调用一次 tasklet_schedule() ， tasklnet 的函数 最多只执行一次） 如果tasklet 的函数尚未执行，多次调用 tasklet_schedule 也是无效的，只会放入队列一次。 下面这种话语这里会反复提起，要熟悉 这些 机制 之间的特点和不同，选择合适的用于不同的场景~！ 定时器、下半部 tasklet，它们都是在中断上下文中执行，它们无法休眠。当要处理更复杂的事情时，往往更耗时。这些更耗时的工作放在定时器或是下半部中，会使得系统很卡；并且循环等待某件事情完成也太浪费 CPU资源了。 如果使用线程来处理这些耗时的工作，那就可以解决系统卡顿的问题：因为线程可以休眠。 ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:11:2","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"work queue：工作队列 处理中断下半部 工作队列的应用场合：要做的事情比较耗时，甚至可能需要休眠，那么可以使用工作队列。 缺点：多个工作(函数)是在某个内核线程中依序执行的，前面函数执行很慢，就会影响到后面的函数。 在多CPU的系统下，一个工作队列可以有多个内核线程，可以在一定程度上缓解这个问题。 API： 首先说： 在 Linux 系统中已经有了现成的 system_wq 等工作队列（这个 等待队列 里面 存在 内核线程 用于处理 该队列 里被添加的 任务） 下面 首先是 使用这个 工作队列 去当作我们的 中断下半部 使用宏 初始化 结构体 struct work_struct 多个 中断下半部 或者 多个其它 “触发-执行一次” 这种任务执行的需求，可以创建多个 work 结构体 做区分， 然后适时用 schedule_work() 函数加入到 工作队列 ~ #define DECLARE_WORK(n, f) \\ struct work_struct n = __WORK_INITIALIZER(n, f) 使用函数 初始化 work 结构体，一般 模块加载 或者 platform_driver 的 probe 里面使用 那就需要先 声明 work 结构体，再取其地址放入 下面 t 参数 #define INIT_WORK(_work, _func) 调度 tasklet，即 把 tasklet 的 任务函数 func（就是中断下半部） 放入执行队列链表，每一次内核软中断时候就 挨个 取出执行 一般 中断上半部里面使用这个，来添加 tasklet 任务 当使用定时器对按键消抖处理的情况，就是放到 定时器 超时函数里面 schedule_work(); schedule_work 是在系统默认的工作队列上执行一个 work ———————————————————————————————— 下面这里 再介绍 创建 新的 工作队列 的相关 API，然后再使用这个自己新创建的工作队列 但是一般，我个人觉得，任务数量少的话，就只用 上面的 “schedule_work 在系统默认的工作队列上执行一个 work” 就可以了， 然后 任务数量多的话，为了编程简洁，用下面 “threaded irq：中断的线程化处理” 就好了~ create_workqueue 在Linux系统中已经有了现成的system_wq等工作队列，你当然也可以自己调用 create_workqueue 创建工作队列，对于 SMP 系统，这个工作队列会有多个内核线程与它对应，创建工作队列时，内核会帮这个工作队列创建多个内核线程 create_singlethread_workqueue 如果想只有一个内核线程与工作队列对应，可以用本函数创建工作队列，创建工作队列时，内核会帮这个工作队列创建一个内核线程 destroy_workqueue 销毁工作队列 schedule_work 调度执行一个具体的 work，执行的work将会被挂入Linux系统提供的工作队列 schedule_delayed_work 延迟一定时间去执行一个具体的任务，功能与schedule_work类似，多了一个延迟时间 queue_work 跟schedule_work类似，schedule_work 是在系统默认的工作队列上执行一个 work，queue_work需要自己指定工作队列 queue_delayed_work 跟schedule_delayed_work类似，schedule_delayed_work 是在系统默认的工作队列上执行一个work，queue_delayed_work需要自己指定工作队列 flush_work 等待一个 work执行完毕，如果这个 work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 work 已经执行完华才调用本函数，那么直接返回false flush_delayed_work 等待一个 delayed_work执行完毕，如果这个 delayed_work已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 delayed_work已经执行完华才调用本函数，那么直接返回 false 例程-核心部分： #include \u003clinux/workqueue.h\u003e#include \u003casm/current.h\u003e struct work_struct work; static void key_work_func(struct work_struct *work) { struct gpio_key *gpio_key = container_of(work, struct gpio_key, work); int val; val = gpiod_get_value(gpio_key-\u003egpiod); printk(\"key_work_func: the process is %s pid %d\\n\",current-\u003ecomm, current-\u003epid); printk(\"key_work_func key %d %d\\n\", gpio_key-\u003egpio, val); } 在中断回调函数里面（中断上半部） 调用下面，即讲 work 当作中断下半部 放入 系统默认的工作队列中 schedule_work(\u0026work); 一般在 模块加载 或者 platform_driver 的 probe 里面使用 初始化 work 结构体 INIT_WORK(\u0026work, key_work_func); 更多参考文章： https://zhuanlan.zhihu.com/p/91106844 https://www.cnblogs.com/vedic/p/11069249.html https://www.cnblogs.com/zxc2man/p/4678075.html ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:11:3","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["【主线剧情】Linux 系列"],"content":"threaded irq：中断的线程化处理 复杂、耗时的事情，尽量使用内核线程来处理。 以前用work来线程化地处理中断，一个worker线程只能由一个CPU执行，多个中断的work都由同一个worker线程来处理，在单CPU系统中也只能忍着了。但是在SMP系统中，明明有那么多CPU空着，你偏偏让多个中断挤在这个CPU上？（也就是说 work queue 处理的线程都在一个 CPU 上面，对于多 CPU 的 SoC 是浪费资源、CPU 负载很不均衡） threaded irq 即让用户提供一个函数，系统会为这个函数创建一个内核线程。发生中断时，内核线程就会执行这个函数。 新技术 threaded irq，为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个CPU上执行，这提高了效率。 在 Linux系统中，对于存储设备比如 SD/TF卡，它的驱动程序就是这样做的，它有自己的内核线程。 threaded irq（线程化中断）可以 创建 不同的 内核线程（threaded irq 给一个中断单独创建一个内核线程，当中断发生时候 先执行 中断回调函数 来执行上半部，然后运行 threaded irq 前面创建的内核线程 来执行下半部） 运行于 不同的 CPU 核。 使用： 发生中断时，系统会立刻调用 handler函数，然后唤醒某个内核线程，内核线程再来执行thread_fn函数。 可以提供handler而不提供thread_fn，就退化为一般的request_irq函数。 可以不提供handler只提供thread_fn，完全由内核线程来处理中断。即可以只提供thread_fn，系统会为这个函数创建一个内核线程。 也可以既提供handler也提供thread_fn，这就是中断上半部、下半部。 调用request_threaded_irq函数注册中断，调用free_irq卸载中断。 从前面可知，我们可以提供上半部函数 handler，也可以不提供： 如果不提供，内核会提供默认的上半部处理函数：irq_default_primary_handler，它是直接返回 IRQ_WAKE_THREAD，然后执行 thread_fn。 如果提供的话，handler 的返回值必须是：IRQ_WAKE_THREAD，然后执行 thread_fn，在 thread_fn 中，如果中断被正确处理了，应该返回 IRQ_HANDLED。 一般在 模块加载 或者 platform_driver 的 probe 里面使用下面，来注册中断，替代 request_irq： err = request_threaded_irq(gpio_keys_100ask[i].irq, gpio_key_isr, 中断上半部，中断回调函数 gpio_key_thread_func, 中断下半部，新创建内核线程要执行的函数 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, \"100ask_gpio_key\", \u0026gpio_keys_100ask[i]); 中断上半部，中断回调函数 static irqreturn_t gpio_key_isr(int irq, void *dev_id) { struct gpio_key *gpio_key = dev_id; //printk(\"gpio_key_isr key %d irq happened\\n\", gpio_key-\u003egpio); tasklet_schedule(\u0026gpio_key-\u003etasklet); mod_timer(\u0026gpio_key-\u003ekey_timer, jiffies + HZ/50); schedule_work(\u0026gpio_key-\u003ework); return IRQ_WAKE_THREAD; 必须返回这个变量 } 中断下半部，新创建内核线程要执行的函数 static irqreturn_t gpio_key_thread_func(int irq, void *data) { struct gpio_key *gpio_key = data; int val; val = gpiod_get_value(gpio_key-\u003egpiod); printk(\"gpio_key_thread_func: the process is %s pid %d\\n\",current-\u003ecomm, current-\u003epid); printk(\"gpio_key_thread_func key %d %d\\n\", gpio_key-\u003egpio, val); return IRQ_HANDLED; 必须返回这个变量 } ","date":"2022-04-20","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/:11:4","tags":["ARM","Linux"],"title":"【主线剧情07.2】Linux驱动编程-各种内核机制总结","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.2-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%90%84%E7%A7%8D%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"},{"categories":["人与世人的关系"],"content":"给本科实验室的分享PPT-回复各种问题","date":"2021-07-30","objectID":"/9%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt-%E5%9B%9E%E5%A4%8D%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/","tags":["杂谈"],"title":"【杂谈】给本科实验室的分享PPT-回复各种问题","uri":"/9%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt-%E5%9B%9E%E5%A4%8D%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"},{"categories":["人与世人的关系"],"content":"谢邀。该文主要面向实验室的大一、大二同学。 ","date":"2021-07-30","objectID":"/9%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt-%E5%9B%9E%E5%A4%8D%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/:0:0","tags":["杂谈"],"title":"【杂谈】给本科实验室的分享PPT-回复各种问题","uri":"/9%E7%BB%99%E6%9C%AC%E7%A7%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9A%84%E5%88%86%E4%BA%ABppt-%E5%9B%9E%E5%A4%8D%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"},{"categories":["【主线剧情】Linux 系列"],"content":"记 Linux 驱动 相关的基本概念和流程，便于 备查 / 复习","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"驱动程序 中的 设备相关 和 常用内核态 API 总结备查 多处网搜和引用，做了良好的整理，侵删。 本文对应的驱动源代码在 github/gitee 仓库里：并且 在 Github 上的原版文章日后可能会更新，但这里不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:0:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"驱动模块编译和插入与系统版本一致性的重要说明 编译驱动程序： 首先编译一次内核（只一次），再编译驱动程序，因为编译后者需要用到前者编译后产生的一些文件，二者要使用同一套编译器工具链。 即使是不同的编译器，编译后的固件、模块的编排格式都有差异！ 插入驱动模块： 编译驱动时用到的内核和编译器，与要插入的系统的内核的编译器尽量一致，即 内核版本号一致 和 编译器工具链一致，最好 内核源码、编译器 这些 始终 都是同一套东西！ 如果 SoC 板子上 运行的 内核 和 编译驱动时候用到的内核源码的版本不一致，应尽量一致，这种情况也可以插入模块，但是会提示可能会有不兼容的不可预知状况！ 如果 SoC 板子上 运行的 内核 和 编译驱动时候用到的内核源码的版本一致，但是编译器不同！这种情况模块是不能插入的，因为不同编译器的编排固件的格式会有差别，这时应该重新编译内核源码，把得到的 内核固件 zImage 、设备树 和 所有模块 都替换 SoC 板子上的。，就可以解决问题。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:1:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"驱动程序和应用程序开源协议说明 驱动必须得采用和 Linux 内核一样的协议 GPL， 因此驱动程序必须随 Linux 源码一样开源， 好多商家为规避开源自己的核心代码，就将核心代码写在应用程序里面，应用程序不用开源， 由而 应用程序写很复杂 而 驱动写的较简单，由此避开自己的核心代码 带上 GPL 协议。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:2:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"内核 API 查询 Linux内核API|极客笔记 (deepinout.com) 极其好！！！ .etc（用到时候慢慢补充） ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:3:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"驱动程序内的 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"主次设备号相关 在内核中，用dev_t类型(其实就是一个32位的无符号整数)的变量来保存设备的主次设备号，其中高12位表示主设备号，低20位表示次设备号。 设备获得主次设备号有两种方式：一种是手动给定一个32位数，并将它与设备联系起来(即用某个函数注册)；另一种是调用系统函数给设备动态分配一个主次设备号。 与主次设备号相关的3个宏： #define MAJOR(dev) ((dev)\u003e\u003e8) #define MINOR(dev) ((dev) \u0026 0xff) #define MKDEV(ma,mi) ((ma)\u003c\u003c8 | (mi)) MAJOR(dev_t dev)：根据设备号 dev 获得主设备号。 MINOR(dev_t dev)：根据设备号 dev 获得次设备号。 MKDEV(int major, int minor)：根据主设备号 major 和次设备号 minor 构建 dev_t 类型设备号。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:1","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"register_chrdev / unregister_chrdev Linux内核API register_chrdev|极客笔记 (deepinout.com)。 int register_chrdev(unsigned int major, const char*name, struct file_operations *fops); 其中参数major如果等于0，则表示采用系统动态分配的主设备号；不为0，则表示静态注册，范围为 1~255。 name 是注册驱动的名子(出现在 /proc/devices)，fops 是 file_operations 结构。 函数register_chrdev()返回int型的结果，表示设备添加是否成功。如果成功返回0，如果失败返回-ENOMEM, ENOMEM的定义值为12。 Linux内核API unregister_chrdev|极客笔记 (deepinout.com)。 static inline void unregister_chrdev(unsigned int major, const char *name); 第一个输入参数代表即将被删除的字符设备区及字符设备的主设备号，函数将根据此参数查找内核中的字符设备。 第二个输入参数代表设备名，但在函数的实现源码中没有用到，没有什么意义。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:2","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"动态字符设备创建 参考 字符设备驱动编写流程以及大概框架_辣眼睛的Developer的博客-CSDN博客。 这里面讲另外两种创建字符设备方式：cdev 方式 和混杂方式。详情看上面这个链接。 register_chrdev_region：对于 手动/静态 给定一个主次设备号（不推荐），使用以下函数：int register_chrdev_region(dev_t first, unsigned int count, char *name);。其中first是我们手动给定的设备号，count是所请求的连续设备号的个数，而name是和该设备号范围关联的设备名称，它将出现在/proc/devices和sysfs中。比如，若first为0x3FFFF0，count为0x5，那么该函数就会为5个设备注册设备号，分别是0x3FFFF0、 0x3FFFF1、 0x3FFFF2、 0x3FFFF3、 0x3FFFF4。用这种方法注册设备号有一个缺点，那就是若该驱动module被其他人广泛使用，那么无法保证注册的设备号是其他人的Linux系统中未分配使用的设备号。 alloc_chrdev_region：对于动态分配设备号，使用以下函数：int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);。该函数需要传递给它指定的第一个次设备号firstminor(一般为0)和要分配的设备数count，以及设备名，调用该函数后自动分配得到的设备号保存在dev中。**次设备号可以指定，主设备号不能指定只能内核动态分配。**动态分配设备号可以避免手动指定设备号时带来的缺点，但是它却也有自己的缺点，那就是无法预知在/dev下创建设备节点是什么名字，因为动态分配设备号不能保证在每次加载驱动module时始终一致，这个缺点可以避免，因为在加载驱动module后，我们可以读取/proc/devices文件以获得Linux内核分配给该设备的主设备号。 struct cdev { struct kobject kobj; struct module *owner; const struct file_operations *ops; // 文件操作函数 struct list_head list; dev_t dev; //设备号（包括主次设备号） unsigned int count; //设备个数 }; 100ask 的例子，01b_hello_drv 里面的： static struct cdev hello_cdev; static struct file_operations hello_drv = {...}; ... rc = alloc_chrdev_region(\u0026devid, 0, 1, \"hello\"); // 直接动态分配 dev_t 类型的设备号，其中包含了主、次涉设备号 cdev_init(\u0026hello_cdev, \u0026hello_drv); // cdev-\u003eops = fops，将 \u0026hello_drv 赋值给 \u0026hello_cdev-\u003eops cdev_add(\u0026hello_cdev, devid, 1); // 将设备号添加进cdev里的dev设备号成员，并向内核注册cdev 然后就是创建设备类 class_create 和创建设备 device_create 更简明的教程 对 linux驱动 及 字符型设备驱动 的理解_艾特号的博客-CSDN博客。 更多例程：字符设备驱动框架3：深入探讨—完整的驱动代码工程_欧阳海宾的博客-CSDN博客，看看理解就好，这个例子并不通用。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:3","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"class_create / class_destroy Linux内核API class_create|极客笔记 (deepinout.com)。Linux内核API class_destroy|极客笔记 (deepinout.com)。 class_create(owner, name); class_create()用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。此函数的执行效果就是在目录/sys/class下创建一个新的文件夹，此文件夹的名字为此函数的第二个输入参数 name。 owner 一般赋值为 THIS_MODULE。 void class_destroy(struct class *cls); 函数class_destroy()用于删除设备的逻辑类。不返回任何值。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:4","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"device_create / device_destroy Linux内核API device_create|极客笔记 (deepinout.com)。Linux内核API device_destroy|极客笔记 (deepinout.com)。 struct device *device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...); 函数device_create()用于动态地创建逻辑设备，并对新的逻辑设备类进行相应的初始化，将其与此函数的第一个参数所代表的逻辑类关联起来，然后将此逻辑设备加到Linux内核系统的设备驱动程序模型中。函数能够自动地在/sys/devices/virtual目录下创建新的逻辑设备目录，在/dev目录下创建与逻辑类对应的设备文件。 函数device_create()的第一个输入参数代表与即将创建的逻辑设备相关的逻辑类。即class_create()的返回值。 第二个输入参数代表即将创建的逻辑设备的父设备的指针，子设备与父设备的关系是：当父设备不可用时，子设备不可用，子设备依赖父设备，父设备不依赖子设备。不用时可填入 NULL。 第三个输入参数是逻辑设备的设备号。可填入 MKDEV(major, minor)。 第四个输入参数是void类型的指针，代表回调函数的输入参数。不用时可填入 NULL。 第五个输入参数是逻辑设备的设备名，即在目录/sys/devices/virtual创建的逻辑设备目录的目录名。可以用 printf 的格式写，比如 \"drv_%d\",drv_num。 函数device_create()的返回值是struct device结构体类型的指针，指向新创建的逻辑设备。 void device_destroy(struct class *cls, dev_t devt); 函数device_destroy()：用于从Linux内核系统设备驱动程序模型中移除一个设备，并删除/sys/devices/virtual目录下对应的设备目录及/dev目录下对应的设备文件。 函数device_destroy()第一个输入参数是struct class类型的变量，代表与待注销的逻辑设备相关的逻辑类，用于Linux内核系统逻辑设备的查找。即class_create()的返回值。 第二个参数是逻辑设备的设备号，与第一个参数共同确定一个逻辑设备。可填入 MKDEV(major, minor)。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:5","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"module_init / module_exit 修饰本模块的 加载 和 卸载 时候 调用的函数。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:6","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"struct file_operations 参考： file_operations结构体详细解释 - 百度文库 (baidu.com)。 linux内核中struct file_operations 结构体介绍_鱼思故渊的博客-CSDN博客_file_operations结构体。 struct file_operations_zlcchina的博客-CSDN博客。 Linux设备驱动的struct file_operations结构体中unlocked_ioctl和compat_ioctl的区别 - 简书 (jianshu.com)。 Linux中的File_operations结构体-pudn.com。 /* 在 include/linux/fs.h 文件中定义 */ struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); unsigned int (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*aio_fsync) (struct kiocb *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *); #endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64); ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *, u64); }; 重要的成员释义： loff_t (*llseek) (struct file *, loff_t, int); llseek 方法用作改变文件中的当前读/写位置, 并且新位置作为(正的)返回值. loff_t 参数是一个\"long offset\", 并且就算在 32位平台上也至少 64 位宽. 错误由一个负返回值指示. 如果这个函数指针是 NULL（即填入 struct file_operations 结构体这个函数指针为 NULL）, seek 调用会以潜在地无法预知的方式修改 file 结构中的位置计数器( 在\"file 结构\" 一节中描述). ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); 用来从设备中获取数据. 在这个位置的一个空指针导致 read 系统调用以 -EINVAL(“Invalid argument”) 失败. 一个非负返回值代表了成功读取的字节数( 返回值是一个 “signed size” 类型, 常常是目标平台本地的整数类型). ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); 发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数. read_iter 和 write_iter 异步读 和 异步写，即完成操作之前就返回。而从4.1版本开始，关于异步读写的函数已经被read_iter和write_iter取代了。 Linux内核4.1在file_operations的read_iter和write_iter_潜行金枪鱼的博客-CSDN博客。 unsigned int (*poll) (struct file *, struct poll_table_struct *); poll 方法是 3 个系统调用的后端: poll, epoll, 和 select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞. poll 方法应当返回一个位掩码指示是否非阻塞的读或写是可能的, 并且, 可能地, 提供给内核信息用来使调用进程睡眠直到 I/O 变为可能. 如果一个驱动的 poll 方法为 NULL, 设备假定为不阻塞地可读可写. int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); ioctl 系统调用提供了发出设备特定命令的方法. 另外, 几个 ioctl 命令被内核识别而不必引用 fops 表. 如果设备不提供 ioctl 方法, 对于任何未事先定义的请求(-ENOTTY, “设备无这样的 ioctl”), 系统调用返回一个错误. int (*mmap) (struct file *, struct vm_area_struct *); mmap 用来请求将设备内存映射到进程的地址空间. 如果这个方法是 NULL, mmap 系统调用返回 -ENODEV. int (*open) (struct inode *, struct file *); 尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是你的驱动不会得到通知. int (*flush) (struct file *); 很少用 flush 操作在进程关闭它的设备文件描述符的拷贝时调用; 它应当执行(并且等待)设备的任何未完成的操作. 这个必须不要和用户查询请求的 fsync 操作混淆了. 当前, flush 在很少驱动中使用; SCSI 磁带驱动使用它, 例如,","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:7","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"总线平台驱动相关 参考 Linux Platform驱动模型(一) _设备信息_Neilo_chen的博客-CSDN博客，关于platform_device一些讲解_Leo丶Fun的博客-CSDN博客_platform_device。 详细用例 Linux 设备驱动开发 —— platform设备驱动应用实例解析_zqixiao_09的博客-CSDN博客_linux设备驱动开发。设备树——platform_driver_7个棋的博客-CSDN博客_platform_driver。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:8","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"dts 和 device 和 driver 文件位置 dts： 可以在 shell 中查看当前已经装载的设备树：/sys/firmware/devicetree 目录下是以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件。这些属性的值如果是字符串，可以使用cat命令把它打印出来；对于数值，可以用hexdump把它打印出来。（一个单板启动时，u-boot先运行，它的作用是启动内核。U-boot会把内核和设备树文件都读入内存，然后启动内核。在启动内核时会把设备树在内存中的地址告诉内核。） driver ：/sys/bus/platform/drivers，platform 总线下注册的驱动都在这了。 device：/sys/devices/platform。 platform_device 的信息：/sys/devices/platform 目录含有注册进内核的所有 platform_device。一个设备对应一个目录，进入某个目录后，如果它有 “driver” 子目录，就表示这个platform_device跟某个platform_driver配对了。设备树被系统解析后生成的 platform_device 可以在这里面找到。 platform_driver 的信息：/sys/bus/platform/drivers 目录含有注册进内核的所有 platform_driver。一个driver对应一个目录，进入某个目录后，如果它有配对的设备，可以直接看到（一个平台设备只能配对一个平台驱动，一个平台驱动可以配对多个平台设备）。在装载 驱动程序中的 driver 的模块 之后就可以在 这个目录看到对应的 driver。 结构体成员只取一部分进行展示。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:9","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"platform_driver_register/unregister platform_device 详细 //include/linux/platform_device.h 22 struct platform_device { 23 const char *name; 24 int id; 25 bool id_auto; 26 struct device dev; 27 u32 num_resources; 28 struct resource *resource; 29 30 const struct platform_device_id *id_entry; 31 32 /* MFD cell pointer */ 33 struct mfd_cell *mfd_cell; 34 35 /* arch specific additions */ 36 struct pdev_archdata archdata; 37 }; --23--\u003ename就是设备的名字，注意， 模块名(lsmod)!=设备名(/proc/devices)!=设备文件名(/dev)，这个名字就是驱动方法和设备信息匹配的桥梁 --24--\u003e表示这个platform_device对象表征了几个设备，当多个设备有共用资源的时候(MFD)，里面填充相应的设备数量，如果只是一个，填-1 --26--\u003e父类对象(include/linux/device.h +722)，我们通常关心里面的platform_data和release,前者是用来存储私有设备信息的，后者是供当这个设备的最后引用被删除时被内核回调，注意和rmmod没关系。 --27--\u003e资源的数量，即resource数组中元素的个数，我们用ARRAY_SIZE()宏来确定数组的大小(include/linux/kernel.h +54 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) ) --28--\u003e资源指针，如果是多个资源就是struct resource[]数组名， struct device { void *driver_data; /* data private to the driver */ void *platform_data; /* Platform specific data, device core doesn't touch it */ struct device_node *of_node; /* associated device tree node */ /* 支持设备树的 device 用于匹配 支持设备树的 driver */ void (*release)(struct device *dev); ... }; struct device_node { const char *name; const char *type; phandle phandle; const char *full_name; struct property *properties; /* 含有 compatible 属性，用于匹配 支持设备树的 driver */ }; struct resource { resource_size_t start; //资源的起始值 resource_size_t end; //资源的结束值 const char *name; unsigned long flags; //资源的类型，如 IORESOURCE_IO,IORESOURCE_MEM,IORESOURCE_IRQ,IORESOURCE_DMA struct resource *parent, *sibling, *child; }; start表示资源开始的位置，如果是IO地址资源，就是起始物理地址，如果是中断资源，就是中断号; end表示资源结束的位置，如果是IO地址地址，就是映射的最后一个物理地址，如果是中断资源，就不用填; name就是这个资源的名字。 flags表示资源类型，提取函数在寻找资源的时候会对比自己传入的参数和这个成员，理论上只要和可以随便写，但是合格的工程师应该使用内核提供的宏，这些宏也在\"ioport.h\"中进行了定义，比如IORESOURCE_MEM表示这个资源是地址资源，IORESOURCE_IRQ表示这个资源是中断资源 //include/linux/ioport.h #define IORESOURCE_BITS 0x000000ff /* Bus-specific bits */#define IORESOURCE_TYPE_BITS 0x00001f00 /* Resource type */#define IORESOURCE_IO 0x00000100 /* PCI/ISA I/O ports */#define IORESOURCE_MEM 0x00000200 #define IORESOURCE_REG 0x00000300 /* Register offsets */#define IORESOURCE_IRQ 0x00000400 #define IORESOURCE_DMA 0x00000800 #define IORESOURCE_BUS 0x00001000 ... #define DEFINE_RES_IO(_start, _size) #define DEFINE_RES_MEM(_start, _size) #define DEFINE_RES_IRQ(_irq) #define DEFINE_RES_DMA(_dma) 下面是一个资源数组的实例，多个资源的时候就写成数组 struct resource res[] = { [0] = { .start = 0x10000000, .end = 0x20000000-1, .flags = IORESOURCE_MEM }, [1] = DEFINE_RES_MEM(0x20000000, 1024), [2] = { .start = 10, //中断号 .flags = IORESOURCE_IRQ|IRQF_TRIGGER_RISING //include/linux/interrupt.h }, [3] = DEFINE_RES_IRQ(11), }; ————————————另一个例子——————————————— static struct resource pxa27x_ohci_resources[] = { [0] = { .start = 0x4C000000, .end = 0x4C00ff6f, .flags = IORESOURCE_MEM, }, [1] = { .start = IRQ_USBH1, .end = IRQ_USBH1, .flags = IORESOURCE_IRQ, }, }; static struct platform_device ohci_device = { .name = \"pxa27x-ohci\", .id = -1, .dev = { .dma_mask = \u0026pxa27x_dmamask, .coherent_dma_mask = 0xffffffff, }, .num_resources = ARRAY_SIZE(pxa27x_ohci_resources), // 这里填入 struct resource 结构体数组的 结构体个数 .resource = pxa27x_ohci_resources, }; ———————————100ask例子——————————————————— static struct resource resources[] = { { .start = GROUP_PIN(3,1), .flags = IORESOURCE_IRQ, .name = \"100ask_led_pin\", }, { .start = GROUP_PIN(5,8), .flags = IORESOURCE_IRQ, .name = \"100ask_led_pin\", }, }; static struct platform_device board_A_led_dev = { .name = \"100ask_led\", .num_resources = ARRAY_SIZE(resources), .resource = resources, .dev = { .release = led_dev_release, }, }; /** *注册：把指定设备添加到内核中平台总线的设备列表，等待匹配,匹配成功则回调驱动中probe； */ int platform_device_register(struct platform_device *); /** *注销：把指定设备从设备列表中删除，如果驱动已匹配则回调驱动方法和设备信息中的release； */ void platform_device_unregister(struct platform_device *); // 通常，我们会将platform_device_register写在模块加载的函数中，将platform_device_unregister写在模块卸载函数中。 platform_driver 详细 struct platform_driver { int (*probe)(struct platf","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:10","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"ioctl 可以参考： ioctl函数详解（参数详解，驱动unlocked_ioctl使用、命令码如何封装）_相望@于江湖的博客-CSDN博客_ioctl函数参数。 Linux驱动学习6（ioctl的实现） - 灰信网（软件开发博客聚合） (freesion.com)。 （八）linux驱动之ioctl的使用 - 灰信网（软件开发博客聚合） (freesion.com)。 linux驱动开发(四)：ioctl()函数_精致的螺旋线的博客-CSDN博客_ioctl函数linux。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:11","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"等待队列 wait_queue 可参考： 小白学Linux——等待队列（waitqueue）_蚝油生菜的博客-CSDN博客_linux等待队列。源码分析。 基本字符设备驱动程序-输入 文件夹内基本字符设备驱动程序获取数据的说明.md 中的 休眠-唤醒 机制 一节。里面有说明都有什么 API，并且有程序例子。 初始化 用一个宏，定义静态的 static DECLARE_WAIT_QUEUE_HEAD(gpio_key_wait); 或用函数，动态的 wait_queue_head_t wq; init_waitqueue_head (\u0026wq); static inline void init_waitqueue_head(wait_queue_head_t *q) { q-\u003elock = SPIN_LOCK_UNLOCKED; INIT_LIST_HEAD(\u0026q-\u003etask_list); } wait_event(wq, condition)：调用wait_event宏定义后进程进入睡眠状态直到传入的条件为真。该进程进入睡眠状态(TASK_UNINTERRUPTIBLE)，直到条件为真。每次唤醒等待队列wq时都会检查条件。休眠，直到condition为真； 退出的唯一条件是condition为真，信号也不能打断。 wait_event_interruptible(wq, condition)：调用wait_event_interruptible宏定义后进程进入睡眠状态直到传入的条件为真。该进程进入睡眠状态(TASK_INTERRUPTIBLE)，直到条件为真或者收到信号。每次唤醒等待队列wq时都会检查条件。如果睡眠期间被信号中断，该函数将返回 -ERESTARTSYS，如果条件为真，则返回0。休眠，直到condition为真； 休眠期间是可被打断的，可以被信号打断。 wake_up(x)：从处于不可中断睡眠状态的等待队列中唤醒一个进程。 唤醒x队列中状态为 “TASK_INTERRUPTIBLE” 或 “TASK_UNINTERRUPTIBLE” 的线程，只唤醒其中的一个线程。 wake_up_interruptible(x)：从处于可中断睡眠状态的等待队列中唤醒一个进程。唤醒x队列中状态为 “TASK_INTERRUPTIBLE” 的线程，只唤醒其中的一个线程。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:4:12","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"其它用到的 设备相关API ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"copy_from_user / copy_to_user 内核空间 的数据与 应用/用户进程 的数据相互之间的拷贝。 初步解析内核函数copy_to_user和copy_from_user_江东风又起的博客-CSDN博客_copy_to_user。 linux系统中copy_to_user()函数和copy_from_user()函数的用法_fxfreefly的博客-CSDN博客_copytouser函数。 unsigned long copy_from_user(void *to, const void __user *from, unsigned long n); /* 失败返回没有被拷贝的字节数，成功返回 0 */ unsigned long copy_to_user(void __user *to, const void *from, unsigned long n); /* 成功返回 0，失败返回没有拷贝成功的数据字节数 */ ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:1","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"ioremap / iounmap 用来将物理地址映射到一个虚拟地址，内核进程通过该虚拟地址访问到实际物理地址，安全。 把物理地址phys_addr开始的一段空间(大小为size)，映射为虚拟地址；返回值是该段虚拟地址的首地址。 virt_addr = ioremap(phys_addr, size); 实际上，它是按页(4096字节)进行映射的，是整页整页地映射的。 假设phys_addr = 0x10002，size=4，ioremap的内部实现是： a. phys_addr按页取整，得到地址0x10000 b. size按页取整，得到4096 c. 把起始地址0x10000，大小为4096的这一块物理地址空间，映射到虚拟地址空间， 假设得到的虚拟空间起始地址为0xf0010000 d. 那么phys_addr = 0x10002对应的virt_addr = 0xf0010002 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:2","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"EXPORT_SYMBOL 变量或函数的导出，表示这些变量对内核公开，其它模块可以访问到，否则访问是 NULL。 使用方法： 就在 驱动程序 .h 文件里面 声明所有要 导出的 函数、变量 和结构体结构（不是结构体变量的定义，而是结构体本身定义放到 驱动程序的 .h 文件里）等，并且都加上 extern 修饰，函数除外。 在驱动程序里面 定义和初始化这些函数、变量和结构体等。 在 其它要用到 这些 函数和变量的 模块 的驱动文件里面 include 前面的驱动程序 .h 文件，然后就可以直接调用了。 a.c编译为a.ko，里面定义了func_a；如果它想让b.ko使用该函数，那么a.c里需要导出此函数。即 如果 a.c, b.c 分别编译出两个 .ko，即 a.ko 和 b.ko，则需使用这个来导出。并且，使用时要先加载a.ko。如果先加载b.ko，会有类似如下“Unknown symbol”的提示。 如果 a.c, b.c 编译在一起，编译出一个 .ko，则无需使用这个来导出。 EXPORT_SYMBOL的作用是什么 (eepw.com.cn)。 linux export_symbol 变量,Linux的EXPORT_SYMBOL和EXPORT_SYMBOL_GPL的使用和区别_App小公主的博客-CSDN博客。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:3","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"file_inode / iminor 参考 字符设备驱动框架2：设备文件(设备节点)如何和驱动建立联系-Linux字符设备中的两个重要结构体(file、inode)_欧阳海宾的博客-CSDN博客 就比较清楚了。 一般而言在驱动程序的设计中，会关系 struct file 和 struct inode 这两个结构体。 用户空间使用open()系统调用函数打开一个字符设备时（ int fd = open(“dev/demo”, O_RDWR) ）大致有以下过程： 在虚拟文件系统VFS中的查找对应与字符设备对应 struct inode节点 遍历字符设备列表（chardevs数组），根据inod节点中的 cdev_t设备号找到cdev对象 创建struct file对象（系统采用一个数组来管理一个进程中的多个被打开的设备，每个文件秒速符作为数组下标标识了一个设备对象） 初始化struct file对象，将 struct file对象中的 file_operations成员指向 struct cdev对象中的 file_operations成员（file-\u003efops = cdev-\u003efops） 回调file-\u003efops-\u003eopen函数 inode 结构体 ​ VFS inode 包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux 管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。 ​ 内核使用inode结构体在内核内部表示一个文件。因此，它与表示一个已经打开的文件描述符的结构体(即file 文件结构)是不同的，我们可以使用多个file 文件结构表示同一个文件的多个文件描述符，但此时，所有的这些file文件结构全部都必须只能指向一个inode结构体。 inode结构体包含了一大堆文件相关的信息，但是就针对驱动代码来说，我们只要关心其中的两个域即可： dev_t i_rdev; 表示设备文件的结点，这个域实际上包含了设备号。 struct cdev *i_cdev;　struct cdev是内核的一个内部结构，它是用来表示字符设备的，当inode结点指向一个字符设备文件时，此域为一个指向inode结构的指针。 file 文件结构体 ​ 在设备驱动中，这也是个非常重要的数据结构，必须要注意一点，这里的file与用户空间程序中的FILE指针是不同的，用户空间FILE是定义在C库中，从来不会出现在内核中。而struct file，却是内核当中的数据结构，因此，它也不会出现在用户层程序中。 ​ file结构体指示一个已经打开的文件（设备对应于设备文件），其实系统中的每个打开的文件在内核空间都有一个相应的struct file结构体，它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数，直至文件被关闭。如果文件被关闭，内核就会释放相应的数据结构。 在内核源码中，struct file要么表示为file，或者为filp(意指“file pointer”), 注意区分一点，file指的是struct file本身，而filp是指向这个结构体的指针。 参考 Linux中的File_operations结构体-pudn.com。 struct inode被内核用来代表一个文件，注意和struct file的区别，struct inode一个是代表文件，struct file一个是代表打开的文件 struct inode包括很重要的二个成员： dev_t i_rdev 设备文件的设备号 struct cdev *i_cdev 代表字符设备的数据结构 struct inode结构是用来在内核内部表示文件的.同一个文件可以被打开好多次,所以可以对应很多struct file,但是只对应一个struct inode. 在 xxx_write() 和 xxx_read() 函数里面，实际控制一个设备类下面的哪一个设备，根据子设备号，获取通过 file_inode() 根据 file 得到文件的 inode，再用 iminor() 根据 inode 得到子/次设备号。 /* 提取主设备号 */ static inline unsigned imajor(const struct inode *inode) { return MAJOR(inode-\u003ei_rdev); } /* 提取次设备号 */ static inline unsigned iminor(const struct inode *inode) { return MINOR(inode-\u003ei_rdev); } 在 xxx_open() 和 xxx_close() 里面 可以根据 int minor = iminor(node); 直接获得次设备号（来或者这一个外设的哪一个具体资源）。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:4","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"devm_kzalloc / devm_kfree 这个功能分配的内存会在驱动卸载时自动释放。参考 linux内核中的devm_kzalloc_不止冬雷和夏雪的博客-CSDN博客_devm_kzalloc。 void * devm_kzalloc (struct device * dev, size_t size, gfp_t gfp); void devm_kfree(struct device * dev，void * p); 参数 dev 是 申请内存的目标设备 device，其它参数与 kzalloc一致。 以下为 request/region/release 相关 API，不常用。 参考 linux （platform_driver）平台设备驱动常用API函数 (icode9.com)。 申请内存资源函数 request_region request_mem_region devm_request_region devm_request_mem_region 释放内存资源 release_region release_ mem_region devm_release_region devm_release_mem_region ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:5:5","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"常用内核态 API ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:0","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"内存申请 一文说明清楚：Linux内核空间内存申请函数kmalloc、kzalloc、vmalloc的区别【转】_danxibaoxxx的博客-CSDN博客。 更多 API Linux内核API 内存管理|极客笔记 (deepinout.com)。 linux中kmalloc函数详解_fulinux的博客-CSDN博客_kmalloc linux。 kmalloc() #include \u003clinux/slab.h\u003e void *kmalloc(size_t size, gfp_t flags); void kfree(const void *objp); kmalloc() 申请的内存位于物理内存映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。 较常用的 flags（分配内存的方法）： GFP_ATOMIC —— 分配内存的过程是一个原子过程，分配内存的过程不会被（高优先级进程或中断）打断； GFP_KERNEL —— 正常分配内存； GFP_DMA —— 给 DMA 控制器分配内存，需要使用该标志（DMA要求分配虚拟地址和物理地址连续）。 更多 标志位 的列举 linux中kmalloc函数详解_fulinux的博客-CSDN博客_kmalloc函数。 下文引自 linux 字符驱动 申请内存最大,Linux驱动技术(一) _内存申请_一只小短腿的博客-CSDN博客。 GFP_KERNEL是最常用的flag，注意，使用这个flag来申请内存时，如果暂时不能满足，会引起进程阻塞，So，一定不要在中断处理函数、tasklet和内核定时器等非进程上下文中使用GFP_KERNEL！ kzalloc() #include \u003clinux/slab.h\u003e /** * kzalloc - allocate memory. The memory is set to zero. * @size: how many bytes of memory are required. * @flags: the type of memory to allocate (see kmalloc). */ static inline void *kzalloc(size_t size, gfp_t flags) { return kmalloc(size, flags | __GFP_ZERO); } void kfree(const void *objp); kzalloc() 函数与 kmalloc() 非常相似，参数及返回值是一样的，可以说是前者是后者的一个变种，因为 kzalloc() 实际上只是额外附加了 __GFP_ZERO 标志。所以它除了申请内核内存外，还会对申请到的内存内容清零。 kzalloc() 对应的内存释放函数也是 kfree()。 vmalloc() #include \u003clinux/vmalloc.h\u003e#include \u003clinux/init.h\u003e#include \u003clinux/module.h\u003e void *vmalloc(unsigned long size); void vfree(const void *addr); vmalloc() 函数则会在虚拟内存空间给出一块连续的内存区，但这片连续的虚拟内存在物理内存中并不一定连续。由于 vmalloc() 没有保证申请到的是连续的物理内存（所以不能用来做DMA之类的操作），对申请的内存大小没有限制，如果需要申请较大的内存空间就需要用此函数了。 注意：vmalloc() 和 vfree() 可以睡眠，因此不能从中断上下文调用。 vmalloc() 还会调用使用GFP_KERN的kmalloc，一定不要在中断处理函数、tasklet和内核定时器等非进程上下文中使用 vmalloc！ 总结 kmalloc()、kzalloc()、vmalloc() 的共同特点是： 用于申请内核空间的内存； 内存以字节为单位进行分配； 所分配的内存虚拟地址上连续； kmalloc()、kzalloc()、vmalloc() 的区别是： kzalloc 是强制清零的 kmalloc 操作；（以下描述不区分 kmalloc 和 kzalloc） kmalloc 分配的内存大小有限制（128KB），而 vmalloc 没有限制； kmalloc 可以保证分配的内存物理地址是连续的，但是 vmalloc 不能保证； kmalloc 分配内存的过程可以是原子过程（使用 GFP_ATOMIC），而 vmalloc 分配内存时则可能产生阻塞； kmalloc 分配内存的开销小，因此 kmalloc 比 vmalloc 要快； 一般情况下，内存只有在要被 DMA 访问的时候才需要物理上连续，但为了性能上的考虑，内核中一般使用 kmalloc()，而只有在需要获得大块内存时才使用 vmalloc()。例如，当模块被动态加载到内核当中时，就把模块装载到由 vmalloc() 分配的内存上。 引自 100ask 手册 kmalloc 分配到的内存物理地址是连续的 kzalloc 分配到的内存物理地址是连续的，内容清 0 vmalloc 分配到的内存物理地址不保证是连续的 vzalloc 分配到的内存物理地址不保证是连续的，内容清 0 内核驱动中的内存用于mmap 引自 100ask 手册 我们应该使用 kmalloc 或 kzalloc，这样得到的内存物理地址是连续的，在 mmap 时后 APP 才可以使用同一个基地址去访问这块内存。(如果物理地址不连续，就要执行多次 mmap了)。 引自 mmap函数_vmalloc与mmap_weixin_39611161的博客-CSDN博客。 需要映射到用户空间的内存段，不能直接利用vmalloc()分配，而应该使用**vmalloc_user()**函数。 Linux内核API vmalloc_user|极客笔记 (deepinout.com)。 vmalloc_user() 的测试：Linux内核 vmalloc_user()|酷客网 (coolcou.com)。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:1","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"likely 与 unlikely 引自 linux内核中likely与unlikely_夜风~的博客-CSDN博客_linux unlikely。 简单从表面上看 if( likely(value) ){ } 和 if(unlikely(value)){ }else{ }。 也就是likely和unlikely是一样的，但是实际上执行是不同的，加likely的意思是value的值为真的可能性更大一些，那么执行if的机会大，而unlikely表示value的值为假的可能性大一些，执行else机会大一些。 加上这种修饰，编译成二进制代码时likely使得if后面的执行语句紧跟着前面的程序，unlikely使得else后面的语句紧跟着前面的程序，这样就会被cache预读取，增加程序的执行速度。 用来引导gcc进行条件分支预测。在一条指令执行时，由于流水线的作用，CPU可以同时完成下一条指令的取指，这样可以提高CPU的利用率。在执行条件分支指令时，CPU也会预取下一条执行，但是如果条件分支的结果为跳转到了其他指令，那CPU预取的下一条指令就没用了，这样就降低了流水线的效率。 简单理解： likely(x) 代表 x 是 逻辑真 的可能性比较大。 unlikely(x) 代表 x 是 逻辑假 的可能性比较大。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:2","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"内核中错误处理 参考： linux中ERR_PTR、PTR_ERR、IS_ERR和IS_ERR_OR_NULL_夜风~的博客-CSDN博客_linux ptr。 Linux内核使用ERR_PTR和PTR_ERR等函数来实现指针函数返回错误码_tanglinux的博客-CSDN博客。 Linux 内核IS_ERR函数 - 简书 (jianshu.com)。 【Linux内核】Linux的errno和ERR_PTR、PTR_ERR简介_gccwdn的博客-CSDN博客。 linux内核中判断返回指针是否错误的内联函数主要有：ERR_PTR、PTR_ERR、IS_ERR 和 IS_ERR_OR_NULL等。 在写设备驱动程序的过程中，涉及到的任何一个指针，必然有三种情况： 有效指针； NULL，空指针； 错误指针，或者说无效指针。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:3","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"内核中对字符串的操作 具体 API 用法看 linux内核驱动中对字符串的操作【转】 - 走看看 (zoukankan.com)。 #include \u003clinux/string.h\u003e int strnicmp(const char *s1, const char *s2, size_t len) int strcasecmp(const char *s1, const char *s2) int strncasecmp(const char *s1, const char *s2, size_t n) char *strcpy(char *dest, const char *src) char *strncpy(char *dest, const char *src, size_t count) size_t strlcpy(char *dest, const char *src, size_t size) char *strcat(char *dest, const char *src) char *strncat(char *dest, const char *src, size_t count) size_t strlcat(char *dest, const char *src, size_t count) int strcmp(const char *cs, const char *ct) int strncmp(const char *cs, const char *ct, size_t count) char *strchr(const char *s, int c) char *strrchr(const char *s, int c) char *strnchr(const char *s, size_t count, int c) char *skip_spaces(const char *str) char *strim(char *s) size_t strlen(const char *s) size_t strnlen(const char *s, size_t count) char *strpbrk(const char *cs, const char *ct) char *strsep(char **s, const char *ct) bool sysfs_streq(const char *s1, const char *s2) void *memset(void *s, int c, size_t count) void *memcpy(void *dest, const void *src, size_t count) void *memmove(void *dest, const void *src, size_t count) int memcmp(const void *cs, const void *ct, size_t count) void *memscan(void *addr, int c, size_t size) char *strstr(const char *s1, const char *s2) char *strnstr(const char *s1, const char *s2, size_t len) void *memchr(const void *s, int c, size_t n) ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:4","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 内核常见宏的作用 Linux内核常见宏的作用_-CSDN博客。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:5","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 内核中随机数函数 参考 了解从Linux内核中获取真随机数_Linux加油站的博客-CSDN博客_linux 真随机数。 ","date":"2022-04-18","objectID":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/:6:6","tags":["ARM","Linux"],"title":"【主线剧情07.3】Linux驱动编程-内核态API总结备查","uri":"/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8507.3-linux%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E6%80%81api%E6%80%BB%E7%BB%93%E5%A4%87%E6%9F%A5/"},{"categories":["【直达本质入门】系列"],"content":"就是超快 STM32 系统入门的指南啊~","date":"2021-09-03","objectID":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","tags":["硬件","STM32","软件"],"title":"超快 STM32 系统入门指南","uri":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"categories":["【直达本质入门】系列"],"content":"计算机类的教程多，框架和 API 用法讲的全面，成系统的教程很多，CSDN上、知乎上很多个人学习记录和全面的成书的教程，而且生动形象有甚至有动画讲解，回过头来看嵌入式的教程，又臭又长。本文 Github 地址。 两种学习模式，一种是从底层开始看大厚书学习，但这只适合那些理解能力和前后关联能力强甚至有天赋的人来看，说白了不是设计给新人看的，而是给熟练的人当字典来看的，现在学校的课本一上来直接怼抽象的概念和公式，可能导致的在网上写教程的也有这毛病，不人性化。另一种学习是面向应用来学，就是下面要说的，是 “真-面向应用”，对于超快 STM32 入门来说就是：听正常人能理解的句子来了解外设概念和意义，然后直接从 API 入手。 这篇文章需要有 基本数模电和单片机的概念、C 语言基础和良好英文（或翻译）。 ","date":"2021-09-03","objectID":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/:0:0","tags":["硬件","STM32","软件"],"title":"超快 STM32 系统入门指南","uri":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"categories":["【直达本质入门】系列"],"content":"第一个外设 这时候可以备好 STM32 编程手册《STM32F10xxx参考手册》。 GPIO（General-purpose input/output）为通用目的输入输出口，所谓通用即不只可以用软件控制高低电平的变化，还有输入、开漏等功能，根据不同应用场景配置成不同功能。以下是该外设的内部数字电路的电路框图。 该图就是 STM32 芯片 里面 GPIO 外设部分的真实存在的电路的框图。 下面两个 P-MOS 和 N-MOS 就是控制输出 I/O 口的高低电平，如果 P-MOS 导通，则输出高电平，这称为 “推挽输出” 模式，输出有一定的驱动能力，输出高电平为 芯片供电电压，即 3.3V，低电平为接地，即 0V，可以先这么理解。 如果 下面两个 P-MOS 和 N-MOS 均不导通，那就是 “浮空输入” 模式，外接的高低电平可以读入，外部接上按键，就可以用按键控制东西。 如果 输出的时候是 P-MOS 一直处于关闭状态，而只有 N-MOS 打开或关闭，那就是 “开漏输出” 模式，在该口上拉一个电阻到 Vref 电压，那么输出高电平就是 Vref 电压，这么做可以改变输出高电平的电压，可以任定，而不是上面 “推挽输出” 时候固定的 3.3V。 图中还有还有上、下拉电阻，还有复用功能，就是配置别的外设比如 SPI、PWM 等的输出要从此 I/O 输出，这些功能组合可以得到这些模式：输入浮空、输入上拉、输入下拉、模拟输入、开漏输出、推挽式输出、推挽式复用功能、开漏复用功能。 ","date":"2021-09-03","objectID":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/:1:0","tags":["硬件","STM32","软件"],"title":"超快 STM32 系统入门指南","uri":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"categories":["【直达本质入门】系列"],"content":"进入主题 下载、安装和会用 STM32CubeMX 软件。 STM32CubeMX 新建一个工程，选择 STM32F103C8T6，将 PA8 设为 推挽输出模式，如下图。 导出工程。路径不要有中文和空格，IDE 选择 MDK（即 Keil 5），右上角生成。 打开 MDK 工程。 打开 main.c 即看到写用户程序的地方，我们在 STM32CubeMX 软件里面图形化的配置了一个推挽输出模式的 PA8 引脚，所以现在工程中有了一个 MX_GPIO_Init() 函数，里面就是通过 HAL 库配置该 I/O 的程序。下面添加上注释来说明。 /* 声明一个 GPIO_InitTypeDef 类型的结构体 名叫 GPIO_InitStruct，该结构体打包了配置 I/O 的所有参数，填这个结构体即可 */ GPIO_InitTypeDef GPIO_InitStruct = {0}; /* 使能 GPIO 的时钟，STM32 中，每个外设都要有时钟信号做驱动，数字电路尤其是时序、同步逻辑电路，当然都需要时钟 */ /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); /* 预先设置该 I/O 的输出电压。在初始化之前，I/O 是浮空的，当初始化完毕之后 I/O 立马变为设置的高或低电平 */ /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET); /* 配置 I/O，结构体 GPIO_InitStruct 共有 Pin、Mode、Pull 和 Speed 这几个参数，分别填为 I/O口 8、推挽输出、没有上下拉电阻、翻转速度为低 然后调用 HAL_GPIO_Init() 函数，填入 结构体 GPIO_InitStruct 的指针，该函数会根据结构体 GPIO_InitStruct 里面的参数配置 I/O 的寄存器 */ /*Configure GPIO pin : PA8 */ GPIO_InitStruct.Pin = GPIO_PIN_8; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, \u0026GPIO_InitStruct); 那么问题就来了，结构体 GPIO_InitStruct 共有 Pin、Mode、Pull 和 Speed 这几个参数，除此之外，库里面外设那么多，每个外设都有好几个结构体和那么多 API，我怎么知道怎么用？ 先进行全编译，如下图。不全编译不能做下一步的 “跳转”。 在 GPIO_InitTypeDef 上面右击，选择 Go To Definition Of 'GPIO_InitTypeDef'，即可跳转到 stm32f1xx_hal_gpio.h 文件里面 该结构体类型定义的地方。 在这里面，一目了然，该结构体都有哪些参数，每一个参数都是做什么的，如下图。 那么每一个参数可以填写的值，HAL 库也有定义，每一项后面都有注释，比如上图的 Mode 参数，注释说 可填入的值 参考 GPIO_mode_define这里，那么就 按快捷键 ctrl+f 调出搜索框，填入GPIO_mode_define搜索，如下图，找到这些宏定义。其中GPIO_MODE_INPUT就是浮空输入模式，GPIO_MODE_OUTPUT_OD就是开漏输出模式，GPIO_MODE_ANALOG就是模拟输入模式（用于 ADC 模数转换外设引脚），带有 AF 字样的就是复用功能，带有 IT 字样的就是中断功能。 HAL 库好就好在，每个外设的配置流程和结构体、宏定义的命名非常规范，命名有意义而且有规律。结构体知道怎么填写了，那么想知道一个外设有哪些 API，就在每一个外设的 .h 文件里面。还在stm32f1xx_hal_gpio.h里面，如下图所示，就是 GPIO 外设所有的可供用户调用的函数，即Exported functions部分。其中HAL_GPIO_Init()为初始化函数，HAL_GPIO_ReadPin()为读 I/O 电平函数，HAL_GPIO_WritePin()为写 I/O 电平函数，等等。 还有最后一件事，这些 API 在哪里使用，比如初始化时候先用什么后用什么，这些也在源码注释里有详细的介绍，请打开stm32f1xx_hal_gpio.c文件，拉到最上面，如下图。两大块，第一个GPIO Peripheral features就是介绍该外设的特性，即能做什么，另一个How to use this driver就是细致介绍如何使用这些 API，即怎么做，需要会英文或者用翻译哈。这里介绍的是 GPIO 外设，HAL 库具有一贯性，对于每一个外设的源文件和组织形式都是这样的哈，比较人性化。 我跟你讲，大多数第一个写教程的，基本都是看源码、看源码注释和看官方手册，再加上不断测试、验证想法而得到足够多经验的时候才学会的，所以我这里把这个从源头获取技能的流程介绍一遍，是更有用的。 该工程还包括的函数SystemClock_Config()用于 STM32 时钟（RCC）初始化，其它还包括 STM32 的众多外设，在此不多做介绍，渔已经演示了。还有一些底层概念需要了解，接着往下看。 看看 MDK 界面中左边的各种源文件： main.c：就是用户写主程序的地方。 startup_stm32f103xb.s：该文件是官方用汇编写成的启动文件，MCU 是微处理器，处理器就是一个复杂的数字电路，该电路的核心有很多寄存器（处理器寄存器）需要初始化，启动文件就是把这些初始化程序固定下来，用户不用管也不用改动，主要内容有初始化中断向量表、定义堆栈空间、准备 C 语言环境和跳转到 main() 函数等等。 ARM Cortex-M 系列处理器在函数跳转的时候有硬件自动的使用栈来保存现场和恢复现场： ARM 系列系列详细看这篇文章【主线剧情 番外01】ARM \u0026 SOC 系列快速鸟瞰 - 知乎 (zhihu.com)， 栈和跳转等可以看 【主线剧情01】ARM \u0026 i.MX6ULL 基础学习记录 - 知乎 (zhihu.com) 这篇文章最后的 “ARM异常处理 \u0026 启动文件的示例” 章节，虽然这些知识点对于新人有点超前了。 stm32f1xx_hal_gpio.h 和 stm32f1xx_hal_gpio.c ：这类文件就是 HAL 库的源文件，操作外设就调用这些文件里面的 API 即可，所有 API 和详细使用方法 在 .h 和 .c 文件的注释里均有详细说明。 stm32f103xb.h：该文件定义 stm32f103xb 系列 MCU 的所有 外设的寄存器，给各个外设的寄存器地址上面加个结构体，以便访问和修改，下文会帮助理解这段话。 MCU 的外设的寄存器都被映射到内存的各个地址上（物理连接），在 C 语言中读/写该寄存器，就是读该外设的状态和控制外设行为，外设本质都是数字电路，外设只会根据寄存器内 0 / 1 二进制值去做对应的行为。 以下例子，比如要对内存中 0x20E0084 位置开始的四个字节进行复位（写 0）和置位（写 1）的操作，C 语言写法如下（程序引自 Staok/coding-style-and-more）： static volatile unsigned int *reg_temp = (volatile unsigned int *)(0x20E0084); /* 置位的标准写法 */ /* 下句表示把 内存中 0x20E0084 位置的 第1、2、5、14位进行置1，其他位不变 */ *reg_temp |= ( (1 \u003c\u003c 14) | (1 \u003c\u003c 5) | (1 \u003c\u003c 2) | (1 \u003c\u003c 1) ); /* 清位的标准写法 */ /* 下句表示把 内存中 0x20E0084 位置的 第0、3位进行清0，其他位不变 */ *reg_temp \u0026= ( ~( (1 \u003c\u003c 3) | (1 \u003c\u003c 0) ) ); /* 读寄存器 */ volatile unsigned int val = *reg_temp; 进一步，MCU 有上千个寄存器，这么一个一个定义肯定不行，下面就是 HAL 库里面的方法，将结构体的地址赋值为相应寄存器的地址，即创建内存地址上连续区域的结构体，该方法常用于嵌入式开发。如下例子（程序引自 Staok/coding-style-and-more）： typedef struct { volatile unsigned int URXD; /**\u003c UART Receiver Register, offset: 0x00 */ volatile unsigned char RESERVED_0[60]; volatile unsigned int UTXD; /**\u003c UART Transmitter Register, offset: 0x40 */ volatile unsigned int UCR1; /**\u003c UART Transmitter Register, offset: 0x44 */ } Periph_x_Type; /* Periph_x 这个外设的寄存器的基地址为 0x20","date":"2021-09-03","objectID":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/:2:0","tags":["硬件","STM32","软件"],"title":"超快 STM32 系统入门指南","uri":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"categories":["【直达本质入门】系列"],"content":"资源站 各大厂家对 STM32 出了特别特别特别丰富的教程和例程，如果比较熟悉外设，直接看他们的例程源码即可，快速掌握各种技巧。各大家的官网和资料下载地址如下： 正点原子： OpenEdv-开源电子网-正点原子论坛 有问题可以在这里找，也可以平时没事逛一逛； 正点原子官方的个人空间_ 哔哩哔哩 _bilibili 所有教学视频； 原子哥教学平台，专注电子技术教学 (yuanzige.com)； 正点原子资料下载中心 — 正点原子资料下载中心 1.0.0 文档 (openedv.com) 各种开发板的电路原理图、例程和教程 统统薅走！ 野火： 野火电子论坛 - (firebbs.cn) 论坛； 野火_ firege的个人空间 _ 哔哩哔哩 _bilibili 所有教学视频； 野火产品资料下载中心 — 野火产品资料下载中心 文档 (embedfire.com) 薅羊毛。 安富莱： 硬汉嵌入式论坛 - Powered by Discuz! (armbbs.cn) 论坛； 武汉安富莱电子有限公司官方网站。STM32开发板,无线IO模块,H7-TOOL工具,嵌入式系统 (armfly.com) 官网； 【安富莱】各种开发板和模块的资料下载汇总贴（2021-08-30） - 安富莱电子 - 博客园 (cnblogs.com) 资料下载站。 硬石： 硬石电子 - 社区 (ing10bbs.com) 论坛； 硬石科技的个人空间_ 哔哩哔哩 _bilibili 教学视频； 硬石开源资料下载链接(该帖总是最新资料) - 硬石资料更新 - 硬石社区社区 (ing10bbs.com) 资料下载站。 原子、野火、安富莱和硬石各有侧重，可以广泛借鉴：野火、正点原子 非常全面；安富莱偏 M4F 的 DSP 使用；硬石偏电机控制，有步进电机、有、无刷电机。 STM32 官网资料下载站，是源头，可以找到任何官方的东西，包括选型手册，好好把握： 中文站：STM32 | 产品 | STM32/STM8 | MCU单片机 | 意法半导体STM | 意法半导体STM | STM32/STM8微控制器 | MCU单片机 (stmcu.com.cn)； ST 官方：微控制器与微处理器 - STMicroelectronics。 ","date":"2021-09-03","objectID":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/:3:0","tags":["硬件","STM32","软件"],"title":"超快 STM32 系统入门指南","uri":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"categories":["【直达本质入门】系列"],"content":"总结 上述方法一句话总结。外设的概念，比如 FSMC、DMA 等，可以先上网查，知道它是做什么的（比如 UART 外设是串口来收发数据，I2C、SPI，重点看明白时序图，FSMC 是 SRAM 接口外设，DMA 是数据在内存间通过硬件传输的途径且不占用处理器资源，等等），然后用 STM32CubeMX 生成例程，看外设如何初始化（看例程学习是最快的），然后看源码注释了解 API 详细使用（当成字典随用随查），就用起来一个外设了，然后按此法循环每一个外设，外设都依照此方法一个一个击破，精神集中的话没几天就掌握不少外设的使用了。 这里有一个 STM32 程序模板 Staok/stm32_framework (github.com)，其几乎写好了大部分外设的驱动，大块复制的时候要注意其开源协议。这里有一个 C 语言的编写规范 Staok/coding-style-and-more (github.com)，其几乎 “无所不包”。 要知道适合大多数人的上道的学习，是先会用（会快速获得成就感，如同游戏般及时获得反馈），然后再去了解架构和细节方面的东西（有兴趣、有信心了之后才会面对这些而不犯怵），当用的比较熟了之后，有了一些自己的感悟和理解，然后去 干 大部头的教程，比如几十个小时的视频或者上千页的 PDF（推荐只看 PDF 文字教程而不去看视频教程）。 —— 我一直觉得，应该减少人们走弯路，这也是 “二项玻”定则 中 “简化之能够简化” 的一个重要延申理念。peace。 ","date":"2021-09-03","objectID":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/:4:0","tags":["硬件","STM32","软件"],"title":"超快 STM32 系统入门指南","uri":"/11%E8%B6%85%E5%BF%ABstm32%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"categories":["随机技术情报"],"content":"就是我的装机、资料库结构与文件备份方案啊~","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"装机、资料库结构与文件备份方案 自从大约 2007 年左右第一次接触计算机到先在，经手了每个都长期使用过的五台电脑但每个阶段积累的文件和资料大都被顺利保存了下来（但是一些如初中时候做过的视频和 Flash 课件、小游戏的源文件等的感觉具有纪念意义的在历史的长河中无了）。 嵌入式领域的学科门类、资料、软件极其多样和广阔，上衔软件下通硬件的，再加上我早期又涉猎异常多的领域，早期对这方面的整理模式一直不敏感，在这几年中，资料库的划分、整理以及备份的架构逐渐形成稳定。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:0:0","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"系统重装步骤梳理 p.s 以下为精简的步骤，捯饬过几次装系统的很容易理解，新手还是多百度吧，反正路线放这了。 p.s 以下步骤是我从初中到本科反复做过 N 次的，或许有的地方过时了，或许近来又有了一些新的方法，可以评论区讨论。 第一步。下载原版系统镜像文件（.iso）（如下链接）；制作USB启动盘，即将 U盘 当作启动盘（推荐专门装机用的启动盘制作软件，有菜单，功能多，最好带 Win-PE 系统，比如 u盘启动盘 _ u盘启动盘制作工具 _ 系统重装 _ u盘重装系统教程 _ u深度官网 (ushendu.com)），再将下载好的系统镜像文件（.iso）放入 U盘。 操作系统原版下载 MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn)；或者 NEXT, ITELLYOU。 PJ 最全的微软msdn原版windows系统镜像和office下载地址集锦-网络教程与技术 -亦是美网络 (yishimei.cn)。（亦是 KMS 工具 下载处） 第二步。进入电脑开机的 BIOS 改启动顺序，将 U盘启动 调整为第一（这一步方法具体百度，win7、win10以及不同主板品牌的方法略有不同，思路都一样）；之后插入 U盘，重启电脑，显示 U盘启动盘的菜单，选择进入 Win-PE 系统，使用 DiskGenius 软件 改分区（分区设置还可以避开硬盘坏道，需要提前扫描硬盘确认坏道位置）；再使用 One Key（推荐）或者 GHOST 给 C 盘装入系统，接下来全自动化运行，电脑会自动安装好一切..直到进入新的系统桌面。 硬盘分区建议： 固态硬盘（SSD）适合经常修改和使用的空间，机械硬盘适合不常修改而偶尔查看的当作冷储存的地方。 C 盘系统盘推荐用固态硬盘（SSD），至少留 128GB 空间。不建议分区过多，这里推荐的分区策略：如果 PC 存储 是 一个 512 GB 的 SSD 和 一个 1T/2T 的机械硬盘，那么 SSD 平均分给 C 盘和 D 盘，然后剩下的一个机械硬盘 整个 给 E 盘；如果 PC 存储是 一个 1T/2T 的固态（毕竟 SSD 国产化之后就大幅便宜了），那么 拿出 256GB 给 C 盘，剩下的容量 给 D 盘。 更多 分区 和 资料分类存放 的建议 见下文 我的资料库结构 一节，这也是本文的主要目的之一。 分区模式，建议：老主板（2015之前的）：BIOS+MBR模式；新式UEFI主板（2015之后基本都是）：UEFI+GPT模式。 win10对MBR和GPT都支持，如果出现问题，先检查启动方式是不是UEFI。如果是win7，还是选传统的BIOS+MBR模式吧。 win10只需要安装专业版和企业版就好了，前者在存储上优化，后者在安全上优化。 所以，分区模式，先在都用 GPT，支持大于2T分区，比 MBR 更稳定，纠错能力更强。固态硬盘必须进行4K对齐。 第三步。装好并进入新的系统桌面后，按下述步骤（只是推荐）： 用驱动精灵（还可以在里面的“医生”窗口里安装常用依赖框架！）或者 360驱动 把驱动补全，装 安全管家 或者 360 调整系统，清理杂鱼软件，清理垃圾，补全补丁，清理垃圾。 用 @live.com 账号登陆系统，这个账号用来统一登陆 Win、Office。 然后是神奇的一通注册…用 KMS 工具注册系统，再安装和用 KMS 工具注册 VOL 版本的 Office 全家桶。 再安装其它软件，安装软件尽量从应用商店中（软件管家 或者 win 自带的应用商店） （不谈人为的坑，就是鉴于有的人只需要摔坑 1~3 次就会举一反三了，而一些人因无法分辨网页中正确的软件下载链接而在第一步就被绊住）。 ~~驱动都正常后，关闭 WIN 的 自动更新驱动，这个会更新不兼容的驱动，很坑。此电脑右键-\u003e属性-\u003e高级系统设置-\u003e硬件-\u003e安装设备设置,选择“否，让我选择要执行的操作”“从不安装来自Windows更新的驱动程序软件”。~~也不一定非要做这一步。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:1:0","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"我的资料库结构 首先是桌面划分。区域划分、功能要素简明全面。 PC 机 的分区以及分区类型划分。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:2:0","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"文件多地备份方案 图中 “初步备份方案” 是我的截止到成文的多地文件备份方案，后边两个方案为为以后设计的两个。 如上图所示，“补充备份方案” 中使用了 NAS 相关的软件，“完善备份方案” 为最省事（氪就完了）、功能最全的。 前两个也就是不使用 NAS 的“凑活”的方案，当然不如 氪金 上 NAS 的完善，比如：快速的文件镜像备份、方便的异地查看文件和生成分享链接、添加离线下载等等。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:3:0","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"NAS 介绍 NAS介绍：NAS（网络附属存储）_百度百科 (baidu.com)。 NAS 可以提供 异地存储/查看、文件备份、下载（BT/迅雷/磁力，PT）、手机/PC端的随时快速查看和播放等。NAS 的硬件载体是运行 Win / Linux 操作系统的小型计算机 / 服务器，或者是一个板载 ARM CA（Cortex-A）处理器的嵌入式系统。 NAS 的软件是 手机 / PC 端的进行访问和控制的主要人机界面，其载体为手机端的 APP 和 PC 端的 网页界面。 NAS 系统分为软、硬件，有两种构建，一种是直接买产品（氪就完了），另一种是用旧的不用的电脑 或者 买/自组 迷你主机 再装个 NAS 软件完事。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:4:0","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"对于直接买产品 NAS 产品现主流两家：群晖、威联通，其它品牌多属于耕耘不深的入门级产品。一买即得全部功能，包括 异地/外网/远程访问。 群晖 群晖 nas 有些什么基本和好玩的功能？ - 知乎 (zhihu.com)。 威联通 从入门到入土——NAS使用全指南（威联通篇）_NAS存储_什么值得买 (smzdm.com)。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:4:1","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"对于自己组建 NAS 软件有 FreeNAS 和 黑群晖可以选择，自备迷你主机，然后将 NAS 软件装入自备的迷你主机。爱捯饬硬件的、体会组装硬件并跑起来的乐趣的，用以下介绍和网上的教程文章做一个练练手，然后再搞专业的。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:4:2","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"迷你主机选择 这一个小节才是作者写本文的原动力。 我不是这方面的深耕的发烧友或者经验丰富的垃圾佬（快乐淘货er），他们可以用几十块钱、几百块钱淘来市场过剩的、二手的或小众的 组件再自组一个能用 / 好用的 小电脑来 7x24 小时的挂一些东西/任务运行，其言语风格如下： “一个猫盘才100多，一个小主机也100多，二手硬盘100多，搞坏了不心疼”。 “前段时间收了几个猫盘做 NAS，才 60 一个，刷的 DS120J。后来又收了几个D525和D2550小主机”。 “呵呵，网上一大把教程。我只用来 bt 下电影，电脑、ipad、手机之间共享很方便”。 “小主机可以 J3455，J4125，J5040，功耗都比较低。也可以用 H61，H81 等便宜、性能高的三、四代 CPU 但功耗大”。 我听不懂，但我大受震撼.jpeg 但了解了之后如获至宝。。 迷你主机可以选择 J4125（指 CPU 型号，功耗小，适合小主机），其就是一个可以运行 Win10、Linux 等系统的小计算机，性能相当于十年前的中等 CPU，但对于 NAS 算是性能过剩了（所以上面有说到 D525、猫盘和 ARM CA（Cortex-A）的相对性能低一些的处理器都已经够用了），价格 500 ~ 1k，手掌大小便携，需要外部电源，24W 功耗左右，日常文档办公足够，有多个 USB 3.0 口、单/双路网口、单/双路 HDMI 接口、耳机接口等，选个接口丰富的。 也可以选择更多其它，淘！ 另外就是作为长期存储的硬盘的选择。 首先移动硬盘不允许长期运行，连续长时间工作容易挂掉。 NAS 专用盘，如希捷的酷狼（群晖对希捷酷狼4T及以上的硬盘有专门的优化），西数的金盘（企业盘）。 ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:4:3","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"FreeNAS NAS 软件有个开源的 FreeNAS（FreeNAS 现已和 TrueNAS 合并到 TrueNAS）。 TrueNAS Open Storage | ZFS for the Home to the Data Center - TrueNAS Open Storage | ZFS for the Home to the Data Center。 FreeNAS中文网 | FreeNAS技术交流。 如何利用FreeNAS自行搭建可以被远程访问的NAS？_u012435915的博客-CSDN博客_freenas外网访问。 … ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:4:4","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"黑群晖 网络上 群晖 DSxxx 的引导文件和固件 写入自备的 迷你主机。 黑群晖NAS保姆级教程：手把手教您安装DS918+固件，开启显卡解码功能！3分钟玩转黑群NAS!_NAS存储_什么值得买 (smzdm.com)。 [黑群晖经典教程] 一步一步建立自己的黑群晖 - “人生苦短” - 博客园 (cnblogs.com)。 黑群晖组建指南 篇十一：大男孩的快乐：垃圾佬入坑群晖指南_NAS存储_什么值得买 (smzdm.com)。 … ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:4:5","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["随机技术情报"],"content":"最后 有一点，上面说到的 “自己组件 NAS” 都不能在远程访问，仅限于局域网访问，外网访问需要用到别人的服务器，当然是需要花钱的；也有人说 “不能远程访问的NAS不叫NAS”，确实，如果想，直接买 群晖 或 威联通的产品 氪就完了；不过也有 自己买公网 IP 或者 让中国电信 分个 IP（三大网络服务商只电信可提供 公网 IP）再买个域名，来让自己的 NAS 系统可以做到外网访问（不过暴露于公网的自己的 NAS 系统的安全性我也怀疑难有保障）。 就上上面 “文件多地备份” 一节里说到的 “补充备份方案”，我设计的备份路径是 本地资料镜像备份至百度云SVIP，然后迷你主机再通过百度云来备份到本地，同时在外网可以通过访问百度云来实现上一段所说的 “远程访问”。 怎么样，如果你想仅仅为了文件备份和局域网共享（其它花里胡哨的功能嘛…暂无需求），比较以上网友的 “自组 NAS” 方法 和 我的 “备份方案”，通过 性-价比的比较，你又做何选择呢？ ","date":"2021-10-25","objectID":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/:5:0","tags":["杂谈","NAS"],"title":"装机、资料库结构与文件备份方案","uri":"/12%E8%A3%85%E6%9C%BA-%E8%B5%84%E6%96%99%E5%BA%93%E7%BB%93%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/"},{"categories":["【直达本质入门】系列"],"content":"介绍运放的第一原理性定量分析法啊~","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"【手撕运放】运放的“第一原理”式定量分析法 数电/模电那两本书我也完整地翻过一、二遍（诶我为什么用“也”），下面就是来点不复杂的（如果是那还不如直接把书的内容粘过来呢）。 对于运放的定量分析，“虚短虚断” 就如同 “奇变偶不变” 一样喜闻乐见的普及，但是对于什么时候用 “虚短”，什么时候用 “虚断”，学习的时候一开始并不能准确拿捏，因为 掐头去尾 啪的一下给出各种 推论、结论，使人被动的认知障碍了。实际上，“虚短虚断” 就是从“放大倍数趋于无穷的极限计算”得来的两个“推论”，“放大倍数趋于无穷的极限计算”也就是本文要介绍的方法，这种“第一原理性”的分析方法可以以不变应万变。 本文中用到的 电路拉氏变换、传函、幅频特性计算等等，与 “自动控制原理” 里面的方法相通，可以先看 这篇文章 【简明自控】为什么特征方程如此重要 - 知乎 (zhihu.com)，这里面均有陈述。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:0:0","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"理想运放的本质 给我一个理想运放： 理想运放的功能，就是对 up 和 un 之间的电压差放大 A 倍后输出 uo，即 uo = A·( up - un ) , A→∞。这是本质，这是核心公式。 好了本文结束了。 . . . 什么？还要我举例手推，好吧~ ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:1:0","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"举6个栗子 同相比例放大； 差分放大； 反相比例放大的T型接法； 二阶有源低通滤波电路； 压控电压源二阶低通滤波电路； 一种线性电源拓扑的可控电流源。 我选择的也是有目的，这几个电路相当实用。以下一一道来。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:0","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"同相比例放大 对于理想运放来说，放大倍数 A 为无穷大，整理出带有 A 的 uo/ui 的式子之后，只需一个 A→∞ 求极限，即可求出 该电路放大倍数的表达式。 下图给出运放的“同相比例放大”接法，以及使用“uo = A·( up - un ) ”来求解的过程。 要记着运放的两个输入端的输入电阻相等的条件。这样使得运放的两个输入端的输入（静态）电流一致，减弱由运放内部的偏置和温漂产生的差模输出，确保 ui = 0 时， uo 也为 0（理想时）。下图说明（“//” 符号为并联）。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:1","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"差分放大 计算过程，一样的，先求 un 和 up，然后带入 核心公式 “uo = A·( up - un ) ”，再求个 A → ∞ 极限，得出结论。 电路和仿真结果（Multisim 仿真）在下图。正输入为 25Hz 的 -5V ~ 5V 的正弦波（橘线），负输入为 1Hz 的 -5V ~ 5V 的正弦波（红线），输出为蓝线。可见，实时的，橘线电压减去红线电压（即橘线电压进行上下偏移）再 1/2 倍得到蓝线，图形有点漂亮吧。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:2","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"反相比例放大的T型接法 反相比例放大的T型接法，小阻值电阻实现高倍数放大（使用大电阻的缺点是容易受到外接电磁干扰，阻值越大，外界电磁干扰的感应电流所引起的干扰电压越高）。 电路、分析和仿真结果均在下图了（列方程组后的手动整理工作量很大，所以用 matlab 帮助进行带符号方程组的整理工作，很方便）。 下图阻值选择，简单做了 uo/ui 为 -2 倍的信号调整/调理，示波器中红色线为输入，橘色为输出。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:3","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"二阶有源低通滤波 简单二阶有源低通滤波电路，即两个 RC 一阶低通滤波串起来。 计算电路的传递函数从而得到其幅、相频率特性，对电路先进行拉氏变换，然后类似欧姆定律求其传函，再求得幅频特性，令幅度等于 0.707（1/√2，即 -3dB（ 20lg0.707 ≈ -3dB），幅值下降到 0.707 的频率认为是截止频率）求出截止频率，约为 0.374 倍的 1/2πRC，在10kHz的时候衰减倍数约为 0.0298，下面进行仿真。 伯德图分析，-3dB 时候 约为 592 Hz，与上图中的计算较拟合。 9.918kHz 的时候约为 -32.506dB，10kHz 的时候的理论值为 20lg0.0298 ≈ -30.51567dB，较为拟合。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:4","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"二阶压控低通滤波 又可以叫压控电压源二阶低通滤波电路（名词的各种换位置组合。。），通频带内最平坦的一种滤波电路，属于巴特沃斯滤波器的一种。 由 R1、R2 和 C1、C2 分别构成两个一阶低通滤波，但 C1 原本的接地端接 uo，引入电压正反馈，形成压控滤波器（书面表达）。 电路、简单计算过程均在下图。 仿真。按照下图的 R、C 参数，可以计算 截止频率约为 2.1kHz，在 10kHz 处的衰减倍数约为 0.0379，通过仿真可以验证均拟合。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:5","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"一种线性电源拓扑的可控电流源 该电路为类 LDO 原理的线性拓扑，靠功率管来分压而动态调整输出到目标位置，线性电源的效率不高（相比较开关电源而言），电流不宜过大（适合小于 1A 的场景），若要大电流的恒流源还得上开关电源。我的一个开源电源项目 【开源项目】叠buff电源板-巧克力板 - 知乎 (zhihu.com)，其实现了恒流恒压可调。 电路和分析均在下图了。其中 PNP BJT 可以换为 P-MOS，门级（栅极）电阻不要太大。 从负反馈的角度理解。R5 为测电流的反馈电阻，当电流 Ic 变大了，R5 两端电压上升，up 端电压就会减小，从而运放的输出电压减小，从而输出电流 Ic 减小，若 Ic 变小了，则 up 会变大，从而 Ic 也会变大，形成动态平衡。从外界来看，即 Ic 跟踪 ui。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:2:6","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["【直达本质入门】系列"],"content":"尾记 这里是演示对于运放从“第一原理”角度理解、推理和验证，从推公式过程也可见对于复杂的电路计算量较大，该法用于学习和定量分析，实际用的时候不用重推，记下结论公式即可。 本文章介绍的这个用“极限”的方法是我学模电的时候想的，还不用“虚短虚断”法而饶有兴趣的用此法对上述的电路都手推了一遍，与正确结论一致，并且还能推出“Rp=Pn”的条件。我自己常用本文的方法而不用 “虚短虚断”，手算是用于初步分析和应付考试，实际中用的话效率很低（手算计算量大），记住各种电路拓扑和结论公式也是为了见到新电路时的初步的定性分析，原理明白后设计时最好还是用仿真软件加以辅助和验证。 滤波器那里计算传递函数、画伯德图、求 -3dB 处频率、求谐振峰值及谐振频率、求 滤波器的品质因数 Q 等等这些，完全可以用 “自动控制原理” 里面的方法来做，模电书上提供的某些带有 f 和 f0 的求传函和幅频特性的方法可能属于是工程计算上的习惯法，掩盖了很多细节，还是学/用更基础的、底层的拉氏变换更好操作。更多阅读 【简明自控】为什么特征方程如此重要 - 知乎 (zhihu.com)，也许会给你带来许多启发，打通不同的学科。 上面电路均有很丰富的应用场景，比如信号调理（包括比例放大、偏移）、信号求和/求差运算、高边测电流、信号滤波等等，基于几个简单的拓扑而变化多端。 运放的用法总结： 正反馈接法：比较器、振荡器。 负反馈接法：比例、求和/求差（或偏移）、微分/积分、滤波。 运放的基本参数：可见我的硬件规范里的 [thoughs-about-hardware-design/SCH \u0026 PCB 设计规范和 AD 的使用.md at master · Staok/thoughs-about-hardware-design——运放小节 (github.com)](https://github.com/Staok/thoughs-about-hardware-design/blob/master/SCH %26 PCB 设计规范和 AD 的使用.md#运放)。 ","date":"2021-11-25","objectID":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/:3:0","tags":["硬件"],"title":"手撕运放-运放的第一原理性定量分析法","uri":"/13%E6%89%8B%E6%92%95%E8%BF%90%E6%94%BE-%E8%BF%90%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8E%9F%E7%90%86%E6%80%A7%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E6%B3%95/"},{"categories":["随机技术情报"],"content":"无线传感网络的定位和时间同步技术简述啊~","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"无线传感网络的定位和时间同步技术简述 只记一些概念。都是在 2005 年的《无线传感网络》一书中摘取，基本概念可以了解，但具体方法在用的时候还需要再查阅最新的综述文献和书籍，再看新方法。这里的无线传感网络，即在一定区域内多节点分布式的分布且通过无线通讯方式而组成传感网络的范畴。 ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:0:0","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"定位技术 随机布放的传感器节点无法事先知道自身位置，因此传感器节点必须能够在布放后实时地进行定位。传感器节点的自身定位就是根据少数已知位置的节点（信标节点），按照某种定位机制确定自身的位置。 多传感器协作。定位信息还有以下用途：目标跟踪（实时监测和报告）、预测目标轨迹、协助通讯的路由等。 传感器网络的定位算法通常具备以下特点： 自组织性，节点随机分布，不依靠全局的基础设施协助定位。 健壮性，节点硬件配置低、功率小、可靠性较差，算法需容错性高。 节省能量，算法对于无线通讯、处理器的计算的能量消耗要控制好。 分布式计算，每个节点计算自身位置，而非由某一个节点对其它多个节点进行计算。 再无线传感网络中，信标节点（已知自身位置）和未知节点（已经接入系统但自身位置未知），信标节点占少量，其可通过自身携带的GPS等定位设备获得自己精确的位置，未知节点通过信标节点的位置信息来确定自身位置。一开始信标节点很少只有几个，但其临近的节点不断定位自身之后也可以转换为信标节点，后续节点接着定位和转换为信标节点，传播遍及整个无线传感网络。 三种基本方法：三边测量法（用三个信标节点到一个未知节点的距离）、三角测量法（用三个信标节点到一个未知节点的角度）、极大似然估计（用 n 个（n ≥ 3）信标节点到一个未知节点的 n 个距离信息，个这 n 个信标节点的自身的位置坐标，建立 n 个方程组成方程组，用最小二乘或极大似然估计（广义逆矩阵）求解该未知节点的估计坐标）。 三边测量法是分别以三个信标坐标为圆心和其到一个未知节点的三个距离画三个圆，圆的交点便是未知节点的位置，但实际距离的测量（用 TOA（到达时间法）、TDOA（到达时间差法）或 RSSI 法（通讯信号强度法）等）并不精确从而使三个圆有一个相交的一片区域，可以用此法估计：任意两个圆的交点确定一个直线，找两对圆得到两个这样的直线，两个直线的交点便是未知节点的估计位置。 还有一种双元检测法，该法中，传感器的距离检测只有 1 和 0 两种状态，侦测距离 R，对于 R - e 距离以内的目标一定检测为 1（有，在范围内），对于 R + e 距离以外的目标一定检测为 0（无，不在范围内），那么密集的该传感器分布在一定区域内，未知节点即在这些检测重叠范围内。优点是硬件要求低，缺点是需要比较密集才能保证检测精度、还需要时间同步和信标节点需求多。 定位算法的几种分类方法： 这里主要以上述第一种分类方法来说明。 ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:1:0","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"距离有关定位算法 两个阶段，先测距，再定位，后者就用上述的三边、三角和极大似然估计，前者就是下面所说的。 对硬件要求、功耗要求、小巧、造价等，都要考虑。 TOA（到达时间法）：假设两个节点时间同步，一个节点发送带有发送时刻信息的通讯帧到另一个节点，另一个节点通过发送和接收的时差确定二者距离，要求是时间同步的精度要高，信息打包、发送、传输、接收和解析的时间还有在空中的传播的速度都要比较精确（定位精度需求小的场景对这些要求会很宽松）。 TDOA（到达时间差法）：一个发射节点同时向两个节点发送两个不同传播速度的无线信号（如一个无线电，一个超声波），接收节点可以利用两种无线信号的到达时差来确定距离。或者，一个发射节点同时向两个不同距离的节点发射无线信号，两个接收节点需要时间同步，再根据接收时延确定距离。 AOA（基于到达角度）：同上述三角测量法。 RSSI 法（通讯信号强度法）：通过接收信号强度来估算距离，两种，利用信号传播的经验模型（多试、求拟合函数，或建立位置和信号强度的数据库），利用信号传播的理论模型。实际中，该法受环境的温湿度、障碍物、传播模型等影响很大。 等。 ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:1:1","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"距离无关定位算法 该类方法精度低，但是对硬件需求较小。 两种，一种是估计距离（通过算法，而非实际测量），另一种是估计出未知节点的一个位置范围区域，然后取该区域的质心（坐标的平均）作为未知节点的位置（典型的就是上面说到的 双元检测法）。 主要有 DV-Hop算法、Amorphous 算法、APIT 算法等。 用时再研究。用时还需查阅最新的综述文献和书籍，寻到更新的更先进实用的方法。 ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:1:2","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"时间同步 不同节点有自己的本地时钟所计数的时间，每个节点有不同程度的时钟漂移而造成时间偏差，需要进行多节点的时间同步（单次或周期性地）。 需要时间同步需求的场景，以及时间同步的性能参数/指标： 网络时间同步机制，典型的是客户端“要时间”，服务器发一次时间，客户端接收到时间同步信息后，根据自身时间和一些传播时间的参数得出要修正的时间。 ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:2:0","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"网络时间协议 NTP 的基本原理 NTP 中，消息传输过程中的延迟的精度决定了时间同步的精度，延迟主要分为四个部分，以下细分析： ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:2:1","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["随机技术情报"],"content":"无线传感网络的时间同步机制 三种基本的同步机制： 参考广播同步（RBS）机制利用无线数据链路层的广播信道的特性，一个节点发送广播消息，多个（至少两个）接收到广播消息的一组节点相互比较各自接收时间的本地时刻（交换），实现它们之间的时间同步（是它们之间的，不是它们与标准时间的同步）。 其它机制用时再研究。用时还需查阅最新的综述文献和书籍，寻到更新的更先进实用的方法。 ","date":"2021-12-03","objectID":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/:2:2","tags":["无线传感网络"],"title":"无线传感网络的定位和时间同步技术简述","uri":"/14%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%AE%80%E8%BF%B0/"},{"categories":["【直达本质入门】系列"],"content":"数据结构与算法简述和CS综合啊~","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"数据结构与算法简述和CS综合 数据结构与算法简述和CS综述整理。本文非基础的教程，本文会列出大量学习和参考网站。老惯例，一个文章是一个集大成（本文借助了语音输入（PC 版 讯飞输入法）由此加速码字，但仍保持简洁的文风）。 数据结构 + 算法 = 程序。数据结构：现实问题的符合计算机存储的建模；算法：解决现实问题的步骤（符合有穷性，确定性，可行性等）。 文末四个附录为 Github 上或其它地方的有极大学习价值的教程或库： 附：算法代码库。 附：CS 综合学习类。 附：嵌入式 综合学习类。 附：算法刷题总结。 该部分涉及十几个 Github 仓库，鉴于挨个下载很麻烦，这里我全部下载并整理好了（四部分仓库 + 硬件领域面经集合 1.42 GB 侵删）： 链接：https://pan.baidu.com/s/1-A_wA3YP4666tge2llxqEg 提取码：XHYN –来自百度网盘超级会员V4的分享 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:0:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"IT 学习路线 C语言基础 → C语言三剑客：《C和指针》、《C陷阱与缺陷》和《C专家编程》，经典永流传 → 数据结构与算法（线性表/树/图/哈希 + 排序/搜索/规划等等等 按需学） → 计算机专业科学看的《计算机组成原理》/《计算机体系结构》，《计算机操作系统》/《现代操作系统》/《深入理解计算机系统》，《编译原理》，《深入分析GCC》，网络协议如《计算机网络》、《TCP-IP详解卷一/卷二/卷三》等 → 可选 《CPU自制入门》 → 走向：嵌入式 Linux 方向、FPGA / 芯片设计方向、具体某算法方向等等。 更多学习路线可详细参考 rd2coding/Road2Coding: 编程之路 (github.com) 的总结，比较全面了。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:1:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"相关坚韧大厚书 没给出链接的 网搜名字即可。 哪本《数据结构与算法》最好？ - 知乎 (zhihu.com) 该回答列举了一些不错的数据结构与算法方面的书籍。 《算法导论》（经典）是计算机学科的算法入门书。 《计算机体系结构》（经典），《计算机操作系统》/《现代操作系统》/《深入理解计算机系统》。 《编码的奥秘》，相关介绍/推荐 想练习《编码的奥秘》里面的知识，有什么软件有帮助？ - 知乎 (zhihu.com)。《编译原理》（经典），《深入分析GCC》。 网络协议如《计算机网络》、《TCP-IP详解卷一/卷二/卷三》，想深入了解 HTTP 协议，有哪些值得推荐的书籍？ - 知乎 (zhihu.com)。 嵌入式应用相关：《GNU Make》，《Debugging with GDB》，《Linux 高级程序开发》，《POSIX 多线程程序设计》，《嵌入式Linux基础教程》，《嵌入式Linxu应用开发完全手册》，《嵌入式Linxu应用程序开发详解》。 嵌入式底层相关：内核相关：《深入理解Linux内核》，《Linux内核源代码情景分析》，《Linux内核设计与实现》；驱动相关：《Linux设备驱动程序》，《Linux设备驱动开发详解》，《Linux驱动开发入门与实践》。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:2:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"相关有趣/耐看书或视频 《算法新解》开源书。《啊哈！算法》。 图解系统 小林。图解网络 小林。 趣谈网络协议。 手绘图解HTTP。30张图解HTTP常见面试题。 TCP/IP 教程 | 菜鸟教程 (runoob.com)。HTTP 教程 | 菜鸟教程 (runoob.com)。 《嵌入式C语言的自我修养》 从沙子讲到CPU，从编辑器讲到编译器，从高阶C语言讲到内存管理，从GNU讲到多任务编程。 （完结）（小甲鱼）数据结构和算法_ 哔哩哔哩 _bilibili。 国嵌唐老师主讲【数据结构与算法C语言】（非常犀利）_ 哔哩哔哩 _bilibili 讲的慢。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:3:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"时间、空间复杂度 时间复杂度表示一个算法内执行语句的数量在最坏的情况下随着循环次数 n 的增加而增长的数量级。一个算法内语句的使用次数（频度）表示为 f(n)，n 为算法内循环语句的循环数，n 的变化直接改变 整个算法的语句使用次数；时间复杂度 O(g(n)) 的定义为，对于一个算法，当且仅当存在正整数 c 和 n0，使得 f(n) ≤ cg(n) 对于所有 n ≥ n0 成立，则该算法的渐进时间复杂度为 f(n) = O(g(n))，g(n) 为 n 的函数。 各个时间复杂度的语句频度的增长速度比较：O(log_2(n)) ＜ O(n) ＜ O(n*log_2(n)) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!)，前三个很好，最后两个不可接受，剩余的强差人意。 程序的执行时间不仅依赖于问题规模，还可能随着数据的状态不同而变化，即其时间复杂度会变化，一般评价算法时候取最坏的情况的时间复杂度。 空间复杂度大同小异。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:4:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"数据结构简述 一个软件项目，数据结构设计的好，后面进行功能实现时候的调用、修改和查询会特别方便，可以达到事半功倍的效果。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:5:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"基本概念 数据结构几大类 线性表：顺序（数组）、链式（链表（单链表、双向链表、循环链表（单向、双向），静态链表（借助数组实现）））、特殊（栈（FILO）、队列（FIFO））。 树：二叉树、红黑树等。 图：无向图、有向图等。 按照关系划分 按照逻辑关系（元素的连接关系）： 集合，线性（数组、栈、队列、链表等），树状（一对多），图状（多对多）。 按照存储关系： 顺序存储：如数组，要提前申请空间（静态分配（编译时进行）或动态分配（malloc \u0026 free））。优点：物理位置连续而紧凑，可 随机 / 直接 存取；缺点：会产生内存碎片，增、删改动时前后要跟着变（需要移动大量元素）。 链式存储：如链表，要提前申请空间（动态分配（malloc \u0026 free））。优点：链式、离散、节点化，空间可动态分配，改动方便（改节点的指向）；缺点：空间占用大，查找不便（需要遍历整个链表）。 索引存储：“索引-数据” 的结构形式。 散列存储：暂略。 数据运算 每个基本数据结构要实现的基本操作：增（插入）、删（删除）、改（更新）、查（检索），判（判空，判满）、排（排序）、复（复位）。 更复杂的操作可用以上基本操作实现。 操作的时间复杂度 具体概念在 “C \u0026 MCU编写规范和其他” 一文的 “时间、空间复杂度” 一节有提到。（数据结构）十分钟搞定时间复杂度（算法的时间复杂度） - 简书 (jianshu.com)。一套图 搞懂“时间复杂度”_ 12 26 25 的博客-CSDN博客 _时间复杂度。 查找：顺序存储结构 O(1)，单链表 O(n)。 插入和删除：顺序存储结构 O(n)，单链表 O(1)。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:5:1","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"典型数据结构列举 栈/队列/链表 描述略。 一些基本的简单实现参考/数据结构简单实现/文件夹里面。 线性表详解：数据结构线性表10分钟入门 (biancheng.net)。 栈(Stack)和队列(Queue)详解 (biancheng.net)。 树 以下为树的基本概念（定义、基本操作、性质、存储结构等）、二叉树（定义、基本操作、存储、遍历等）、平衡二叉树、红黑树等。 引自：树及二叉树的基本概念_青萍之末的博客-CSDN博客。 树是由一个或一个以上的节点（node）组成，存在一个特殊节点称为树根（root），它是n（n\u003e=0）个节点的有限集。n=0时称为空树。n\u003e0时，有限集的元素构成一个具有层次感的数据结构。 树的一些概念 节点的度：一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3。 树的高度：也称为树的深度，树中节点的最大层次。 有序树：树中节点各子树之间的次序是重要的，不可以随意交换位置。 无序树：树种节点各子树之间的次序是不重要的。可以随意交换位置。 森林：0或多棵互不相交的树的集合。 引自：《数据结构教程》。 树的一些性质 非空树的节点总数等于树中所有节点的度之和加1。 度为 k 的非空树的第 i 层，最多有 k^(i-1) 个节点（i ≥ 1）。 深度为 h 的 k 叉树最多有 (k^h - 1)/(k - 1) 个节点。 具有 n 个节点的 k 叉树的最小深度为 log_k(n*(k - 1)) + 1。包含 n 个结点的二叉树的高度至少为 log_2(n) + 1。 树的基本操作 建立一棵空树 T。 求结点 x 所在树的根节点。或求树 T 的根节点。 求树 T 中结点 x 的双亲结点。 求树 T 中节点 x 的第 i 个孩子节点。 求树 T 中节点 x 右边 的兄弟节点。 把以 S 为根结点的树插入到 树 T 的 节点 x 的第 i 个子节点位置上。 删除树 T 中 节点 x 的第 i 棵树。 对一棵树进行遍历，按照某种次序遍历树所有节点并得到一个由所有节点组成的序列。 树的存储 采用链式存储方式居多。除了储存节点本身的数据信息之外，还必须做到把树中各个节点之间的连接关系反映在存储结构中。 多重链表表示法：分为 定长链接数目 和 不定长链接数目。 前者： 后者： 三重链表表示法： 二叉树 树及二叉树的基本概念_青萍之末的博客-CSDN博客。 引自：《数据结构教程》。 二叉树结构被广泛用来解决计算机领域中的各种实际问题。例如，在排序、检索、数据库管理系统以及人工智能等许多方面，二叉树都提供了强而有效的支持。 … 每一个节点最多只有两颗子树。在二叉树中严格区分节点的左、右子树，其次序不能随意颠倒。因此二叉树是有序树。 二叉树又可以分为满二叉树和完全二叉树。 二叉树的基本操作 二叉树的存储结构 顺序存储结构：顺序存储结构固有一些缺陷，使得二叉树的插入、删除等操作不方便，而且效率比较低（线性表的固有缺点）。 链式存储结构：更适合，更广泛。两种：二叉链表结构 和 三叉链表结构。 二叉链表结构：链表中每一个链接点由三个域组成分，别为数据域和两个指针域，后者分别给出该节点的左、右节点的存储地址。 三叉链表结构：相比于二叉链表结构，多增加一个用来指向双亲节点的指针域，这样在查找二叉树中某个节点的双亲节点时候不用遍历整个二叉树。就是空间换时间（如查找的时间等）。 二叉树与树的遍历 有关二叉树的许多操作几乎都是建立在二叉树的遍历之上。二叉树是一种非线性结构，因此需要寻找一种规律，使得二叉树中的所有节点能够排列在一个线性序列中，这就叫遍历。 若以符号 D、L 和 R 分别表示访问根节点、遍历根结点的左子树 和 遍历根结点的右子树 三个过程，并且限定先左后右的顺序，则通常采用三种遍历方式：DLR、LDR、LRD，分别称之为 前序遍历、中序遍历、后续遍历。还有 按层次 的遍历顺序。 遍历可以用递归的方式（对于很大的树容易栈溢出）。非递归方法，通常利用一个栈结构。 下面举例按照 中序遍历 顺序遍历的程序。 按照层次遍历（或叫 广度优先遍历） 即 若被遍历的二叉树非空，则依次访问二叉树的第1层、第2层……直到最后一层，对每一层的访问按照从左到右的顺序进行。 该方法通常用一个队列实现。下面举例程序。 由遍历序列恢复二叉树 三步： 线索二叉树 在二叉树的结点上加上线索的二叉树称为线索二叉树。对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。 彻底理解线索二叉树_ Walk the horizon-CSDN博客 _线索二叉树的作用。 线索二叉树的理解_ huangwei18351的博客-CSDN博客 _线索二叉树。 二叉排序树 引自：《数据结构教程》。 二叉排序树用于排序、查找/检索，可以大大提高查找的时间效率（在一般情况下，查询效率比链表结构要高）。二叉排序树又叫二叉查找树。有人说，当需要完成的功能是插入、删除和检索，二叉排序树具有比迄今为止研究过的任何数据结构都有更好的性能。 引自：二叉排序树（二叉查找树）及C语言实现 (biancheng.net)。 二叉排序树要么是空二叉树，要么具有如下特点： 二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值； 二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大小根结点的值； 二叉排序树的左右子树也要求都是二叉排序树； 如下图所示就是一个二叉排序树。 引自：《数据结构教程》。 二叉排序树中插入数据，同样需要按照二叉排序树的原则进行。每次将一个新的元素插入到二叉排序树中，该元素对应的节点都是插在叶节点位置，插入的过程没有移动二叉树中其他节点。一个数据元素序列不一定按照值的大小进行排列，但当对其构造成为一棵二叉排序树以后，对该二叉排序树进行中序遍历得到的序列是一个按值大小排列的序列。 二叉排序树（二叉查找树）及C语言实现 (biancheng.net)。 二叉排序树_百度百科 (baidu.com)。 二叉查找树（BST）及二叉树的遍历_ 青萍之末的博客-CSDN博客 _二叉搜索树的遍历。 二分搜索树 | 菜鸟教程 (runoob.com)。 平衡二叉树（AVL树） 引自：平衡二叉树（AVL树）及C语言实现 (biancheng.net)。 平衡二叉树，又称为 AVL 树。实际上就是遵循以下两个特点的二叉树： 每棵子树中的左子树和右子树的深度差不能超过 1； 二叉树中每棵子树都要求是平衡二叉树； 其实就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1，则这棵二叉树就是平衡二叉树。 把二叉树中每个节点的左子树深度与右子树深度之差定义为该节点的平衡因子，因此平衡二叉树中每个节点的平衡因子只能是 1、0 或 -1。 引自：《数据结构教程》。 二叉排序树的形态，事先无法预料，随意性很大，得到的往往是一颗很不 “平衡” 的二叉树，深度差越大，其运算时间也越长，丧失了其优势。为了克服二叉排序树的这个缺陷，需要在插入和删除节点的同时对二叉树的形态结构进行必要的调整，使二叉排序树始终处于一种平衡状态。 … 理论上已经证明，具有 n 个节点的平衡树的深度在任何情况下都不会比具有相同节点数目的理想平衡数的深度高出 45% 以上。因此再平衡树上进行查找操作虽然比理想平衡树要慢一些，但通常比任意生成的二叉排序树中进行查找要快得多，其时间复杂度的数量级仍为O(Log_2(n))。 平衡二叉树（AVL树）及C语言实现 (biancheng.net)。 AVL树（平衡二叉树）_ 青萍之末的博客-CSDN博客 _avl树是平衡二叉树吗。 红黑树 引自 红黑树（RB-Tree）_青萍之末的博客-CSDN博客。 红黑树是一种二叉查找树。 红黑树与AVL树的对比 如果插入一个节点引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除节点引起树的不平衡时，最坏情况下，AVL需要维护从被删节点到根节点这条路径上所有节点的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度； 但是由于红黑树没有AVL树那么高度平衡，所以红黑树的查找性能相比AVL树要差一些，查找上的这一点性能差相比数据的插入和删除时的旋转性能是值得的，这就是为什么很多场合是用的红黑树，而不是AVL树，例如STL中的map和set。因此，RB-Tree在需要大量插入和删除节点的场景下效率更高。自然，由于AVL高度平衡，因此AVL的查找效率更高。 红黑树和AVL树的实现与比较—–算法导论 - 希隆囚徒 - 博客园 (cnblogs.com)。 红黑树（RB-tree）比AVL树的优势在哪？_mmshixing的博客-CSDN博客_红黑树的优点。 动画红黑树，旋转的艺术 - 知乎 (zhihu.com)。 其它树种和应用介绍 B树和B+树_青萍之末的博客-CSDN博客 B树是对二叉查找树的改进，B树大量应用在数据库和文件系统当中。 浅谈二叉查找树、AVL树、红黑树、B树、B+树的原理及应用_青萍之末的博客-CSDN博客。 还有哈夫曼树、字典树等等树种。。 图 引自：《数据结构教程》。 概念 图可以使得元素之间的关系是 多对多。图中任意两个数据元素之间都可能存在连接关系。图作为一种数据结构，可以表达数据元素之间广泛存在着的更为复杂的关系。在众多应用之中，如电子线路分析、工程计划分析、寻找最短路径等等，图是描述这类关系的","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:5:2","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"算法简述 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:6:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"基本 咳咳嗯…算法嘛，咱也不是 CS 科班学生，咱就说，算法是对已经建模后的问题的解决的具体途径和方法，是学习 对于编程来讲的 一些 已经成熟/成型的 完成问题的计算的 套路和思想。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:6:1","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"典型算法列举 串和串的匹配 基本 串（string）是由零个或多个字符组成的有限序列，又名叫字符串。一个串（流口水）中任意个连续的字符组成的子序列为该串的子串。串的编码方式即字符编码如 ASCII编码、Unicode编码等。 串中的元素都是字符，串的操作主要与 字符串的操作 而非 单个元素 有关，其多为 查找子串位置、得到指定位置子串、替换子串等操作，如下： 显而易见，标准库如 string.h 给出了串的基本操作 API，关于 C 标准库的详细使用可参考 “C \u0026 MCU编写规范和其他” 一文的 “7 C 标准库的使用” 一节。 串的匹配算法（也可叫串的模式匹配） 串匹配，比如：要从主串 S = “BBC ABCDAB ABCDADCDABDE” 中 找到 与 模式串 P = “ABCDABD” 相同的 子串 的位置。 串的模式匹配算法-BF算法（或叫暴力算法） 主串 S 从 i = 0 位置开始与 模式串 P 从 j = 0 位置开始一个字符一个字符的匹配是否一样，如果相同则 i 和 j 均加一然后再判断是否匹配，若不同则 i 回到 这次匹配开始的位置同时 j 回到首位，继续挨个匹配。一图说明： 引自：21 串模式匹配算法（BF算法） - 知乎 (zhihu.com) 串的快速模式匹配算法-KMP算法 主要思想就是相比于 BF 算法，为了加速匹配，找一些规律，当匹配失效的时候 j 不用每次回到 P 的 开头位置，而是根据（注意，不了解的推荐先看下面给出的教程文章，这里是明白后的总结） 模式串的 各个字串的 各个前缀、后缀子串的 最大公共元素长度 来构造 next 数组，j 每次移动的位数根据 next 来调整。 从头到尾彻底理解KMP - Chris_z - 博客园 (cnblogs.com)。Coding-Zuo (cnblogs.com)。该文讲的很清楚。 「天勤公开课」KMP算法易懂版_ 哔哩哔哩 _bilibili。 排序 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)。 算法大总结之—-10大经典排序算法(从小到大排列)_ Frank的博客-CSDN博客 _从小到大排序算法。 深度/广度优先搜索 图的遍历 通常采用 深优先搜索（DFS） 与 广度优先搜索（BFS） 方式进行。“如果把树看做一种特殊的图的话，DFS 就是前序遍历”。 搜索思想——DFS \u0026 BFS（基础基础篇） - 知乎 (zhihu.com)。 搜索思想——DFS \u0026 BFS（基础篇） - 知乎 (zhihu.com)。 图的深度优先搜索（DFS）与广度优先搜索（BFS）_青萍之末的博客-CSDN博客。 深度优先遍历与连通分量 | 菜鸟教程 (runoob.com)，广度优先遍历与最短路径 | 菜鸟教程 (runoob.com)。 动态规划 什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 知乎 (zhihu.com)。 DP-动态规划问题心得 - 知乎 (zhihu.com)。 一只脚迈进DP的海洋 - 知乎 (zhihu.com)。 五大常用算法——动态规划算法详解及经典例题_ 别再想更好的办法的博客-CSDN博客 _动态规划算法经典例题。 有的人理解为用“动态规划”的思想（写出优化目标和状态转移方程（或者叫递归关系式））去理解和建模问题使得找出问题的优化解可以不用遍历所有可能解（剪枝，或去除不可能为最优解的计算从而节省时间，或者去除重叠的子问题）；常用一种实现方法为用缓存存储数据来减少重复计算（把穷举的计算过程展开为一棵树，然后找出其中重复计算的部分，用缓存来保留一份之前要重复计算的结果，来减少重复计算），还有其它许多技巧和方法。 分治 引自：五大常用算法——分治算法详解及经典例题_ 别再想更好的办法的博客-CSDN博客 _分治算法经典例题。 分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 如果原问题可分割成k个子问题，1\u003ck≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 可使用分治法求解的一些经典问题： （1）二分搜索 （2）大整数乘法 （3）Strassen矩阵乘法 （4）棋盘覆盖 （5）合并排序 （6）快速排序 （7）线性时间选择 （8）最接近点对问题 （9）循环赛日程表 （10）汉诺塔 分治算法的一个核心在于子问题的规模大小是否接近，如果接近则算法效率较高。 分治算法和动态规划都是解决子问题，然后对解进行合并；但是分治算法是寻找远小于原问题的子问题（因为对于计算机来说计算小数据的问题还是很快的），同时分治算法的效率并不一定好，而动态规划的效率取决于子问题的个数的多少，子问题的个数远小于子问题的总数的情况下（也就是重复子问题多），算法才会很高效。 五大常用算法——分治算法详解及经典例题_ 别再想更好的办法的博客-CSDN博客 _分治算法经典例题。 贪心 引自：五大常用算法——贪心算法详解及经典例子_ 别再想更好的办法的博客-CSDN博客 _贪心算法。 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 基本思路 建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。 实现该算法的过程 从问题的某一初始解出发； while 能朝给定总目标前进一步 do； 求出可行解的一个解元素； 由所有解元素组合成问题的一个可行解。 该算法存在问题 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 引自：什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 知乎 (zhihu.com) 来说明贪心算法的缺陷：　先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，需要用到尽量少的钞票。 依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。 这种策略称为“贪心”：假设我们面对的局面是“需要凑出w”，贪心策略会尽快让“还需要凑出的部分”变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。 但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错： 15=1×11+4×1 （贪心策略使用了5张钞票） 15=3×5 （正确的策略，只用3张钞票） 为什么会这样呢？贪心策略错在了哪里？ 鼠目寸光。 刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。 在这里我们发现，贪心是一种只考虑眼前情况的策略。 五大常用算法——贪心算法详解及经典例子_ 别再想更好的办法的博客-CSDN博客 _贪心算法。 回溯 引自：leetcode回溯算法（backtracking） 总结_wonner_的博客-CSDN博客 _leetcode 回溯。 回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 回溯算法详解及Leetcode经典例题解答_ 芒果就是没有盲的博客-CSDN博客 _回溯算法leetcode。 leetcode回溯算法（backtracking）总结_ wonner_的博客-CSDN博客 _leetcode 回溯。 五大常用算法——回溯算法详解及经典例题_ 别再想更好的办法的博客-CSDN博客 _回溯算法经典例题。 分支限界 引自：五大常用算法——分支限界算法详解及经典例题_ 别再想更好的办法的博客-CSDN博客 _分支定界法例题详解。 对比回溯法 回溯法的求解目标是找出解空间中满足约束条件的所有解，想必之下，分支限界法的求解目标则是找出满足约束条件的一个解，或是满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 另外还有一个非常大的不同点就是，回溯法以深度优先的方式搜索解空间，而分支界限法则以广度优先的方式或以最小耗费","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:6:2","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"附：算法代码库 零散： 《常用算法程序集》 第五版(C C++)和第六版(C++) 徐士良等著。 C语言程序设计50例(经典收藏)_ 雷银行的博客-CSDN博客 _c语言程序设计。 【】。 Github 开源项目： The Algorithms (the-algorithms.com)-欢迎来到GitHub最大的开源算法库，介绍 搜索算法，一触即达：GitHub上有个规模最大的开源算法库 - 知乎 (zhihu.com)。 TheAlgorithms/C: Collection of various algorithms in mathematics, machine learning, computer science, physics, etc implemented in C for educational purposes. (github.com)。网页版 Algorithms_in_C: The Algorithms - C。 Dev-XYS/Algorithms: 全面的算法代码仓库 (github.com)，C++ 版本。 【】。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:7:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"附：CS 综合学习类 CS 相关的学习路线大总结：rd2coding/Road2Coding: 编程之路 (github.com)。 杂且全：CS-Notes 算法和刷题、操作系统、网络、数据库、系统设计等 CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计 (github.com)。网站版 CS-Notes (cyc2018.xyz)。 杂且全：be-a-professional-programmer stanzhai/be-a-professional-programmer: 成为专业程序员路上用到的各种优秀资料、神器及框架 (github.com)。网页版 前言 | be-a-professional-programmer (stanzhai.site)。 杂且全：easy-cs 网络、算法、系统设计、Java、MySQL、分布式、聊人生等 allentofight/easy-cs: CS，如此简单! (github.com)。 Freely available programming books EbookFoundation/free-programming-books: Freely available programming books (github.com)。网站版 free-programming-books | Freely available programming books (ebookfoundation.github.io)。 算法学习：algorithm-note 算法笔记 dairongpeng/algorithm-note: 该系列包括数组，链表，树，图，递归，DP，有序表等相关数据结构与算法的讲解及代码实现。 (github.com)。知乎介绍文字 《algorithm-note》算法笔记中文版正式发布！ - 知乎 (zhihu.com)。 算法学习：fucking-algorithm 算法刷题 labuladong/fucking-algorithm: 刷算法全靠套路，认准 labuladong 就够了！English version supported! Crack LeetCode, not only how, but also why. (github.com)。网站版 labuladong 的算法小抄 :: labuladong的算法小抄 (gitee.io)。 算法学习：hello-algorithm 基础、刷题、面经和汇总 geekxh/hello-algorithm: 🌍 针对小白的算法训练 | 包括四部分：①.算法基础 ②.力扣图解 ③.大厂面经 ④.CS_汇总 | 附：1、千本开源电子书 2、百张技术思维导图（项目花了上百小时，希望可以点 star 支持，🌹感谢~） (github.com)。网站版 小浩算法 (geekxh.com)。 杂且全：Best-websites-a-programmer-should-visit-zh tuteng/Best-websites-a-programmer-should-visit-zh: 程序员应该访问的最佳网站中文版 (github.com)。 C 相关 杂且全：awesome-c-cn jobbole/awesome-c-cn: C 资源大全中文版，包括了：构建系统、编译器、数据库、加密、初中高的教程/指南、书籍、库等。 (github.com)。 技术面试最后反问面试官的话：reverse-interview-zh yifeikong/reverse-interview-zh: 技术面试最后反问面试官的话 (github.com)。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:8:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"附：嵌入式 综合学习类 linux_kernel_wiki：Linux 内核知识体系与面试题 0voice/linux_kernel_wiki: linux内核学习资料：200+经典内核文章，100+内核论文，50+内核项目，500+内核面试题，80+内核视频 (github.com)。 linux-insides-zh：MintCN/linux-insides-zh: Linux 内核揭秘 (github.com)。网站版 简介 · Linux ­Insides­中文 (gitbooks.io)。 EmbeddedSoftwareEngineerInterview：ZhongYi-LinuxDriverDev/EmbeddedSoftwareEngineerInterview: 嵌入式软件工程师笔试面试指南，主要收录笔试面试八股文。包括C/C++，计算机基础，操作系统，Linux驱动，Arm体系与架构，网络编程，大厂笔试面试题等。持续更新中~~有问题可以加我微信，LinuxDriverDev (github.com)。 embedded-notes：xiaowenxia/embedded-notes: 嵌入式linux软件开发、嵌入式linux驱动开发、c语言、单片机开发、IOT开发等面试要点记录 (github.com)。 从事嵌入式行业的你，现在年薪多少，有什么经历想和大家分享？ - 知乎 (zhihu.com)。 嵌入式面试题，不断更新 - 知乎 (zhihu.com)。 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:9:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"附：算法刷题总结 hello-algorithm 基础、刷题、面经和汇总 geekxh/hello-algorithm: 🌍 针对小白的算法训练 | 包括四部分：①.算法基础 ②.力扣图解 ③.大厂面经 ④.CS_汇总 | 附：1、千本开源电子书 2、百张技术思维导图（项目花了上百小时，希望可以点 star 支持，🌹感谢~） (github.com)。网站版 小浩算法 (geekxh.com)。 CS-Notes 算法和刷题、操作系统、网络、数据库、系统设计等 CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计 (github.com)。网站版 CS-Notes (cyc2018.xyz)。 LeetCode C++ 题解：soulmachine/leetcode: LeetCode题解，151道题完整版 (github.com)。 LeetCode Go 题解：halfrost/LeetCode-Go: Solutions to LeetCode by Go, 100% test coverage, runtime beats 100% / LeetCode 题解 (github.com)。网站版 序 | LeetCode Cookbook (halfrost.com)。 Shortest-LeetCode-Python-Solutions：cy69855522/Shortest-LeetCode-Python-Solutions: Leet Code 刷题笔记 - - 不求最快最省，但求最短最优雅，Shorter is better here. (github.com)。 LeetCode with Python and JavaScript：HuberTRoy/leetCode: 算法相关知识储备 LeetCode with Python and JavaScript (github.com)。 四个附录，该部分涉及十几个 Github 仓库，鉴于挨个下载很麻烦，这里我全部下载并整理好了（四部分仓库 + 硬件领域面经集合 1.42 GB 侵删）： 链接：https://pan.baidu.com/s/1-A_wA3YP4666tge2llxqEg 提取码：XHYN –来自百度网盘超级会员V4的分享 ","date":"2021-12-10","objectID":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/:10:0","tags":["数据结构与算法","软件"],"title":"（大集合）数据结构与算法简述和CS综合","uri":"/15%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0%E5%92%8Ccs%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"BLDC 六步法 \u0026 PMSM  FOC 法 综合啊~","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"BLDC 六步法 \u0026 PMSM FOC 法 综合 查阅 n^2 的各方资料，对 BLDC\u0026PMSM 进行一个大综合、大整理，查阅、比较和整理 大量的 网络教程、大厂手册、开源解决方案，在这里形成 原理和解决方案 的打通式介绍。 我的相关项目的开源部分 iBLDC 项目仓库，包括 方案原理的详细介绍、原理图、Multisim 仿真 等丰富资料。本文所分享的资料： 搜集大量的教程文档、大厂手册：链接：https://pan.baidu.com/s/1LtJ5qIsCgXu5O3LZAy3UHA 提取码：XHYD （侵删）（497MB） 搜集的 大厂方案 + Github 开源项目：链接：https://pan.baidu.com/s/1G76TcIt1bzDZkOVQ3Zhn7A 提取码：XHYL （侵删）（944MB） ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:0:0","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"网络教程 入门文章，首先看：无刷电机的工作原理图解 (360doc.com)、【学习】无刷直流电机的基本结构及工作原理_duoduo_bu的博客-CSDN博客_无刷直流电机工作原理、无刷直流电机系统基础知识 - 电工基础知识_电工学习网 (diangon.com)。 BLDC驱动学习_ 啥也不会唉的博客 -CSDN博客_bldc驱动。 【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术 - 知乎 (zhihu.com) 该文对于 BLDC 和 PMSM 的介绍和区别 讲的比较好。 永磁同步电机控制笔记：foc控制原理通俗讲义_ 搞机的博客 -CSDN博客 _foc原理。 对于两个变换的一些形象演示的动图，比较直观： FOC中的Clarke变换和Park变换详解（动图+推导+仿真+附件代码）_ GREYWALL-CSDN博客 _clarke变换。 永磁同步电机控制笔记：clark变换park变换示意图_ 搞电机的博客-CSDN博客 _电流clark变换。 一个 FOC 相关的文章集 永磁同步电机_搞电机的博客-CSDN博客。 完整展示 SVPWM 的计算过程 svpwm仿真_ 基于Simulink的SVPWM仿真模块 _weixin_39631689的博客-CSDN博客。 对于无刷电机的 概念基础知识 和 与 有刷电机的比较：无刷电机_百度百科 (baidu.com)；(原创）让你真正了解手里的无刷电机 (360doc.com)。 引自：无刷电机_百度百科 (baidu.com)、(原创）让你真正了解手里的无刷电机 (360doc.com)、无刷电机基础知识 (360doc.com)，摘一些句子，侵删。 无刷电机优点：低干扰、低噪音、寿命/工作时间长、低维护成本、可控性好、高速、节能、功率密度大等等。其的一些缺点：驱动器成本较高、永磁体不适用于高温、转矩波动等需要控制好（较难）才能用于高性能/低速/位置控制的伺服系统。 无刷电机的换向模式分为方波和正弦波驱动，就其位置传感器和控制电路来说，方波驱动相对简单、价廉而得到广泛利用。目前，绝大多数无刷电机采用方波驱动，目前市场上的模型电机全部是方波驱动。 电机的转矩和转速在同一个电机内永远是一个此消彼长的关系，基本可以认为转矩和转速的乘积是一个定数。导体的发热与电流的平方是正比关系，在更高的电压下，如果是同样的功率，电流将下降导致发热减少，使得最大功率增加。这也解释了为什么在专业的航拍飞行器上，大量使用22.2V甚至30V电池来驱动多轴飞行器，高压下的无刷电机，电流小、发热小、效率更高。 槽极结构 （N：槽数，P：极数） 模型常见的内转子无刷电机结构有：3N2P（有感电机常用）、12N4P（大部分内转子电机） 模型常见的外转子无刷电机结构有：9N6P、9N12P、12N8P、12N10P、12N14P、18N16P、24N20P。 模型用内转子无刷电机极数不高的原因：目前内转子电机多用于减速使用，所以要求的转速都比较高。电子（电角度）转速=实际转速*电机极对数，电子控制器支持的最高电子转速往往都是一个定数，所以如果电机极对数太高的话，支持的最高电机转速就会下降，所以目前的内转子电机极数都是4以内。 关于12N4P内转子电机：属于整数槽电机，大量使用于模型内转子电机，电机使用单层绕组分布绕线。 模型用外转子电机都是分数槽电机，其结构特点和性能如下： N必须是3的倍数，P必须是偶数（磁钢必须是成对的，所以必须是偶数）。 P数越小，最高转速越高。例如12N10P的最高转速肯定低于12N16P，反之亦然。 N比P大，则相对转速更高。9N6P最高转速肯定高于9N12P，反之亦然。 同样的N，P越大扭力越强。扭力，12N16P大于12N14P大于12N10P。 N和P之间不能整除，比如12N6P。 外转子槽极结构与应用领域：9N6P减速使用于400-500级别的直升机模型以及小型涵道、9N12P直驱使用于小型固定翼或者其他模型、12N8P减速使用于500-700直升机模型或者直驱使用于中大型涵道、12N10P减速使用于600-800直升机模型、12N14P直驱使用于大部分固定翼和船模，高于12槽结构的无刷电机多见于多轴飞行器。 有感电机与无感电机（即有、无传感器的） 有感电机的优势：运转精度高、启动平稳 有感电机的劣势： 在高温、振动等条件下由于传感器的存在使系统的可靠性降低。 传感器连接线多不便安装、易引起电磁干扰。 传感器的安装精度直接影响电机运行性能，特别是在多极电机安装精度难以保证。 占用空间，限制电机小型化。 无感电机的优点：结构简单、成本较低、安装方便 无感电机的缺点：转子位置检测精度降低，运转精度降低，启动不如有感电机平稳。 什么是有感电机：传统的无刷电机都安装有霍尔传感器，利用霍尔传感器检测转子位置实现转向。 什么是无感电机：去除霍尔传感器，利用电子控制器检测电机的反电动势变化从而确定转子位置实现转向。 外转子无刷与内转子无刷 外转子无刷电机的优点：转动惯量大、转动平稳、转矩大、磁铁好固定。 外转子无刷电机的缺点：定子热量无法排出、内部工作环境部封闭，外部杂物可能进入电机内部影响运转。 内转子无刷电机的优点：绕组与外壳直接接触，热量可直接排出，电机内部与外部隔绝，避免外部杂物进入内部。 内转子无刷电机的缺点：扭矩不如外转子无刷电机、磁铁固定较为复杂。 搜集大量的教程文档、大厂手册： 链接：https://pan.baidu.com/s/1LtJ5qIsCgXu5O3LZAy3UHA 提取码：XHYD –来自百度网盘超级会员V4的分享（侵删）（497MB） ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:1:0","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"原理详解 高清原图在 iBLDC 项目仓库 内可下载。 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:2:0","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"方波 BLDC 六步换向法 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:2:1","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"方波 BLDC 控制器实施 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:2:2","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"正弦波 PMSM FOC 法 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:2:3","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"FOC 算法实现细节 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:2:4","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"正弦波 PMSM 控制器实施 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:2:5","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"未来需求 关于未来无刷电机驱动的技术满足要求（p.s 画饼什么的，最快乐了），这是美国能源部的数据，如下表，主要是针对汽车应用： 我的无刷电机驱动板子（iBLDC），尺寸在 3cm * 4cm * 1cm，按照上图来讲，2020年要达到高于 94% 效率，并且功率大于160W（远已经达到），2025年要达到1200W，效率要高于98%。 另外，这个表的成本要求非常高；还有提高频率来减小器件体积封装，先进封装，提升散热效率等；更先进的门机驱动提升安全性，完善的保护电路；采用更鲁棒的算法。 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:3:0","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"方案收集 搜集的 大厂方案 + Github 开源项目： 链接：https://pan.baidu.com/s/1G76TcIt1bzDZkOVQ3Zhn7A 提取码：XHYL –来自百度网盘超级会员V4的分享（侵删)（944MB） ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:4:0","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"大厂库 infineon 电机控制芯片选型：电机控制芯片 - Infineon Technologies。 英飞凌有一些 带 MOS 预驱的 M3 MCU 选型，如 集成 Arm® Cortex® M3 的 3 相桥式驱动器 - Infineon Technologies，另还有许多 BLDC 电机评估版，并配套了 软件库 等全套东西，比如 BLDC_SHIELD_TLE9879 - Infineon Technologies。 TI TI 电机驱动器 选型：无刷直流 (BLDC) 驱动器 | 概述 | 电机驱动器 | 德州仪器 TI.com.cn。 搜索 TI 的参考设计库，有非常丰富的 BLDC\u0026PMSM 参考设计，原理图、软件库均公开：TI 参考设计库：BLDC。 评估板 的软件包 和 FOC 算法软件 具体在每一个 BLDC\u0026PMSM 参考设计页面均提供下载。 可以使用 其 IQmath 库：基于STM32实现SVPWM调制算法 - 知乎 (zhihu.com)；基于C语言的Q格式使用详解 - 知乎 (zhihu.com)； ST ST 的无刷直流电机驱动选型：无刷直流电机驱动器 - STMicroelectronics。 评估板：3相6步控制 - STMicroelectronics；三相磁场定向控制FOC - STMicroelectronics。 运动和驱动解决方案：运动和驱动解决方案 - STMicroelectronics。 ST 的 电机软件库 使用 ST MCSDK，其作为 X-CUBE-MCSDK 部件，其自带 上位机界面 进行曲线查看和参数调试等。下载页面 X-CUBE-MCSDK - STM32电机控制软件开发套件（MCSDK） - STMicroelectronics，其更多文档下载 stmcu.com.cn X-CUBE-MCSDK 页面，更多培训视频 基于MC SDK V5.4电机库的STM32电机控制理论与实践-电堂科技 (51diantang.com)、STM32电动机控制应用系列讲座-电堂科技 (51diantang.com)、STM32 TALK (电机控制私享会)-电堂科技 (51diantang.com)。 ST MCSDK 网络文章教程： STM32G4板卡分享—STM32G4在电机控制中的应用 - 知乎 (zhihu.com)。 如何拷贝工程_工程师笔记 | 如何结合STM32CubeMX与MC Workbench生成修改未包含的芯片程序…_喵仔冲鸭的博客-CSDN博客。 type=file 把默认的未选择文件换成别的_工程师笔记：如何结合STM32CubeMX与MC Workbench生成修改未包含的芯片程序…_weixin_39630247的博客-CSDN博客。 对于 STM32 F4 的 DSP 和 一些 数学函数 的使用，使用 CMSIS 的 DSP，可以参看 安富莱 对于 STM32 DSP 的丰富教程。 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:4:1","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["【直达本质入门】系列"],"content":"开源项目 选择一个去看手册和源码去实现即可。 国内做 BLDC\u0026PMSM 教程开发板的，举例两家 硬石 和 匠心，淘宝搜即可，前者资料开源，后者的资料其实也 被 “开源了”。 ODrive：官网 ODrive (odriverobotics.com)；odriverobotics/ODrive: High performance motor control (github.com)；madcowswe/ODriveHardware: High performance motor control (github.com)。 VESC（国内常称 “本杰明方案”）：VESC Project (vesc-project.com)；vedderb/bldc: The code for my custom BLDC controller. (github.com)；vedderb/bldc-hardware: Brushless DC Motor controller from Benjamin Vedder (github.com)；vedderb/bldc-hardware: Brushless DC Motor controller from Benjamin Vedder (github.com)。 基于VESC的衍生开源项目 举例： shamansystems/Cheap-FOCer-2: Low-Cost Motor Controller based on the VESC 6 (github.com)； aramaerospace/Micro-VESC-6: Micro VESC-6 (github.com)； BMS mpater/bldc-BMS: Battery management system for a VESC (github.com)；vedderb/vesc_bms_fw: The VESC BMS Firmware (github.com)。 SimpleFOC：Home | Arduino-FOC (simplefoc.com)。 中文网页手册 simplefoc/docs_chinese: SimpleFOC docs website translated to Chinese (github.com)； simplefoc/Arduino-FOC: Arduino FOC for BLDC and Stepper motors - Arduino Based Field Oriented Control Algorithm Library (github.com)； \u003c 5A 版本：simplefoc/Arduino-SimpleFOCShield: Arduino Shiled for running Gimbal BLDC motors with FOC algorithm (github.com)； \u003c 30A 版本：simplefoc/Arduino-SimpleFOC-PowerShield: A powerful Arduino shield for running BLDC motors using the FOC algorithm (github.com)。 更多开源项目： FOC 算法经过优化、合并精简的一个自实现：ZhuYanzhen1/miniFOC: 你还在为有刷电机的高噪声、低响应速度和低寿命而烦恼吗？这个项目是一个20块钱就能搞定的FOC无刷电机控制方案！This project is a FOC (Field Oriented Control) BLDC Motor control scheme that can be done for 3$! (github.com)。 一个 无感 FOC 实现：NYCParker/sensorless_foc: 电机驱动开发项目：sensorless_foc (github.com)。 使用 ST MCSDK 库生成工程：dtltljb/FOC-MOTOR-CONTROLLER: 基于STM32有感直流无刷电机驱动控制程序，集成CANopen通讯电机控制子集协议 和 MONDBUS 协议。 (github.com)。 一个 C++ 实现 FOC：BetzDrive/bldc-controller: Motor controller firmware! (github.com)；硬件：BetzDrive/bldc-controller-hardware: Hardware design files for BLDC servo controller (github.com)。 基于Hall估计角度的FOC，Matlab仿真并生成c文件的方案：FOC 算法的 Matlab 仿真 EFeru/bldc-motor-control-FOC: Field Oriented Control (FOC) for BLDC motors (github.com)；FOC 仿真后部署在 板子上 EFeru/hoverboard-firmware-hack-FOC: With Field Oriented Control (FOC) (github.com)。 SimpleFOC 实现 ChenDMLSY/FOC-SimpleFOC-MotorDriveDevelopmentBoard: drive a brush motor，drive brushless motor (github.com)； 方波BLDC六步法 ChenDMLSY/ZM_Xdrive_1.0: 该驱动板支持：霍尔无刷驱动、感应电动势无刷驱动、simpleFOC、直流减速电机改舵机，多样性功能，性价比高 (github.com)。 zhutongwen/BLDCM_square_wave: 无刷直流电机方波驱动程序，stm32f4驱动两个无刷电机 (github.com)；zhutongwen/BLDCM_sine_wave: 有感无刷直流电机驱动程序，一个stm32同时驱动两个无刷电机，正弦波驱动 (github.com)。 ","date":"2021-12-24","objectID":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/:4:2","tags":["无刷电机驱动"],"title":"【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合","uri":"/16bldc%E7%9A%84%E5%85%AD%E6%AD%A5%E6%B3%95pmsm%E7%9A%84foc%E6%B3%95%E7%BB%BC%E5%90%88/"},{"categories":["人与世人的关系"],"content":"批判与扶正歪气啊~","date":"2022-01-22","objectID":"/17%E6%89%B9%E5%88%A4%E4%B8%8E%E6%89%B6%E6%AD%A3%E6%AD%AA%E6%B0%94/","tags":["杂谈"],"title":"批判与扶正歪气","uri":"/17%E6%89%B9%E5%88%A4%E4%B8%8E%E6%89%B6%E6%AD%A3%E6%AD%AA%E6%B0%94/"},{"categories":["人与世人的关系"],"content":"批判与扶正歪气 前言：我有两个有关总结自己社交账号发的情绪化或理性化的随笔、想法，一个是给我自己也希望帮助到别人——《只剩结论的故事便是短句合集》，另一个是给别人也希望帮助到自己——《批判与扶正歪气》。 在开始本文之前，可以先打开下面链接看一看： 在这里我只陈述事实，我只讲我的亲眼所见、亲耳所听以及亲身感受到的最真实的一切 - 知乎 (zhihu.com)。 有关教育的理性讨论和批判的收集 - 欢迎来到 Staok - 瞰百易 (github.io) “捅破窗户纸，把磕唠明白” 说实在的，上了研究生后周围的同学（包括同级的、学长、学弟等等）让体会到了人的多样性（中性意思）（知乎等网站上看我写的东西的同学不多），可能是我本科在电子类实验室充实的学习、比赛的时光比较长，在实验室住了两年多，二十多个包括国、省奖的证书，那时候周围的人还都算比较上进，就是一到了研究生周围的人大都变成了是普普通通“正常的”本科只有上课、考试这么过来的，有些不适应罢，（可甚至有个别日常不自觉的负能量，可以自我批判，但是能不能别经常这样口嗨贬低自己和给自己负面心理暗示，朝气蓬勃一些像个年轻人）。欸你可不要有什么偏颇误解，本科时候在实验室认识的学长、学弟等，他们其中上了研究生的，我们也交流过，他们也说感觉周围同学的水平一下下降的太明显了（其中一个原话：“刚来的（研究生）连C语言都不会”，欸好几个人不约而同的表达过这种意思，这只是其中一个例子，我可不是鸡蛋里挑骨头或者搞特例），而且还都是不错的211、985学校，而且要说明的是，这是学生和学校教学两方面的事情。批判、扶正歪气我实在憋不住，自上研究生后（2020.9以后）偶尔输出的一些这样的话，大都发在知乎的想法里，现都收集罗列在下面。 补充一句，我只说整体感觉而非针对个人更非所有人。我有提到，在社会上爱怎么摸鱼躺平都是你的自由，但是这是在高等学府里，主旋律还是钻研，而不是国家养着混日子的年轻时光。由未来想做到的（远景）来反推当下应该怎样（深度思考），至少这没坏处，寻求反馈和激励，何乐而不为之？。 “戒骄戒躁，慎言慎行” 在整理完本文之后，回来在开头添加一些内容： 本“合订本”，语言糙了些，说话直了一些，但，是出于一种提醒，一种批判，一种“强迫症”？，这种声音，这种发声，得有，“脱离冷气，向上走”。 我想，有这篇文，是在看到现实中有缺陷可以变得更好的地方，想要批判一番，没什么，若有能力让这个世界更美好一些，但愿那时我是美好的，也能赠你美好。 本文总结下来，无非是这两个事情： 深入理解学科：课程上多理论联系实际，带着学生完整的经历项目的发现问题、分析理解、设计方案和解决问题的过程。 向上的积极氛围：实验室形成学习路线参考清单，实践方面的经验和规范积累可以形成文件和表格，自主看、学、做，自动化管理，自动化传帮带。 以下开始。一些说的有点过了的话加了删除线嘿~ p.s 试看本篇，大体为此：研一阶段嘎嘎输出吐槽，研二开始对事不对人，研三开始在 “我才不管呢~” 和 “我得试着改变！” 之间。 有用的讨论西边升起的太阳，没用的叽叽喳喳几十年如一日，那首歌“xx还是从前那个少年没有一丝丝改变”，太对了，~~视野还跟小孩一样呢，~~没有一丝丝改变（混就完了）。（2020年12月23日） 喧浮雕楼，起于沙丘，凝结沙丘，继续盖楼，这样的事情，烦。醉如一叶知秋，实却一叶障目（释义：喧嚣、浮躁的起一栋标致的楼，细看却是沙丘的地基。这样的事情，贻笑大方、司空见惯了。沉醉、自信好似一叶便知了秋，实却一叶障目）。（2021年1月25日） 这果真是一个熟人社会而不是专业者的社会，遇到问题首先找自己熟悉的人，即使更熟悉这个问题的人就在ta身边。（2021-01-1） 可以这样体会一下。在一群整天不严肃不认真、开玩笑、玩梗、事不关己高高挂起的人中间，有一个人只要严肃认真思考一点，这人就是另类~~，就是sb，就一直被误解。~~（2021.3.19） 还有一件事，如果你有这种倾向，那就是“不了解的，就是对立面！没看到的，就是不存在！”,或者“容易陷入迷之自信”，或者“容易陷入以点盖面、以偏概全”，等等，细细考虑，若有这种机械静止独立的形而上学的潜意识，或者“吾日三省吾身：聚餐乎？闲扯乎？摸鱼乎？”，那么你不适合搞技术或者科研，甚至可能是打内心深处“看不起”搞技术的人，你认为他们生僻、独行、神秘、没有娱乐等等。（2021.3.26 无同道中人ing） 种种社会现象，似乎说明摸鱼已经是一些年轻人中的真实写照，而不是只是一句玩笑，一个梗吧。或许有两个原因，一，想在大城市富起来并安居乐业的追求与自身现实的实力严重不匹配，而回到三四线的家乡可能又难为情，或者互联网上资本的反对声音越来越广泛和同频 ，误解为为资本辛苦劳累的打工，同时又不能实现一步登天的幻想，便索性把曾经热血和追求高远理想的自己杀死，然后说着平平淡淡难能可贵，思想之随热点肆意变化，难能安心寻找自我和保持前后一致，二，梗，不是乱刷的，全民皆复读机，不分场合，这好吗，这不好，误读多了就当真的，当真就输了，好自为之，好好反思。（2021-4-19） 补充：关于第一点，我为什么说“先杀死那个热血的自己，再想过平平淡淡”这个有先后逻辑的句子，而不是“有的人本来就希望中庸过完一生”，因为我思考，一个成年人，不会无缘无故就变得享乐主义和佛系和无所事事，那是小孩，我想一定是有原因的，只是在潜意识里影响了自己发生改变，比如现实的“遥遥无期”和沉重以及需要辛苦，比如十几年的应试教育或者叫樊笼教育（久在樊笼里）没有让自己找到方向找到人生意义而迷茫，比如社会风气的影响等等。 但可不用为这些话感到焦虑，我只是说说，也可能说的不对，因为“摸鱼”是人类的正常反应，只是有的鱼跟我说，他们在游向龙门的时候，老被摸很烦。再说两个原因，三，恶性竞争病态加班的风气就像各个高中学衡中模式一样希望提高产出率，当生产队的驴一样不敢让歇，有时管理水平低效，表面嘻嘻哈哈，实则巴不得逃离岗位就像逃离炼狱，本就有机会把工作变成兴趣或者把兴趣变成工作，但内部和外部的重重暗示和影响，整的正好本末倒置，享乐风气兴起不是没有道理；四，想不起来了。（2021-04-20） 有没有发现，“我太难了”、“我好南”这个梗现在几乎没人提了，怎么说？看来在现在和在这个梗出现之前不难，有这个梗的时候大家都很难，开个玩笑；如果现在的某个梗在以后渐渐消失的时候，那么人的思想是否也会随之改变，变到下一个热门的梗？没有独立的人格，就没有完善的审美，独立性何在？也许大家玩梗并没有当真，只是说笑，但是没有人能挡住一些负能量的梗，偏偏就被一些人潜移默化的学去了。在另一个角度上，文化繁荣可不是指望这个，是百花齐放，百家争鸣，多种多样的有意义的想法和声音，而不是工厂生产出来的复读机。 不妨跳出一个圈子去看这个圈子，你会看的清清楚楚。很多非常像，我不是指外貌上，而是“同质化、复读机式的玩梗、丧、摸鱼、听不进去、躺平、变化的立场、诡辩一流、前后无法一致是他们平时的言语主基调”。（2021-05-24) 有的人说要追求快乐，难道你是人类个体里面特殊的吗？我觉得，是个人都会这样，有这样的想法。我见过一个大佬在文章里说看linux源码就像欣赏冰川，袁老说最大的梦想之一是“禾下乘凉梦”，想必，那一定是莫大的慰藉和欣慰，他们转化了人生要做的事为快乐。而我经常遇到，一些人看到那个人所做的事情不是能让我自己快乐的，所以认定那个人一定不快乐，怎么说？人类的悲欢并不相通。（2021-05-25） 这是卡尔，是个乐意助人的家伙，哦，瞧瞧谁来了，这是查理，他想开一家私人侦探所，而这位…这位是麦克，对所有人类发展出的学科和技艺都不感兴趣，就像在这个地球上的其它所有生物一样，喜欢进食和不断加强自己在娱乐方面的非条件反射，并对自己的判断有自以为是的审美。（2021-08-14） 如果你认为只是打工，那么如愿以偿，永远低水平打工；如果你认为这个世界有那么多人造物和自然造物等待好奇，那么如愿以偿，一直都在探索、探险；如果你认为要鸟瞰，那么你会向上走去开阔视野。你自己是什么模样的，你看到的世界就是什么样的，你自己是多面的，你看到的多个角度的世界同样是分明多彩的。（2021-08-18） 带着消极、无趣的态度去学习，就好像小朋友不吃饭然后被家长说时候，很难的一边哭一边吃，饱了之后，熟练了之后，然后真香。（2021年8月28日） 如果被问起来与我现在周围人的关系，我的回答记录在这里。没事，不久就会好起来或者周围的人就换了。 日常量看，第一态度，第二野心，第三这个态度是否匹配这个野心。野心有，态度不行，这是什么，眼高手低，蒙混过关，心比天高，实操浮躁，不成体系。 不是人多的一方的立场就一定正确，但是有一样对多数人都正确，就是走正道。国家开始从注重发展效率向注重公平过渡，歪门邪道的相信会被毒打。~~做面试题拍下来让其他人代搜，这是什么歪门邪道的传统，提议取消，~~既然还在学校里，日常主旋律是学习，专注于某一个赛道而不是朝三暮四，到社会上之后再想着日常的玩、享受怎么来。我本科实验室就是老的给新的讲几次，交流频繁，氛围浓厚，数据结构与算法，网络，操作系统，扎扎实实沉积下来，甚至留下经过筛选和考验的优质资料，一代强就代代强形成良性循环了。 我以后应该多向上、向高一点的地方看。（2021-09-10） 真得说一句，解解惑。 之所以知道电源怎么画，mos怎么驱动等等，是咋来的啊？从大一开始，软件玩着写，画板子芯片发烫、输出不正常，线路熔断，电路板着火，炸管子，一直到大四还会出问题，细节经验没人带、没人说，就靠做得多试的，这么一个坑一个坑一个不落的过来的（但也有开窍、上","date":"2022-01-22","objectID":"/17%E6%89%B9%E5%88%A4%E4%B8%8E%E6%89%B6%E6%AD%A3%E6%AD%AA%E6%B0%94/:0:0","tags":["杂谈"],"title":"批判与扶正歪气","uri":"/17%E6%89%B9%E5%88%A4%E4%B8%8E%E6%89%B6%E6%AD%A3%E6%AD%AA%E6%B0%94/"},{"categories":["人与世人的关系"],"content":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计啊~","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计 ","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/:0:0","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"按 这篇考研经验总结文章提到过，我自身对于一个英文句子如果单词都认识那么大概率可以自然翻译出来（大概是得益于看英文电影（偶尔不带翻译字幕）和英文芯片手册多的原因培养了语感），所以主要矛盾是单词，那么考研英语的单词是有限的，我在想数十年的考研英语真题会不会有一部分词的频率会非常高而且我不认识呢？把这一部分找到并记住，那估计就能达到事半功倍的效果。有人会说很多考研英语大V都总结了高频词汇，我看过了…不知怎的，我觉得我要亲自给历年所有真题的词汇排个序看看长什么样。因此我找到了十几年的英语真题并对所有单词的频率做了一个排列，当这个列表出来的时候，我心里就有谱了，过一遍这个感觉比背数千个考研词汇感觉较踏实（或省事儿，果然懒是第一生产力。但背这个表的这个途径是我个人的感觉和想法，不代表所有人），这里分享一下当年（2019秋天）做这个列表的过程。 直接拿结果（1986-2019考研英语一/英语二真题 + 软件 + 词频统计结果）：链接：https://pan.baidu.com/s/1QUho1dUEBYfKHYQcyiRvdA 提取码：XHYQ。 ","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/:0:1","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"步一：收集全部文本 找到所有真题。 大部分是 .pdf 文件，用 Adobe Acrobat 一个一个文件 做识别 并 复制-粘贴 所有文字到一个 word 文档里。 关于 PDF 文字提取： 国内很多 PDF 浏览器带付费功能的 pdf 转 word，氪金玩家可以忽略后面的方法； 使用 Po解版的 Adobe Acrobat 可以直接导出 PDF 的文字； 个别免费/Po解的 小型 OCR 软件来提取一小部分文字； 百度网盘 SVIP 提供此功能； 一款被严重低估的PDF阅读器，含多项实用功能：PDF-Xchange editor 9.0； PDF 补丁丁简介 - PDF补丁丁 - 博客园 (cnblogs.com)； 等等。 ","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/:0:2","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"步二：词频统计 词频统计，word 竟无此功能，查到 Replace Pioneer 软件可以做到词频统计： 引用 推荐一个好用的统计词频软件：replace pioneer - 简书 (jianshu.com)： 引用 Replace Pioneer 统计单词出现频率 - 知乎 (zhihu.com)： Replace Pioneer是一款与众不同的专业文本批量替换和处理软件。 它的强大可以简单概括为：给定任何纯文本文件，二进制文件甚至网页地址，只要你能描述清楚转换规则，就能得到任何需要的结果文件。 虽然Replace Pioneer主要是一个文本替换工具，但是它衍生出来的功能几乎覆盖了纯文本处理的任何一个角落，而且在任一领域，它都有独到之处。 我常常用它来统计单词出现的次数。 操作方法:打开菜单栏的Tools-\u003eBatch Runner 官方教程：Replace Pioneer Demo – Count_and_statistics (mind-pioneer.com)。 ","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/:0:3","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"步三：浓缩 统计之后得到一个 词频统计列表，很长，word 有184页，截开头一部分如下图，左边是词频，右边是单词： 这个表 我没事的时候就刷，快速的从头到尾 把 其中的生词 用红色标出，为了单独提取出来，如下图举例： 然后在 word 中 查找-\u003e高级查找，再按如下操作，来查找所有字体颜色为红色的部分。 查找完后会选中所有红色标记的单词，就是生词，有 1044 项，这些目前都是被选择的状态，可以直接 复制-粘贴 到一个新的文档。 接着，可以全部粘贴到 excel 里面（共一列），然后可以丢给 百度翻译，得到 一列 的 翻译结果，然后再 复制-粘贴 到 excel 的第二列，得到如下表（截最后一部分）（翻译只是给个提醒，有些词是多意思的）： 得到这里最适合自己的精华，背就完了！ . 全部资料：1986-2019考研英语一/英语二真题 + 软件 + 词频统计结果 链接：https://pan.baidu.com/s/1QUho1dUEBYfKHYQcyiRvdA 提取码：XHYQ –来自百度网盘超级会员V4的分享 ","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/:0:4","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"最后 当然，以后遇到的生词啊和需要用到英语的地方，该内化的是迟早要内化掉的（内化：即想即来的听说读写）。 做事不局限于表面，而是想这件事儿的根本在哪，抓主要矛盾，抓住底层关键起作用的少部分东西去解决，而比生硬的解决（比如记忆力好的人可以靠全背下来这种暴力穷举破解（如穷举法破密码）方法）要高效很多，有点儿像第一原理的方法论，其实，不管做什么事儿都可以像做科研一样调研呀。甚至可以反复品读和验证自然辩证法和其中的方法论模式思考问题，太强了（想回顾一下过去十几年学的所有政治课本，感觉全是宝库）。当设计和路线完成之后，其实会发现最缺的就是，时间，时间。 ","date":"2022-01-29","objectID":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/:0:5","tags":["杂谈","考研"],"title":"抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计","uri":"/18%E6%8A%93%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%BB%E8%A6%81%E7%9F%9B%E7%9B%BE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"},{"categories":["人与世人的关系"],"content":"关于人生、学习的阶段性总结和小窍门（2021及以前）的记录啊~","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前） ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:0:0","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"关于人生小窍门 ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:1:0","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"自己总结 【杂谈】过往时期 - 知乎 (zhihu.com)，以小见大，杂记过往历程。 【杂谈】给本科实验室的分享PPT - 知乎 (zhihu.com)，一步一步推演出正确的观念（其实就是用来勉励大家学习的一文）。 【杂谈】给本科实验室的分享PPT-回复各种问题 - 知乎 (zhihu.com)，接上文。 批判与扶正歪气 - 知乎 (zhihu.com)，一言难尽。 【杂谈】师之传达（长期更新） - 知乎 (zhihu.com)，杂记。 【杂谈】只剩结论的故事便是短句合集（长期更新） - 知乎 (zhihu.com)，杂记，包罗万象。 ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:1:1","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"关于人生，网上提醒文章 p.s. 网上的鸡汤文很多，内容很丰富看不完的，所以先认真看几个、学几个就行了暂时。 工作能力强的人，都有哪些特点? - 知乎 (zhihu.com)。 接受工作，只问标准。 请示工作，必带方案。 汇报工作，突出结果。 分享工作，细说流程。 复盘工作，漫谈感受。 如何从底层杀出？ - 知乎 (zhihu.com)，看看罢，努力的结果就像开盲盒。 你有哪些屡试不爽的经典话术？ - 知乎 (zhihu.com)，杂而实用。 27岁了跨考计算机研究生会不会太晚？ - 知乎 (zhihu.com)，我加一句，除了“干就完了”，还要搭配“求稳”，多面考虑。 有哪些有哲理有深度有内涵的好句子？ - 知乎 (zhihu.com)，杂。 人的一生到底该追求什么？ - 知乎 (zhihu.com)，其中最后说到 “如此，越来越多的人会觉醒：与其消极沉沦，不如奋力抗争，与其选择庸俗的残喘，何不选择高尚的绽放”，对啊~ 如何辨认身边的聪明人？ - 知乎 (zhihu.com)。 基础指标的第一个标准，是元认知（Metacognition）能力。 基础指标的第二个标准，是有具有逻辑性的思维跳跃能力。 现实指标的第一个标准，是好奇心。 现实指标的第二个标准，是用简单的语言解释复杂的问题的能力。 25岁前，一定要完成哪些人生规划？ - 知乎 (zhihu.com)，可传家。 加菜 知乎禁止转载的回答怎么复制做笔记？ - 知乎 (zhihu.com)。 ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:1:2","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"关于学习和本门功夫 ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:2:0","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"关于学习，网上启发文章 我们高中数学为什么不重视算法？高中学的数列，三角函数，求导，圆锥曲线相关问题的解法和算法有什么关系？ - 知乎 (zhihu.com)，对于新学一门技艺，工欲善其事必先利其器，这里的“器”我想应该是建立解决问题的“思维”或对的习惯。链接中介绍的认知逻辑很少见？原因在于… 毛泽东为什么对当年教育现状那么不满？ - 知乎 (zhihu.com)。 中国教育的现状如何？ - 知乎 (zhihu.com)。 如何看待微信朋友圈里这种论调「孩子，我宁愿欠你一个快乐的少年，也不愿看到你卑微的成年」？ - 知乎 (zhihu.com)。 耳目一新的说法，不过我本科时候电子科技… - 知乎 (zhihu.com)。老生常谈的兴趣，或可以极大提升人生体验。 符合人认知逻辑的的学习流程，才是根儿上的东西： 编程新手如何提高编程能力？ - 知乎 (zhihu.com)。 编程究竟难在哪？ - 知乎 (zhihu.com)。 为什么部分大一学生认为线性代数听不懂？ - 知乎 (zhihu.com)。 ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:2:1","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"本门功夫 我一直留着几个看起来不起眼的东西，这个… - 知乎 (zhihu.com)。 自动化专业硕士毕业走向，转图供参考 - 知乎 (zhihu.com)。 【目录贴】软硬件规范化 - 知乎 (zhihu.com)。 ","date":"2022-02-10","objectID":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/:2:2","tags":["杂谈"],"title":"【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）","uri":"/19%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F-%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E5%B0%8F%E7%AA%8D%E9%97%A82021%E5%8F%8A%E4%BB%A5%E5%89%8D/"},{"categories":["人与世人的关系"],"content":"Judy Hevenly (Psychic and spiritual counselor) 的2022预测我挑几个感兴趣的记录在此","date":"2022-03-04","objectID":"/20-2022%E9%A2%84/","tags":["杂谈"],"title":"Judy Hevenly's 2022 Predictions that for future reference","uri":"/20-2022%E9%A2%84/"},{"categories":["人与世人的关系"],"content":"Judy Hevenly’s 2022 Predictions that for future reference 外网预测相关的博主（如 youtuber——conscience，还有本文这位都自幼有“gift”的主）火了好几波了，外网娱乐 youtuber 老高与小沫在近期视频有提到这些，并提道“毕竟这种能火了好几拨的，说明人家可能真有实力”哈哈。对于这些”预言“，在这里前置的补充一些说法： 有的很具体，有的比较模糊；对于很具体的有说：“人家有些预测也是基于广泛的真实有效的信息，相互牵绊和推理来总结，结论是有相互关联的”，对于比较模糊的有说是：“人家看到的东西大抵是比较模糊的画面和预兆，只是去猜这个景象的意思”。 “说出来可能就不发生了”；但，我提供另一个角度，也有可能有神秘力量、deep state 之流把这些当作“剧本”去执行，然后大部分兑现了…额…我就是说说。 Judy Hevenly (Psychic and spiritual counselor) 的2022预测我挑几个感兴趣的记录在此，备将来查（引用原网址：2022 Predictions - Judy Hevenly）： 1、Covid-19 will make its way out by the end of 2022. Direct impact of COVID-19 and variants will last well into 2023.（意思是整体上来讲，而非所有地方，尤其是呕洲和霉国方向） 2、2022 will be a new world, a re-shaped economy, people will change their long-held beliefs as they adapt to a new society trying to get back to normal. It’s a time to rebuild lives, and a willingness to work hard to see future success and growth. 3、America’s leader will be able to get things done in the first half of the year but in the second half there are possible health problems for President Biden. 4、Us automakers come out with a crash-avoid brake in 2022. A big fire breaks out in Chicago causing much damage to the city. An electrical power outage in New York City. 5、Nasa lands a rover on the Moon to find water and later will mine this water to make rocket fuel during future trips to the Moon. 6、Boris Johnson could step down, Chancellor Rishi Sunak of the Conservatives, Liz Truss, Foreign Secretary, or Jeremy Hunt, could replace him. A hard Brexit could end UK’s growth in 2022. 6.9、Putin will try to destroy the independent state of Ukraine, and get rid of Nato to cement Russia’s role as rival to the West, United Kingdom will have to choose between gas from Russia or Ukraine and Putin will provoke Ukraine by a show of military power. 7、（这一条就很有趣，接上一条，“彼时彼刻、就是此时此刻”）The Chinese will make their move on Taiwan and US will be helpless because of the debt they owe to China, and it will be disastrous for US and the global economy and everyone will have to adjust to a more difficult relationship with that country. 8、Unexpected illness for Vladimir Putin, and protests, uprising and unrest in in his country. 9、Japan becomes a nuclear weapon nation.（第7条的”代价“？） 10、（神秘的光？还着陆？）New sighting and several landings of unknown lights and objects are observed on and above earth, moon and solar system planets and also in Mexico. 11、The Saudis will move further away from America their security guarantor for military and economic purposes ties with China will become more important.（结合第7条后半句？） 12、关于奥斯卡获奖的预测，这主据说准确率90%以上，我没查证，因此这相关的”94th Academy Awards, March 27, 2022“内容略过。 13、The market for artificial intelligence chips will become more popular including designs by start-ups backed by funders.（这个圈内明眼人都可见） 14、The Chinese space station Tiangong will be fully operational which will include anti-satellite weapons. Blue Origin founded by Jeff Bezos has edge I space exploration; Nasa in US will launch three probes in 2022 to study space rocks between Mars and Jupiter. Elon Musk’s Space X will continue to work towards a permanent base on Mars.（马斯克这个我信，毕竟话早已经放出去了） 15、A rocket ship to be launched to shorten the flight from London to Sydney in Australia in under 3 hours.（以后如果问”你咋来的？“回道”我坐火箭来的“可能不是一句玩笑） 16、Hurricane season reaps havoc for parts of New York city, high tides and storms for Philippines, with wildfires in Canada, and Australia. Flooding in China and Caribbean in Winter of 2022. 记录在此将来备查，看看疗效，别”嘴上都是主义，心里都是生意“，大概不会吧…乐观对待。 ","date":"2022-03-04","objectID":"/20-2022%E9%A2%84/:0:0","tags":["杂谈"],"title":"Judy Hevenly's 2022 Predictions that for future reference","uri":"/20-2022%E9%A2%84/"},{"categories":["随机技术情报"],"content":"10分钟入门、10天练习，哪有那么难。根本用不着科班通过上课学几个月。。","date":"2022-04-04","objectID":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/","tags":["软件"],"title":"C 语言学前班","uri":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/"},{"categories":["随机技术情报"],"content":"10分钟入门、10天练习，哪有那么难。根本用不着科班通过上课学几个月。。 ","date":"2022-04-04","objectID":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/:0:0","tags":["软件"],"title":"C 语言学前班","uri":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/"},{"categories":["随机技术情报"],"content":"程序 = 数据结构 + 算法 数据结构：容器来存储要进行各种操作的数据。 算法：对各种数据进行各种操作（加减乘除，增删改查 + 判（判断）排（排序）复（复位））输出结果来达到计算、控制目的。就像函数 f(x)，有输入和输出的盒子，代入 x，计算得到 y = y(x)，这个过程，就是算法。吃经验和天赋，需要反复学习和实践，经验出编程思维。 ","date":"2022-04-04","objectID":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/:1:0","tags":["软件"],"title":"C 语言学前班","uri":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/"},{"categories":["随机技术情报"],"content":"数据结构：基本数据类型 定义一个 存储占用空间 1 字节的 数字，或者叫 变量 a：char a;。 定义一个 整形类型（整数）变量，一般占用 4 字节：int d;。 定义一个 浮点类型（小数）变量，一般占用 4 字节：float c;。 变量可以装填数字，比如 a = 10;、c = 3.14; 等等。 ","date":"2022-04-04","objectID":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/:2:0","tags":["软件"],"title":"C 语言学前班","uri":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/"},{"categories":["随机技术情报"],"content":"算法：顺序、分支和循环 所有的可以归结为算法的问题都可以通过 运算+赋值+顺序+分支+循环 等基本要素完成，支持做到这样的机器可以被称为图灵完备的。 顺序执行：计算 和 赋值。 (a^2 + b^2) + c^2，这是计算，这是一个算式，最终计算结果是一个数，这个数 为 0 就为 逻辑上的 假（false），否则为 逻辑上的 真（true）。 d = 2*c^2;，这是赋值，2*c^2 的值赋给 d，这是一个 语句，以 分号 ; 标识结束，这是要被执行的语句，是行为。 分支 if-else、switch-case、三段式。 if( \u003c判断这个式子是否为真\u003e ) { /* 如果为真就执行这里 */ }else { /* 不为真就执行这里 */ } switch( 一个整形变量 a ) case \u003c某一个整数 x\u003e: /* 如果 a 等于 x 就执行这里 */ break; case \u003c某一个整数 h\u003e: /* 如果 a 等于 h 就执行这里 */ break; case \u003c某一个整数 y\u003e: /* 如果 a 等于 y 就执行这里 */ break; default: /* 哪个都不等于就执行这里 */ break; a = \u003c这个式子是否为真\u003e ? \u003c如果为 真 就把这里的值赋给 a\u003e : \u003c如果为 假 就把这里的值赋给 a\u003e; 循环 while、do-while、for。 while( \u003c1、判断这个式子是否为真\u003e ) { 2、如果为真就执行这里 3、执行完毕后，再去 判断 步骤 1 里的 式子是否为真，若为真则接着执行 步骤2，否则跳出这个循环 } for( \u003c1、先执行这里的语句一次\u003e ; \u003c2、再判断这里的式子是否为真\u003e ; \u003c语句2\u003e ) { 3、如果步骤 2 中的 式子为 真 则执行这里 4、执行完后，再执行 \u003c语句2\u003e，然后再 判断 步骤 2 里面的式子是否为真，如果为真则执行步骤 3，否则跳出这个循环 } ","date":"2022-04-04","objectID":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/:3:0","tags":["软件"],"title":"C 语言学前班","uri":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/"},{"categories":["随机技术情报"],"content":"正式开始吧~ 现在带着这些印象再去看正经的、完整的、系统的 C 教程，应该会体会到 “行云流水” 的学习感觉吧（大概）。 b 站视频：C语言入门_搜索_哔哩哔哩-bilibili。 C 语言教程 | 菜鸟教程 (runoob.com)。 C语言入门教程，C语言学习教程（非常详细） (biancheng.net)。C语言编译器（C语言编程软件）完全攻略 (biancheng.net)。 【规范】万字集大成的C编写规范_Real-Staok的博客-CSDN博客。 勤能补拙，熟能生巧。 再看 《数据结构与算法》，可参考 【万字总结】数据结构与算法简述和CS综合，保姆级一文打包_Real-Staok的博客-CSDN博客。 然后可以学习其它方向，可以参考 【目录贴】软硬件规范化 - 知乎 (zhihu.com)（CSDN 链接）。 ","date":"2022-04-04","objectID":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/:4:0","tags":["软件"],"title":"C 语言学前班","uri":"/21c%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%89%8D%E7%8F%AD/"},{"categories":["人与世人的关系"],"content":"专门分享一些学习、比赛经验","date":"2022-04-12","objectID":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/","tags":["杂谈"],"title":"新生工程导论讲座PPT-17.11.23","uri":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/"},{"categories":["人与世人的关系"],"content":"大三，时间 2017.11.23。PPT 使用 锤子演示 制作，动态立体旋转的切图效果很赞。同另外几个同学一同受以升老师邀请专门分享一些学习、比赛经验。主要分为两个部分，第一个部分讲一个刚做完的比赛，第二部分是主体：学习、比赛经验分享。 ","date":"2022-04-12","objectID":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/:0:0","tags":["杂谈"],"title":"新生工程导论讲座PPT-17.11.23","uri":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/"},{"categories":["人与世人的关系"],"content":"第一部分：讲一个当时刚做完的比赛 （该项目在2017暑假获得：国家发明专利 和 大学生节能减排大赛国一奖） ","date":"2022-04-12","objectID":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/:1:0","tags":["杂谈"],"title":"新生工程导论讲座PPT-17.11.23","uri":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/"},{"categories":["人与世人的关系"],"content":"第二部分：学习、比赛经验 当日的纪念… ","date":"2022-04-12","objectID":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/:2:0","tags":["杂谈"],"title":"新生工程导论讲座PPT-17.11.23","uri":"/22%E6%96%B0%E7%94%9F%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E8%AE%B2%E5%BA%A7ppt/"},{"categories":["人与世人的关系"],"content":"关于本科学习、竞赛、兴趣的分享","date":"2022-04-12","objectID":"/23%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%9B%E5%AE%A2%E6%B2%99%E9%BE%99%E6%9A%A8%E5%B9%B3%E5%8F%B0%E8%81%94%E5%90%88%E6%8E%A2%E8%AE%A8%E4%BC%9Appt/","tags":["杂谈"],"title":"第二次创客沙龙暨平台联合探讨会PPT-18.5.12","uri":"/23%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%9B%E5%AE%A2%E6%B2%99%E9%BE%99%E6%9A%A8%E5%B9%B3%E5%8F%B0%E8%81%94%E5%90%88%E6%8E%A2%E8%AE%A8%E4%BC%9Appt/"},{"categories":["人与世人的关系"],"content":"大三，时间 2018.5.12 晚，于创客空间实验室。主动发起开一次各个实验室、各个学科的交流会，专门做了请柬邀请以升平台十几个实验室各派代表前来参会。 当时写了 旁白 来辅助讲解PPT内容，但是可能做的时候思索快于记录，导致旁白写的比较抽象和发散（其实整个PPT都很抽象…），现在我也不能100%看明白，只是尽量原文粘贴过来。 PPT 旁白： 在沙龙开始之前，首先感谢各个实验室的萌新和大佬前来参加这次沙龙会议（鞠躬） 举办这次会议的机缘巧合，是三件事情遇到了一块： 1 我们创客又到了每月一次的沙龙时间（以前都是内部开） 2 以升平台，我认为，是我们学校的亮点之一，鉴于我校有时候各个部门各个实验室之间比较缺乏联系互动，信息不是很流通，斗胆，尝试这么一次联合沙龙的形式。 鉴于这里可能有各个实验室的成员，有大佬有萌新，如果我有讲的有不合适的地方，随时，直接指出哈 3 有一个关于平台的大项目需要组建队伍和开启连年传承开发的模式。 PPT 旁白： 思考的问题。 我们是否一直在玩剩下的：参加比赛、做作品 很大重复性 并没有什么改进啊，创新啊 好想法的重要性：节能减排比赛，一个大一的，好想法，国一 要么有一个好想法，如果没有，大多数人也没用，就去学点什么，学多了，创意啊比赛啊就都来了。 所以有两个分支，顺着好想法不断做下去，学好自己想学的东西。 百闻不如一见：一会放视频，并不是给创客空间做广告啊，而且要说，创客概念，处处皆有，处处可以拿去用。 很火：小含义是好像是一群做东西的人，大含义，是一会视频里介绍 创客需要什么：放视频。视频链接：创客教育简介-腾讯视频 (qq.com)。 创客不仅仅培养动手能力，而且培养创新思维，团队意识，项目统筹规划等等能力，也是企业需要的能力。 PPT 旁白： TRIZ故事12——古塔是否在下沉 城市的中心广场有一座古塔，似乎在逐渐下沉。名胜古迹保护委员会前来测量研究这个古塔的下沉问题。测量的第一步是要选择一个高度不变的水平基准，并且在塔上可以看到这个基准以便进行比较测量。 很可能广场周围建筑也在一起下沉，所以需要寻找一个远离古塔而且高度不变的基准，最后他们选择了远离古塔1500英尺以外的一个公园的墙壁，但古塔和公园的墙壁之间被高层建筑物遮挡住了，无法直接进行测量。 …… 突然，TRIZ先生出现了。 一个基于等势原则的方案呈现了。 拿2根玻璃管，一个安装在塔上，一个安装在公园的墙壁上，用胶管将其连接起来，然后灌入液体，就组成一个水平仪，两只玻璃管中的液体应保持同样的高度，我们在玻璃管上标出这个高度。如果古塔下沉，则塔上的玻璃管内液体会升高。 TRIZ故事3——巨大的过滤器 一家工厂获得了一个大订单，产品是一个圆柱形过滤器，圆柱的直径1米，长度2米，轴向均匀分布直径为0.5毫米的密密麻麻的很多过滤通孔。 工程师们看到图纸后都惊呆了，每个过滤器要加工出成千上万个轴向小孔。 “显然，钻这么长的小孔是不可能实现的，也许可以用高温铁针来扎出这些孔，”一位年轻的工程师毫无把握地说道。 这似乎是一个无法解决的难题。 …… 突然，TRIZ先生出现了。 “我们既不需要钻床，也不需要铁针，这件事应该这样来考虑……” 随后，一个基于局部质量原理的解决方案展示了出来： 将过滤器的功能进行分解，其主要构成元素是过滤孔和基体，有用功能的元素是过滤孔，即过滤孔是有用的局部质量。每个过滤孔不就是一条管子吗！ 用细圆棒做原料，然后捆扎起来，而圆棒之间的空隙就形成了过滤孔，也可以实现过滤器的功能。 PPT 旁白： 对于同一个东西的学习，不同的人学到的不一样，会用是一回事，知道原理是一回事 就比如： 萌新对一个电子模块的学习，我们学硬件的指标是，能够自己简单造一个模型，需要一直分析，到电路实现层面， 这样不论是做项目还是做理论， 对于不同的人，所产生的成果是不一样的。 再看下面那个物联网简单入门的例子： 一条线钻研下去，再回头顺一遍，很多看似复杂的事情，通过分层和拆解，还是很好理解的 有了这样的学习方法，那么对下面的项目的制作和学习会比较快。 PPT 旁白： 其实有时候， 对于拿奖多的人，不是为了拿奖儿比赛， 第一个，人家是参加自己喜欢的 第二，自己闲不住，总想做点事情 第三，学习自己喜欢学习的，顺便参加比赛拿拿奖 我们画了这么一个图，也是想说，成为一个多学科融会贯通的人，再好不过 这种人，不能让其具体参与分工， 特别适合统筹一个综合性项目， 因为和各技术领域的人好交流。 打开了视野，提升了追求。 PPT 旁白： 现在如果各位是有想法的可以提出来，大家一块讨论。 说不定会迸溅智慧的火花 解决好问题后，继续进行我的想法的说明。 PPT 旁白： 一说到，电梯按键的识别，大家有没有什么主意，怎么去实现？ 还有语音交流？ 还有人脸识别？ 自动切换充电装置如何设计？ 学无止境哈。。 OpenCV（模板匹配） 做的 电梯按钮识别和定位，便于机器人的机械手去操作电梯，而实现自主上下楼。 机器人楼道内定位依靠 RFID 技术。 文章内对一些具体技术的描写。 结束。 某一夜想到那一天… ","date":"2022-04-12","objectID":"/23%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%9B%E5%AE%A2%E6%B2%99%E9%BE%99%E6%9A%A8%E5%B9%B3%E5%8F%B0%E8%81%94%E5%90%88%E6%8E%A2%E8%AE%A8%E4%BC%9Appt/:0:0","tags":["杂谈"],"title":"第二次创客沙龙暨平台联合探讨会PPT-18.5.12","uri":"/23%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%9B%E5%AE%A2%E6%B2%99%E9%BE%99%E6%9A%A8%E5%B9%B3%E5%8F%B0%E8%81%94%E5%90%88%E6%8E%A2%E8%AE%A8%E4%BC%9Appt/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux进程和线程的基本编程、通讯和例程","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 进程 和 线程 的基本 编程、通讯 和 例程 注：【杂记】系列为日常网搜资料的堆砌而积累成之。如有错误恭谢指出。标识为“原创”其实不完全是，只是多引用再整理和加上自己的理解，进行记录备查，大都引自网络，侵删！ 大量参考 100ask、网络文章等资料（参考源均以给出，侵删），这里参考网络文章和官方文档并做多处横向对比，形成系统性 一文全解，给出保姆级别的参考，则避免 同质化（不完全是直接引用，我整理了很好、很漂亮的格式，还为了 句子流畅、整理标点符号 和 补充说明（中文语境的名词混乱、口水话输出等等，你懂的） 做了很多 整理、修改和补充）。 注：在 Github 上的原版文章日后可能会更新，但这里不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:0:0","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"查看进程/线程/系统运行状况等的命令 主线剧情02-ARM-Linux基础学习记录_Real-Staok的博客-CSDN博客 里面的 Linux Shell 一节 的 任务后台执行 / 任务\u0026进程查看 部分。 关于Linux下进程的详解【进程查看与管理】 - AshJo - 博客园 (cnblogs.com)。 linux top命令查看内存及多核CPU的使用讲述 - tamatama - 博客园 (cnblogs.com)。 Linux vmstat命令实战详解_浮生忆梦的博客-CSDN博客_vmstat。 etc. ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:1:0","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"前置了解和其他 这里仅仅是将我随机看到的放在这里，网搜会有更多/更好的文章，广泛的看看。这里也是本文的参考源之一。 进程 \u0026 线程相关知识 - blcblc - 博客园 (cnblogs.com)，基本概念 和其 异同 的介绍。 linux基础——linux进程与线程的区别与联系_yexz的博客-CSDN博客。 操作系统基础知识复习总结_loserChen.的博客-CSDN博客_操作系统基础知识、操作系统基础_wang德华的博客-CSDN博客、操作系统基础知识整理_零分分分分的博客-CSDN博客_操作系统基础知识、操作系统基础知识总结整理_EasyChill的博客-CSDN博客_操作系统基础知识总结。 etc. ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:2:0","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"一些进程/线程调试经验 设计模式 / 分配策略 相关： 【杂记】进程和线程的分配策略_Real-Staok的博客-CSDN博客_资源在进程和线程上如何分配 里面的 “启发任务分配的规则” 和 “进程 和 线程 设计经验参考” 一节。 从内核角度分析：当linux多线程遭遇Linux多进程 - 知乎 (zhihu.com)。 一些 线程池 编写经验 linux基础——经典线程同步问题解析及编程实现_yexz的博客-CSDN博客。 设计模式 POSIX多线程程序设计（第4章：使用线程的几种方式）_瓦釜苑-CSDN博客_posix多线程程序设计。 etc. 调试相关： Linux进程崩溃原调试_guotianqing的博客-CSDN博客。 etc. ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:3:0","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 进程 参考： 「linux操作系统」进程的切换与控制·到底有啥关系？ - 知乎 (zhihu.com)，Linux进程解析_deep_explore的博客-CSDN博客，腾讯面试：进程的那些数据结构 - 知乎 (zhihu.com)，如何在Linux下的进行多进程编程（初步） - 知乎 (zhihu.com)，彻底搞定面试官，linux的进程里面的一些细节 - 知乎 (zhihu.com)，操作系统进程的概念，进程的状态及状态转换，进程控制_程小智的博客-CSDN博客_进程的状态及其转换。 Linux 进程详解 - 程序员大本营 (pianshen.com)。Linux进程基础教程详解_Linux_脚本之家 (jb51.net)。 【Linux】Linux进程的创建与管理_Yngz_Miao的博客-CSDN博客_linux 创建进程。 《Linux System Prorgrammin》，Linux系统编程 _ 中文版 _ by _ 哈工大（翻译）-第五章-进程管理。 Linux 操作系统 C 语言编程入门。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:0","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"进程基础概念 程序与进程 通俗的讲程序是一个包含可以执行代码的文件，是一个静态的文件。而进程是一个开始执行但是还没有结束的程序的实例。就是可执行文 件的具体实现。一个程序可能有许多进程，而每一个进程又可以有许多子进程。 进程状态 创建态：进程正在被创建，尚未转到就绪态。 就绪态：进程获得了除处理机以外的一切所需资源，一旦得到处理机便可立即运行。 状态特点：处理机（或者理解为调度器）资源：只缺处理机。资源获得：已获得所需资源。当获得处理机时：立即运行。 状态转换：就绪态——\u003e运行态：处于就绪态的进程被调度后，获得处理机资源，于是进程由就绪态切换为运行态。 运行态：进程正在处理机上运行；对于单处理机，同一时刻只有一个进程处于运行态。 状态转换：运行态——\u003e就绪态：情况1：处于运行态的进程在时间片用完后，不得不让出处理机，进而转换为就绪态。情况2：在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。 状态转换：运行态——\u003e阻塞态（主动行为）：进程请求某一资源（如外设）的使用或等待某一事件的发生（如I/O操作的完成）时，它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的，由用户态程序调用操作系统内核过程的形式。 阻塞态：又称等待态，进程正在等待某一事件而暂停运行/休眠，如等待某资源或IO完成，即使处理机空闲，该进程也不能运行。 状态特点：处理机（或者理解为调度器）资源：可能缺；也可能不缺。资源获得：等待某资源可用或等待一件事情完成。当获得处理机时：即使处理机空闲，当等待的事情没有完成，仍无法运行。 状态转换：阻塞态——\u003e就绪态（被动行为，需要其他相关进程的协助）：进程等待的事件到来，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。 终止态：进程正从系统中消失，可能是进程正常结束或其他原因退出运行。 对应到 Linux 内核中，各个进程状态的标志： TASK_RUNNING 说明进程已经准备好了，就看操作系统给不给分时间片在 CPU 上执行了，进程获得了时间片，就是执行状态，不分配时间片就是就绪状态。代表状态的字段又不用变。 其实 TASK_RUNING 这个字段既对应了进程的就绪态又对应了进程的运行态。 只有在该状态的进程才可能在 CPU上运行。而同 一时刻可能有多个进程处于可执行状态，这些进程的 task_struct结构（进程控制块）被放入对应 CPU的可执行队列中（一个进程最多只能出现在一个 CPU的可执行队列中）。进程调度器的任务就是从各个 CPU的可执行队列中分别选择一个进程在该 CPU 上运行。 只要可执行队列不为空，其对应的 CPU就不能偷懒，就要执行其中某个进程。一般称此时的 CPU“忙碌”。对应的， CPU“空闲”就是指其对应的可执行队列为空，以致于 CPU无事可做。 很多操作系统教科书将正在 CPU上执行的进程定义为 RUNNING状态、而将可执行但是尚未被调度执行的进程定义为 READY状态，这两种状态在 linux下统一为 TASK_RUNNING状态。 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 是两种睡眠状态，对应上面的阻塞状态。TASK_INTERRUPTIBLE 可以再被信号唤醒，TASK_UNINTERRUPTIBLE 不可被信号唤醒。 TASK_INTERRUPTIBLE，可中断的睡眠状态。处于这个状态的进程因为等待某某事件的发生（比如等待 socket连接、等待信号量），而被挂起。这些进程的 task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他 进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过 ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于 TASK_INTERRUPTIBLE状态（除非机器的负载很高）。 TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。与 TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是 CPU不响应外部硬件的中断，而是指进程不响应异步信号。即 kill -9 无法 关掉/杀死 这种进程。TASK_UNINTERRUPTIBLE 状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。 在进程对某些硬件进行操作时（比如进程调用 read 系统调用对某个设备文件进行读操作，而 read 系统调用最终执行到对应设备驱动的代码，并与对应的物 理设备进行交互），可能需要使用 TASK_UNINTERRUPTIBLE 状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的 状态。这种情况下的 TASK_UNINTERRUPTIBLE 状态总是非常短暂的，通过 ps 命令基本上不可能捕捉到。Linux系统中也存在容易捕捉的 TASK_UNINTERRUPTIBLE状态。执行 vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用 exit或 exec。 TASK_STOPPED 是在进程收到 SIGSTOP 以及 SIGTTIN 等信号的状态，你 Linux 进程运行起来按 Ctrl + z 后进程就是这个状态。 向进程 发送一个 SIGSTOP信号，它就会因响应该信号而进入 TASK_STOPPED状态（除非该进程本身处于 TASK_UNINTERRUPTIBLE状态而不响应信号）。（ SIGSTOP与 SIGKILL信号一样，是非常强制的。不允许用户进程通过 signal系列的系统调用重新设置对应的信号处理函数。） 向进程发送一个 SIGCONT信号，可以让其从 TASK_STOPPED状态恢复到 TASK_RUNNING状态。 TASK_TRACED 是进程被监视的状态。 当进程正在被跟踪时，它处于 TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在 gdb中 对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。 TASK_STOPPED和 TASK_TRACED状态判断。对于进程本身来说， TASK_STOPPED和 TASK_TRACED状态很类似，都是表示进程暂停下来。而 TASK_TRACED状态相当于在 TASK_STOPPED之上多了一层保护，处于 TASK_TRACED状态的进程不能响应 SIGCONT信号而 被唤醒。只能等到调试进程通过 ptrace系统调用执行 PTRACE_CONT、 PTRACE_DETACH等操作（通过 ptrace系统调用的参数指定 操作），或调试进程退出，被调试的进程才能恢复 TASK_RUNNING状态。 TASK_DEAD - EXIT_ZOMBIE，退出状态，进程成为僵尸进程。EXIT_DEAD 是最终状态，进入这个状态代表进程要从系统中删除了EXIT_ZOMBIE 是EXIT_DEAD 的前一个状态，这个时候进程已经终止，但父进程还没有用 wait() 等系统调用来获取他的终止信息，这个状态的进程叫做僵尸进程。这个状态 kill 命令是杀不死的，你们可以想以下应该怎样清楚僵尸进程，以及怎样避免僵尸进程的存在。 关于 退出 相关的 进程状态（上面四个），更多可详见 Linux进程解析_deep_explore的博客-CSDN博客。 Linux 进程状态转换示意图： 系统进程常见的 STAT 代码： 就绪队列与阻塞队列： 就绪队列：系统中处于就绪状态的进程可能有多个，通常把它们排成一个队列。只要就绪队列不空，CPU就总是可以调度进程运行，保持繁忙，这与就绪进程的数目没有关系；除非就绪队列为空，此时CPU进入等待态，CPU效率下降。 阻塞队列：系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因不同，设置多个阻塞队列。 进程的构成 引自 进程的那些数据结构 - 知乎 (zhihu.com)，Linux下的task_struct结构体 - 百度文库 (baidu.com)。 进程一般由以下几个部分组成： 进程控制块（PCB）：每个进程在创建时， 系统都会为进程创建一个相应的 PCB。PCB 是进程存在的唯一标志。 创建进程实质就是创建进程的 PCB。PCB 要能展示进程身份和关系，标记任务状态，标记权限，帮助任务调度等等。 Linux 内核中是把进程和线程统一当作任务来实现的，Linux 内核的 进程控制块 是 task_struct 结构体，里面包含有： The identifier of the process (a process identifier , or PID) ;（进程的标识自身的唯一标识符 PID） Register values for the process including, notably, the program counter and stack pointer values for the process;（进程调度时候退出时间片（保存现场）与进入时间片（恢复现场）时候用到的寄存器值包括栈指针 SP、程序计数器 PC 等等） The address space ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:1","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"进程控制相关 API p.s 进程控制中的状态转换 相关 API，用户很少用到，在此不提。 一般来说，这些内核标准 API，在执行出错（可能是资源不够、权限不够等等）会返回负值（比如 -1），并设置 errno 值。 父进程创建子进程 fork() 在 Linux 中，为了创建一个子进程，父进程用系统调用 fork() 来创建子进程。fork() 其实就是把父进程复制了一份（子进程有自己的特性，比如标识、状态、数据空间（堆栈区和数据区）等（这些是子进程独有的）；子进程和父进程共同使用程序代码、共用时间片（这些是共有的）等）。 通常在调用fork函数之后，程序会设计一个if选择结构。当PID等于0时，说明该进程为子进程，那么让它执行某些指令，比如说使用exec库函数(library function)读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用fork的一大目的: 为某一程序创建进程)；而当PID为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。 pid_t fork();，fork() 对子进程 返回 0，对父进程 返回 子进程的 ID，返回 小于 0 值为出错。 #include\u003cstdio.h\u003e#include\u003cunistd.h\u003e int main() { int p_num = 0; int c_num = 0; int pid = fork(); if(pid == 0) // 返回的pid为0为子进程 { c_num++; } else { p_num++; // 返回的pid大于0为父进程 } printf(\"p_num=%d, c_num=%d\\n\",p_num,c_num); printf(\"pid=%d\\n\",pid); return 0; } // 运行结果如下所示 p_num=1, c_num=0 pid=36101 p_num=0, c_num=1 pid=0 子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。 其它： fork() 的 写时复制 概念，可网搜了解。即 用到某个资源时候才会复制，不需要修改的资源不会复制，尽量推迟高系统消耗的操作直到必要时才会执行。 vfork() 不常用，实现可能不会完全没问题，概念可网搜来了解。 进程分离 exec 族函数 通过 fork 后，子进程并没有和父进程独立开，用的是相同的代码。另外还有一个问题时，这个时候子进程的时间片是和父进程一分为二来共享的。为了彻底将父进程和子进程分离开来，就要用到一个系统调用 exec 族函数，这是读取另一个程序文件，并在当前的进程空间执行。当我们创建了一个进程之后，通常将子进程替换成新的进程映象，这可以用 exec 系列的函数来进行，且新进程与原进程有相同的 PID。 参考 Linux下exec函数族(execl,execv,execle,execve,execlp,execvp,fexecve)的使用和对比_leumber的博客-CSDN博客_exec和execv，exec系列函数（execl,execlp,execle,execv,execvp)使用_gauss的博客-CSDN博客 这个里面有每个 API 的使用例子，exec和execv区别 - CSDN。 各个 API 原型：#include \u003cunistd.h\u003e int execl(const char *path, const char *arg, …); int execlp(const char *file, const char *arg, …); int execle(const char *path, const char *arg, …, char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); 传入参数：path 参数表示你要启动程序的名称包括路径名；file 参数表示 要启动的 程序 / 文件 的文件名（系统从环境变量 PATH 里面寻找该程序，因此不用带路径全名）；arg 参数表示启动程序所带的参数，一般第一个参数为要执行命令名，不是带路径且arg必须以NULL结束； 返回值：成功返回0，失败返回-1。 exec 族函数名中 l 表示列表 list，v 表示数组。 execl、execlp、execle 将新程序的每个命令行参数都以一个单独的参数，这种参数列表以NULL结尾。 execv、execvp、execve 和 fexecve 则应先构造一个指向各参数的指针数组，然后将该数组地址作为参数传入。 exec 族函数名中 p 结尾表示函数第一个参数取 filename。 execlp、execvp与其他函数不同就是第一个参数取filename，用 PATH 环境变量寻找可执行文件，filename 既可以是文件路径加程序名，也可以是PATH环境变量下的 /sbin: /bin: /usr/bin: 即shell命令。 exec 族函数名中 e 结尾表示可以传递环境表信息 environ。 execle、execve、fexecve 可以传递一个指向环境字符串指针数组的指针。 // process.c #include\u003cstdio.h\u003e#include\u003cunistd.h\u003e int main() { int pid = fork(); if(pid == 0) { execv(\"./test.o\",NULL); // test.o是一个经过编译的c语言文件，这里记得要放test.o的绝对路径 } printf(\"This is parent process\\n\"); return 0; } // test.c #include\u003cstdio.h\u003eint main() { printf(\"This is child process\"); return 0; } // 运行结果如下所示 This is parent process This is child process exec 族函数的使用例子 /* exec.c */ #include \u003cunistd.h\u003emain() { char *envp[]={\"PATH=/tmp\",\"USER=lei\",\"STATUS=testing\",NULL}; /* 数组 必须以 NULL 做结尾 */ char *argv_execv[]={\"echo\", \"excuted by execv\", NULL}; char *argv_execvp[]={\"echo\", \"executed by execvp\", NULL}; char *argv_execve[]={\"env\", NULL}; if(fork()==0) if(execl(\"/bin/echo\", \"echo\", \"executed by execl\", NULL)\u003c0) /* 路径全名，传入参数写全，以NULL结尾 */ perror(\"Err on execl\"); if(fork()==0) if(execlp(\"echo\", \"echo\", \"executed by execlp\", NULL)\u003c0) /* 只写执行程序的文件名，系统会去 PATH 环境变量寻找 */ perror(\"Err on execlp\"); if(fork()==0) if(execle(\"/usr/bin/env\", \"env\", NULL, envp)\u003c0) /* 可传入环境变量 */ perror(\"Err on execle\"); if(fork()==0) if(execv(\"/bin/echo\", argv_execv)\u003c0) /* 带 v 的就是 传入参数 以 指针数据（字符串数据）传入，其它与上面的 API 一样 */ perror(\"Err on execv\"); if(fork()==0) if(execvp(\"echo\", argv_execvp)\u003c0) perror(\"Err on execvp\"); if(fork()==0) if(execve(\"/usr/bin/env\", argv_execve, envp)\u003c0) perror(\"Err on execve\"); } /* 执行 ./exec 后返回： executed by execl PATH=/tmp USER=lei STATUS=testing executed by execlp excuted by execv executed by execvp PATH=/tmp USER=lei STATUS=testing */ exec 族函数 的常见的错误返回（exec 返回 -1，并设置 errno 为以下的值）： 找不到文件或路径，此时errno被设置为ENOENT； 数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT； 没有对要执行文件的运行权限，此时errno被设置为EACCES。 等等，有很多种类型的错误返回。 更多要注意的地方： 实际操作时， 一般在 调用 exec 函数之前 关闭所有已经打开的文件。也可以通过 f","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:2","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"系统调用 API 参考：用时现查 如何在Linux下的进行多进程编程（初步） - 知乎 (zhihu.com)。 Linux 下系统调用的三种方法_海风林影的博客-CSDN博客。 linux系统调用(持续更新….)_tiramisu_L的博客-CSDN博客。 通过 glibc 提供的库函数、使用 syscall 直接调用、通过 int 指令陷入；popen() 函数、fgets() 函数、system() 函数、strstr() 函数。 system（）函数先调用fork（），然后再调用exec（）来执行用户的登录shell，通过它来查找可执行文件的命令并分析参数，最后它么使用wait（）函数族之一来等待子进程的结束。函数popen（）和函数system（）相似，不同的是它调用pipe（）函数创建一个管道，通过它来完成程序的标准输入和标准输出。这两个函数是为那些不太勤快的程序员设计的，在效率和安全方面都有相当的缺陷，在可能的情况下，应该尽量避免。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:3","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"创建守护进程 参考：用时现查 Linux应用程序中出现两次fork的解释_leng_que的博客-CSDN博客_linux 两次fork，如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵尸状态直到父进程终止，实现这一要求的技巧是调用fork两次。 【Linux】如何创建daemon进程\u0026fork一次和fork两次有什么区别_pointer_y的博客-CSDN博客。 守护进程 它运行在后台，很重要，Linux下大多数服务器就是用守护进程实现的。因为它独立于终端运行，也就是说它的运行不受当前登录或者注销的影响，自成会话，周期性的执行某项任务或者等待处理某些事件。 创建守护进程：法1：两次 fork()；法2：调用 daemon() 函数来创建。 守护进程中fork一次与两次的区别_Number_0_0的博客-CSDN博客。 创建守护进程为什么要fork两次_TerryZjl的博客-CSDN博客_fork创建守护进程。 etc. 创建守护进程 即 编写一个常驻内存的程序。 对于 在 shell 中启动一个程序，把一个程序放到后台去执行：我们只要在命令后面加上 \u0026 符号，SHELL 就会把我们的 程序放到后台去运行的。 对于编写程序：这里是 一次 fork() 的方法（父进程终止，子进程进入后台），还有两次 fork() 的方法（父进程运行，子进程终止，孙进程进入后台） 后台进程的创建思想：首先父进程创建一个子进程，然后子进程杀死父进程，这样子进程成为孤儿进程 / 被过继给 init 进程 / 成为后台任务，任务处理的工作由子进程来处理（终止父进程：kill(getppid(),SIGTERM);）。 暂 总结有四种常用方法： shell 中启动一个程序 最后 加 \u0026 标识符 将其放入后台执行。 一次 fork() 的方法（父进程终止，子进程进入后台）。 两次 fork() 的方法（父进程运行，子进程终止，孙进程进入后台）。 使用 daemon() 函数，int daemon (int nochdir, int noclose);，数：nochdir 非 0 表示不会将工作目录改为根目录，noclose 非 0 表示不会关闭所有打开的文件描述符，通常均设置为 0，成功则返回 0，失败返回 -1 并设置 errno 值。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:4","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"高级进程管理 可参考：《Linux System Prorgrammin》，Linux系统编程 _ 中文版 _ by _ 哈工大（翻译） 等等。 内容包括： 进程调度。 让出处理器。 进程优先级。 处理器亲和度（讨论多进程在多处理器间的 平衡/均衡 问题）。 实时系统（Linux 的一些实时性的支持，主要包括设置调度策略、设置优先级等）。 资源限制。 参考专业书即可，用时现查。进程的高级编程 比较专业了，看来很吃对系统的理解和经验等等。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:5","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"使用这些 API 的例程 暂略。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:6","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"进程间通讯（IPC） 参考 / 引用： 如何在Linux下的进行多进程编程（初步） - 知乎 (zhihu.com)。浅析进程间通信的几种方式（含实例源码） - 知乎 (zhihu.com)。 linux基础——linux进程间通信（IPC）机制总结_千里之行，始于足下-CSDN博客。 Linux IPC总结（全）_xuexingyang的博客-CSDN博客_linuxipc。 Linux进程间通信-详解(经典)_linux进程间通信,linux进程间通信-硬件开发文档类资源-CSDN文库。 Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal) - as_ - 博客园 (cnblogs.com)。 Linux-应用编程-学习总结（3）：进程间通信（上）_努力学习的花椰菜的博客-CSDN博客。 最初的 UNIX 进程间通信（IPC：InterProcess Communication）方式：包括管道(PIPE)，有名管道(FIFO)，和信号(Signal)；System V 进程通信方式：包括信号量(Semaphore)，消息队列(Message Queue)，和共享内存(Shared Memory)。这两种都是早期 UNIX 的 IPC，还有 套接字 和 内存映射，这基本的 八种方式，Linux 则都继承了下来。 总结起来：管道、命名管道、信号、信号量、消息队列、共享内存、内存映射 和 套接字。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:7","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"UNIX IPC 管道（Pipe） 管道是一种半双工的通信方式，是内核的一段缓冲区，数据只能单向流动，一端写和一端读，而且只能在具有亲缘关系(父子进程)的进程间使用。另外管道传送的是无格式的字节流，并且管道缓冲区的大小是有限的（管道缓冲区存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。 半双工（双向通讯，同一时刻只能有一方发和一方收）；用于父子、兄弟进程之间通讯（你看的下去这男权社会的命名方式吗？不如我们揭竿而起，都用 “亲子进程”、“同辈进程” 来叫吧！），管道也叫 无名管道 或 匿名管道；用于任意两个进程之间通讯的管道叫 有名管道。 使用 pipe() 函数 创建一块用于管道通讯的 缓冲区，该函数 会返回 两个文件描述符 分别为 “读入文件描述符” 和 “写入文件描述符”，分别指向 该缓冲区 的 输入端/读取端 和 输出端/写入端，然后两个 有亲缘关系的进程 一个 用 write() 对 “写入文件描述符” 写入数据 另一个用 read() 对 “读入文件描述符” 读取数据即可。 #include \u003cunistd.h\u003eint pipe(int pipefd[2]); /* 参数 pipefd 数组，需要传入 两个文件描述符，pipefd[0] 为读取用的，pipefd[1] 为写入用的 */ 调用pipe函数时在内核中开辟一块缓冲区用于通信，它有一个读端，一个写端。pipefd[0]指向管道的读端，pipefd[1]指向管道的写端。所以管道在用户程序看起来就像一个打开的文件，通过read(pipefd[0])或者write(pipefd[1])向这个文件读写数据，其实是在读写内核缓冲区。 操作流程 父进程（作者注：这里要改称 “双亲进程”，树结构 中的 “父节点” 要改为 “双亲结点”！！！）调用pipe开辟管道，得到两个文件描述符指向管道的两端。 父进程（作者注：啊啊啊）调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 以父进程（作者注：后面我不管了）向子进程发送数据为例：父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读。管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。 pipe 通讯 例子： pipe()函数返回的是文件描述符(file descriptor)，因此只能使用底层的read()和write()系统调用来访问。 管道读写规则 当没有数据可读时 O_NONBLOCK disable：read调用阻塞，即进程暂停执行，一直等到有数据来到为止。 O_NONBLOCK enable：read调用返回-1，errno值为EAGAIN。 当管道满的时候 O_NONBLOCK disable： write调用阻塞，直到有进程读走数据。 O_NONBLOCK enable：调用返回-1，errno值为EAGAIN。 管道出现的四种特殊情况 写端关闭，读端不关闭：那么管道中剩余的数据都被读取后,再次read会返回0,就像读到文件末尾一样。 如果所有管道写端对应的文件描述符被关闭，则read返回0。 写端不关闭，但是也不写数据，读端不关闭：此时管道中剩余的数据都被读取之后再次read会被阻塞，直到管道中有数据可读了才重新读取数据并返回。 读端关闭，写端不关闭：此时该进程会收到信号SIGPIPE，通常会导致进程异常终止。 如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE。 读端不关闭，但是也不读取数据，写端不关闭：此时当写端被写满之后再次write会阻塞，直到管道中有空位置了才会写入数据并重新返回。 写入数据量的情况 当要写入的数据量不大于PIPE_BUF（Posix.1要求PIPE_BUF至少 512字节）时，linux将保证写入的原子性。 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。 使用管道的缺点 两个进程通过一个管道只能实现单向通信，如果想双向通信必须再重新创建一个管道或者使用sockpair才可以解决这类问题。 只能用于具有亲缘关系的进程间通信，例如父子，兄弟进程。 命名管道（FIFO） 有名管道也是半双工通信的，但是它相比较于 管道/无名管道/匿名管道 来说 允许无亲缘关系进程间的通信。命名管道 也有叫 有名管道 或 实名管道（在中文语境下，仅我看见的，现在 Pipe 和 FIFO 这两个东西总共就有六个名字了啊）。 参考：Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal) - as_ - 博客园 (cnblogs.com)，Linux进程通信：命名管道FIFO小结_Mr_John_Liang的博客-CSDN博客。 命名管道 FIFO 详细的参考：【Linux】进程间通信-命名管道FIFO_编程学习指南的博客-CSDN博客_命名管道fifo。 FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接。 #include \u003csys/types.h\u003e#include \u003csys/stat.h\u003eint mkfifo(const char *filename, mode_t mode); int mknode(const char *filename, mode_t mode | S_IFIFO, (dev_t) 0 ); /* 其中pathname是被创建的文件名称（该文件必须不存在），mode表示将在该文件上设置的权限位和将被创建的文件类型（指明其读写权限），dev是当创建设备特殊文件时使用的一个值。因此，对于先进先出文件它的值为0。 */ 操作流程 可以先 使用 access() 先来判断 目标的 命名管道 FIFO 文件是否存在。如果存在则可以跳到第三步，如果不存在则跳到第二步。 使用 mkfifo() 创建一个 命名管道 FIFO 文件，mode 参数使用 0777。如果创建的 FIFO 文件是 /tmp/my_fifo，则可以使用命令行 ls -lF /tmp/my_fifo 看到该文件。 然后 使用 open() （或者 fopen() 这个高级封装）再去打开这个 FIFO 文件（传入标志有 O_RDONLY、O_WRONLY 和 O_NONBLOCK，单独或组合，关于传入标志在 后面 关于 FIFO 读写时候的阻塞问题 会详细讨论）。因为 FIFO 是文件，因此使用前必须先打开。 然后再使用 read/write （或者 fread/fwrite）进行读写。 最后使用 close() 关闭文件。 参考例子 写例子 wirte_fifo.c #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstring.h\u003e#include \u003cfcntl.h\u003eint main(int argc, const char* argv[]) { if(argc \u003c 2){ printf(\"./a.out fifoname\\n\"); exit(1); } // 判断文件是否存在 int ret = access(argv[1], F_OK); if(ret == -1) { int r = mkfifo(argv[1], 0777); /* 在文件系统中创建一个文件，该文件用于提供FIFO功能，即命名管道 */ if(r == -1){ perror(\"mkfifo error\"); exit(1); } printf(\"有名管道%s创建成功\\n\", argv[1]); } int fd = open(argv[1], O_WRONLY); if(fd == -1){ perror(\"open error\"); exit(1); } char *p = \"hello, world\"; int len = write(fd, p, strlen(p)+1); close(fd); return 0; } 读例子 read_fifo.c #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstring.h\u003e#include \u003cfcntl.h\u003eint main(int argc, const char* argv[]) { if(argc \u003c 2) { printf(\"./a.out fifoname\\n\"); exit(1); } // 判断文件是否存在 int ret = access(argv[1], F_OK); if(ret == -1) { int r = mkfifo(argv[1], 0664); if(r == -1){ perror(\"mkfifo error\"); exit(1); } printf(\"有名管道%s创建成功\\n\", argv[1]); } int fd = open(argv[1], O_RDONLY); if(fd ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:8","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"System V IPC System V IPC指的是AT\u0026T在System V.2发行版中引入的三种进程间通信工具:(1)信号量，用来管理对共享资源的访问 (2)共享内存，用来高效地实现进程间的数据共享 (3)消息队列，用来实现进程间数据的传递。我们把这三种工具统称为System V IPC的对象，每个对象都具有一个唯一的IPC标识符(identifier)。要保证不同的进程能够获取同一个IPC对象，必须提供一个IPC关键字(IPC key)，内核负责把IPC关键字转换成IPC标识符。 System V IPC 具有相似的语法，API 命名来说：semxxx() 用于信号量，shmxxx() 用于共享内存，msgxxx() 用于消息队列。 System V IPC 一般操作如下： 1、选择IPC关键字（API 中的 形参 key_t key），可以使用如下三种方式： IPC_PRIVATE。由内核负责选择一个关键字然后生成一个IPC对象并把IPC标识符直接传递给另一个进程。 直接选择一个已经存在的关键字。 使用 ftok() 函数生成一个关键字。 2、使用semget()/shmget()/msgget()函数根据IPC关键字key和一个标志flag创建或访问IPC对象。 如果key是IPC_PRIVATE、或者key尚未与已经存在的IPC对象相关联且flag中包含IPC_CREAT标志，那么就会创建一个全新的IPC对象。 3、使用semctl()/shmctl()/msgctl()函数修改IPC对象的属性。 4、使用semctl()/shmctl()/msgctl()函数和IPC_RMID标志销毁IPC对象。 System V IPC为每个IPC对象设置了一个ipc_perm结构体并在创建IPC对象的时候进行初始化。这个结构体中定义了IPC对象的访问权限和所有者: struct ipc_perm{ uid_t uid; //所有者的用户id gid_t gid; //所有者的组id uid_t cuid; //创建者的用户id gid_t cgid; //创建者的组id mode_t mode; //访问模式 … }; 消息队列、信号量以及共享内存 它们被统称为XSI IPC，它们在内核中有相似的IPC结构（消息队列的msgid_ds，信号量的semid_ds，共享内存的shmid_ds），而且都用一个非负整数的标识符加以引用（消息队列的msg_id，信号量的sem_id，共享内存的shm_id，分别通过msgget、semget以及shmget获得），标志符是IPC对象的内部名，每个IPC对象都有一个键（key_t key）相关联，将这个键作为该对象的外部名。 XSI IPC的IPC结构是在系统范围内起作用，没用使用引用计数。如果一个进程创建一个消息队列，并在消息队列中放入几个消息，进程终止后，即使现在已经没有程序使用该消息队列，消息队列及其内容依然保留。而PIPE在最后一个引用管道的进程终止时，管道就被完全删除了。对于FIFO最后一个引用FIFO的进程终止时，虽然FIFO还在系统，但是其中的内容会被删除。和PIPE、FIFO不一样，XSI IPC不使用文件描述符，所以不能用ls查看IPC对象，不能用rm命令删除，不能用chmod命令删除它们的访问权限。只能使用ipcs和ipcrm来查看可以删除它们。 shell 中管理IPC对象的命令是 ipcs、ipcmk 和 ipcrm。 如： ipcs -s 查看创建的信号量集合的个数，ipcrm -s \u003csemid\u003e 删除一个编号为 semid 的信号量集合。 ipcs -m 查看创建的共享内存的个数，ipcrm -m shm_id 删除共享内存。 信号量（Semaphore） 额外 参考/引用：IPC对象之信号量_朝辞暮见的博客-CSDN博客_ipc信号量，IPC之信号量详解_Qiuoooooo的博客-CSDN博客_ipc信号量。 信号量是一个计数器，它用来记录 各个进程 对某个资源的存取状况，可以用来控制多个进程对共享资源的访问（比如后面的 共享内存 就用到信号量）。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。常用来处理临界资源的访问同步问题（临界资源：为某一时刻只能由一个进程或线程操作的资源）。在任一时刻只能有一个线程访问临界资源。 信号量的工作流程： （1）创建 控制某资源的 信号量。 （2）若此信号量的值为正，则允许进行使用该资源。进程将进号量减1。 （3）若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤（1）。 （4）当进程不再使用一个信号量控制的资源时，信号量值加1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。 当一个进程不再使用资源时，信号量+1(对应的操作称为V操作)，反之当有进程使用资源时，信号量-1(对应的操作为P操作)。对信号量的值操作均为原子操作。 P 操作，要准备开始读写，P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行等待操作。 V 操作，读写完毕可以释放，V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。 简单理解就是 P 相当于申请资源，V 相当于释放资源。 举个例子，就是两个进程共享信号量sv，初始值为 1，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行了。 二值信号量：值为0或1。与互斥锁类似，资源可用时值为1，不可用时值为0；即 P操作相当于上锁，V操作相当于解锁。 计数信号量：值在0到n之间。同来统计资源，其值代表可用资源数。 在Linux系统中，使用信号量通常需要创建信号量、初始化信号量、信号量PV操作以及信号量删除四种操作。 创建/获取一个信号量集合： #include \u003csys/types.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/sem.h\u003eint semget(key_t key, int nsems, int semflg); /* key:信号量集合 编号/键值 可以用函数key_t ftok(const char *pathname, int proj_id);来获取 不同进程只要key值相同即可访问同一信号量集合 其中有个特殊值IPC_PRIVATE，表示创建当前进程的私有信号量 nsems:这个参数表示你要创建的信号量集合中的信号量的个数。信号量只能以集合的形式创建。 需要创建的信号量数目，通常为1。若创建多个信号量则称为信号量集。 如果是创建新集合，则必须指定nsems。 如果是引用一个现有的信号量集合则将nsems指定为0。如果只是获取信号量集的标识符(而非新建)，那么nsems可以为0。 semflg: IPC_CREAT|IPC_EXCL 表示key对应的信号量不存在则创建，存在则报错。即会创建一个新的信号量集合，若已经存在的话则返回-1。 IPC_CREAT 表示key对应的信号量不存在则创建，存在则直接返回该信号量的标识符。返回一个新的或者已经存在的信号量集合。 flag的低8位作为信号量的访问权限位，类似于文件的访问权限. flag低8位是权限位。一般用0666（6的二进制是110，表示可读，可写，不可执行，三个6分别对应当前用户，group组用户，其他用户） 例如，flag 可以为 IPC_CREAT|0666 返回值：成功返回信号量集合的semid（非负整数），失败返回-1。 比如 A 进程和 B 进程之间要用同一个信号量，那么设计 A 先 产生/创建 信号量，然后 B 引用/绑定 这个信号量： 因此 A 调用 semget() 时候 semflg 参数应该传入 IPC_CREAT|IPC_EXCL|0666，且 nsems 为要创建的信号量数量； 而 B 因该传入 IPC_CREAT|0666 或 IPC_CREAT，且 nsems 为 0。 */ key_t ftok( const char * fname, int id ); /* IPC键值的格式转换函数。系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值。通常情况下，该id值通过ftok函数得到。 fname 就是你指定的文件名（已经存在的文件名），一般使用当前目录 id 是子序号。虽然是int类型，但是只使用8bits(1-255）。 计算过程：如指定文件的索引节点号为65538，换算成16进制为0x010002，而你指定的ID值为38，换算成16进制为0x26，则最后的key_t返回值为0x26010002。 用于保证 同一段程序，在两个不同用户下的两组相同程序 获得互不干扰的IPC键值。 例子 key_t key = ftok(\".\", 'a'); */ 对信号量的设置（初始化值或销毁）： /* 内核中定义的结构体 */ union semun{ int val; // SETVAL 使用的值 struct semid_ds *buf; // IPC_STAT、IPC_SET 使用缓存区 unsigned short *array; // GETALL、SETALL 使用的缓存区，ALL，某个信号量集合的所有信号量 struct semin","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:9","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"IPC 额外方式 内存映射（Memory Map） 即 通过 mmap() 函数 将一个文件 映射到一块内存，然后进行读写操作。两个进程都对同一个文件都映射后，可以分别读写，不必调用 I/O API 而是 直接对 内存 进行操作。 每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）。 #include \u003csys/mman.h\u003e#include \u003cunistd.h\u003evoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *start, size_t length); void *mmap(void*start,size_t length,int prot,int flags,int fd,off_t offset); //mmap函数将一个文件或者其它对象映射进内存。 第一个参数为映射区的开始地址，设置为0表示由系统决定映射区的起始地址，第二个参数为映射的长度，第三个参数为期望的内存保护标志，第四个参数是指定映射对象的类型，第五个参数为文件描述符（指明要映射的文件），第六个参数是被映射对象内容的起点。成功返回被映射区的指针，失败返回MAP_FAILED[其值为(void *)-1]。 int munmap(void* start,size_t length); //munmap函数用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。如果解除映射成功则返回0，否则返回－1，错误原因存于errno中错误代码EINVAL。 int msync(void *addr,size_t len,int flags); //msync函数实现磁盘文件内容和共享内存取内容一致，即同步。第一个参数为文件映射到进程空间的地址，第二个参数为映射空间的大小，第三个参数为刷新的参数设置。 API 详解可见文件里面：【Linux 应用开发】\\0-用到的API-收集积累\\文件IO、字符流收发和字符串处理相关的API收集积累.c 。更多可网搜。 mmap() 详解 Linux内存管理-详解mmap原理 - 知乎 (zhihu.com)。 例子：这里的例子就是将 一个 文件 通过 mmap() 映射到一块内存，然后读这个内存。另外有一个进程将同样的文件 通过 mmap() 映射后可以修改。 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/types.h\u003e#include \u003csys/stat.h\u003e#include \u003cstring.h\u003e#include \u003csys/mman.h\u003e#include \u003cfcntl.h\u003e int main(int argc, const char* argv[]) { int fd = open(\"english.txt\", O_RDWR); if(fd == -1){ perror(\"open error\"); exit(1); } // get file length int len = lseek(fd, 0, SEEK_END); void * ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(ptr == MAP_FAILED){ perror(\"mmap error\"); exit(1); } close(fd); char buf[4096]; printf(\"buf = %s\\n\", (char*)ptr); // 从内存中读数据 // 释放内存映射区 int ret = munmap(ptr, len); if(ret == -1){ perror(\"munmap error\"); exit(1); } return 0; } 共享内存和内存映射文件的区别： 内存映射文件是利用虚拟内存把文件映射到进程的地址空间中去，在此之后进程操作文件，就像操作进程空间里的地址一样了，比如使用c语言的memcpy等内存操作的函数。这种方法能够很好的应用在需要频繁处理一个文件或者是一个大文件的场合，这种方式处理IO效率比普通IO效率要高。 共享内存是内存映射文件的一种特殊情况，内存映射的是一块内存，而非磁盘上的文件。共享内存的主语是进程（Process），操作系统默认会给每一个进程分配一个内存空间，每一个进程只允许访问操作系统分配给它的哪一段内存，而不能访问其他进程的。而有时候需要在不同进程之间访问同一段内存，怎么办呢？操作系统给出了 创建访问共享内存的API，需要共享内存的进程可以通过这一组定义好的API来访问多个进程之间共有的内存，各个进程访问这一段内存就像访问一个硬盘上的文件一样。 内存映射文件与虚拟内存的区别和联系： 内存映射文件和虚拟内存都是操作系统内存管理的重要部分，两者有相似点也有不同点。 联系：虚拟内存和内存映射都是将一部分内容加载到内存，另一部放在磁盘上的一种机制。对于用户而言都是透明的。 区别：虚拟内存是硬盘的一部分，是内存和硬盘的数据交换区，许多程序运行过程中把暂时不用的程序数据放入这块虚拟内存，节约内存资源。内存映射是一个文件到一块内存的映射，这样程序通过内存指针就可以对文件进行访问。 虚拟内存的硬件基础是分页机制。另外一个基础就是局部性原理（时间局部性和空间局部性），这样就可以将程序的一部分装入内存，其余部分留在外存，当访问信息不存在，再将所需数据调入内存。而内存映射文件并不是局部性，而是使虚拟地址空间的某个区域银蛇磁盘的全部或部分内容，通过该区域对被映射的磁盘文件进行访问，不必进行文件I/O也不需要对文件内容进行缓冲处理。 套接字（Socket） 创建 Socket 的时候 作用域 选择 系统内使用（而 选择 以太网 就是不同机器间的 TCP/UDP/IP 通讯了）。 套接字有三个属性:域(domain)、类型(type)和协议(protocol)，对应于不同的域，套接字还有一个地址(address)来作为它的名字。 域(domain)指定了套接字通信所用到的协议族，最常用的域是AF_INET，代表网络套接字，底层协议是IP协议。对于网络套接字，由于服务器端有可能会提供多种服务，客户端需要使用IP端口号来指定特定的服务。AF_UNIX代表本地套接字，使用Unix/Linux文件系统实现。 IP协议提供了两种通信手段:流(streams)和数据报(datagrams)（分别对应 TCP 协议 和 UDP 协议），对应的套接字类型(type)分别为流式套接字和数据报套接字。流式套接字(SOCK_STREAM)用于提供面向连接、可靠的数据传输服务。该服务保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字使用TCP协议。数据报套接字(SOCK_DGRAM)提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP协议。 #include \u003csys/types.h\u003e#include \u003csys/socket.h\u003e int socket(it domain,int type,int protocal); int bind(int socket,const struct sockaddr *address,size_t address_len); int listen(int socket,int backlog); int accept(int socket,struct sockaddr *address,size_t *address_len); int connect(int socket,const struct sockaddr *addrsss,size_t address_len); ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 参考 【Linux 应用开发】\\3-Socket编程\\ 里面的内容。更多可网搜。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:4:10","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"Linux 线程 详细学习的地方，可以当字典备查： Multi-Threaded Programming With POSIX Threads (kent.edu)。 书《POSIX多线程程序设计》。 书《Unix_Linux_Windows_OpenMP多线程编程》中的《第三章 Unix/Linux 多线程编程》。 多线程指的是在单个 程序/进程 中可以同时运行多个不同的线程（可以视作共享同一块内存资源的多个任务），执行不同的任务： 更高的运行效率，并行执行； 多线程是模块化的编程模型； 与进程相比，线程的创建和切换开销更小； 通信方便； 能简化程序的结构，便于理解和维护；更高的资源利用率。 多线程的应用场景： 程序中出现需要等待的操作，比如网络操作、文件IO等，可以利用多线程充分使用处理器资源，而不会阻塞程序中其他任务的执行。 程序中出现可分解的大任务，比如耗时较长的计算任务，可以利用多线程来共同完成任务，缩短运算时间。 程序中出现需要后台运行的任务，比如一些监测任务、定时任务，可以利用多线程来完成。 线程安全与线程同步： 线程安全：多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全：不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。如果多个线程同时读写共享变量，会出现数据不一致的问题。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作， 线程异步：访问资源时在空闲等待时同时访问其他资源，实现多线程机制。 同步：A线程要请求某个资源，但是此资源正在被B线程使用中，因为同步机制存在，A线程请求不到，怎么办，A线程只能等待下去 异步：A线程要请求某个资源，但是此资源正在被B线程使用中，因为没有同步机制存在，A线程仍然请求的到，A线程无需等待 线程同步的优势： 好处：解决了线程的安全问题。 弊端：每次都有判断锁，降低了效率。 但是在安全与效率之间，首先考虑的是安全。 Linux 系统下的用 C 开发多线程使用叫 pthread 的线程库；内核级线程 和 用户级线程 是在创建线程时通过传入 API 的不同参数进行 区分/设置 的。 因为 pthread 并非 Linux 系统的默认库，而是 POSIX 标准的线程库。在 Linux 中将其作为一个库来使用，因此编译选项需要加上 -lpthread（或-pthread）以显式链接该库。例子：gcc xxx.c -lpthread -o xxx.bin。 ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:5:0","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"各个 API 原型介绍 pthread_self()——获取线程 ID。 /* pthread_self()——函数获取线程 ID #include \u003cpthread.h\u003e pthread_t pthread_self(void); 成功：返回线程号 */ #include \u003cpthread.h\u003e#include \u003cstdio.h\u003eint main() { pthread_t tid = pthread_self(); printf(\"tid = %lu\\n\",(unsigned long)tid); return 0; } pthread_create()——线程创建。 /* pthread_create()——线程创建 #include \u003cpthread.h\u003e int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg); 该函数第一个参数为pthread_t指针，用来保存新建线程的线程号。 第二个参数表示了线程的属性，可传入NULL表示默认属性。 第三个参数是一个函数指针，就是线程执行的函数。这个函数返回值为void*，形参为void*。 第四个参数则表示为向线程处理函数传入的参数，若不传入，可用NULL填充。 返回 0 表示成功，负值表示失败。 */ #include \u003cpthread.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003evoid *fun(void *arg) { printf(\"pthread_New = %lu\\n\",(unsigned long)pthread_self()); } int main() { pthread_t tid1; int ret = pthread_create(\u0026tid1,NULL,fun,NULL); ... 简化，错误处理略 /* tid_main 为通过pthread_self获取的线程ID，tid_new通过执行pthread_create成功后tid指向的空间 */ /* 即 tid1 与 pthread_New 打印结果应为一致 */ printf(\"tid_main = %lu tid_new = %lu \\n\",(unsigned long)pthread_self(),(unsigned long)tid1); /* 因线程执行顺序随机，不加sleep可能导致主线程先执行，导致进程结束，无法执行到子线程 */ /* 也就是说，主线程 执行到这里 如果不加 sleep 则 后面直接 return 结束了，那么 线程 fun 还没执行 本进程就结束了 */ sleep(1); return 0; } /* 通过pthread_create确实可以创建出来线程，主线程中执行pthread_create后的tid指向了线程号空间，与子线程通过函数pthread_self打印出来的线程号一致。 特别说明的是，当主线程伴随进程结束时，所创建出来的线程也会立即结束，不会继续执行。并且创建出来的线程的执行顺序是随机竞争的，并不能保证哪一个线程会先运行。可以将上述代码中sleep函数进行注释，观察实验现象。 */ 创建 进程时候 传入参数： #include \u003cpthread.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003evoid *fun1(void *arg){ printf(\"%s:arg = %d Addr = %p\\n\",__FUNCTION__,*(int *)arg,arg); } void *fun2(void *arg){ printf(\"%s:arg = %d Addr = %p\\n\",__FUNCTION__,(int)(long)arg,arg); } int main() { pthread_t tid1,tid2; int a = 50; int ret = pthread_create(\u0026tid1,NULL,fun1,(void *)\u0026a); /* 传入地址 */ ... 简化，错误处理略 ret = pthread_create(\u0026tid2,NULL,fun2,(void *)(long)a); /* 传入值 */ ... 简化 sleep(1); printf(\"%s:a = %d Add = %p \\n\",__FUNCTION__,a,\u0026a); return 0; } pthread_exit / pthread_cancel 和 pthread_join / pthread_tryjoin_np——线程的退出。 线程的退出情况有三种： 第一种是进程结束，进程中所有的线程也会随之结束。 第二种是通过函数 pthread_exit() 来主动的退出所在的线程。 第三种被其他线程调用 pthread_cancel() 来被动退出。 关于线程退出后的资源回收： 一个进程中的多个线程是共享数据段的。如果一个线程是 joinable 或者叫 非分离状态的，在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放，要用 pthread_join/pthread_tryjoin_np 函数来同步并释放资源，即 当线程结束后，主线程要通过函数 pthread_join/pthread_tryjoin_np 来回收线程的资源，并且获得线程结束后需要返回的数据。如果一个线程是 unjoinable 或者叫 分离状态的，则 在线程退出之后 其自己会主动回收资源，主线程里便不用再调用 pthread_join/pthread_tryjoin_np 来回收线程的资源，当然此时 线程退出的时候也就不能传出参数。joinable 和 unjoinable 可以设置，后面 线程属性 部分会说到。 关于主线程 / 进程的退出： 在主线程中，在 main 函数中 return 了或是调用了 exit() 函数，则主线程退出，且整个进程也会终止，此时进程中的所有线程也将终止，因此要避免 main 函数过早结束。 在任何一个线程中调用 exit() 函数都会导致进程结束，进程一旦结束，那么进程中的所有线程都将结束。 以下 是对 pthread_exit / pthread_cancel 和 pthread_join / pthread_tryjoin_np 线程的退出 相关 API 的说明。 /* 线程主动退出 pthread_exit #include \u003cpthread.h\u003e void pthread_exit(void *retval); pthread_exit函数为线程退出函数，在退出时候可以传递一个void*类型的数据带给主线程，若选择不传出数据，可将参数填充为NULL。 pthread_exit函数唯一的参数value_ptr是函数的返回值，只要pthread_join中的第二个参数value_ptr不是NULL，这个值将被传递给value_ptr 线程被动退出 pthread_cancel，其他线程使用该函数让另一个线程退出 #include \u003cpthread.h\u003e int pthread_cancel(pthread_t thread); 成功：返回0 该函数传入一个tid号，会强制退出该tid所指向的线程，若成功执行会返回0。 线程资源回收（阻塞在执行到 pthread_join 的地方，然后等待 thread 线程的退出） #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **retval); 该函数为线程回收函数，默认状态为阻塞状态，直到成功回收线程后才返回。第一个参数为要回收线程的tid号，第二个参数为线程回收后接受线程传出的数据， 或者该线程被取消而返回PTHREAD_CANCELED。 线程资源回收（非阻塞，需要循环查询） #define _GNU_SOURCE #include \u003cpthread.h\u003e int pthread_tryjoin_np(pthread_t thread, void **retval); 该函数为非阻塞模式回收函数，通过返回值判断是否回收掉线程，成功回收则返回0，其余参数与pthread_join一致。 阻塞方式 pthread_join 和 非阻塞方式 pthread_tryjoin_np 使用上的区别： 通过函数 pthread_join 阻塞方式回收线程，几乎规定了线程回收的顺序，若最先回收的线程未退出，则一直会被阻塞，导致后续先退出的线程无法及时的回收。 通过函数 pthread_tryjoin_np 使用非阻塞回收线程，可以根据退出先后顺序自由的进行资源的回收。 */ 线程属性相关： 参考 pthread_attr_init线程属性_高司机的博客-CSDN博客_pthread_attr_destroy，线程属性详解 线程属性pthread_attr_t简介_Robin Hu的专栏-CSDN博客。 /* 定义 pthread_attr_t 线程属性变量，用于设置线程属性，主要包括 scope 属性(用于区分用户态或者内核态)、detach（分离/joinable）属性、堆栈地址、堆栈大小、优先级 */ pthread_attr_t attr_1,attr_2_3_4[3","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:5:1","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"使用这些 API 的例程 /* 文件：线程基本API的例子\\线程API的例程-Linux下，被动回收.c */ #define _GNU_SOURCE #include \u003cpthread.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cerrno.h\u003e /* 例子说明： 创建 系统级 线程 1，无传入和传出参数，死循环，特定条件时退出，使用 pthread_join 回收 创建 用户级 线程 2、3、4 三个线程，线程号使用数组，传入和传出参数，使用 pthread_tryjoin_np 回收 在 linux 环境 的 gnu 编译器 下 执行编译：gcc temp.c -lpthread -o temp.bin */ /* 用于设置线程属性，主要包括 scope 属性(用于区分用户态或者内核态)、detach（分离/joinable）属性、堆栈地址、堆栈大小、优先级 */ pthread_attr_t attr_1, attr_2_3_4[3]; /* 指向线程标识符的指针，区分线程，即可称为 线程号，仅在本进程中有效。本质是 unsigned long int */ pthread_t id_1, id_2_3_4[3]; /* 线程 1，无传入和传出参数，执行完后退出，使用 pthread_join 回收 */ void *thread_1(void *in_arg) { int i = 0; printf(\"thread_1 ID = %lu\\n\", (unsigned long)pthread_self()); for(;;) { printf(\"thread_1 print times = %d\\n\", ++i); if(i \u003e= 3) pthread_exit(NULL); /* 用 pthread_exit() 来调用线程的返回值，用来退出线程，但是退出线程所占用的资源不会随着线程的终止而得到释放 */ sleep(1); /* sleep() 单位秒，程序挂起 1 秒 */ } } /* 线程 2 3 4 */ void *thread_2_3_4(void *in_arg) { /* 必须要 static 修饰，否则 pthread_join/pthread_tryjoin_np 无法获取到正确值 */ static char* exit_arg; /* exit_arg 是 本函数的一个局部变量，多个线程 2、3、4 都会修改它，因此最后返回的时候不知道是谁最后一次修改的 */ /* 因此要格外注意 */ exit_arg = (char*)in_arg; pthread_t self_id = pthread_self(); if(self_id == id_2_3_4[0]) { printf(\"thread_2 ID = %lu\\n\", (unsigned long)self_id); sprintf((char*)in_arg,\"id_2 gagaga\"); }else if(self_id == id_2_3_4[1]) { printf(\"thread_3 ID = %lu\\n\", (unsigned long)self_id); sprintf((char*)in_arg,\"id_3 lalala\"); }else if(self_id == id_2_3_4[2]) { printf(\"thread_4 ID = %lu\\n\", (unsigned long)self_id); sprintf((char*)in_arg,\"id_4 hahaha\"); }else { pthread_exit(NULL); } pthread_exit((void*)in_arg); } int main(void) { int ret = -1, i = 0, return_thread_num = 0; char *str_gru[3]; void *exit_arg = NULL; pthread_attr_init(\u0026attr_1); pthread_attr_setscope(\u0026attr_1, PTHREAD_SCOPE_SYSTEM); /* 系统级线程 */ for(i = 0;i \u003c 3;i++) { pthread_attr_init(\u0026attr_2_3_4[i]); pthread_attr_setscope(\u0026attr_2_3_4[i], PTHREAD_SCOPE_PROCESS); /* 用户级线程 */ } /* 创建线程 1 */ ret = pthread_create(\u0026id_1, \u0026attr_1, thread_1, NULL); if(ret != 0) { /* perror 把一个描述性错误消息输出到标准错误 stderr, 调用\"某些\"函数出错时，该函数已经重新设置了errno 的值。perror 函数只是将你输入的一些信息和 errno 所对应的错误一起输出 */ perror(\"pthread1, pthread_create: \"); return -1; } /* 创建线程 2、3、4 */ for(i = 0;i \u003c 3;i++) { str_gru[i] = (char*)malloc(sizeof(char) * 42 + i); ret = pthread_create(\u0026id_2_3_4[i], \u0026attr_2_3_4[i], thread_2_3_4, (void *)str_gru[i]); if(ret != 0) { perror(\"pthread 2 3 4, pthread_create: \"); return -1; } } /* 等待所有线程结束，先等 线程 2、3、4 相继的、无顺序要求的 退出，再等 线程 1 退出 */ for(;;) { for(i = 0;i \u003c 3;i++) { /* pthread_tryjoin_np 的 np 为不可移植，是gnu定的非POSIX标准的API，仅linux里面的编译器能用 */ if(pthread_tryjoin_np(id_2_3_4[i], \u0026exit_arg) == 0) { printf(\"pthread : %lu exit with str: %s\\n\", (unsigned long)id_2_3_4[i], (char*)exit_arg); free(str_gru[i]); return_thread_num++; } } if(return_thread_num \u003e= 3) break; } pthread_join(id_1, NULL); return 0; } ","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:5:2","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["【主线剧情】Linux 系列"],"content":"线程间通讯 / 线程同步方式 p.s 以下有很多段落是直接引用，没有使用 markdown 的 “引用” 格式，出处均已放出。 参考 / 引用： 100ask。 linux基础——linux线程间通信及同步机制总结_yexz的博客-CSDN博客_linux 线程间通信。 pthread的互斥量和自旋锁_zhaopengnju的博客-CSDN博客_pthread 自旋锁、pthread_spin自旋锁_gdut17的博客-CSDN博客_pthread 自旋锁。 pthread-win32 semaphore信号量总结 - ayanmw - 博客园 (cnblogs.com)。 由于线程间共享进程变量资源，线程间的通信目的主要是用于线程同步（即约束多个线程的执行的顺序规则（信号量）或互斥规则（互斥锁）），所以线程没有像进程通信中的用于数据交换的通信机制。 互斥锁、条件变量和信号量的区别： 互斥锁：互斥，一个线程占用了某个资源，那么其它的线程就无法访问，直到这个线程解锁，其它线程才可以访问。 信号量：同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增。 条件变量：同步，一个线程完成了某一个动作就通过条件变量发送信号告诉别的线程，别的线程再进行某些动作。条件变量必须和互斥锁配合使用。 锁机制适用于类似原子操作的情况，加锁后 快速的处理某一个临界区的资源，然后立马解锁，不适合长时间的加锁（更不好的情况就是在加锁后的临界区里被执行了中断，在中断里面又要阻塞的进行加锁，那么这时就发生死锁了，卡住了）；而信号/信号量（和 条件变量）适合 长时间的 等待 信号/条件的发生，而且 在等待/阻塞 期间调用者是休眠的。 为了减少错误 和 复杂性，设计程序前应尽量考虑 不要在 中断中 使用 锁、信号 等之类的东西，中断程序里面设计的要 简洁、优雅。 锁机制 互斥锁（Mutex） 互斥锁 / 互斥量 用来防止多个线程 同时/并发的 访问某个临界资源。 互斥量本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量。对互斥量进行加锁以后，其他识图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。 如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成运行状态的线程可以对互斥量加锁，其他线程就会看到互斥量依然是锁着，只能再次阻塞等待它重新变成可用，这样，一次只有一个线程可以向前执行。 即 多个线程都要访问某个临界资源，比如某个全局变量时，需要互斥地访问：我访问时，你不能访问。 头文件：#include \u003cpthread.h\u003e。 常用 API： int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr); // 初始化量 /* 该函数初始化一个互斥量，第一个参数是改互斥量指针，第二个参数为控制互斥量的属性，一般为 NULL。当函数成功后会返回 0，代表初始化互斥量成功。 当然初始化互斥量也可以调用宏来快速初始化，代码如下： pthread_mutex_t mutex = PTHREAD_MUTEX_INITALIZER; */ int pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞） int pthread_mutex_unlock(pthread_mutex_t *mutex); // 解锁（非阻塞） /* lock 函数与 unlock 函数分别为加锁解锁函数，只需要传入已经初始化好的 pthread_mutex_t 互斥量指针。成功后会返回 0。 当某一个线程获得了执行权后，执行 lock 函数，一旦加锁成功后，其余线程遇到 lock 函数时候会发生阻塞，直至获取资源的线程执行 unlock 函数后。unlock 函数会唤醒其他正在等待互斥量的线程。 特别注意的是，当获取 lock 之后，必须在逻辑处理结束后执行 unlock，否则会发生死锁现象！导致其余线程一直处于阻塞状态，无法执行下去。在使用互斥量的时候，尤其要注意使用 pthread_cancel 函数，防止发生死锁现象！ */ int pthread_mutex_trylock(pthread_mutex_t *mutex); // 互斥量加锁（非阻塞） /* 该函数同样也是一个线程加锁函数，但该函数是非阻塞模式通过返回值来判断是否加锁成功，用法与上述阻塞加锁函数一致。 */ int pthread_mutex_destroy(pthread_mutex_t *mutex); // 销毁互斥量 /* 该函数是用于销毁互斥量的，传入互斥量的指针，就可以完成互斥量的销毁，成功返回0。 */ 例程：参考 pthread库-线程编程例程-来自百问网\\01_文档配套源码\\Pthread_Text10.c。 互斥锁的属性： /* 与 线程属性类似的，先 声明变量，再用 pthread_mutexattr_init 初始化， 再用 pthread_mutexattr_getxxx/pthread_mutexattr_setxxx 来 获取 / 设置 属性的某个选项， 然后在 调用 互斥锁初始化 pthread_mutex_init 的时候 填入 该属性 最后可以销毁 */ int pthread_mutexattr_init(pthread_mutexattr_t* attr); int pthread_mutexattr_destroy(pthread_mutexattr_t* attr); int pthread_mutexattr_getshared(const pthread_mutexattr_t* attr, int* pshared); int pthread_mutexattr_setshared(pthread_mutexattr_t* attr, int* pshared); pshared 的可以传入的参数： PTHREAD_PROCESS_SHARED：互斥锁可以被跨进程共享 PTHREAD_PROCESS_PRIVATE：只能被初始化线程所属的进程中的线程共享 int pthread_mutexattr_gettype(const pthread_mutexattr_t* attr, int* type); int pthread_mutexattr_settype(pthread_mutexattr_t* attr, int type); type 的可以传入的参数： PTHREAD_MUTEX_NOMAL：公平锁，对一个已经加锁的普通锁再次加锁，将引发死锁;对一个已经被其他线程加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致不可预期的后果。 PTHREAD_MUTEX_ERRORCHECK：检错锁，对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLOCK。对一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错锁再次解锁，则解锁操作返回EPERM。 PTHREAD_MUTEX_RECURSIVE：嵌套锁，错误使用返回EPERM PTHREAD_MUTEX_DEFAULT：跟nomal差不多。 读写锁（rwlock） 　读写锁与互斥量类似，不过读写锁拥有更高的并行性。互斥量要么是锁住状态，要么是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁有 3 种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。 一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。 头文件：#include \u003cpthread.h\u003e。 常用 API： int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *rwlockattr); // 初始化读写锁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); // 读模式锁定读写锁 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); // 写模式锁定读写锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); // 解锁读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); // 销毁读写锁 自旋锁（spin） 如果 互斥锁 被占用（被锁住），另一个线程进入时，互斥锁会引起线程切换（不死等，而是 yield 一次去运行其它线程）。适合锁的内容比较多的。 对于自旋锁，如果锁被占用（被锁住），来了的线程会一直等待直到获取这把锁相当于 while(1);（死等，跑满一个时间片时间）。适合锁的内容比较少的 当线程切换的代价远远比等待的","date":"2022-04-14","objectID":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/:5:3","tags":["软件","Linux"],"title":"（大集合）Linux进程和线程的基本编程、通讯和例程【杂记】","uri":"/24linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E7%A8%8B-%E9%80%9A%E8%AE%AF%E5%92%8C%E4%BE%8B%E7%A8%8B/"},{"categories":["随机技术情报"],"content":"可供选择的软件开源协议的罗列","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"Public License List 罗列各种开源代码的公共协议以供选择。具体每一个协议的含义可以另外找教程文章或看官网原文，这里解决“都有什么”的问题。 List of licenses that can be chosen. 注：在 Github 上的原版文章日后可能会更新，在其它位置发的不会跟进。文章的 Gitee 仓库地址，Gitee 访问更流畅。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:0:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"杂项 主流开源协议之间有何异同？ - 知乎 (zhihu.com)。 这是一篇不错的介绍开源协议的文章 当你决定把代码开源之前先选择一个合适的 License。 这是一个开源协议选择器 public-license-selector——Tool that will help you select the right open license for your data or software。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:1:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"CC 协议 对于非编程代码的个人作品如图片、文字等可选择使用 CC 协议。 都有什么：About CC Licenses - Creative Commons。 在每个协议页面下面有 use the license（这个以 CC BY-NC-SA 为例），点进去可以获得该协议的图标，可以加到 个人作品 中 表示 使用该协议，他人使用您的作品需要遵守该协议的规则。 License name URL Creative Commons Attribution (CC-BY) http://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution-NoDerivs (CC-BY-ND) http://creativecommons.org/licenses/by-nd/4.0/ Creative Commons Attribution-NonCommercial (CC-BY-NC) http://creativecommons.org/licenses/by-nc/4.0/ Creative Commons Attribution-NonCommercial-NoDerivs (CC-BY-NC-ND) http://creativecommons.org/licenses/by-nc-nd/4.0/ Creative Commons Attribution-NonCommercial-ShareAlike (CC-BY-NC-SA) http://creativecommons.org/licenses/by-nc-sa/4.0/ Creative Commons Attribution-ShareAlike (CC-BY-SA) http://creativecommons.org/licenses/by-sa/4.0/ .etc 关于 CC 协议的详细介绍： CC 协议使用 FAQ。 所有 Creative Commons 协议的罗列和选择。 知识共享@中国大陆 - 知识共享中国大陆项目官方网站 (creativecommons.net.cn)。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:2:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"正经的（Official） License name URL Affero General Public License 3 (AGPL-3.0) http://opensource.org/licenses/AGPL-3.0 Apache License 2 http://www.apache.org/licenses/LICENSE-2.0 Artistic License 1.0 http://opensource.org/licenses/Artistic-Perl-1.0 Artistic License 2.0 http://opensource.org/licenses/Artistic-2.0 Common Development and Distribution License (CDDL-1.0) http://opensource.org/licenses/CDDL-1.0 Eclipse Public License 1.0 (EPL-1.0) http://opensource.org/licenses/EPL-1.0 GNU General Public License 2 or later (GPL-2.0) http://opensource.org/licenses/GPL-2.0 GNU General Public License 3 (GPL-3.0) http://opensource.org/licenses/GPL-3.0 GNU Library or “Lesser” General Public License 2.1 or later (LGPL-2.1) http://opensource.org/licenses/LGPL-2.1 GNU Library or “Lesser” General Public License 3.0 (LGPL-3.0) http://opensource.org/licenses/LGPL-3.0 Mozilla Public License 2.0 http://opensource.org/licenses/MPL-2.0 Public Domain Dedication (CC Zero) http://creativecommons.org/publicdomain/zero/1.0/ Public Domain Mark (PD) http://creativecommons.org/publicdomain/mark/1.0/ The BSD 2-Clause “Simplified” or “FreeBSD” License http://opensource.org/licenses/BSD-2-Clause The BSD 3-Clause “New” or “Revised” License (BSD) http://opensource.org/licenses/BSD-3-Clause The MIT License (MIT) http://opensource.org/licenses/mit-license.php .etc ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:3:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"感动的（Be moved） ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:4:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"“良心授权” 协议 本软件对于最终用户免费。由于本软件使用了带有 AGPL 条款的第三方开源组件，因此，本软件及其源代码的使用协议也基于 AGPL。另外还带有如下附加条件。在遵守本软件的前提条件下，你可以在遵循本协议的基础上自由的使用和传播它，你一旦安装、复制或使用本软件，则表示您已经同意本协议条款。如果你不同意本协议，请不要安装使用本软件，也不应利用其源代码。 附加条件： 每一个使用本软件的用户，如果本软件帮助了您，每使用本软件后，您应当做 1 件善事。善事无分大小，有心则行。例如： 如果您的父母在身边，你可以为您的父母做一顿美味的饭菜，或者为他们按摩、洗脚；如果他们身处远方，你可以向他们发起通话，问候他们的健康和生活。 在大雨滂沱的时候，如果您有雨伞，可与同路的人共享；在烈日当空的时节，如果您看到环卫工人太阳下工作，您可以为他们买一瓶水送给他们；在拥挤的公共交通工具上，或在公共场合排队等候之际，如果您有座位，可以让给老人、孕妇或提着重物的人就坐。 您可以用您擅长的技能，为身边的人排难解困；您可以将您的知识，分享给其他人，让他们有所获益；您可以向比您困难的人捐资赠物。 如果您觉得这个软件真的好用，请将它的使用方法介绍给别人，让别人也通过使用本软件而得到好处；或者将其它您觉得好用的软件介绍给别人。 如果您无法做到使用本软件后做 1 件善事，请记在心中。在有机会的时候，多行善积德。本用户协议之遵循与否，全在于您的良心。是为“良心授权”。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:4:1","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"Anti-996 License kattgu7/Anti-996-License: Anti-996 License Version 1.0 (github.com). 版权所有（c）\u003c年份\u003e\u003c版权持有人\u003e 反996许可证版本1.0 在符合下列条件的情况下， 特此免费向任何得到本授权作品的副本（包括源代码、文件和/或相关内容，以下统称为“授权作品” ）的个人和法人实体授权：被授权个人或法人实体有权以任何目的处置授权作品，包括但不限于使 用、复制，修改，衍生利用、散布，发布和再许可： 个人或法人实体必须在许可作品的每个再散布或衍生副本上包含以上版权声明和本许可证，不 得自行修改。 个人或法人实体必须严格遵守与个人实际所在地或个人出生地或归化地、或法人实体注册地或 经营地（以较严格者为准）的司法管辖区所有适用的与劳动和就业相关法律、法规、规则和 标准。如果该司法管辖区没有此类法律、法规、规章和标准或其法律、法规、规章和标准不可 执行，则个人或法人实体必须遵守国际劳工标准的核心公约。 个人或法人不得以任何方式诱导或强迫其全职或兼职员工或其独立承包人以口头或书面形式同 意直接或间接限制、削弱或放弃其所拥有的，受相关与劳动和就业有关的法律、法规、规则和 标准保护的权利或补救措施，无论该等书面或口头协议是否被该司法管辖区的法律所承认，该 等个人或法人实体也不得以任何方法限制其雇员或独立承包人向版权持有人或监督许可证合规 情况的有关当局报告或投诉上述违反许可证的行为的权利。 该授权作品是\"按原样\"提供，不做任何明示或暗示的保证，包括但不限于对适销性、特定用途适用 性和非侵权性的保证。在任何情况下，无论是在合同诉讼、侵权诉讼或其他诉讼中，版权持有人均 不承担因本软件或本软件的使用或其他交易而产生、引起或与之相关的任何索赔、损害或其他责任。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:4:2","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"不正经的（Unofficial） License name URL “Good Luck With That” Public License https://github.com/me-shaon/GLWTPL DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE https://github.com/anak10thn/WTFPL Dont Be a Dick Public License https://github.com/philsturgeon/dbad The Sandia Message Public License https://github.com/cdanis/sandia-public-license SAY NO TO SUICIDE PUBLIC LICENSE https://github.com/unbug/snts The Star And Thank Author License(SATA License) https://github.com/zTrix/sata-license；一篇中文介绍：SATA License——开源的泥石流 .etc ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:5:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"开源协议的选择 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:6:0","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"对几个常用开源协议的简短说明 AGPL-3.0： 引自 AGPL 开源授权协议_cnhome的博客-CSDN博客_agpl，GPL和AGPLv3的区别_KeepLearningBigData的博客-CSDN博客_agpl gpl。 AGPL = GPL + 一条限制。 GPL：如果你使用的GPL的代码作为基础完成你自己的软件，如果你要分发你的软件，你的软件必须也是GPL的。如果使用GPL成分的软件通过互联网或者其他方式发布，就必须提供源代码。 一条限制：如果使用AGPL许可的软件与用户通过网络进行交互，也需要提供源代码给用户，所有的修改也要给用户。 GPL 和 AGPLv3 的区别： GPL v3 协议，意味着修改和使用其代码都需要开源，但是这是建立在软件分发的基础上，如果使用代码作为服务提供，而不分发软件，则不需要开源。这实际上是 GPL 协议本身的缺陷。 AGPL v3 协议，也就是说，除非获得商业授权，否则无论以何种方式修改或者使用代码，都需要开源。 MIT：限制几乎是最少的开源协议。 引自 MIT开源协议_yanqing0924的博客-CSDN博客_mit开源协议。 被授权人权利：被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本；被授权人可根据程序的需要修改许可协议为适当的内容。 被授权人义务：在软件和软件的所有副本中都必须包含版权声明和许可声明。 其他重要特性：此许可协议并非属copyleft的自由软件许可协议，允许在自由及开放源代码软件或非自由软件（proprietary software）所使用；MIT的内容可依照程序著作权者的需求更改内容，此亦为MIT与BSD（The BSD license, 3-clause BSD license）本质上不同处；MIT许可协议可与其他许可协议并存，另外，MIT条款也是自由软件基金会（FSF）所认可的自由软件许可协议，与GPL兼容。 CC-BY-NC-SA 4.0： 引自 YunYouJun/yun: ☁️ 小云设定资源大公开！ (github.com)。 简而言之，在非商业使用与署名（发布时注明原设出处即可）的前提下，您可以任意对其进行修改（包括但不限于 P 图、二次创作）、印刷、分发等。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:6:1","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"其它更多协议的详细描述 开源软件许可协议介绍_Dave888Zhou的博客-CSDN博客_gpl开源协议。 详细介绍六种开源协议（程序员须知） - 知乎 (zhihu.com)。 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:6:2","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["随机技术情报"],"content":"用图描述开源协议的选择 下图出处：乌克兰程序员 Paul Bagwell 画了一张分析图（图为阮一峰汉化版 http://www.ruanyifeng.com/blog/ Cc-By-3.0 / 2011.5.2） 下图出处：见图中右下角 ","date":"2021-05-06","objectID":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/:6:3","tags":["软件"],"title":"（大集合）可供选择的软件开源协议的罗列","uri":"/25%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%97%E5%88%97/"},{"categories":["人与世人的关系"],"content":"涨经验的提醒几句  和 王者荣耀的匹配机制和英雄平衡已经崩了","date":"2022-09-01","objectID":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/","tags":["杂谈"],"title":"王者荣耀的匹配机制和英雄平衡已经崩了","uri":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/"},{"categories":["人与世人的关系"],"content":"王者荣耀的匹配机制和英雄平衡已经崩了 本文分为两个部分：分别是 “涨经验的提醒几句” 和 “王者荣耀的匹配机制和英雄平衡已经崩了”。 首先我总结一些提醒。 ","date":"2022-09-01","objectID":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/:0:0","tags":["杂谈"],"title":"王者荣耀的匹配机制和英雄平衡已经崩了","uri":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/"},{"categories":["人与世人的关系"],"content":"涨经验的提醒几句 选相克英雄，对面肉就出真伤英雄（貂蝉、吕布），对面百里可以女娲应对，对面有蔡文姬要记得出梦魇，对面控制多就可以考虑庄周解控等等等等。 把我方的输出的经济搞的多多的，把对方输出的经济搞的少少的（压制对方的输出）。尤其是扶持我方射手和多针对对面射手（或者对面哪个势头强就针对哪个）。就是把朋友和对面威胁小的搞的多多的，把敌人和对面威胁大的搞下去。不就这么个理儿嘛。 辅助多扶持射手，能提升赢的概率。把我方射手经济扶持起来，有输出的射手就算只会在后面站着傻射，至少也确保了团队的输出。 开局节奏：辅助跟射手去压制对面射手，法师或打野时不时去发育路支援（如果我们发育路势头很猛但是我方对抗路被压制，就去多支援对抗路，木桶效应，阵容别有太大的短板）。如果对面法师去了对面发育路，我方法师及时发信号，同时也对等的去我方发育路支援。战斗至少要对等的打，以多打少更好，胜率才大，以少打多大部分情况不可取，因此直接尽量避免就是了。发育路射手打掉对面一塔之后，立马去打中路对面一塔，对面中路一塔掉了，我们的各种优势大概率就慢慢起来了。 买装备，根据对面英雄特点随时或预先调整。对面法伤多出法抗，对面物伤强出物抗或反甲，对面有蔡文姬等加血的出梦魇，和对面打的势均力敌出名刀或复活甲（给自己增加逃或反杀的机会），在此基础上尽量出增加自己伤害的装备，或者灵活预判调整。 尽量有控制技能的，或者肉的先冲上去开团，然后输出站好有利位置去补伤害，优势大。总之就尽量只打优势大的团战，少打劣势战，才能胜率大，不就这个理儿。 大家打大龙的时候，辅助去帮看视野和骚扰对面，防止对面过来抢龙，这是这时候辅助的重要职责。辅助不用帮着打龙，辅助的伤害在打龙的时候能起多大作用？对面打龙的时候，看情况，如果我方人都到齐了，如果能抢，就上，主要针对对面大野和射手，我方坦克先冲上去开团，我方法师有控制技能的赶紧上去补，辅助保护我方打野和射手去抢龙；如果我方人还没到齐，就骚扰对面打龙，吸引对面注意让其停止打龙，给我方队友赶来拖时间；如果对面人很多，就别骚扰了；或许我方有能人异士单枪直入抢龙呢，或许直接等着守家清兵吧，对面可能也有意外发生呢。 多找机会清兵线、推塔，多分散对面注意力，别好像没事的时候就布朗运动随机转悠遛弯，你要么是在支援，要么是在清兵带线，要么是探视野，随时注意对面的兵线是否压过来、对面是否偷塔，等等，思路清晰，时刻有个事干，别在峡谷里遛弯似的，搁那布朗运动。 后期，尽量带着兵线去打、带着兵线上，优势大，兵线没到就想着随时撤退。并行清理多路兵线，多路兵线上去会有效干扰和分散对面人员，而我方人员可以集中一路攻上去。 ","date":"2022-09-01","objectID":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/:1:0","tags":["杂谈"],"title":"王者荣耀的匹配机制和英雄平衡已经崩了","uri":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/"},{"categories":["人与世人的关系"],"content":"王者荣耀的匹配机制和英雄平衡已经崩了 你说我这么多百强英雄，怎么着也是轻轻松松王者段位吧，不，以前是，但现在匹配，让我打个钻石都上不去 已经卸载游戏了。 本来有王者段位的水平和意识，但tmd赢多少局就输多少局，始终上不去分，强行的压制你的胜率在50%（实际上我大部分英雄胜率在55%~60%），等你这局打的好了再开下一局给你匹配4个混子，你没发挥好、打不好的时候再给你匹配系统认为和你水平差不多“一样次”的；几个赛季以前很少遇到双方人头数量差距特别悬殊的情况，差不多都是旗鼓相当的，打得很欢乐，现在这几个赛季，上来几分钟就是动不动一边倒的态势，要么队友哐哐哐一直送个不停，跟丢了脑子似的，要么是对面儿哐哐哐的一直有人送，不像以前还可以经常打的有来有回比较有意思，现在，要么跟打人机一样，要么就被对面压的几乎根本没有反制的可能，没什么意思了，真的。 它这匹配机制现在是有大问题的，很伤体验。对比一下你就能发现，之前我们10个人相互认识的同学开房间开黑，我们的水平都是差不多的，打了两局，打的有来有回，最后一看两边的人头数都一致，但是如果你要是自己打匹配，系统指不定给你各种不公平的匹配，由此来强行控制你的胜率，而不是根据你的真实水平来让你达到相应的段位，这么一对比，这匹配机制是有大问题的。还有，英雄之间的平衡也开始崩了，像是夏洛特、狂铁、孙策，这种又肉、又特别控、还有不小的爆发输出的，就是bug的存在，还有墨子和刘禅，控制别人是不是太容易了，而且输出还很高，我只要看见对面选这些，那么我的胜率很大很大概率会掉，这些都是bug英雄，他们的技能机制相比其他同类英雄来说都是过于明显的不合理的存在（其他英雄要么是有控制但是输出很小之类的，总之都各有短板），这里只是举几个例子，在你想说可能我可能打不好、不会玩之前，你先想想或者再有意观察观察，仔细看看我上面描述的用词。 甚至有时在打的时候我都怀疑我是不是在局内被弱化了、或者加强了，顺风局的时候我的伤害超出我认知的高，我残血还可以反杀三个，莫名其妙，逆风局的时候对面的伤害超出我的认知的高，我们三个满血瞬间1秒左右被对面秒掉了，莫名其妙；伤害、暴击是有一定概率打出来的，是不是系统检测到你们顺风，那么打出暴击的概率就比对面要高？然后这样可以加快结束一局？然后可以让赢的玩家和输的玩家都还想再开一局？比一局玩很长时间更能留住玩家？？ 更多讨论： (Staok 的想法: 就想让王者官方看看，是不是针对老用户 - 知乎 (zhihu.com) (王者荣耀的匹配机制公平吗? - 知乎 (zhihu.com) (我就想知道现在的王者荣耀匹配机制是怎么样的? - 知乎 (zhihu.com) (王者荣耀匹配机制是如何运作的? - 知乎 (zhihu.com) ","date":"2022-09-01","objectID":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/:2:0","tags":["杂谈"],"title":"王者荣耀的匹配机制和英雄平衡已经崩了","uri":"/26%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E6%B6%A8%E7%BB%8F%E9%AA%8C%E7%9A%84%E6%8F%90%E9%86%92%E5%87%A0%E5%8F%A5/"},{"categories":["人与世人的关系"],"content":"《清单革命》这本书的内容梳理\u0026随笔","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"《清单革命》内容梳理\u0026随笔 ","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:0:0","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"起 书即是将四散的知识按照逻辑和网状联系编排起来。你应该这样去读，高屋建瓴、层次有秩、显得貌似自己有经验（褒义）的读，读出一些感想和方法论，无论是读出书里的还是书外的，皆是收割的果实。 ","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:1:0","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"注 这本书在列举外科手术、大厦建筑、飞机飞行、演唱会超多设备管理和安装的不出差错、超高并发的厨房里要保证每一道菜的质量、金融投资对数十数百家公司评估的高效且准确等一系列人类面对的繁杂系统、复杂系统、大机器的时候，个人的“大师力“越来越不能驾驭，我们自身必须在方法上、思路上有所改变，而不是选择粗糙的过活甚至”硬刚“（比如头疼医头、吃啥补啥和无脑补习等朴素直观思维），我们愈发需要的是实践出真知、实事求是并不断总结升级（十几年政治学科的教育不要白白丢了，那里面都是方法论精华），团队的力量、不断总结以及清单备查等简洁但不简单的有效、实用和可测的措施被提出，来将愈加复杂的、不断有新状况发生的、难以预测的事情去做好、作对。不同领域的人不约而同的想到了清单检查。 我也自发的形成总结备查的梳理性文章和其中的清单检查项，比如我的三篇技术规范文章 “C 编写及其规范”、“SCH \u0026 PCB设计规范” 以及 “HDL \u0026 FPGA 学习总结”，查看我的【规范】系列 文章，其中也包括 更高层面上的、做事的总结，当然，我还在积累，我的这些文字就是这些点滴改变的记录。所以说和这本书还是有点缘分滴。 读这本时自发可明显读出每个章节的主题，以及一个章节中从前往后每个小节的起承转合的承上启下、前后呼应的逻辑关系，即一个小节一个小节来：给出例子引出思考、思考出问题所在并提炼出来、经过探究的过程得出一些方法论（通过比如结合自身经验思考、拜访其它有相关问题的业内权威获得启示等等）、进行比较充分的实践验证得出结论、思考这些问题为什么会出现以及别人对待这些问题和解决方案的态度和顾虑等等，比较喜欢这种顺畅的感受，激发随笔欲。 读的时候加了很多随笔、“注脚”，以及很多很多折角（这些折角，物理上的把书读厚了呢，开个玩笑..）如下样貌： 这篇文章就是将书中随笔摘下记录在此。书本身以及其中一些例子和细节我就不介绍了，仅梳理出精华罗列于此。书内段落引用我会用 markdown 的 ”引用“ 标出。本文使用键盘打字、讯飞语音输入和电子版原文共同完成~（2022.10.6） 正文大量引用原书内容，侵删！ ","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:2:0","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"梳 ","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:3:0","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"引言：“无知之错”和“无能之错” 我们喜欢认为一切都在自己的掌握之中，但约翰的故事（前面一个医疗事故的故事，来说明外科手术这个复杂事情的步骤繁杂、信息有时候不够、粗心等等导致犯错、造成事故（但是后来救过来了））让我们开始反思一个问题，我们到底能掌握多少？有哪些事情根本不在我们的可控范围之内？ . 关于世界和宇宙，其中很大一部分是我们无法理解无法掌握的，现在如此将来也如此。 . 人类的错误可以分为两大类型。 第一类错误是”无知之错“，我们犯错是因为没有掌握相关知识，科学只让我们部分理解了世界的运行规律。 第二类错误是”无能之错“，我们犯错并非因为没有掌握相关知识，而是因为没有正确使用这些知识。 如果把约翰讲述的故事看作21世纪初医学问题的一个缩影，我们会惊奇的发现原来倾向于”无知之错“的天平，现在越来越倾向于”无能之错“了。 对上面随笔：这是 ”知识爆炸“ 的必然趋势，必须要采取些什么，但不是 ”硬刚“、“使蛮力”，是什么，后文的书的内容和我的随笔和梳注会娓娓道来。 我花了不少时间想搞明白：现代医学面临的困境和压力都是由哪些原 因造成的？结果发现，主要的原因并不是金钱或政府，也不是法律诉 讼或保险公司制造的麻烦，而是现代科学的复杂性以及我们在运用复 杂知识时所面临的紧张和压力。 现在我们面临的错误更多的是无能之错，也就是如何持续正确的运用我们所掌握的知识。 对上面梳注：无知之错——不可避免；无能之错——不可原谅。 在大多数技术含量很高的专业领域，对于失败的正确处理方法不是惩罚，而是鼓励从业人员积累更多经验和接受更多培训。 . 外科医生只看教科书是不够的，…，一名优秀的外科医生还必须熟悉诊疗的真实环境，熟知实施各种步骤的次序和正确时机，不断练习，不断积累经验，会让你熟能生巧。如果导致失败的原因仅仅是缺乏某些技能，那么只需接受更多的培训和练习就能解决问题。 . 但这并不是约翰所碰到的问题的症结，…，无论是在医学还是在其他领域，个人能力往往不是最难克服的障碍。 对上面梳注：实践 + 梳理 + 记录 我们所掌握的知识和数量和复杂程度已经超出了个人正确安全和稳定的发挥及功效的能力范围，知识的确拯救了我们，但也让我们不堪重负。 对上面梳注：引出后续。 ","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:3:1","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"第一部分：清单革命是一场观念变革 第1章：人人都会犯错 我们的身体能够以13000多 种不同的方式出问题，而科学几乎给每一种疾病都提供了解决问题的 方法。…现在，医生们手边就有6000多种药物和4000多种治疗手段可供选择， 每一种都有不同的要求、风险和注意事项，这让医生们很难不出错。 . 他（这个病人）当然不是一台简单的机器。我们（外科手术医生们）面临的困难就好比仅仅依靠几个简单的仪表和操控装置，就要把一辆从山上飞奔而下的18轮汽车安全开到山脚下。 . 超级专家有两大优势：他们知道更多重要的细节，而且还学会了如何掌控特定工作的复杂性。 （但）无论是在医疗行业，还是在其他领域中，一些工作的复杂性远远超出 了个人可以掌控的范围，即便是最能干的超级专家也难免会犯错。 成功和失败并存的现代医疗向我们发出了严竣的挑战：如果专业分工 都不足以解决问题，那该怎么办呢？如果超级专家都会失败，我们还 有什么办法吗？渐渐地，我们看到了问题的答案，但它来自一个意想 不到的领域，一个和医疗完全没有关系的领域。 对上面随笔：说明复杂问题。说明我们手头的工具和信息获取都是有限的，更何况人类自身的意识的“内存” 和 发散寻找经验和解决方案的思考也是有限的。还只是一个行业的现实情况。 前面很多专业例子来佐证和引出“记录”（就是“清单”）的呼之欲出。 即便专业愈发细化分工，但随知识和经验积累，细化分工后的窄领域内也会堆叠知识和经验，因此不能将所有细节都交由脑去记，应将知识的“目录和大纲”记住并作分析（这才是大脑擅长的），而将余下的细枝末节卸放到“记录”上去，并且“记录”中，“关键点” 比 “大而全” 更重要。 第2章：“关键点” 比 “大而全” 更重要 抓取“关键”要素与“必不可少”的基本要素 和当年的试飞员一样，现在很多领域的专家，如软件设计师、财务经 理、消防员、警官、律师，还有医生等，也面临着越来越复杂的工 作，单凭记忆他们很难万无一失地完成自己的工作。也就是说，现在 很多领域已经成了不能由单人操作的“飞行堡垒”。 . 在复杂的环境中，专家们要应对两大困难。 第一种困难是人类记忆和注意力的谬误。在重压之下，人们特别容易忽视一些单调的例行事项。 第二种困难那就是人们会麻痹大意，会跳过一些明明记得的步骤。 对上面梳注：就是 记忆 和 注意力 的不稳定（承认吧，人类~） 清单会提醒我们不要忘记一些必要的步骤。 让清单变成理性的选择 实践中，普罗诺弗斯特（文中一个医生同事）要求自己重症监护室里的护士对医生的操作观察一个月并记录他们实施上述步骤的情况，调查结果显示1/3以上的操作不够规范，医生至少跳过了一个步骤。 对上面随笔：用事实说话，既然很多经常做不到尽善尽美，那么就写下来提醒着点儿，实事求是！ 初步验证一下清单的作用。研究人员发现，仅仅是要求重症监护室医护人员为日常操作编写清单 就能显著提高他们的绩效水平，并能让病人在重症监护室里的停留时 间减少一半。 普罗诺弗斯特发现，除了上述效果之外，医院里的清单也可以在其他 领域发挥作用。它们帮助我们记忆关键步骤，并且清晰地列出了操作 过程中必不可少的基本步骤。 . 发现执行清单有问题。重症监护室的医护人员往往人手不足，他们时间紧迫，压力重重，已经有很多烦人的表格要填写了，而现在你又要让他们填写一张清单，这实在是件非常困难的事情。 . 与此同时，大家的工作压力却 有增无减，因为新的规定严格限制了住院医生连续工作的时间。而就 在这样一个时刻，普罗诺弗斯特却给医护人员增加工作负担，要他们 抽时间填写日常检查清单。 对上面随笔：执行有难处，那就想办法优化执行。 可以尝试电子化呗，思路是正确的时候，为提高执行效率和便利化执行，就借助科技的力量！科学是第一生产力yyds~ 要简化之能够简化，优化执行。 至于清单是否增加了工作负担，在本书最后会经过大量的实践调查发现得出结论，长期来看、整体而言，是大幅的提升了效率的。 但我发现他们真的做到了。 在大多数情况下，负责这项工作的是护士。每天早上，一位手里拿着写字板的高级护士会查房，她会检查每个接入呼吸机的病人其病床床头抬起的角度是否正确，确认每个病人是否服用了正确的药物、接受 了正确的检查。每当医生要为病人插入中心静脉置管的时候，护士会根据清单进行检查，在填写完清单后将其放入病人的记录档案内。我还查阅了医院的档案，结果发现在过去的3年多时间里，他们一直认真 地实施这一举措。 推广清单的使用。普罗诺弗斯特是个精明的人。在清单推广初期，他并没有要求医院管 理层立刻使用中心静脉置管清单，而是请他们收集医院中心静脉置管 感染率的相关数据。他们发现，在2004年年初，密歇根州各个医院重症监护室的感染率高于美国平均水平，有些医院的感染率高得出奇。 西奈-格雷斯医院的感染率高于美国75%的医院。与此同时，密歇根州 的蓝十字蓝盾协会（Blue Cross Blue Shield）同意为每家参与普罗诺弗 斯特推广计划的医院颁发一小笔奖金。突然之间，试验清单变成了理 性的选择。 . 普罗诺弗斯特还坚持要求每家医院指派—名高层领导分管这项 工作，并要求其每月至少下基层一次，倾听员工的意见和建议，并协 助项目经理解决问题。 医院高管有些不情愿。办公室和会议室是他们的主战场，他们关心的 是医院的战略问题和财务问题，而不是冒险到病区和大家打交道，那 不是他们想要去的地方。虽然一些医院的高层在下基层的时候碰了钉 子，但事实说明，他们的参与对于项目的推广至关重要。 . 在基层里遇到的很多困难和不足，此类问题只有医院管理层才能解决。 . 2006年12月，《新英格兰医学杂志》（New England Joumal of Medicine）刊登了一篇里程碑式的文章，发表了基石行动所获得的丰硕成果。清单的力量“基石行动”开展3个月后，密歇根州重症监护室中心静脉置管的感染率 下降了66个百分点。大多数重症监护室，其中包括西奈-格雷斯医院的重症监护室病房的季度感染率下降为零。密歇根州的平均感染率显著 下降，在全美名列前茅。 项目实施18个月后，参与行动的医院总共节省了1.75亿美元，挽救了1500多人的生命。这项行动取得的辉煌成就已经延续了好几年，这都要归功于一张看似愚蠢的清单。 对上面随笔：收集数据，让问题浮出水面，提出解决方案，然后找“天使投资”~ 即 正确的事情 + 找到强有力的支持！ 之后思考。清单对哪些类型的失误非常有效，而对哪些又欠缺。 抓住关键，就抓住了一线生机。 这里给讲一个例子，对一个深度病危重症的溺水女孩的一切救援步骤都有序进行，在短时间内就一步接一步依次进行，由于抢救及时，女孩儿有了生还的希望。 对上面随笔：不是什么都要往清单放的，那样又成了大厚手册了，也就慢慢引出后面讲好的清单有一些特点：“抓重点，抓关键”、“简洁，实用，可测，高效”。 第3章：团队犯错的概率比单个人要小 当简单的个人“强制函数”不再奏效时 但没有什么东西是万能的，清单也不例外。所以在使用它们之前，我们必须搞清楚在哪些情况下它们能够帮助我们，而在哪些情况下它们 没有什么用处。 对上面随笔：上面讲去看它的两面性。 美国约克大学的布伦达·齐默曼（Brenda Zimmerman）和加拿大多伦多 大学的肖洛姆·格鲁伯曼（Sholom Glouberman）是两位专门研究复杂性科学的教授。他们提出了一种理论，将世界上的问题分为三类： 简单问题、复杂问题和极端复杂的问题。 简单问题是那些具有明确解决方法的问题。如用特定配料烘焙蛋糕。 对于这类问题，可能需要学习一些基本技巧，但是一旦掌握了这些技 能，成功的可能性就会非常大。 复杂问题类似于把火箭发射到月球上这类问题。虽然有时候你可以将 其分解为一系列简单问题，但是却无法找到直接的解决方案。一般来说，这类问题需要掌握不同专业技能的人组成团队，通力合作才能成 功解决。时机和协调成了成功的关键因素。 极端复杂的问题类似于抚养子女这类问题。一旦成功地将火箭发射到 了月球上，那么在发射其他火箭的时候就能重复和完善这一过程。毕竟，火箭就是火箭，它们之间有很大的相似性。但抚养子女就不同了，因为每个孩子都是独一无二的。虽然成功抚养一个孩子能让你积累经验，但这并不意味着在抚养下一个孩子的时候也能成功。虽然专业技术是非常重要的，但它们却不是获得成功的充分条件。抚养不同孩子的方法可能截然不同。这体现出极端复杂问题的另一大特性：结果的不确定性非常大。虽然我们知道有可能成功抚养孩子，但是这一过程极其复杂。 虽然很多问题看似非常不同，但它们本质上非常相似。1935年，试飞 员要想办法避免飞机坠毁；2003年，医护人员要想办法避免中心静脉置管感染；而在不久之前，医生挽救了一个3岁溺水女孩的生命。影响这些问题的因素虽然非常不同，但它们的核心都是一个简单的问题， 那就是集中注意力。对第一个问题来说，飞行员需要集中注意力给飞行控制面解锁；对第二个问题来说，医护人员需要集中注意力保持无菌状态；而对第三个问题来说，外科小组需要集中注意力准备为女孩接上人工心肺机。 这些问题都是可以解决的，只要我们使用被工程师称做“强制函数”的 方法，即用相对简单而直接的方法来迫使必要行为的发生，如使用清单来塑造行为。 . 但是，人们所做的大多数重要工作没有那么简单。要知道，插入中心静脉置管只是重症监护室医护人员每天所要进行的178项操作中的一 种，他们的工作极端复杂。我们真的能够为每种工作都编制出清单， 并在工作中按部就班地使用吗？这种想法是不是太不切实际了？我们很难找到一个简单明了的方法来照料重症监护室的病人，我们需要不同专业的专家在不同的情况下通力合作，完成不同的任务，","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:3:2","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"第二部分：清单革命的行事原则 第4章：权力下放 建筑业为了应对极端复杂问题会使用特殊清单，其中一些清单所体现 出的理念非常引人注目，那就是把权力分给更多人。在面对风险的时 候，大多数当权者喜欢把权力、决策权等聚集在自己手里。一般清单所发挥的其实就是这一功能，高层会用清单列出下属应该完成的工作，并确保其及时正确地完成。 比如在建高楼的楼板突然出现 意料之外的内倾状况，这张清单就能派上用场了。它所体现出的理念与前者截然不同，因为它将决策权分散到外围，而不是聚集在中心。 对上面随笔：两个清单，”日程表“发挥决策者功能（也不是替代拉）列出工作和确保及时完成，”商议表“发挥放权、商讨的功能。 高层需要做的并不是直接进行决策， 而是督促大家积极参与讨论，让他们担负起自己的那一份责任。这就是此类清单奏效的关键所在。 在面对极端复杂的问题时，高层应该尽可能把权力下放给一线人员， 而不是将大权集中在自己手中。极端复杂的问题本来就是出乎人们意料的，对于此类问题，传统的中央集权处理范式是行不通的。 问题并不是这些高官缺乏同情心，而是他们没有认识到，在面对极端复杂的问题时，他们应该尽可能把权力下放给一线救援人员和当地官员，而不是将大权集中在自己手中。每个人都在等待救世主，但中央集权的解决方法只会让灾民们等得望眼欲穿。 对上面随笔：书本中讲了一个无政府状态下一个地方的中央集权官僚造成的赈灾的延误的可怕后果的例子来说明要放权而不是中央集权。 我对国外资本主义世界这种敌对社会主义的氛围和腔调比较敏感（外网逛多了你也这样。。），在他说这个例子的时候，我隐隐约约感觉有所指（我点到为止不多说是指什么）。。他们的观念中，中央集权都是比较极端的例子，他这个中央集权是比较典型官僚的那种，且没有足够备案和经验处理此情况；若有比较预先的备案和考虑各种情况比较充分的话，那么动员起来不至于这么低效，因此这是官僚政府不作为的例子，此例子来批判所有”中央集权“的类型并不充足；有个决策中心是必要的，它应保证收集充分信息和下达顶层指令才能发挥好的、带头的总指挥作用。 让人意想不到的是，在所有组织中，把救灾问题的复杂性理解得最透彻的竟然是沃尔玛。哈佛大学肯尼迪政府学院的教授对沃尔玛在救灾过程中的表现进行了案例研究。这份报告向我们展现了一个灵活应变、充分下放权力的超低价零售巨擘。得知新奥尔良遭受严重风灾的消息之后，沃尔玛首席执行官李·斯科特（Lee Scott）只是发布了一条非常简短的指令：“本公司将对风灾做出相应级别的响应。”有人记 他在公司高层会议上是这么说的：“在座各位将要做出超出自己级别 决定，请务必根据所掌握的信息及时做出最佳的选择。记住，最重要的就是做正确的事情。” 就这样，简简单单的指令从高层传递到一线门店经理那里，这条指令也给他们松了绑，让他们放开手脚便宜行事。 沃尔玛的门店经理自行决定为当地居民分发物资。当联邦紧急事务管理局的官员还在思考应该如何征用各种补给品的时候，沃尔玛的门店经理们已经启 用了手动记账系统来记录提供给先遣救援队的各种物资。 沃尔玛的高层把工作重点放在设定目标、监控进度以及保持和一线员 工及政府机构的联络上。也就是说，在应对这一极端复杂的危机时，他们没有发布具体的指令。由于情况出乎意料，而且瞬息万变，所 以，他们努力确保人们能够及时有效地进行沟通。 公司的物流团队已经想办法让一辆 辆满载着食品、饮用水和救援设备的卡车绕过重重障碍，到达迫切需 要援助的灾区。他们在政府救援力量到达灾区的前一天就把水和食物 送到灾民甚至是美国国民警卫队的手里。 后来，杰斐逊县（Jefferson Parish）县长亚伦·布劳萨德（ Aaron Broussard）在接受电视访问时说：“如果美国政府也能像沃尔玛那样做 出及时响应，这场灾难就不会造成这么巨大的损失了。” . 而政府部门也并非一事无成。比如，在灾难发生后的几天 里，新奥尔良当地的警察和消防队员虽然缺乏各种救援设备，但是他 们组织很多体格健壮的志愿者用平底船从水中、房顶上和阁楼里救出 了62000多人，这是非常了不起的。 为上面人类的赞歌全体起立！！ 是的，“中央集权” 可以是： 1、充分拿到信号 → 2、确保各方充分交流讨论协商 → 3、形成解决方案 和 总指挥 / 顶层设计 → 4、执行阶段包括充分下放权力。 因此并不是说 “中央集权” 就一定是坏，它可以做得更好，此 “中央集权” 非 古式、传统的，而是不断进化、检验的，先进的。 由于极端复杂问题往往不可预测，这类问题的解决超出了个人能力的范围，所以，事无巨细都由核心层、最高层来决定的做法是注定要失败的。 所以他想说的是 “事无巨细由 顶层/中央 去处理” 是坏的，这并不等于 “中央集权”。 建筑行业从业人员对于应对极端复杂问题，解转变为简单易行的清单，把对复杂性的管理纳入平时的例行工作之中。 他们使用一整套清单来确保那些看似简单但十分重要的步骤不被人们忽略，而用另一 套清单来确保人们充分沟通，互相协调，承担责任，并赋予他们权 力，让他们用所知的最佳方法来解决瞬息万变和出人意料的问题。 在极端复杂的情况下，清单不只有助于成功，而且还是人们获得成功所需的必要 条件。当然，主观判断也是不可或缺的，但是我们需要使用清单来协助主观判断，甚至用清单来提高主观判断的质量。 对上面梳注：面对极端复杂的问题清单是做好事情的必要条件，事在人为，清单用于协助我们的主观判断和提高主观判断的质量。 下面两个例子：演唱会超多设备管理和安装的不出差错，超高并发的厨房里要保证每一道菜的质量，均与建筑行业类似的， 充分的共商 + 纪律的执行。 清单，安全与高质量服务的关键 演出清单的故事。故事的主人公是著名摇滚乐手大卫·李·罗斯（David Lee Roth），他是范-海伦（Van Halen）乐队的主唱之一。每次签订巡演合同的时候，罗 斯都会坚持在合同中包含这样一个条款：后台化妆间里必须摆放一碗 M\u0026M’s 巧克力豆，而且里面不能有一粒棕色巧克力豆，如果主办方没有做到的话，演唱会将被取消，而且主办方还要对乐队进行全额赔偿。至少有那么一次，范-海伦乐队因为上述原因霸道地取消了科罗拉 多的一场演唱会，因为罗斯在化妆间里找到了棕色的巧克力豆。有人或许会认为大明星总是喜欢摆谱，提出不近人情的苛刻要求。但其实不然，这是罗斯用来保障演唱会安全的一块试金石。 工作人员一不留神就会犯技术错误，比如横梁因为无法负重而倒塌，地板也 会因为不堪重负而塌陷，还有舞台的门不够大，舞台置景无法通过。 演出的合同附文读起来就像是看黄页一样，因为设备实在是太多了， 调试安装工作需要大量人手。”所以，他们设计了一个小测试，也就是 合同附文的第126条那个关于巧克力豆的条款。罗斯写道：“如果在后台放置巧克力的碗里发现了棕色巧克力豆，我们就会对各项装配工作逐一进行检查。我保证会发现技术错误，会碰到各种各样的问题。”这些可不是鸡毛蒜皮的小事，一些错误会威胁到人们的生命安全。就拿 那次被取消的科罗拉多演唱会来说吧，乐队发现当地主办方没有仔细 阅读有关舞台重量的要求。如果演出如期进行的话，舞台完全有可能 在演出中坍塌。 厨房清单的故事。我很清楚像汉堡王和塔可钟（Taco Bell）这类快餐连锁店是如何在全球范围内进行标准化 运营的。这些店里的每一种食品都是根据既定规程，用流水线生产出来的。但在大饭店里，厨师要对菜谱不断进行改进和雕琢，每一道菜都是不同的。而且，他们要日复一日，年复—年地保持高水平，要知道，他们晚上最多要接待300多位顾客。我为这一完美的表现找到了一 种理论。 在人们的印象里，烹饪靠的是技巧和创意。现如今，厨师已经成了风 云人物。他们的大胆发挥是厨艺比拼节目大受欢迎的重要原因，但我在里阿尔托（一个书作者提到的非常喜爱的餐厅，他到这里来观察学习）看到的却是严明的纪律，而不是光鲜亮丽的外表和天马行空的发挥。厨房的正常运转需要的是纪律，而清单又在其中起到了关键作用。 亚当斯（餐厅主厨和老板）她说：“遵从菜谱对于长期维持高质量服 务是至关重要的。” 可有时厨师们会觉得整个制作过程（细化分工，这些厨师各有分工，有的只做面点，有的负责烘焙，你还能在他们中找到烧烤厨师、 煎炸厨师、甜点厨师、副主厨和酒侍）早就已经烂熟于心了，自己不需要再按部就班了。但亚当斯却认为，这时候菜肴质量水平就会开始下滑。 菜谱也会不断变化革新，适应更好的品质和更流畅的制作过程。亚当斯和其他两位厨师对（某一个菜的）制作工序进行了改进。他们决定事先做好调味酱，并将龙虾煮成半熟。一次又一次的尝试让这道菜变得越来越完美。而菜谱则重新写了一遍。 亚当斯也开发了沟通清单，以确保大家在面对意料之外的问题时能够像一个完整的团队一样沟通协作。每天下午5：00，也就是离饭店开门迎客还有一个半小时的时候，当值厨师会聚在一起召开一个碰头会。他们要简短地讨论一下事先没有料到的问题，并以此来应对这一复杂行业的不确定性。在我访问的那天晚上，他们在开 会的时候讨论了当天顾客的预定菜单，对菜单进行了两处修改，想办法为一名请病假的员工补缺，还为一个突发情况制定了应对方案。在开会的时候，每个人都能发言，而且大家会共同商讨行动计划。 亚当斯还设置了最后一道检查。每道菜在被端出厨房之前都必须经过她或副主厨的检查。他们要确保菜肴看起来没有问题，要核对顾客的订单，要闻一闻，或许还要用干净的勺子舀一勺尝 一口。 亚当斯的厨艺更像是一门艺术，而不是一门科学。但即使在这个高度专业化、分工细致并且需要高超手艺的行业里，人们还是离不开清单。 第5章：简单至上 清单要素（清单里每各个条目）的遴选，必须坚 守简单、可测、高效三大原则…… ","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:3:3","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["人与世人的关系"],"content":"第三部分：让清单成为一种习惯 第8章：清单，让世界更简单 超越复杂性 这个机会不仅属于医疗行业，几乎每个行业都能利用它。即便是最资深的专家也能通过寻找错误和失败的质因，并制定相应的检查项目来显著提高自己的业绩。但是清单对每一个行业都有效吗？这些问题的答案尚不清晰。 对上面随笔：进一步分析 “清单”，提出新问题，进行新思考。 我们的目标并不是让医生们在检查项旁边乖乖打钩，而是要培养注重合作和纪律的文化。 对上面随笔： Stick to the checklist is not the final goal. 恪守清单不是目的，能给人带来自在的、习惯上的，并且是更好的变化才是长久的提升，是可持续的。 改变我们的核心价值观 在《不可或缺的那些东西》 这本书里，汤姆·沃尔夫（Tom Wolfe）不但讲述了美国第一代宇航员 的故事，而且还记录了一个辉煌时代的终结。 在20世纪50年代，极端危险的试飞工作主要靠像查克·耶格尔（Chuck Yeager）这样的王牌试飞员完成。他们驾驶推力巨大、难以驾驭的复 杂飞行器冲向蓝天，将生死置之度外。据统计，有1/4的试飞员最终以身殉职。试飞员必须英勇、睿智，不仅要集中注意力，而且还要随机应变，这些就是沃尔夫所说的“不可或缺的那些东西”。 . 随着控制飞行风险的知识不断积累，随着飞行清单和模拟器变得越来越普遍，越来越复杂，试飞的危险系数正在不断下降。谨慎和 一丝不苟成了更加重要的决定因素，试飞员从此不再像摇滚明星那样叱咤风云。 相似的过程也发生在医疗行业。对于最复杂、最危险的那些工作，如 手术、急救和重症监护等，我们已经找到了更好的方法来完成它们， 但是这些方法的使用需要我们大刀阔斧地改变传统文化，特别是改变 我们的核心价值观：在高风险的复杂情况下，专家的胆大心细才是最 重要的，这些也属于沃尔夫所说的“不可或缺的那些东西”。 对上面随笔： 胆大心细，主要先是心细，想的周全了才有底气去 “胆大”。 别让“可卡因头脑”作祟 还有很多行业看到了清单这个机会，但对于它的抵制也同样无处不 在。金融业就是一个很好的例子。 投资是一个高风险的行业，并且投资评估繁杂、复杂。 最近，我和穆尼斯·帕巴里（Monish Pabrai）进行了交谈。他是帕巴里投资基金（Pabrai Investment Funds） 的合伙人之一。 帕巴里向我介绍了他是如何进行价值投资的。在过去的15年间，他每 过3~6个月要进行一次新的投资。为了找到一家真正有投资价值的公司，他往往要深入调查10家公司。他的消息来自于各种渠道，如路牌 广告、有关巴西房地产的报刊文章，或者是他随便拿起的一本矿业杂志。帕巴里的阅读面非常广，视野非常宽阔，他会睁大眼睛去发现那些埋在土里，但露出一丝光芒的宝石，也就是那些现在不为人知、但将来会飞黄腾达的企业。 帕巴里能发现成百上千的投资机会，但是只需稍加分析，他就会放弃大多数所谓的机会。 神经学家发现，赚大钱的预期能够刺激头脑中的原始奖励中枢，其效果和吸食可卡因是一样的。帕巴里说，对一个专业投资人来说，越是在这个时候（发现了一笔潜在的好买卖）就越是要保持头脑清醒，进行系统而全面的调查。 对上面梳注：投资评估的基本情况。 价值投资这块圣地的守护神是沃伦·巴菲特，他是史上最成功的投资者 之一。帕巴里对巴菲特以及他拥有的伯克希尔\u0002哈撒韦公司做出的所有投资决策，无论是成功的还是失败的都进行了仔细分析。他把自己能够找到的所有关于巴菲特的书籍都读了一遍。 他告诉我说，巴菲特的脑子里有一张清单，他用这张清单对潜在的投资机会进行评估。 但也有出错的经历。帕巴里说：“芒格和巴菲特对网络公司泡沫一清二楚，但他们却忽视了科特公司的收入十分依赖网络公司这一事实。”芒格后来认为他在这次交易中犯了“宏观经济错误”。 “科特公司的赢利能力曾经非常出众，但在这次危机之后的较长时间里，他们几乎丧失了赢利能力。”在向股东承认错误的时候芒格如是说。 所以，帕巴里将下面这个检查项添加到了他的清单里：在对一家公司进行分析的时候，必须确认这家公司的收入是否因为经济周期的大幅波动而被高估或低估。 显然，巴菲特也应该做一张纸质清单。帕巴里注意到，即便是巴菲特也会经常重复某一类错误。他说：“这让我知道巴菲特并没有使用真正的清单。” 对上面梳注：小插曲 帕巴里所说的错误并不是一般意义上的错误或错失良机。投资是一个高风险的行业，有些错误是不可避免的，而帕巴里所说的是那一类原本可以避免的错误，是由于计算失误或分析不到位造成的“无能之错”。比如，帕巴里在总结经验教训的时候发现，他总是在评估被调查公司财务杠杆安全性的时候屡屡犯错。相关信息其实都能得到，只是他没有进行仔细分析。 他说，对于令人兴奋的投资机会，无论自己如何保持冷静客观，头脑总是会诱骗他，让他能够轻易 看到可以支持自己初始判断的证据，而对那些负面因素却视而不见。 这就是“可卡因头脑”干扰理性思维的特征。他说：“你抵挡不住诱惑， 于是便开始投机取巧。” 在进行分析的时候，他们会尽力排除不理性情绪的影响， 做到既不过于乐观，又不过于悲观。他们会仔细分析公司的财务报表，了解公司的债务和风险，调查公司管理团队历年来的表现。他们 还会对被调查公司的竞争对手进行分析，考虑整个市场的前景，对投资机会和风险进行全面评估。 如果你想做出高质量的投资决策，那么就需要对公司各个方面的情况进行多方位的调查。 帕巴里发现，即使“可卡因头脑”没有作祟，他还是会常常考虑不周， 因为他头脑里的清单还不够完善。他说：“我不是巴菲特，我的智商达不到300。”所以，他需要一种即使智力一般的人也能使用的方法。因此，他设计了一张纸质清单。 他将自己见到过的所有错误都列了出来，其中包括巴菲特、其他投资人和他自己犯过的错误，清单上很快就累积了几十种错误。为了防止这些错误再次发生，他为每种错误都设置了相应的检查项，所以他的清单上已经有了70项检查内容。 对上面随笔：不慌不忙，有条不紊，有清单就是从容~ 本节随笔： 投资行业也建立投资目标评估的检查项清单。复杂的问题，考虑因素非常多，就应该将一些共性的、之前遇到过的、经验性的东西往清单上记一记、放一放，“好记性不如烂笔头”。 也就是说把什么都交由大脑去记忆和事无巨细的分析处理是不可靠的，还得依靠由清单等之类的外界“借力”来给大脑“卸货”，从而让自己尽量多的思考顶层、高价值的东西、战略上的事情，而在战术上做到“清单化”，清单多记录高效、实用、可测、简化的“法术”，以供作为 战略上的 “工具箱”，做参考、提醒，和乃至 “开箱即用” 之用。 效率，清单带来的额外优势 和帕巴里一样，那位匿名的投资家，暂且称他库克，也制作清单，但他做得更加细致，他会将投资过程各个阶段可能出现的问题分别罗列出来。他把整个过程分为4个阶段，即研究阶段、决策阶段、执行阶段以及交易完成后的问题监测阶段。他会根据各阶段的特点来设计清单以避免这些错误。这些清单都设置了清晰的检查点，每当到了这些关键节点，他和他的投资团队就会进行相应的检查。 比如，他有一张第三日清单。当对某家公司的分析进入第三天的时 候，他们会使用这张清单进行检查。在这个检查点到来之前，他们应 该已经完成了对于这家公司过去10年间财务报表的分析。库克为报表上的每个项目以及不同报表的关联项都制定了详细的检查项。 . 库克说，每50次检查中可能会有49次一无所获，但就是这一次发现却能让你避免重大损失。 . 清单能够帮助人们在投资过程中的每一步都尽力保持冷静而睿智的头脑，确保在必要的时候得到所需的重要信息，系统地进行决策，并和每一个应该沟通的人进行充分交流。 对上面随笔：我突然想到，这些投资检查、避坑清单，在网上能搜到吗 在变化越来越快的商业环境里，清单让众多商业人士具有了一个额外的优势，那就是效率。 当库克刚刚引入清单的时候，他认为投资团队 的决策速度会慢下来，认为这会增加决策所需的时间和工作量。对此，他已经做好了心理准备，并愿意付出相应的代价。毕竟，少犯错 能够让他们避免巨大损失，这笔生意划得来。事实证明，他们进行前期调研的时间的确增多了，但让他感到惊讶的是，从整体上来看，他们却能在较短的时间里对更多的投资机会进行评估，而且整体效率的提高不是一星半点。 当人们对一家公司 仔细研究了一个月以后，他们往往会决定对其进行投资。但在使用了清单后，他和他的团队发现，他们完全可以在执行第三日清单的时候就做出这一决定。他说：“虽然决策过程变得更加仔细，但速度却变得更快了。这就像是棒球比赛，我们一旦挥杆把球击出去，就可以全神贯注向前飞奔。” 2008年下半年，股票市场开始暴跌，投资人纷纷恐慌性地抛售手中的股票，物美价廉的股票在市场上比比皆是。在一个季度里，帕巴里对100多家公司进行了调查，并将其中10家公司的股票添加到自己的证券组合中。**他说如果缺少了清单的帮助，自己根本无法完成那么大量的分析工作，而且对分析的结果也不会那么有信心。**一年之后，他旗下投资组合的市值增长了160%。帕巴里完全没有犯错。 各种投资诀窍层出不穷，如投资网络公司，购买抵押贷款证券等，但其中绝大多数都很快被市场这个巨大的黑洞无情地吞噬 了，但使用清单这种方法却生存了下来。 . 帕巴里使用 清单已经有一年时间了，他管理的基金市值已经增长了一倍以上。当然，这不能完全归功于清单的使用。不过他发现，这一举措能够帮助 他大幅缩短投资决策的时间，而且让投资分析变得更加完整和系统。 对上面随笔：也别把清单奉为绝对，人家本身也已经是那个领域里的头部选手了。 运用清单系统评估工作 对风险投资人来说，最难做的决定就是是否要把大把钞票投给某个创业者。斯玛特对他们的决策过程","date":"2022-10-06","objectID":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/:3:4","tags":["杂谈"],"title":"《清单革命》内容梳理\u0026随笔","uri":"/27%E6%B8%85%E5%8D%95%E9%9D%A9%E5%91%BD-%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86-%E9%9A%8F%E7%AC%94/"},{"categories":["随机技术情报"],"content":"对当前 AI 工具和用法的一个大汇总","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"AI 工具和用法汇总 汇集整理 by Staok/瞰百，源于相关资料在我这慢慢越积累越多，到了不得不梳理的程度。文中出现的网图侵删。 文中有许多内容作者还没有亲自尝试，所以很多内容只是罗列，但信息大源都已给出，授人以渔，欢迎 PR 补充细节内容，比如 好的教程、简明使用步骤、工具的优缺点、使用经验等等！！！ 注：这是 本文原版文章的 Github 仓库，在这里日后可能会更新，在其它位置发的不会跟进，原文使用 Markdown 写成，在一些网站的排版会不完美，推荐去 github/gitee 或者 个人小站 看原文，这是文章的 Gitee 仓库地址，Gitee 访问更流畅。 带着AI看这大千世界 富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:0:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"！Awesome AI Tools 相关仓库！ Github 上面直接搜：Repository search results · GitHub。 ikaijua/Awesome-AITools: Collection of AI-related utilities. Welcome to submit issues and pull requests /收藏AI相关的实用工具，欢迎提交issues 或者pull requests (github.com)。 jiji262/awesome-AIGC-tools: AIGC information including ChatGPT , GPT-4 and others. (github.com)。 pingan8787/awesome-ai-tools: Finding the AI tools you need! (github.com)。 JMcrafter26/awesome-ai-tools: A list of AWESOME AI tools on Github。 nanogiants/awesome-ai-tools: A curated list of AI-powered tools (github.com)。 georgezouq/awesome-ai-in-finance: 🔬 A curated list of awesome machine learning strategies \u0026 tools in financial market. (github.com)。 altryne/awesome-ai-art-image-synthesis: A list of awesome tools, ideas, prompt engineering tools, colabs, models, and helpers for the prompt designer playing with aiArt and image synthesis. Covers Dalle2, MidJourney, StableDiffusion, and open source tools. (github.com)。 CognonicLabs/awesome-AI-kubernetes: Awesome tools and libs for AI, Deep Learning, Machine Learning, Computer Vision, Data Science, Data Analytics and Cognitive Computing that are baked in the oven to be Native on Kubernetes and Docker with Python, R, Scala, Java, C#, Go, Julia, C++ etc (github.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:1:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"AIGC 相关 AIGC 词义，百度百科 be line AIGC_百度百科 (baidu.com)，维基百科 be like Generative artificial intelligence - Wikipedia，还有 AIGC - MBA智库百科 (mbalib.com)，人工智能生成内容（AIGC）白皮书（2022年）–中国信通院 (caict.ac.cn) 可直接下载 pdf。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"ChatGPT 快速使用 ChatGPT国内镜像网站整理 - 哔哩哔哩 (bilibili.com)。 Chat8永久地址 地址发布页 (chat88.co)。 Chat8永久地址 地址发布页 (chat838.com)。 本文作者目前只用过这个，蛮好，注册用户免费 提问 1000 次（日常使用够了）。 chating AI-智能AI领导者 (yiweiss.com)。 首页 - Deeppp新一代AI技术驱动Bot平台,自定义Bot,自训练Bot。 道合顺infinigo官网-国产芯片替代,IC交易网上商城,电子元器件智能匹配平台 适合搞硬件的用。 一个 综合贴 GPT-4与GPT-3.5免费AI平台大全_-资本家-的博客-CSDN博客。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:1","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"GPT 相关软件-离线版 / 类 ChatGPT 快速本地部署 【AI对话】离线版GPT最终版 无需额外下载安装! ✔支持Llama2 ✔支持翻译 ✔支持AI绘图 ✔附带7B中文模型_哔哩哔哩_bilibili。 本地部署类chatGPT私有化CPU流畅运行130亿参数大语言模型AVX512指令集加速vicuna_哔哩哔哩_bilibili。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:2","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"GPT 相关介绍 / 感悟文章 / 相关话题 综合性，持续更新的： 差评君的个人空间 - AI大模型实测_ 哔哩哔哩_bilibili。 GitHubDaily 的 #ChatGPT (qq.com) 列表，持续更新。 知乎相关话题：ChatGPT - 知乎 (zhihu.com)。ChatGPT变现 - 知乎 (zhihu.com)。ChatGPT概念 - 知乎 (zhihu.com)。 相关话题文章（按时间先后往后排）： ChatGPT的工作原理 (qq.com)。 冒冷汗…. GPT-5 已经看完了人类世界所有视频 (qq.com)。 ChatGPT是传说中的银弹吗？ (qq.com)。 「AI 孙燕姿」火遍全网，随着技术的发展，未来 AI 歌手会成为主流吗？这一技术还可能应用到哪些场景？ - 知乎 (zhihu.com)。 AI 孙燕姿爆火、美国女网红出售 AI 女友爆赚、AI 券商分析师也来了，AI 还将改变哪些行业？ - 知乎 (zhihu.com)。 ChatGPT 成功诊断 4 岁男孩怪病，击败 17 位医生，这意味着什么？ - 知乎 (zhihu.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:3","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"ChatGPT 综合 / 报告合集 GPT 相关论文 / 报告合集 dalinvip/Awesome-ChatGPT: ChatGPT资料汇总学习，持续更新…… (github.com)。 综合性 GPT 教程： 🧭 ChatGPT 学习导航 | Learning Prompt。 ‍‍⁢⁢‌⁤‍‌⁣⁢‌‌‌⁣⁣‌⁣﻿⁢‌⁤﻿‍﻿⁤⁣‌‍⁢‬﻿﻿‍‍最全 ChatGPT 使用手册 - 飞书云文档 (feishu.cn)，翻译自外网。 综合贴： LangLangShanDeNanKe/chatgpt: ChatGPT网址导航，分享免费好用AI网站！ (github.com)。 📚 资料 \u0026 产品推荐 | Learning Prompt。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:4","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"ChatGPT 做事情景列举 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:5","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"ChatGPT 接口调用 / 本地部署 优秀例子 mic1on/chatGPT-web: chatGPT私有化部署 (github.com)。 SkywalkerDarren/chatWeb: ChatWeb can crawl web pages, read PDF, DOCX, TXT, and extract the main content, then answer your questions based on the content, or summarize the key points. (github.com)。 Yidadaa/ChatGPT-Next-Web: One-Click to deploy well-designed ChatGPT web UI on Vercel. 一键拥有你自己的 ChatGPT 网页服务。 (github.com)。 pengzhile/pandora: 潘多拉，一个让你呼吸顺畅的ChatGPT。Pandora, a ChatGPT that helps you breathe smoothly. (github.com)。 lss233/chatgpt-mirai-qq-bot: 🚀 一键部署！真正的 AI 聊天机器人！支持ChatGPT、文心一言、Bing、Bard、ChatGLM、POE，多账号，人设调教，虚拟女仆、图片渲染、语音发送 | 支持 QQ、Telegram、Discord、微信 等平台 (github.com)。 202252197/ChatGPT_JCM: OpenAI管理界面，聚合了OpenAI的所有接口进行界面操作(所有模型、图片、音频、微调、文件)等，支持Markdown格式(公式、图表，表格)等，GPT4接口官方只是在申请阶段，后期会一点一点的将OpenAI接口进行接入大家支持一下，微信群号在下方，右上角点个Star，我会一直更新下去，大家一起学习，一起加油，一起努力，一起成长。 (github.com)。 ztjhz/BetterChatGPT: An amazing UI for OpenAI’s ChatGPT (Website + Windows + MacOS + Linux) (github.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:6","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"ChatGPT 插件 / 妙用 xcanwin/KeepChatGPT: 这是一个ChatGPT的畅聊与增强插件。开源免费。不仅能解决所有报错不再刷新，还有保持活跃、取消审计、克隆对话、净化首页、展示大屏、展示全屏、言无不尽、拦截跟踪、日新月异等多个高级功能。让我们的AI体验无比顺畅、丝滑、高效、简洁。 (github.com)。 ChatGPT 有什么新奇的使用方式？ - 知乎 (zhihu.com)。 用 ChatGPT 将 Excel 工作效率提高 10 倍！ (qq.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:2:7","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"提示词工程 引自 吴恩达给五一假期贡献了Prompt教程 (qq.com)。 熟练掌握 Prompt 编写的人，能够很快让 ChatGPT 理解需求，并很好的执行任务。只要你的 Prompt 写的足够好，ChatGPT 可以帮你快速完成很多工作，包括写爬虫脚本、金融数据分析、文案润色与翻译等等，并且这些工作还做的比一般人出色。 在上面 GPT 综合性合集 一节里面 也列举了一些 提示词 教程。 提示工程 - 维基百科，自由的百科全书 (wikipedia.org)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"ChatGPT-Shortcut 该项目整理并汇总了多种让生产力加倍的 ChatGPT 快捷指令，按照领域和功能分区，可对提示词（Prompt）进行标签筛选、关键词搜索和一键复制。 相关文章：5 个令人惊艳的 ChatGPT 项目，开源了！ (qq.com)。 Github 仓库：rockbenben/ChatGPT-Shortcut: Maximize your efficiency and productivity. 让生产力加倍的 ChatGPT 快捷指令，按照领域和功能分区，可对提示词进行标签筛选、关键词搜索和一键复制。 (github.com)。 即用网页：ChatGPT Shortcut - 简单易用的 ChatGPT 快捷指令表，让生产力倍增！标签筛选、关键词搜索和一键复制 Prompts | Tag filtering, keyword search, and one-click copy prompts (aishort.top)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:1","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"awesome-chatgpt-prompts Github 仓库：f/awesome-chatgpt-prompts: This repo includes ChatGPT prompt curation to use ChatGPT better. (github.com)。 网页：Awesome ChatGPT Prompts | This repo includes ChatGPT prompt curation to use ChatGPT better.。 一个对 这个 仓库的 中文梳理：ChatGPT | LearnData-开源笔记 (newzone.top)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:2","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"awesome-chatgpt-prompts-zh Github 仓库：PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。 (github.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:3","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"img-prompt - 图像生成提示词 极简的图像提示词编辑器，专注于提示词文本组合，可用于Stable Diffusion和Midjourney。 Github 仓库：rockbenben/img-prompt: 极简的图像提示词编辑器，专注于提示词文本组合，可用于Stable Diffusion和Midjourney。 (github.com)。 即用网页：IMGPrompt (newzone.top)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:4","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"《Prompt 编写模式》开源书 Github 仓库：prompt-engineering/prompt-patterns: Prompt 编写模式：如何将思维框架赋予机器，以设计模式的形式来思考 prompt (github.com)。 即用网页，书直接看：Prompt 编写模式：如何将思维框架赋予机器 | prompt-patterns (phodal.com)。 更多内容 Prompt Engineering（瑞书工程） (github.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:5","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"《ChatGPT Prompt Engineering for Developers》开源课 引言笔记 吴恩达ChatGPT Prompt Engineering for Developers课程学习笔记 (qq.com)。 一些笔记 吴恩达老师ChatGPT提示工程课程笔记 (qq.com)。 原版视频，哔哩哔哩 可直接看 GitHubDaily的个人空间 - ChatGPT提示 _ 哔哩哔哩 _ bilibili。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:6","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"OpenAI 官网教程 https://platform.openai.com/docs/guides/completion。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:7","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"GPT 生成网文 ChatGPT最实用的提示（Prompts）写法有哪些？ - 知乎 (zhihu.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:8","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"GPT 充当角色 chatgpt的150个指令大全_cxscode的博客-CSDN博客。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:9","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"GPT 在教学中使用 / 安排计划 / 给建议 OpenAI 首次发布 ChatGPT 课堂使用指南，生成式 AI 进入课堂后会带来哪些改变？ - 知乎 (zhihu.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:3:10","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"AI 相关工具集 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"！！！合集！！！ AIChannel官方的个人空间_ 哔哩哔哩 _bilibili，AIChannel中国绊爱的个人空间_ 哔哩哔哩 _bilibili。误 AI工具-哔哩哔哩_Bilibili，AIGC工具-哔哩哔哩_Bilibili。 在我忘记之前 - 知乎 (zhihu.com)。 产品君的个人空间-AI生产力系列_ 哔哩哔哩 _bilibili。 Github高赞开源项目速览-AIGC的N种玩法-20230808_哔哩哔哩_bilibili，直接看简介。 Mega会玩的个人空间_哔哩哔哩_bilibili。 AI_Fox的个人空间_哔哩哔哩_bilibili。 即时灵感的个人空间-即时灵感个人主页-哔哩哔哩视频 (bilibili.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:1","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"！！！AI工具箱软件！！！ Baiyuetribe/paper2gui: Convert AI papers to GUI，Make it easy and convenient for everyone to use artificial intelligence technology。让每个人都简单方便的使用前沿人工智能技术 (github.com)。 小白兔AI - 人工智能工具箱软件 (xiaobaituai.com)，要钱的，不过可以试用 14 天，功能还算丰富。 AI工具箱来啦，AI绘画、VITS文本转语音，唇型同步，视频修复_哔哩哔哩_bilibili。 .etc ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:2","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"“图灵测试” Character.AI 这里是放 AI 聊天 相关的工具软件、经验用法等。 Character.AI 首周下载量碾压 ChatGPT，这一应用有哪些特点？将会带来哪些影响？ - 知乎 (zhihu.com)。 Character.AI 由谷歌 LaMDA 的前开发人员 Noam Shazeer 和 Daniel De Freitas 开发，最早的测试版于 2022 年 9 月开放。 在 Character.AI 中，用户可以创建「角色」，塑造他们的「个性」，设置特定参数，然后发布到社区供其他人聊天。这些角色可以基于虚构的名人，也可以是完全是原创的；这些角色可以为了特定的目标而制作——例如协助创意写作或成为基于文本的冒险游戏。 在交互形态上，用户既可以与单个角色联系，也可以组织包含多个角色的群聊；同时，这些角色也可以与单个/多个用户交谈。 ChatGPT 并不是万能的，你要像对待一个「知识全能而经验全无的员工」一样对待他。**他并不知道你的工作背景、实际需求，你千万不要直接扔给他一个标题就完事，否则大概率得不到什么太好的结果。**你可以像给实习生布置工作一样，告诉他背景，告诉他提纲，告诉他要点，甚至给他几个示例，然后，相信他会给出你更完美的答案。 基于大语言模型能力和情感陪伴需求，不难想象出角色扮演类产品的工作流其实是这样的：找到一个固定的 prompt 或技术手段，喂给 AI 故事背景，洗脑 AI 来扮演一个特定的角色。既可以预设一些批量生成的故事，也可以由用户来自定义生成。 .etc ZeroGPT ZeroGPT - Accurate Chat GPT, GPT4 \u0026 AI Text Detector Tool Detect OpenAI text: The most Advanced and Reliable Chat GPT and GPT-4 detector tool. Easy and fully comprehensive detection solution. UnrealPerson This Person does not exist - Unreal Person created by AI Free The most advanced AI image generator for Human, Cat, Horse and Art. With UnrealPerson, generate Fake images with AI that looks 100% real but they don’t exist in reality! ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:3","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"AI 全链路 / 助理类 AutoGPT - AI 全链路 相关文章： 近期最火的GPT神器：AutoGPT，你知道多少 (baidu.com)。 AutoGPT怎么使用 AutoGPT使用教程一览 - QT软件园 (qtvcd.com)。 Github 仓库： Significant-Gravitas/Auto-GPT: An experimental open-source attempt to make GPT-4 fully autonomous. (github.com)。 RealHossie/Auto-GPT-Chinese: AutoGPT真中文版 (github.com)。 部署相关： Dogtiti/AutoGPT-Next-Web: 🤖 Assemble, configure, and deploy autonomous AI Agents in your browser.一键免费部署你的私人AutoGPT 网页应用 (github.com)。 thecookingsenpai/autogpt-gui: A graphical user interface for AutoGPT (github.com)。 AgentGPT 相关文章：AI杀疯了 | 自动帮你分解任务AgentGPT - 知乎 (zhihu.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:4","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"开发相关 / GPT 衍生工具 学术优化 binary-husky/gpt_academic 为GPT/GLM提供图形交互界面，特别优化论文阅读润色体验，模块化设计支持自定义快捷按钮\u0026函数插件，支持代码块表格显示，Tex公式双显示，新增Python和C++项目剖析\u0026自译解功能，PDF/LaTex论文翻译\u0026总结功能，支持并行问询多种LLM模型，支持清华chatglm等本地模型。 功能 描述 一键润色 支持一键润色、一键查找论文语法错误 一键中英互译 一键中英互译 一键代码解释 可以正确显示代码、解释代码 自定义快捷键 支持自定义快捷键 配詈代理服务器 支持配置代理服务器 模块化设计 支持自定义高阶的实验性功能 自我程序剖析 ［实验性功能］ 一键读懂本项目的源代码 程序剖析 ［实验性功能］ —键可以剖析其他Python/C+＋项目 读论文 ［实验性功能］ —键解读latex论文全文并生成摘要 批量注释生成 ［实验性功能］ —键批量生成函数注释 chat分析报告生成 ［实验性功能］运行后自动生成总结汇报 公式显示 可以同时显示公式的tex形式和渲染形式 图片显示 可以在markdown中显示图片 支持GPT输出的markdown表格 可以输出支持GPT的markdown表格 相关文章：学术科研专用ChatGPT来了！Github上已斩获2.9w+ Star (qq.com)。 Github 仓库：binary-husky/gpt_academic: 为GPT/GLM提供图形交互界面，特别优化论文阅读润色体验，模块化设计支持自定义快捷按钮\u0026函数插件，支持代码块表格显示，Tex公式双显示，新增Python和C++项目剖析\u0026自译解功能，PDF/LaTex论文翻译\u0026总结功能，支持并行问询多种LLM模型，支持清华chatglm等本地模型 (github.com)。 kaixindelele/ChatPaper ChatPaper全流程加速科研：论文阅读+润色+优缺点分析与改进建议+审稿回复。 工具名称 工具作用 ChatPaper 通过ChatGPT实现对论文进行总结，帮助科研人进行论文初筛 ChatReviewer 利用ChatGPT对论文进行优缺点分析，提出改进建议 ChatImprovement 利用ChatGPT对论文初稿进行润色、翻译等 ChatResponse 利用ChatGPT对审稿人的提问进行回复 ChatGenTitle 利用百万arXiv论文元信息训练出来的论文题目生成模型，根据论文摘要生成合适题目 视频教程：ChatPaper网页版使用小白教程_哔哩哔哩_bilibili。 官网：ChatPaper。 Github 仓库：kaixindelele/ChatPaper: Use ChatGPT to summarize the arXiv papers. 全流程加速科研，利用chatgpt进行论文总结+润色+审稿+审稿回复 (github.com)。 AI 帮你看 首先，直接给 GPT 聊天框 投喂 要 AI 来帮你看 和 总结 的文本，并让 他 根据你的需要输出，其次，下面列举一些 专用的 GPT 衍生的 AI 帮你看东西的 工具。 BloopAI/bloop - AI 读代码 自然语言搜索非常适合探索不熟悉的代码库。它可以定位代码、总结、解释、推理，甚至提出改进建议。 相关文章：一个基于 GPT-4 的代码搜索引擎，开源了！ (qq.com)。 Github 仓库：BloopAI/bloop: bloop is a fast code search engine written in Rust. (github.com)。 peterw/Chat…Repo - AI 读 GitHub 仓库 相关文章：3 个令人惊艳的 ChatGPT 项目，开源了！ (qq.com)。 Github 仓库：peterw/Chat-with-Github-Repo: This repository contains two Python scripts that demonstrate how to create a chatbot using Streamlit, OpenAI GPT-3.5-turbo, and Activeloop’s Deep Lake.。 bhaskatripathi/pdfGPT - AI 看PDF 相关文章：最近爆火的一款 PDF 神器！ (qq.com)。 Github 仓库：bhaskatripathi/pdfGPT: PDF GPT allows you to chat with the contents of your PDF file by using GPT capabilities. The only open source solution to turn your pdf files in a chatbot! (github.com)。 AI 帮你码 首先，用好提示词生成代码，即自己亲自与 ChatGPT 结对开发，用好、用对 提示词 让 ChatGPT 处于 “编程” 模式 去输出代码，快速做原型开发。 提示词相关教程 见下文 提示词工程 一节。 一个使用例子：程序员如何利用 AI 将自己的工作完全自动化？ - 知乎 (zhihu.com)。 getcursor/cursor 相关文章：首个接入 GPT-4，曾经比 GitHub Copilot 还好用的代码编辑器，开源了！ (qq.com)。 Github 仓库：getcursor/cursor: An editor made for programming with AI 🤖 (github.com)。 GitHub Copilot X 相关文章：动动嘴，就能帮你生成代码！焕然一新的代码编辑器：GitHub Copilot X，来了！ (qq.com)。 Copilot Voice 相关文章：集成 GPT-4，动动嘴就能上线一个网站，这个工具强的离谱！ (qq.com)。 Codex 相关文章：支持文字和语音指令，AI实时自动编程，OpenAI升级版Codex面世了 (baidu.com)。 CodeWhisperer 体验了一把最新的AI自动编程工具，我失眠了_哔哩哔哩_bilibili。 codegeex 可以离线版。 Codeium - 网站代码 输入简单描述，自动为你写出一个网站的代码。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:5","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"日常相关 / 文案相关 Tome - PPT Tome，一个集合GPT3和Dalle2的PPT平台。 优点： 1. 支持输入中文命令，输出输入都可以用中文 2. 生产的PPT实际可用 3. 支持自定义添加界面，编辑文字，上传图像视频。 缺点： 不能导出，只能在线播放。 教程： B 站搜：Tome教程-哔哩哔哩_Bilibili。 Beautiful AI - PPT Writesonic - 写作 HoppyCopy - 写邮件 Notion ai - 笔记 十秒内做个表格，自动填充数据；快速写篇博文、会议日程、新闻稿、职位描述，做个优劣势分析……帮你头脑风暴、写大纲、做菜谱，带你学东西…… 教程： B 站搜：Notion ai-哔哩哔哩_Bilibili。 Rezi - 简历 Writesonic - 文案 输入描述，自动为你生成你想要的策划文案。 Writesonic-哔哩哔哩_Bilibili。 Copy.ai - 写作 这款AI写作工具非常适合各种类型的营销人员，无论是电子邮件、产品描述、标题、按钮文案还是广告，只需要选择所需的内容，提供一些输入数据，并选择合适的语气，AI将会为你生成多个不同版本的文案，让你挑选最符合你需求的一种。 官网 Free AI Writing Generators \u0026 Tools | No Login Required (copy.ai)。 其它更多情报 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:6","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"绘画/图片相关 在 上面 提示词工程 一节 也有 AI 图像生成相关的 提示词教程。 awesome-ai-painting 相关资料合集 hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform (github.com)。 即用网页：数字绘画 (notion.so)，集合了平台、教程等。 AI绘画从入门到精通-【AI绘画】教程-deepfacelab中文网 - Powered by Discuz! (dfldata.cc)。 Midjourney 教程： 🧭 Midjourney 学习导航 | Learning Prompt。 Midjourney提示词集合 - 知乎 (zhihu.com)。 直接 学习网站——B 站搜：Midjourney教程-哔哩哔哩_Bilibili。 .etc 官网：Midjourney。 diffusion 相关文章： 咳咳 确认了，全网的福利姬，都将彻底凉凉|图源_手机网易网 (163.com)。 教程： 零基础入门 Stable Diffusion - 无需显卡把 AI 绘画引擎搬进家用电脑 | LearnData-开源笔记 (newzone.top)。 喂饭级stable_diffusion_webUI调参权威指南 - 知乎 (zhihu.com)。 直接 学习网站——B 站搜：diffusion教程-哔哩哔哩_Bilibili。 .etc 开源模型网站：civitai.com。 DragGAN 相关视频演示： AI可控精准修图，AIGC新里程碑｜妈妈问我为什么跪着看视频！_哔哩哔哩_bilibili。 【DragGAN】单张照片生成多角度高精度图像_哔哩哔哩_bilibili。 官网介绍页面：Drag Your GAN: Interactive Point-based Manipulation on the Generative Image Manifold (mpg.de)。 Github 仓库：XingangPan/DragGAN: Code for DragGAN (SIGGRAPH 2023) (github.com)。 Dragon Diffusion 北大兔展联合实验室提出 Dragon Diffusion，可一键拖拽编辑图像，效果如何？ - 知乎 (zhihu.com)。 文生 3D 无需任何 3D 数据，直接文本生成高质量 3D 内容，清华朱军团队带来重大进展，将带来哪些影响？ - 知乎 (zhihu.com)。 文心一格 文心一格 - AI艺术和创意辅助平台 (baidu.com)。 Visual ChatGPT 不愧是微软，短短 5 天，项目突破 18000 GitHub Star！ (qq.com)。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:7","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"设计相关 Looka - 图标设计 输入指令，为你生成从图标到VI品牌的整套设计 Fliki - 文字转视频 / 生成视频素材 输入文案、图片等素材自动帮你生成视频。 通过AI技术，视频的生成和编辑已经变得更加容易和高效，AI可以通过深度学习和自然语言处理等技术来识别并理解视频中的元素，并根据用户的需求生成符合预期的视频内容。在这个领域，Fliki是一个非常出色的AI视频生成工具，它结合了最先进的技术，为用户提供了高质量的视频生成和编辑体验。 这是一款利用人工智能技术将文本转换为自然语音的视频应用。用户可以输入任何文本，然后选择所需的语音风格和声音特点，AI将生成一个高质量的语音视频。这种AI语音视频应用可以用于各种场景，如教育、广告、宣传等，让内容更加生动有趣，提高用户体验和吸引力。 Fliki-哔哩哔哩_Bilibili。 Artflow AI - 动画生成 创建角色、输入文案后即可生成动画视频。 FakeYou - 文字转语音 / 配音 利用人工智能技术，可以将文字内容转换成名人语音，使得文字和语音之间的转化变得更加简单和高效。用户可以轻松地将自己的文字内容转换成名人的语音风格，增加内容的趣味性和吸引力。此外，这种技术还可以用于制作语音包、广告语音等多种场景，为用户带来更加便捷和有趣的体验。 深度伪造技术FAKE YOU - 知乎 (zhihu.com)。 官网 FakeYou. Deep Fake Text to Speech.。 Uberduck - 配音 Uberduck.AI: 在线AI文字转语音合成配音平台 – 网络探索者 (nettsz.com)。 官网 Uberduck | Make Music With AI Voices。 MusicGenerate - 音乐 文本生成音乐，免费。 Music Generate - best Free AI tool to generate music using text Jukebox - 音乐 这是一款OpenAI推出的AI音乐生成器，可以生成不同风格和流派的歌曲和音乐。 官网 Jukebox (openai.com)。 Interior AI - 室内设计 super-resolution - 超分辨率 / 图像增强 超分辨率工具-哔哩哔哩_Bilibili。 放大 / 高清修复 Stable Diffusion最好用的高清修复插件 - 知乎 (zhihu.com)。 Topaz Video Enhance AI 收费，可试用 官网：Topaz Video AI (topazlabs.com)。 相关文章：AI视频超分工具，720P视频一键转8K！ - 知乎 (zhihu.com)。 用AI把24帧动画补到超清60帧，突破次元壁！丝滑流畅……_哔哩哔哩_bilibili。 下载，咳咳，那个…用磁力搜索能找到一些版本，比如 “Topaz Video Enhance AI 2.6.4 RePack (\u0026 Portable) by TryRooM”。 关于使用： Topaz Video Enhance AI 软件里面 右边，两个栏，是选择模板 或者自己调， 如果多个模板都不理想，那么 自己调里面有 fine tun ，这个是参数精细调整，下面有几个参数可以调整 有增加细节、棱角分明、减噪声等等。 关于转移放置模型的目录： 默认是放在 C:\\Users\\staok\\AppData\\Roaming\\Topaz Labs LLC\\Video Enhance AI\\models 可以在软件界面file-\u003emodel manage 里面 选择存放model的目录，可以放到其他盘，确定之后会自动转移。 Waifu2x-Extension-GUI 软件开源免费。 Waifu2x-Extension-GUI: 图片, GIF 和 视频 放大与降噪(超分辨率)及视频补帧(插帧)程序 集成了 Waifu2x, SRMD, RealSR, Anime4K, Real-ESRGAN, Real-CUGAN, RIFE, RTX Super Resolution, IFRNet, CAIN, DAIN 和 ACNet. (gitee.com)。 使用体验：可以对 动漫 和 实景视频 进行 画面放大、降噪和补帧，软件可以直接选择预设，这个比较方便，上面菜单栏主页的下一列是调整各个算法；经过多次实验，直接用预设里面的选择之后导出，这个一般就是最好的效果了，比手动选择用哪个算法方便而且效果可以。 注意：添加安装目录为杀毒软件信任区，或者关闭杀毒软件。 Anime4kCCP 相关文章：Anime4KCPP 一款开源的高性能动漫类图像与视频超分辨率工具 - 发现频道 🔎 - 小众软件官方论坛 (appinn.net)。 Github 仓库：TianZerL/Anime4KCPP: A high performance anime upscaler (github.com)。 说明： Anime4kCCP速度特别快, 修复效果不如waifu2x, 适合画质已经不错但是分辨率低的动漫. 而且效果比原版Anime4k好. 我那个waifu2x-extension-GUI比这个多了 处理GIF 和 视频的音频降噪 , 俩都能处理图片和视频. 而且waifu2x-extension-GUI里面同时集成了多个版本的waifu2x和Anime4kCCP. waifu2x修复能力强, 但是速度慢, 适合画质不咋地的动漫. 比如说, 你有个画质不错的720p动漫, 但是你有个4k屏, 那么你就可以直接用anime4k把它拉到4k, 不需要用速度慢的waifu2x 如果你有个画质不咋地的480p动漫或者老照片老电影, 那么你就需要waifu2x来修复画质然后拉到高分辨率. 因为waifu2x慢主要就是因为他集成了人工智能降噪的功能, 拉伸并不是很费时间, 而anime4k就是单纯的拉伸和套滤镜, 所以快. 如果你用了waifu2x就没必要用anime4k, 如果用了anime4k拉伸后再降噪, 也不会给你节省任何时间. Aimages 一款基于AI技术的视频增强工具，可以不用下载新软件，在线实现视频的清晰度提升、色彩校正和去噪等多种增强效果。 这是一款基于AI技术的视频增强工具，可以不用下载新软件，在线实现视频的清晰度提升、色彩校正和去噪等多种增强效果。通过对视频进行智能分析和处理，提高观看体验，同时也提高了视频的质量和可视化效果。 Aimages - Online AI Video Enhancer。 Remove.bg - 抠图 Remove.bg-哔哩哔哩_Bilibili。 3个好用的在线抠图工具：Remove.bg，Adobe Remove Background，佐糖PicWish!_哔哩哔哩_bilibili。 抠图适应与 产品抠图，人物发丝等等，跨境电商，运营必备的神仙网站及应用： 🌈 remove bg https://www.remove.bg。 🌈 Adobe Remove Background https://express.adobe.com/tools/remove-background。 🌈 佐糖PicWish https://picwish.com。 AI 图片补全 - 合 女神被打码了？一笔一划脑补回来，效果超越Adobe | 已开源 - 知乎 (zhihu.com)。 AI 调色 / 上色 - 合 Palette.fm - 调色 / 黑白图上色 Palette.fm-哔哩哔哩_Bilibili。 官网 Palette - Colorize Photos。 GitHub上万星：超精细的漫画上色AI，老婆画风任你选择，登上了趋势榜 - 知乎 (zhihu.com)。 AutoDraw - 绘图 / 线条设计图 Autodraw-哔哩哔哩_Bilibili。 官网 AutoDraw。 deep-fake DeepFaceLive： iperov/DeepFaceLive: Real-time face swap for PC streaming or video calls (github.com)。 【教程汇总】DFL从入门到精通（持续更新）-【DFL】精品教程-deepfacelab中文网 - Powered by Discuz! (dfldata.cc)。 DeepFake： 入门教程 – DeepFake中文网 (deepfaker.xyz)。 主要软件： DeepFaceLab（推）。 Faceswap（适合研究）。 OpenFaceSwap（界面友好，比较老了）。 Fakeapp，Myfakeapp（界面友好，功能单一，比较老了）。 DeepFakes | AI换脸 | 直播换脸 | 软件下载 – DeepFake中文网 (deepfaker.xyz)。 目前Deepfacelab和faceswap都自带依赖，Fakeapp和openface已经停更根据，依旧需要自己安装依赖。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:8","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"视频生成/连续多帧动画 DALL·E 生成现实影像 / 案例 AI 生成多帧画面组成 动画、视频 单独放在这里，是想，虽然现在 AI 生成连续画面 还比较 “抽象”，但 AI 进步很快，记录一下进化历程，说不定之后连视频也能以假乱真了~估计这个进步很快，越往后的质量越好~~ 截至 23.6 的相关成品： 【AI生成】成龙吃饼干_哔哩哔哩_bilibili。 ai生成的狗粮广告_哔哩哔哩_bilibili。 欢迎来到AI时代嘉年华！未来与复古的碰撞_哔哩哔哩_bilibili。 AI生成的口香糖广告_哔哩哔哩_bilibili。 “亡灵鸡块\"💀 由AI生成的广告片_哔哩哔哩_bilibili。 【AI生成】鸡 你 太 美_哔哩哔哩_bilibili。 AI生成的逃离魔爪后开心吃竹子的大熊猫丫丫_哔哩哔哩_bilibili。 相关报道： 国外公司全程用AI制作电影，时长12分钟，人物可以眨眼和张嘴 - 知乎 (zhihu.com)。 《霜》背后的创作公司名为 Waymark，是一家来自美国底特律的公司。该公司的斯蒂芬·帕克（Stephen Parker）说：“似乎到了一个地步，我们不再追求和渴望摄影的准确性，而是开始倾向于探索 DALL-E 的怪异。”。 截至 xx.x 的相关成品： 未完待续… 生成动画 / 案例 AnimatedDrawings：又一款 AI 应用开源了，让你的绘画作品动起来！ (qq.com)。 AI 生成 动画/视频 的 实例 和 工具列举： 【水蛭】耗时7天！我用人工智能生成了全篇《桃花源记》！_哔哩哔哩_bilibili。 【水蛭】质量爆炸！我用AI完全生成了一个《蝙蝠侠》电影！_哔哩哔哩_bilibili。 此视频由OpenAI、Stable Diffusion、Yuan初，UberDuck 共同完成。 【水蛭】我在AI的帮助下，20小时完成了这个阿凡达动画！_哔哩哔哩_bilibili。 用到的人工智能有: stable diffusion, NVIDIA Omniverse, NVIDIA Canvas, Photoshop Neural Filters(不是), Point-E demo (删除，括弧也要删除) 。 【水蛭】我用百度的AI生成了一首关于文心一言的歌+MV！_哔哩哔哩_bilibili。 此视频由百度文心大模型，文心一格，AIVA，SynthesizerV，stable diffusion共同完成。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:4:9","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"大语言模型汇总表 目前大语言模型技术综述： 最新大语言模型综述：T5到GPT-4最全盘点，20余位研究者联合撰写 (baidu.com)。大语言模型综述 - 知乎 (zhihu.com)。 必看！大语言模型调研汇总！！_人工智能与算法学习的博客-CSDN博客。 目前各大语言模型汇总表： 最近的大语言模型汇总 (baidu.com)。 NLP领域大语言模型汇总_syfly2014的博客-CSDN博客。 盘点超三十款国产类ChatGPT大语言模型，你最期待哪个？|模态|大模型|人工智能_网易订阅 (163.com)。 开源大语言模型(LLM)汇总（持续更新中） (dtmao.cc)。 公司 名称 相关 OpenAI ChatGPT，以及 GPT 后续版本 阿里 通义 通义千问 (aliyun.com)。 百度 文心 文心一言 (baidu.com)。 文心百中 — 大模型驱动的产业级搜索系统 (baidu.com)。 文心一格 - AI艺术和创意辅助平台 (baidu.com)。 华为 盘古 腾讯 混元 昆仑万维 天工 天工官网 (singularity-ai.com)。 商汤 日日新 知乎 知海图 毫末智行 雪湖·海若 科大讯飞 1+N认知智能大模型 等等等 北大ChatExcel 酷表ChatExcel。 复旦MOSS MOSS (txsun1997.github.io)。 MiniGPT-4 Minigpt-4。 StableLM Stable Diffusion 母公司开源大语言模型，代号「StableLM」！ (qq.com)。 Claude https://www.anthropic.com/index/introducing-claude。 BARD BARD AI。 TruthGPT TruthGPT。 .etc ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:5:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"AIGC 搞笑使用 / 惊人使用 / 变现相关 回顾初遇 ChatGPT / AIGC 人们的种种反应，各种搞笑对话，脑洞打开的使用方法！ 你用 ChatGPT 生成过哪些有趣的回答？ - 知乎 (zhihu.com)。 你见过最离谱的Midjourney生成图片是哪张？ - 知乎 (zhihu.com)。 我花了几百块买ChatGPT赚钱课，结果卖课的摊牌了【差评君】_哔哩哔哩_bilibili。 有使用ChatGPT+剪影流水线做“爆款”视频新号一个星期十个视频播放百万（艹，这种东西还很有人看）： 引用 流程，侵删 1、输入指令，让gpt整理50个爆款标题。 2、然后让gpt，根据这些爆款标题，直接生成新的标题。 3、接下来，用这些新标题，让gpt，以第一人称，口语化的方式，去写脚本。 记得规定好字数，和框架。写出来的脚本基本就够用了。 4、直接把脚本文案导入“剪映”，选择图文成片。 5、粘贴脚本、然后把提前拍好的视频片段导入进去，根据脚本完成剪辑。 6、最后，选择文本朗读 7、使用 智影 或者 Easy元宇宙 添加数字人播报 ChatGPT 官网 App 使用，苹果手机，需要科学上网： 要在手机APP上使用ChatGPT及其Plus会员服务，需要注意以下条件和步骤： 必备条件： iPhone设备的版本需要为16.1或更高。 确保PC端和移动端能自由访问全球网络。 需要拥有一个美区Apple ID，可以参考网上的教程来获取。 需要一个海外手机号，可以通过淘宝等途径获取。 准备20美元的费用。 操作步骤： 使用美区Apple ID登录App Store，并下载ChatGPT App。 下载后，使用Apple ID登录，登录过程的最后一步需要使用海外手机号接收验证码。完成这些步骤后，就可以开始聊天了。 如果你想购买Plus会员： 需要将支付宝切换到国外，然后购买App Store的充值卡，费用是20美元。 之后回到ChatGPT App进行会员服务购买。如果你一次购买成功，恭喜你可以开始享用GPT-4了。 如果遇到购买不成功的情况，可能是因为触发了Apple的风控策略，此时你需要在PC端登录支持平台联系客服。 注意：以上步骤（除了支付宝购买充值卡）均需要在能自由访问全球网络的前提下进行。 p.s.以上内容由Chat GPT-4修改优化。 ","date":"2023-05-03","objectID":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/:6:0","tags":["软件"],"title":"（大集合）AI工具和用法汇总","uri":"/28ai%E5%B7%A5%E5%85%B7%E5%92%8C%E7%94%A8%E6%B3%95%E6%B1%87%E6%80%BB/"},{"categories":["人与世人的关系"],"content":"有关教育的理性讨论和批判的收集啊~","date":"2022-03-06","objectID":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/","tags":["杂谈"],"title":"有关教育的理性讨论和批判的收集","uri":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/"},{"categories":["人与世人的关系"],"content":"有关教育的理性讨论和批判的收集 阳谋： 如何看待周鸿祎称「打工是用老板的钱给自己交学费，在公司混日子是浪费生命」？ - 知乎 (zhihu.com)。 【杂谈】给本科实验室的分享PPT-21.7.23 - 欢迎来到 Staok - 瞰百易 (github.io)。 ","date":"2022-03-06","objectID":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/:0:0","tags":["杂谈"],"title":"有关教育的理性讨论和批判的收集","uri":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/"},{"categories":["人与世人的关系"],"content":"自己写的关于兴趣、教育的一点东西（大多引自我的知乎） 引用一个高赞评“应试教育的致命弱点就是让人丧失学习兴趣。而现代社会的对人的要求就是需要终身学习。” 所以当《罗辑思维》的罗胖提出“终身学习”、“爱智求真”，网上骂声一片，貌似可以有一个解释了。更多引用：引用一个高赞评“应试教育的致命弱点就是… - 知乎 (zhihu.com)。（2022-03-07） 没有难学的知识，而是良莠不齐的教材乱花渐欲迷人眼，深表同意，多少人一开始抱着看看试试的心态要开始学点东西但是被各种“当做入门用的复习书”和“碎片化泛滥”的信息碾压躺的平平整整，若编教材的人恶习遗毒难改，难以形成循序渐进、旁引博证、节点网络化、准确而完善，就可恨。更多引用：没有难学的知识，而是良莠不齐的教材乱花… - 知乎 (zhihu.com)。（2022-03-12） 我在一旁，这里上着本科stm32课，老师讲的慢慢悠悠自言自语实在太催眠了，下面学生也细细碎碎自己的，我听着音乐做着事都快被这个氛围整睡着了。 什么天祥有个十天入门51，那么整个10天入门32完全可以。 我们真的是，非常容易将本来有趣的东西整的无聊和痛苦，无论是学习还是实践，以人为本这些年不怎么提了，都知道这很虚对吧。 没有学会这种事情，不是没找到好的教程，就是没有遇到对的人给你力挽狂澜般的梳理。 所以他们被动的，大把时间浪费掉了。（注：这种高效努力、目标明确、不要粗糙的过活等这种观点，在我的各处文字都会一致性的体现，包括“二项玻”、“阶段性总结”和“初心与用心”等等）（2022-05-03） 很纠结说但不得不提出一点 如果我写一本教材不是让人觉得有趣、实用，以至于觉得很牛b、当好书收藏着，而是让人们云里雾里以至于害怕、谈书色变、用完就卖，我是很失落的 一直在进步的，就是光明的 至于我会怎么写，可以看我所写的第一个文章【简明自控】为什么特征方程如此重要，以及这篇【未来的动力】BLDC的六步法\u0026PMSM…，和这个【手撕运放】运放的“第一原理”式定量分析…。这几篇都属于我自拟的“直达本质入门”系列 这些的反馈很不错，证明了这种思路，符合一个正常人的认知历程，且有趣、实用 如果有机会正式编撰，或许我能写得更好 即，从底层（意义）出发，也从熟悉的认知出发，会更好（2022-12-31） 为什么我会感觉中国大学教材很烂？ - 知乎 (zhihu.com)。 理论培养不耽误与实际联系[爱]。 【【睡前消息514】给05后观众回信：羡慕… - 知乎 (zhihu.com)。 茫然与自由的话题 【【睡前消息514】给05后观众回信：羡慕你的茫然与自由-哔哩哔哩】 链接。 对于初中生来说可能“道理都懂”，对于本科生、研究生中显著占比的人群来说刚刚好~ 文中初中生的小文章让我想起了我初中也写过类似的好多文字，甚至作文里面出现过“万子争校，亿子同道”之流的词句，很多，也对于考试迷茫，代价是在很长一段时间都不擅长考试，而很擅长在课余自学、搞软硬件设计、参加比赛拿奖等等（但是找工作会卡学历，我本科双非/硕士985，多年前考试的那一瞬的成绩竟能影响到能力更强的现在的我mmp）。 马督公说到“迷茫”和“应试教育”的部分我是不完全认同的。 关于迷茫，虽说是还有选择的自由，感性上是这样，督工那个年代的自由或许不比现在才这样想，但是理性上迷茫会带来微妙的代价，时机上的、顿悟上的，应通过“靠近牛人、做难得事、提前规划”避免过多的迷茫或者叫迷失。参考 【杂谈】给本科实验室的分享PPT。 关于应试教育，这是基本制度，由此带来的督公说的卷出很多无用的应试技巧，这是一部分弊病，但是这种内容实用化改变对于改革只是边角，因为筛选要发挥作用同时人太多的基本国情长期存在，这时候应该拿出“第一原理”，分析本质反推措施，教育的本质是“发掘潜力和培养兴趣”，有了这样的原动力，学习者会自发学习，因此改革主力包括教育一线教学模式的改变，是提升知识技能传递的效率，而不是流水线培养半吊子（当然，现在的普通本科差不多就相当于上世纪的中专/高职之流，大学四年当一个空气混混僵僵贴着底线毕业，现在当然毕业就是空气，大学四年卷学习、科研、竞赛、能力，再看看？是吧~）。 只要理性批判教育的，我们就都是同志 - 知乎 (zhihu.com)。 只要理性批判教育的，我们就都是同志。两个必然的趋势：1、知识爆炸，2、产业往高精尖转型必然使得高技术含量工作需求越来越大，因此教育，或者叫知识的传递的质量和效率，也必然需要新方法、新思路，教育也需要“工业革命”式创新革命，否则，往大了说到底，人类的科技就是这么被放缓甚至自我锁死的。（这也是我的科幻小说《请留在未来》里面核心“科幻点”之一，巨大的传统教育观念惯性很难升级，所以这很“科幻”） 请问中国式教育有多悲哀? 教育工厂模式确… - 知乎 (zhihu.com)。 请问中国式教育有多悲哀? 教育工厂模式确实比兴趣教育模式让大多数平凡的人感到公平而感恩戴德，正好人口基数大让这种模式培养的顶尖人才的数量不显得少，其实都赢，真心的[爱]。不过人口减少之后问题立马被摆在最前面。 为什么感觉当今一些大学生乃至中小学生不… - 知乎 (zhihu.com)。 为什么感觉当今一些大学生乃至中小学生不愿…。 为什么感觉当今一些大学生乃至中小学生不愿…。 知行合一，实事求是，这么多年政治教育，没有多少人真正入脑（就说是不是吧） 普遍客观来说，咱不空穴来风，这些本来有… - 知乎 (zhihu.com)。 普遍客观来说，咱不空穴来风，这些本来有趣的领域和科目和知识，在形式化的课堂和考试和应付式的所谓实践训练中，这些学科的培养和教育都整得很没意思，对于有强烈兴趣的人可能影响不大，但是对于大多数，就肯定什么热门去什么喽[吃瓜] 我国理工科学生比例下降，同济大学副校长称「我国人才自主培养质量有待提高」，并提出建议，如何看待此现象？。 麻匪有句话叫站着把钱挣了，我有理念叫从… - 知乎 (zhihu.com)。 麻匪有句话叫站着把钱挣了，我有理念叫从兴趣和项目角度提高教育效率，但无论是现在的素质教育还是应试教育，都不符合，现在都是流水线批量生产半吊子，应回归教育的本质和其第一原理。 另一角度，在地球上，如果说人类群体中诞生天才的概率是均匀分布的，那么每个国家按照人口比例，应该有一定比例的顶级人才，但实际各个国家的人均人才比例是大相径庭的，也就是说，有的国家不但能让一个天才从小到大一直都是天才，也能让一部分普通人努努力升级为“天才”，而也存在国家是人均人才是个洼地，也就是说一些人才会被相反的被压制或者跑了[吃瓜][吃瓜] 你支持素质教育，还是支持应试教育？。 “教师引导，学生主导，在教师的引导下，… - 知乎 (zhihu.com)。 “教师引导，学生主导，在教师的引导下，学生主动发现问题，提出问题，学生一起合作探索，解决问题”，这是最考验教师的，我认为教师首先必须一定要有个意识，就是学生脑袋瓜里先有一定的背景知识、思考逻辑和相关经验，然后才能按上面那样展开，否则，一个脑袋空空、一群没有经验的人聚在一块，你让他们讨论，能讨论出什么？你说这时候教师引导，那还不是就成了一步一步手把手教？严重的话，就适得其反，本末倒置，还不如老师主动多讲[爱]所以中心还在于教师，或者叫导师，一个优秀老师，会按照人类正常理解的逻辑思维，去引导和表达[爱]（鉴于大多数人是应试教育逆来顺受过来的，我在说什么自己感觉[害羞]） 有位老师曾说：“没有教不会的学生，只有不会教的老师。”你是如何评价这句话的？你认为如何教育学生？。 Staok 的想法: 你说的我基本赞同，因为我的985硕士生涯… - 知乎 (zhihu.com)。 有没有一种可能，咱要改变的是教学一线，不要再批量培养半吊子，是提升理论联系实际，是提高培养效率，保持住学生的独立思考、批判创新、实践等能力，跟考试形式无关，而你们这种一看见别人说教育问题就讲“啊可是考试是唯一公平的”，属于思维懒惰。 ","date":"2022-03-06","objectID":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/:1:0","tags":["杂谈"],"title":"有关教育的理性讨论和批判的收集","uri":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/"},{"categories":["人与世人的关系"],"content":"有关教育的理性讨论和批判的收集 在我想到把这些放到什么地方之前就先暂时放这里。 对教育的理性批判（个人执念）。如果你是坚定的唯物主义、实事求是者，就请不要 羞于、无视于、愤于、放弃革命于 现存的种种问题之所在。 下面，有的是批判、提出问题所在，有的还补充了初步解决方法。 —————— （中二呐喊）研究加快学习效率提升，世界属于二项玻！！！ —————— 关于具体的措施和先进经验，这是非常复杂和依赖经验的（或存在普世的方法论为所有人所用），提前说明这里只列出一些具有启发性的文字而，思考即可，我个人的目前的、浅显的、自己总结的方法论——列在上面的“Essence / 个人方法论”里面了。 下面只是罗列，还没有按照因果逻辑排放。 大思想家·一哲思一人生 (bilibili.com)。 有教无类，因材施教，仁为爱人——孔子，伟大的教育家、思想家。 让学生学习做君子，而不是做学习机器。 中国人口这么多，为什么顶端人才比不了西方？ - 知乎 (zhihu.com)，也许有人一理性批判起教育，就有人条件反射似的讲那你有比目前高考更好的措施吗（没有独立思考的典中典之问），高考是从“人口众多”等的国情出发的基本制度，而很多一线教师不断流水线培养“做题机器”，以很低的人才培养效率n年如一日的尾大不掉的循环，所以你发现问题在哪了吗？（“人口众多”这也引出前面这个链接里面文章提到的“踩踏效应”，引来两个弊端：1、运气的加成相比于能力被极大放大（公平但低效，虽然低效，但是人口基数大且经济上行时期，问题才不突出），2、对制度的腐蚀） 你觉得中国的高中生最缺少什么？ - 知乎 (zhihu.com) 引： 缺的太多太多，这里仅列出 20 条：1 缺乏试错，2 缺乏学习热情，3 缺乏创造力，4 缺乏探索，5 缺乏交流，6 缺乏多样思想，7 缺乏质疑精神，8 缺乏学习信心，9 缺乏对学习的热爱，10 缺乏对睡眠的尊重，11 缺乏对生理学的尊重，12 缺乏详略得当的学习，13 缺乏泛化能力，14 缺乏激情，16 缺乏目标，17 缺乏反抗能力，18 缺乏对自由的尊重，19 缺乏自尊，20 缺乏自由。 我们的创造力都被谁毁掉了？ - 知乎 (zhihu.com)。我们需要老师吗？ - 知乎 (zhihu.com)。 上大学到底是为了什么呢？ - 知乎 (zhihu.com)，对 《上海交通大学生存手册》 的解读。 国内本科阶段的教学是一直被高校忽略的部分 - 知乎 (zhihu.com) 引： 以业界指导教学的模式来让学生适应社会 在学校里，教师应不应该阻止学生提出表面上看似是“胡思乱想”、“愚蠢”、和“无意义”的问题？ - 知乎 (zhihu.com) 引： 真的不能再同意本问题高赞 @叶峻峣 翻译的文章，学校教育想让学生知道 迷宫 里的一条正确路线，但那些岔路对于还原地图的原貌来讲也是非常宝贵的。知道A路线足够考高分，但如果想彻底地研究和理解，就必须知道B怎么错，C处在什么样的模糊状态才行。可惜很多时候学生根本不知道B和C的存在，因为他们只要刚开始尝试，就会被拦回来。 回到提问，其实从学生的角度，比如在我那堂政治课下，老师只需要小小地提示一下。她可以在课下告诉我，“这是一个政治理论的问题，你需要学得更深入一点才能懂，现在不理解的话不用强求”。 **虽然仅靠老师来改变学校教育的弊端是不太可能的，**但是很多时候老师并不需要讲明白岔路是什么情况，告诉学生“这里有岔路”，让他们把自己的疑问标记在岔路口，有空的时候可以回来探索，就足以改变很多事。 我就非常喜欢初中和高中时的历史老师，老师会告诉我们课本的观点，也会告诉我们各种异议的存在，“虽然总体来说我们是这样评价这个事件的，但你也可以去找xxx这本书，或者你们知道同时期也发生了这些事吗…”，“这些经济的问题你们可能很难理解，虽然我说可以读xxx，但是这都快高考了，你先把结论记下来，之后慢慢看”。我觉得这就足够了。 一篇对 现代的教育体系 的 理性批判 - 知乎 (zhihu.com)。 作为学生，该怎么办？ 尽可能地多进行自学。 自学就是一个人自己学。自学不需要老师。自学的最好形式是自我导向（即基于自己选择的材料和方向）和自定进度（即基于自己的最佳学习速度）。自学使人们能够在完全符合学习的基本规律[41]的情况下自然地运用学习内驱力[42]。家庭作业[43]是非自我导向的自学例子，因此效率低下。 自定进度学习是由学生决定在多长时间内准备掌握多少材料的学习。自定进度学习通过调整学习速度来适应个人的认知需求和能力，从而极大地提高了学习效率。 自我导向学习是学生选择材料和方向（即目标）的自学。自我导向学习是非学校教育[47]成功和普及的基础。自我导向学习的效率是基于这样一个事实，从定义上讲，它受到学习内驱力[42]的强烈影响，并且几乎总是满足学习的基本规律[41]。这使得通过涌现[48]来构建高质量的知识成为可能。 知识结晶比喻 - 知乎 (zhihu.com) 引： 学校教育制度有一个强大的副作用，那就是削弱了对自主学习[1]的重视。定期且系统性的强制指导导致有效的自主发展所需的技能和兴趣萎缩。学校教育抑制学习内驱力[2]。 对学习内驱力[2]的力量和在构建连贯[3]知识中的涌现力量的无知无处不在。所有优秀的教育工作者、优秀的老师和优秀的学生都明白，自主学习具有惊人的价值。然而，为了社会的突破，我们需要让大多数人发声。学生们担心没有学校他们会变得懒惰。他们可能是对的。学校失败的原因之一是它们削弱了自我激励、自我约束，并压制了学习内驱力[2]。除非我们从小独立学习，否则自律的堕落就可能发生[4]。 叶峻峣 - 钻研人类记忆，探索复习算法。改善教育公平，践行自由学习。 Thoughts Memo - 教育技术决定教育关系，教育关系要适应教育技术的发展。 谢寅 - 科学教育搬运工(._.)。 现代的数学研究抽象到了哪种地步？ - 知乎 (zhihu.com) 好句引： 整个数学的所有分支都去欢天喜地搞公理化。 这是一个显著的里程碑。 后来者要学数学就得从他们写好的公理化的教材入手，一来就是公理假设，虽然也会给你举些例子，但是你已经不能从中获得这个概念的发展进程了，因为只有知道发展进程，你才能更好的认识问题，提出问题的动机等等。 从这开始，就损失了很多直观的东西。 再后来，就有很多人出来反对这股公理化运动，觉得这样思考问题不妥。当初伽罗华发现群论，又不是从群概念的公理化定义出发，他是从实际的问题“五次以上方程的根式解”发现高次方程的复数根具备一种对称性，这种对称性可以通过变换来体现，才去研究这些变换构成的集合，从而发现群这个东西的。 而我们学东西是反过来的，先学一堆公理化的概念，如线性空间，线性变换，群环域等，等到学了一大堆后，才发现原来可以用来证明“五次以上方程无根式解”，而不感兴趣的人早就因为前面的学习而消耗了大量的兴趣和精力，只有少数人还记得这个目标或者问题。 这就是普遍数学系本科感到数学越来越抽象，越来越无法直观理解和描述的原因。 我本人反对这种 “本末倒置” 教学方式，但不反对以这种方式进行自学和科研~这种 “反着来认知” 的 课堂教学 现象，我觉得在国内大学各个 理、工 学科普遍存在。Staok 的想法: 别996了，看了一个高一的作息表 | 每个人都那么努力的学习好几年，高端人才一定不少吧。 中科院刘益东：只见一流学者，不见一流成果 (qq.com) 好句引： 科技史和科技运行规律表明，最有利于创新的科技体制机制就是让人才、特别是让一流人才及时胜出并充分发挥作用的体制机制。 综上所述，目前国家对一流人才既有巨大需求、迫切需求，又有充足经费和科研条件，但却无法及时解决一流人才匮乏问题，陷入僵局。原因有三：一是人才评价标准僵化，把“二流人才”标准误认为是“一流人才”标准，过分崇尚国际排名，陷入“数数循环陷阱”；二是“四唯”“五唯”标准长期流行，受惠者众多，困局难破；三是缺乏高效合理的新标准、新方法，以解决一流人才甄选难题。 “是否具有创造力，是一流人才和‘三流人才’的分水岭。”此定义被学界广为接受。 一流人才不是数顶级期刊论文篇数数出来的，而是做出突破性成果、与世界一流成果一流人才公开比较比出来的。 钱学森之问：“为什么我们的学校总是培养不出杰出人才？” - 知乎 (zhihu.com)。素质教育是为了兴趣引导学习，产学研是为了教育产业化，这两个事情，就别再像把学生对丰富多彩的知识的态度搞成厌恶一样，搞的本末倒置。 真正的教育应该是什么样的？ - 知乎 (zhihu.com)，引用一些想到一块或者我同意的： 1.要告诉他们是什么，为什么，怎么做。3.文理兼修。5.学习应该是以项目为导向，推演和实践为主要形式，以小组学习为组织形式。 (为什么上了研究生发现导师永远是对的？ - 知乎 (zhihu.com) ： 我至今记得刚入学时，导师给我提过两个阶段的要求。 第一阶段是 challenge me。第二个阶段是 persuade me。 The Lesson to Unlearn (paulgraham.com)。 中国的应试教育还有改变的希望吗？ - 知乎 (zhihu.com)： 不过，教育的根本变革正在传统学校体系之外发生。它发生在那些决定让孩子进行「非学校教育」（即以自由的方式在家教育孩子，没有课程和评价）的家庭中，以及那些创办类似瑟谷学校模式的非学校教育机构的人们中。这些运动中的人们在彼此之间建立了一套新的社会规范，使他们能够克服以看似异常的方式行事的障碍。他们观察到那些正在自我教育的孩子，从而以崭新的眼光看待教育，将其视为值得欣赏、享","date":"2022-03-06","objectID":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/:2:0","tags":["杂谈"],"title":"有关教育的理性讨论和批判的收集","uri":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/"},{"categories":["人与世人的关系"],"content":"世界经济论坛-教育4.0框架 教育4.0全球框架:未来学校教育与模式转变——世界经济论坛《未来学校:为第四次工业革命定义新的教育模式》之报告解读 - 百度学术 (baidu.com)。 教育4.0全球框架：未来学校教育与模式转变 (baidu.com)。 环球 | “教育4.0时代”来了，你还在用旧思路给孩子上课？ (shobserver.com)。 世界经济论坛白皮书提出未来学校八大特征16案例，中国一课程入选 (baidu.com)。 ","date":"2022-03-06","objectID":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/:3:0","tags":["杂谈"],"title":"有关教育的理性讨论和批判的收集","uri":"/29%E6%9C%89%E5%85%B3%E6%95%99%E8%82%B2%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%89%B9%E5%88%A4%E7%9A%84%E6%94%B6%E9%9B%86/"},{"categories":["人与世人的关系"],"content":"本硕时期小剪影","date":"2023-06-23","objectID":"/30%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F2/","tags":["杂谈"],"title":"【杂谈】过往时期2-嵌入式求学故事线简忆","uri":"/30%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F2/"},{"categories":["人与世人的关系"],"content":"过往时期2-嵌入式求学故事线简忆 前一篇文章 过往时期 - 欢迎来到 Staok - 瞰百易 (github.io)。 在我兴趣广泛的过去，关于嵌入式方面的经历啊，讲一条这个的故事线。 小学，电子积木，灯泡，电机，上电发光、风扇旋转，风扇转的快了还会飞到空中转，好玩，但更多的是感觉神奇！ 初中高中，参考电子积木上进阶电路，父亲偶的一次带领我到一个本地的电子零件店，买了电烙铁焊锡松香，还有一些电子零件，自己做了三极管和阻容感结合的频闪、蜂鸣器等电路，可以用电位器调节震荡频率。小初高同样的，也拆过很多东西，机械的、电子的，看看瞧瞧里面啥样，它为啥能运转，好玩。 那个时候对电路和元器件只有一些朴素的感性认知。 直到大学，带着这些感性认识，也就是说带着期待、兴趣和问题，去学、去理解自动控制、数模电，算是对这些电路有了理性认识，能够计算和模块化设计了，但仍然是不成系统的，只是一些不怎么连贯的知识单元、碎片。 本科的经历，具体来说： 在高中毕业的那个暑假，接触了51单片机，淘宝了一个开发板，五十几块钱，那几个小时的配套视频教程，连带C语言和单片机编程都讲了，很感谢那是我的启蒙教程，以前玩电路，搭好了就不能变了，现在，任意IO口的高低电平，我可以通过程序控制、自定义，这种灵活性、高度可玩性的特点，一次次对我小小心灵予以震撼和开阔视野。 大一进了校内的电子科技协会，和一众四处聚来的志同道合小伙伴，在群里拉呱，后来统一被安排去一个屋子里，在那里学习，简陋朴素，但每天相互见面有说有笑，互相学习、互相交流。后参加校电赛，我组三个人的作品第一名，进入实验室，大二备战智能车竞赛和电赛，和基本同样的那一群十几个小伙伴，在实验室住了半年，因为那个实验室传统就是这样。 大三大四的也都还常在实验室，自然的传帮带，自然的搞技术的氛围，都是感觉很自然而然，而且备战比赛、学习嵌入式很方便。技术上，前辈好多届磨练出的软硬件，可学性、可用性很高，至少对当时的我来说，又是一次次对我小小心灵的震撼和开阔视野，包括IMU、编码器、摄像头、屏幕、用结构体、指针等实现的菜单库等等的软件，H桥、运放信号调理、电源等等硬件，在那时候有了很丰富的认识。 当了两个实验室（校级的电子科技实验室和创客空间）的管理层，这里本科时候故事好多，多的也不在这里提了。 在这个实验室基本上考研上岸率很高（每一届基本上只有很少本科毕业去工作的，大部分都上研究生了），并且工作基本都不错，相当于 一个双非学校里面一小群“985”质量的学生，甚至可能高于“985”学生的平均质量（有点自夸嘿嘿）。 技术上的学习和实物设计基本合理，积累也丰富，做东西去比赛大概率就能成，智能车国一，节能减排国一，电赛省一（当时个人模电还不算好，复赛综合测评没过，差一点进入国赛）。 上图是本科阶段做过的一部分东西的合订本图，包括智能车国赛的、国电赛的、节能减排国赛的，以及一些自己做着玩的学习新东西的。 进入研究生，还没入学，意识让我定下一些大的小的目标，写在一张纸上一直存着，时不时看一看，主要是： 1、对本科接触到的软硬件进行一个综合性的再学习和分门别类的梳理。这其中学习部分包括正点原子上千页的手册的STM32的几乎所有外设、软件组件；还有对自动控制、数模电的再学习，这次是联系实际的学，从我的相关网络发表的技术文可瞥见一二 【直达本质入门】系列，而不是课堂那样抽象的涂鸦；还有一直想学并且实验室需要的FPGA，主要是Verilog和SOPC（这是对计算机组成原理的真实体验）。这是打基础，对嵌入式有个上下层贯通的认识，从沙子到CPU再到汇编和C，梳理就是总结经验、软硬件模块和软硬件设计规范，从我的相关网络发表的技术文可瞥见一二 【规范】系列，具体太多，这里不展开。 说到基础，那么一些经典，学习一下：计算机组成原理，计算机操作系统，深入理解计算机系统，计算机网络。初步的时候，理解这些东西的结构，有个印象，之后理解越深越好，这东西学了也不容易变。 2、学Linux，这块硬骨头在我硕士期间一定啃下。学习的步步前进的总结可见 【主线剧情】Linux 系列。 在硕士实验室自主学到了很多。 在硕士的生涯丰富，各种意义上。 谨以我的毕业论文的 扉页 和 致谢的开头部分： 说这么多，我觉得，其实就是巨大的兴趣驱动力。做成一件事后的成就感、满意感颇丰。 找对教程（开发板、教程手册和视频。注重综合性和系统性，即横向开阔认识，纵向刨根问底）。 勤于实践（学习例子验证，自己有点想法实施试试，做东西，搞出来，好似在施展魔法，麻瓜的魔法是科技）。 及时总结（实践、调试经验的成篇章的文字总结，软硬件模块化总结、归档，方便以后，并且越积累越多）。 这里，可见我总结的一个 硕士实验室嵌入式学习路线参考清单。 投了、面试了哪些公司（不分先后）：大疆、华为、蔚来、理想、荣耀、字节、英伟达、英特尔、恩智浦、算能、科大讯飞、美团、京东、小米、乐鑫、360、虹软、地平线、芯驰、嘉楠，等等。 还有这种合订本 23届春招内推全汇总_互联网-科技-国央企-游戏-快消-金融 (qq.com)。多找一找，总有很多很好的网友的总结。 面试准备 1、基本：先介绍自己，姓名、学校、啥时候毕业，自己会什么，再概括性的介绍自己硕士期间的项目，说两个最具代表自己的。然后面试官大概率都围绕项目里的技术细节问，这是我刚才说的横向和纵向深度的理解自己做的东西，横向认识的东西多、相关机制基本都知道（比如进程间通讯和线程间同步能不能全面且准确讲到位），纵向认识要知其所以然，而不只是表面用用。 2、面试前的笔试，以及面试时候现场编程： 笔试看一看搜一搜 牛客、CSDN、Github 等上面相关的。 提前学一些数据结构与算法，然后力扣刷一些代表性的题，可以 B站 搜 热门题、大厂高频题等等，包括牛客上看一看面经，github上面也有一些面经和学习总结和笔试题总结等的好的仓库 （大集合）数据结构与算法简述和CS综合 - 欢迎来到 Staok - 瞰百易 (github.io)。 比如：这里只是举例，多找找适合自己的、看得进去的。 代码随想录 (programmercarl.com)。 华为算法大佬耗时200小时录制：Leetcode刷题100道，足以吊打字节面试官！_哔哩哔哩_bilibili。 LeetCode 最热门 100 题_哔哩哔哩_bilibili。 复习100分钟拿下100分，你能做得到吗？【C++】(面向对象程序设计)（总复习）_哔哩哔哩_bilibili。 基本的：栈（FILO）、队列(FIFO)、链表（单\\双）、树（线索\\排序\\平衡\\红黑）、图（DFS\\BFS），常见的排序算法，双指针思想（快慢双指针、相向移动双指针），哈希表的运用，串搜索（暴力法和KMP法），五大常见算法思想：动态规划、分治、贪心、回溯、分支限界。 最近的这几年，除了上面研究生订的计划，还有一个一些要学的东西的计划 StaokGo的动态 - 哔哩哔哩 (bilibili.com)（始于2020），这个现在基本还算中。然后是一个“瞰百易”计划，十年磨一剑，源于考研期间的一个晚上有感而想的，具体是实现一些可变现的东西，只一些想法，但是还不确定能不能成，说是十年，已经过去4年（始于2019）。 选择。进体制、进国企，一个师兄说，这是一种假稳定，我借用他的评价。另外可看一看这个 【张雪峰】计算机好还是体制内好？穷和累你更受不了哪个？_哔哩哔哩_bilibili，说的在理。我可能注重效率，一年挣的能赶上五年挣的，我加把劲几年，挣到了，更自由，感性上或者说心理上那时候能接受的东西可能也更多了，我需要的是，我还有选择。如何看待周鸿祎称「打工是用老板的钱给自己交学费，在公司混日子是浪费生命」？ - 知乎 (zhihu.com)，【杂谈】给本科实验室的分享PPT-21.7.23 - 欢迎来到 Staok - 瞰百易 (github.io)。 ","date":"2023-06-23","objectID":"/30%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F2/:1:0","tags":["杂谈"],"title":"【杂谈】过往时期2-嵌入式求学故事线简忆","uri":"/30%E8%BF%87%E5%BE%80%E6%97%B6%E6%9C%9F2/"},{"categories":["随机技术情报"],"content":"找工作笔试面试经验分享","date":"2023-06-27","objectID":"/31%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/","tags":["算法","软件"],"title":"找工作笔试面试经验分享","uri":"/31%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["随机技术情报"],"content":"本文引自 【杂谈】过往时期2-嵌入式求学故事线简忆 - 欢迎来到 Staok - 瞰百易 (github.io)。 …说这么多，我觉得，其实就是巨大的兴趣驱动力。做成一件事后的成就感、满意感颇丰。 找对教程（开发板、教程手册和视频。注重综合性和系统性，即横向开阔认识，纵向刨根问底）。 勤于实践（学习例子验证，自己有点想法实施试试，做东西，搞出来，好似在施展魔法，麻瓜的魔法是科技）。 及时总结（实践、调试经验的成篇章的文字总结，软硬件模块化总结、归档，方便以后，并且越积累越多）。 这里，可见我总结的一个 硕士实验室嵌入式学习路线参考清单。 ","date":"2023-06-27","objectID":"/31%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/:0:0","tags":["算法","软件"],"title":"找工作笔试面试经验分享","uri":"/31%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["随机技术情报"],"content":"找工作笔试面试 投了、面试了哪些公司（不分先后）：大疆、华为、蔚来、理想、荣耀、字节、英伟达、英特尔、恩智浦、算能、科大讯飞、美团、京东、小米、乐鑫、360、虹软、地平线、芯驰、嘉楠，等等。 还有这种合订本 23届春招内推全汇总_互联网-科技-国央企-游戏-快消-金融 (qq.com)。多找一找，总有很多很好的网友的总结。 面试准备 1、基本：先介绍自己，姓名、学校、啥时候毕业，自己会什么，再概括性的介绍自己硕士期间的项目，说两个最具代表自己的。然后面试官大概率都围绕项目里的技术细节问，这是我刚才说的横向和纵向深度的理解自己做的东西，横向认识的东西多、相关机制基本都知道（比如进程间通讯和线程间同步能不能全面且准确讲到位），纵向认识要知其所以然，而不只是表面用用。 2、面试前的笔试，以及面试时候现场编程： 笔试看一看搜一搜 牛客、CSDN、Github 等上面相关的。 提前学一些数据结构与算法，然后力扣刷一些代表性的题，可以 B站 搜 热门题、大厂高频题等等，包括牛客上看一看面经，github上面也有一些面经和学习总结和笔试题总结等的好的仓库 （大集合）数据结构与算法简述和CS综合 - 欢迎来到 Staok - 瞰百易 (github.io)。 比如：这里只是举例，多找找适合自己的、看得进去的。 代码随想录 (programmercarl.com)。 华为算法大佬耗时200小时录制：Leetcode刷题100道，足以吊打字节面试官！_哔哩哔哩_bilibili。 LeetCode 最热门 100 题_哔哩哔哩_bilibili。 复习100分钟拿下100分，你能做得到吗？【C++】(面向对象程序设计)（总复习）_哔哩哔哩_bilibili。 基本的：栈（FILO）、队列(FIFO)、链表（单\\双）、树（线索\\排序\\平衡\\红黑）、图（DFS\\BFS），常见的排序算法，双指针思想（快慢双指针、相向移动双指针），哈希表的运用，串搜索（暴力法和KMP法），五大常见算法思想：动态规划、分治、贪心、回溯、分支限界。 刷题 题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台 (leetcode-cn.com)。 牛客网在线编程_算法篇_面试必刷TOP101 (nowcoder.com)，牛客网机考与leetcode不同，需要自己处理输入输出，需要提前在牛客网上做一些往届机考题，适应一下考试环境。 leetcode刷题题号： 字符串：3，49，30 线性表：16，27，86 队列：406，641，899 栈：143，331，445 哈希表：17，36，128 dfs：98，105，112，494 bfs：101，102，752 ","date":"2023-06-27","objectID":"/31%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/:1:0","tags":["算法","软件"],"title":"找工作笔试面试经验分享","uri":"/31%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"categories":["人与世人的关系"],"content":"Encourage 勉励，关于过这一世，关于本门功夫","date":"2022-02-11","objectID":"/32encourage%E5%8B%89%E5%8A%B1/","tags":["杂谈"],"title":"Encourage 勉励","uri":"/32encourage%E5%8B%89%E5%8A%B1/"},{"categories":["人与世人的关系"],"content":"Encourage 勉励 关于过这一世： 有哪些一发入魂醍醐灌顶的警句？ - 知乎 (zhihu.com)。 我是如何看这个世界 (qq.com)。 【杂谈】给本科实验室的分享PPT - 知乎 (zhihu.com)，关于初心与用心。 一个知乎用户想法: 认为说的比较内核/在点- 知乎 (zhihu.com。 如何看待现在年轻人对马斯克的崇拜? - 知乎 (zhihu.com)，膜。 如何做到专注？ - 知乎 (zhihu.com)，强！1、启动效应，2、无干扰的休息，3、主动工作，4、固定日程。 大环境不好的情况下如何🐶着 - Tw93，中心思想：摆烂和努力都不够纯粹所以痛苦。 关于本门功夫： 很多编程书籍都是垃圾，大家一定要擦亮眼睛，不要被误导 (biancheng.net)。没有难学的知识，而是良莠不齐的教材乱花… - 知乎 (zhihu.com)。 联系上面 “个人方法论” 里面 “关于 难学/学不会 的东西” 一段话。 为什么我会感觉中国大学教材很烂？ - 知乎 (zhihu.com)。 【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前）_Real-Staok的博客-CSDN博客，总结帖。 【目录贴】软硬件规范化 - 知乎 (zhihu.com)，自己总结的初学者学习路线。 技术手艺人如何更值钱 ~ Murphy’s Blog，一些心谈。 成为程序员后你都明白了什么? - 知乎 (zhihu.com)，多年软件工程师写下的一些工作相关 要点 \u0026 经验。 一个电控大牛的回答 - 知乎 (zhihu.com)，自律，稳定学习，跟踪前沿，扩展视野。 BJTU Synergy Lab 招生说明 (github.io) 不是 ad，只是里面说的是正道——“人间正道是沧桑”，很有感染。BJTU Synergy Lab 经验汇编 (github.io)。 职场杂谈|几条忠告，不鸡汤，值得思考 (qq.com)。 ","date":"2022-02-11","objectID":"/32encourage%E5%8B%89%E5%8A%B1/:1:0","tags":["杂谈"],"title":"Encourage 勉励","uri":"/32encourage%E5%8B%89%E5%8A%B1/"},{"categories":["随机技术情报"],"content":"TIA 弱电流测量措施和经验汇总","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"TIA 弱电流测量措施和经验汇总 本文对应的 Github/Gitee 仓库地址，本文最新的原文 和 资料等等 均放在里面，发在其它地方的不会更新。 TIA 电路 用于测量弱电流（uA、nA、pA、fA 测量）。 弱信号测量，且 SMU 四象限的测量，哪一个都是需要很强的硬件积累、功底和经验，包括数学上的分析和大量不寻常的电路拓扑（可见下面 弱信号测量开源仪表汇集） 应对任何称为仪器的东西有着敬畏之心 是测量小信号，nV级别、pA级别 是测量大信号，如连续持续监测几千摄氏度温度 是输出小信号，如前量级 是高速采集，考虑整个链路的复杂传递函数、信息传递环节，之间的相互配合 是慢信号采集，0.1Hz以下的慢和微弱信号，调制解调法等 每一块都是特多特多的考虑、权衡、经验、发现与启发等等 应对任何称为仪器的东西有着敬畏之心 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:0:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"弱信号测量开源仪表汇集 CERN超强开源八位半电压表HPM7177 Home · Wiki · Projects / OPT-ADC-10k-32b-1cha HPM7177 · GitLab (ohwr.org) 【硬核】超强八位半开源万用表-腾讯云开发者社区-腾讯云 (tencent.com) home-built-stm Home-Built STM | Dan Berard (dberard.com) Keithley吉时利源测流单元和电表仪器手册附原理图 安捷伦电表原理图 nvm 开源纳伏表 jaromir-sukuba/nvm: Open source nanovoltmeter (github.com) OpenSTM-Ref-Document Dimsmary/OpenSTM at Ref-Document (github.com) 制作六位半数字电表源码及电路方案 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:1:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"TIA 外围电路注意点 参考 SCH \u0026 PCB 设计规范和 AD 的使用 文中 最基本的 PCB 绘制过程 一节 和 4 SCH-PCB 设计规范 一章里面的 本科生级 和 电源规范设计、运放设计注意 / 低噪声精密电路 小节 等。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:2:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"电源噪声 DCDC到LDO之间加LC环节，LC衰减高频噪声的频带要覆盖LDO的RSRR不力的频带。 运放供电前加LC环节，同样的，LC衰减高频噪声的频带覆盖运放的PSRR不力的频带。 防止电路块之间的工地干扰，模拟部分和数字部分分别供电，分别在一点接地，进行单点接地，电路块不要串接起来。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:2:1","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"电路噪声 电阻热噪声：不同电阻的电压和电流噪声如下。经验值，一般的100M电阻在100Hz频率约有1pA电流噪声（随着阻值减小），约有10uV电压噪声（随着阻值增大）。不同材质的电阻有不同的噪声表现，金属膜的一般相对于碳膜的较低，具体可见厂家电阻手册。并且考虑 电阻精度。 一般电阻热噪声表格（室温 300 K） 电阻值 (Ω) 热噪声电压密度 (nV/√Hz) 热噪声电流密度 (pA/√Hz) 1 kΩ 4.07 4.07 10 kΩ 12.88 1.29 100 kΩ 40.7 0.407 1 MΩ 128.8 0.129 10 MΩ 407 0.0407 100 MΩ 1288 0.0129 1 GΩ 4070 0.00407 运放的电压和电流噪声密度指标，这些噪声经过具体的运放电路连接形式放大到输出端。 TIA电路考虑电流噪声密度（即输入端的）应该远小于被测电流（还有Ib和Ib的温漂都应该考虑）。 TIA电路考虑运放电压噪声对输出的贡献，为跨阻和信号源内阻组成的电压放大电路的倍数（也即噪声增益） * 运放电压噪声密度值 * 带宽的开平方。 对于弱电流信号源，可以认为信号源内阻是很大的，与TIA合适量程的跨阻阻值相当或更大。 运放的增益带宽积（电压型运放的闭环增益和带宽的积通常为一个定值）GBW不必很大，否则噪声带宽就越大，按需。 信号源的噪声。 以上还有其它种种，合起来可估算总噪声。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:2:2","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"各种隔离和防护 数模电路分离，单点接地，防共地干扰。电源树设计，多路电源分别与之供电。PCB 两个 高性能的 LDO 分别给 模拟（TIA 和 ADC 部分） 和 数字部分（如 MCU 部分） 供电，电源端，数字部分 和 模拟部分 在单点接地（不要串起来），做好防共地串扰，空间分离。 TIA 部分 + ADC 部分 独立，ADC输出数字接口 与 后面 电路 之间做 隔离（专用电磁隔离芯片、光耦等）。 对外数字接口可使用 光耦做的接口，做好对外 数字接口的 ESD 防护。 电源防护 如 瞬态抑制（TVS 管）、防反接、欠压、过压、过流 等。 输入过流保护，硬件或软件上检测到若输入超过 最大可测量电流，则关闭输入到 TIA 的连接（如 继电器），直到下次软件开机才恢复正常，这是一种模式；另一种模式是超过 最大可测量电流 的时候不管，仍继续，TIA 运放输出饱和而已，这种相比于第一种不需要重新开机而打断测量过程，但也许仍需要一个极端情况的切断保护。 成品电路板做到 批量打出来 上电就能用，不用复杂的调试等等。校准只针对随机拿出一些数量有限的电路板进行，得到的校准数据输入到新做出来的电路板上就好使。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:2:3","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"TIA 电路概括 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:3:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"相关书籍文献 系统参考书籍 《跨阻放大器设计参考》，比较全的介绍了围绕 TIA 电路的 种种。 还要系统参考下 吉时利的 最新《低电平测量手册》第六版。 芯片大厂文档，如 ADI、TI 等的。经典如： 跨阻放大器电路设计和计算。 ADA4530、LMP7721 等芯片相关的所有技术、应用文档。 多看一些论文，关键字有：弱信号采集、弱电流测量，nA测量，pA测量，等，多看多思考多总结。 CSDN 下载区里面搜索 弱电流测量 相关的文档（有些是比较珍贵的、生动真实的一手的实践经验总结，要的就是这种真实性的）。经典如： 图解DIY 1pA超微电流测试器 lymex 穿越电流测量的无人区——pA等级电流测量 微电流测量60问答 微弱电流检测放大器PCB布线布局设计-保护环介绍 基于深度学习的ADI微弱信号布线指南 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:3:1","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"弱信号检测相关好书 电子电路抗干扰技术 弱信号检测技术. 刘国福 电子噪声与低噪声设计. 高晋占 弱信号检测. 高晋占 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:3:2","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"主要问题总览 “由于模拟电路的特殊性，实际电路中的参数，元件数量等会根据每批电路的参数分布不同而有所调整，无法保证和原理图中完全一致” 分布式参数等导致实际设备的直流误差、噪声 等。 微电流检测的主要障碍是：工频噪声，直流误差，直流泄漏电流。 噪声 工频噪声：软硬件去除。 硬件上，双T陷波滤波器等（《信号与系统》4.10.2工频干扰的滤除_抑制工频干扰需要什么滤波器-CSDN博客）（但是占地方，且增加器件增加噪声，不值当，应当：降低系统噪声 + 软件滤波处理）。 硬件上，给 ADC 之前可做 压控有源二阶滤波 常规的。 软件上：平均法、滑动窗口，FIR / IIR 数字滤波 等（如何把50Hz工频干扰定点清除-电子发烧友网 (elecfans.com)，心电滤波(STM32)小结-CSDN博客）。 软件上，可做 FIR 滤波，50Hz工频滤除，测量频率 以上的噪声滤除。 其它噪声： 建议只用电池供电来使用。纹波尽量降低。 直流误差 和 校准 主要来自 运放的 Ib、Vos 以及它们的温漂等，应选择满足测量需求的运放。 对于电流测量，输入空接，测量输出，来实现自动校零。每次开机自动校零下，或依据环节变化 自动周期性调零 或 用户一键调零。（对于电压测量，就是 “差分对消”，可以硬件上可以只加个 电压采集端 的 接到 输入端 和 采集端的参考地 的 二选一切换，TIA 输入 切不可接地或接 IN+！） 各量程范围与参考源做校准，对硬件非线性、温漂、湿度等的影响做减弱（各温度、各湿度下做 每个量程选择 一个 或多个点 的校准）。 如 使用 吉时利 2400、2450、6517B、6220 之类的设备去校准。源表的价格原因，最终可以选择 DMM6500 或 34465（测量精度能达到 1pA） 六位半万用表来做，可以自制个恒流源发生器 用 前面的万用表来标定，然后 用这个 标定过的 自制的电流源 来给自己的设备来校准，这个思路只是想法，不一定实用。也许还得靠 专业仪表输出的弱电流源 来校准。 经验标明，温湿度对运放参数影响较大，尤其是高湿度环境下线路漏电流极具增加。 因此仪器就只在室温（25℃）和寻常湿度（50%以下）进行电流的校准。 温湿度测量若超出合适环境，则应该提醒当前温度过高或者过低，湿度过高（提示电路板应干燥 或 手动烘干），当前读数不保证准确。 减小 PCB 漏电流。目标：经验上，漏电流至少要比测量精度低一个数量级。具体看下面，从 运放选型、保护环设计、硬件配套措施等 上入手。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:3:3","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"关于运放选型 下面一些双引号括起来的句子为上面参考资料里面一些拿出来的。 考虑上面 ”电源噪声“ 和 ”电路噪声“ 里面的描述。 关注 Ibias、Vos，以及同样也很重要的它们的变化范围，如 温变、随着 Vcm（共模电压）变化，以及 噪声 等。 Vos 要低来满足测量需求，一个是降低输出误差，一个是降低保护环和输入线路的压差。 基本要求：Vos（全温度、电源、输入共模电压范围内）« 电压测量真实最小精度，Ib（同前，全范围内）« 需求电流测量精度（至少小于一个数量级，更好小于两个数量级以上）。 ADC 的输入阻抗，和信号线路的电阻形成分压，从而导致直流误差，所以 ADC 前尽量用精密运放（Vos 等要小于需求测量精度）（跟随或信号调理）输出，减少信号在传输线上的电压损失。 ADC 选择 Sigma-Delta 类型。 ”金属封装的芯片漏电流不如塑封的芯片低“ “这里的性能，一般是指噪音或灵敏度。Ib 当然选小的好，但 Ib 不是极限，完全可以做出比Ib 的实际值更好的微电流测试器。极限是 Ib 的噪音。” “Ib 的噪音是无法克服的，例如 LMC6062 的噪音是 0.20fA、LMC6001 是 0.13fA，OPA128L 是 0.12fA，LMP7721 是 0.10fA。以上噪音的单位是√Hz，也可以认为是带宽 B=1Hz 下的噪音值。当然，这些都是噪音的典型值，通过筛选，可以取得更小的电流噪音，因此理论上在 B=1Hz 下取得 0.1fA 的噪音是完全有可能的，这已经远小于运放的 Ib 了。” 实际买回来芯片，主要是 运放 和 模拟开关，也许需要挑一挑，挨个试，哪个放到板子上工作更好。直接做出来试试，再换几个器件试试，都试试。 “若被测电流变化范围极宽，不适合手动换挡的，建议选择对数放大器。搞不定交流电50Hz工频震荡干扰的，也建议选择对数放大器。” 可以研究下对数运放，或许可以直接搞宽范围测量而不用换挡。 不过经过检查，对数运放可能不好选择 Ib 极低 的选型。而且，把很宽的输入范围比如跨8个数量级分在可能0.2V~1.6V之间，对于ADC的有效测量精度有较高要求。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:4:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"关于 TIA 反馈网络 选择大电阻，而不是 T网络 接法。 “用 T 型网络后电阻是降下来了，但带来的问题就是电流噪音相应的增大。正规的微电流计没有一个采用 T 型网络的。纵观商品的静电计/微电流计，都是采用大电阻的方式，一般都用到100G，更有吉时利的642和6430，用到了1T，这样才能取得0.08fA的噪音有效值和0.4fA峰峰值（有效值和峰峰值一般是 5 倍的关系）。” 跨阻 Rf 应靠近运放的 IN-；Vout 从 Rf 出。加入保护环。具体可以看 ADA4530 和 LMP7721 等芯片的有关手册里面的 推荐 PCB 图。 跨阻 Rf 并联的 Cf 根据闭环稳定性要求 有 最小值。 具体计算看 经典文档如 跨阻放大器电路设计和计算 或 书籍 《跨阻放大器设计参考》。整 TIA 电路噪声也可以计算预估。 输入线路尽量短，减少漏电流。 各 RC 环节，依 需求 采集速率 来确定。 在仿真软件里面跑一跑，可 TINA-TI 或 LTspice，放上实际选用的芯片型号。 看一看 各种性能指标，伯德图，相位裕量，噪声功率谱图，噪声功率密度 等 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:5:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"保护环 保护环 的 PCB 布局应包裹整个输入到 IN- 有关的所有线路。弱有多层板，保护环应在多层电路板都把输入线路整个都包裹住。具体可以看 ADA4530 和 LMP7721 等芯片的有关手册里面的 推荐 PCB 图。 保护环应尽量使得 输入电流 的线路 到 TIA 电路 上的 漏电流 小于 测量精度 一个数量级。 减小保护环（Guard Ring）与信号线的电压差。 保护环保持低的阻抗，至少要比信号线上阻抗更低，让外围漏电流往保护环上漏而不是信号线。保护环由运放 IN+ 经过跟随运放（选择尽量低的 Vos 的精密运放）再串入1K 电阻 来驱动。 保护环不应该带载，带载会拉起其电压从而与被保护线路的电压形成客观压差而造成被保护电路漏电流。若需要带载则需要使用输出电阻更低（输出能力更强）的跟随运放做驱动。 参考 ADA4530 手册中的 PCB，其中 ”高阻抗走线和保护走线移除了阻焊层，确保保护环与所有表面漏电流路径形成电气接触。基于同样的原因，应避免在此部分中印刷丝网。“ ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:6:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"硬件配套措施 “在测量1uA以下电流，尤其是近1nA电流时，由于电流极低，空气湿度，灰尘，电路板洁净程度，电路板所处的电磁环境，电路板自身的体电阻等均会对测量产生很大的影响，尤其是工频震荡问题，使用者必须对这些有一定程度的了解，才有可能发挥到最佳性能。” ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:7:0","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"关于清洁 敏感信号 PCB 上不要有喷墨字符等干扰物。 敏感信号附近，不要使用助焊膏。 清洁后烘烤以消除吸收的湿气。 ”湿度水平较高 (\u003e60%) 时，有效输入偏置电流幅度变得对相对湿度非常敏感。漏电流幅度迅速提高（两个数量级，fA到100fA），且极性可能改变“ 板材保持清洁，增加板材上的绝缘电阻；避免污染物接触信号区域。电路板密封，防止吸湿导致绝缘下降；控制湿度（\u003c30% RH）。 PCB 表面 涂敷三防漆，比卖你水汽、灰尘等的侵入。注意三防漆的绝缘性。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:7:1","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"PCB 材质 PCB材料建议使用专用于射频微波电路的瓷片薄片，具有的高阻抗，优秀介电系数（尤其是对于pA和亚pA级别测量电路）。 ”Rogers 4350B是一种设计用于射频/微波电路的陶瓷薄片。经测试，该材料在不到20秒时间内便可将介电弛豫电流耗散到1 fA以下。“ ”玻璃环氧树脂薄片需要1小时才能将介电弛豫电流耗散到10 fA以下。这表明，玻璃环氧树脂薄片不适合用于高性能静电计电路。“ 根据 板材绝缘电阻 和 信号线与保护环电压差，可以估算漏电流，应小于 10% 测量精度，即小于需求测量精度一个数量级。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:7:2","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"电路屏蔽壳 电磁笼防护壳，不仅屏蔽一些外来电磁干扰，也遮光，防止光照在敏感电路引起一些半导体器件的光电反应引起的电流。 避免外界有复杂的电磁环境，以及震动等。 TIA电路部分可以焊接金属屏蔽罩封起来，防电磁干扰，也防湿度过大等。当然 温湿度传感器 芯片 就放在 此 旁边。 ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:7:3","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["随机技术情报"],"content":"输入连接 可使用 BNC 接口 输入被测电流，电流输入端 到 TIA 尽量短短短以减少漏电流！可尝试在 1cm 以内。 电流输入使用三同轴电缆，BNC 接口，线缆的中心走输入电流，中层连接保护环 Guard Ring 电位，外层走输入电流的地。 实际调查，BNC 三同轴 的接口 和 线缆比 二同轴 的贵很多（5倍以上）。按需吧。若测量 pA 以及 亚 pA 级别的，这种级别仪表本身也不便宜，这个接口和线缆成本也就占个零头了。 线缆进来的输入电流和地，直连测量端的查分输入，注意这个差分线两条线到测量端要阻抗一致。传感器端单端输出时的地与测量端的前端运放的地连接，注意防止共地干扰 “商品的微电流测试设备不仅禁止在测试中晃动电缆，而且电缆都是特殊材料制作的，以便减少压电和摩擦生电效应，而且电缆都做成很硬的那种，使其对气流和振动不敏感。” ","date":"2025-03-03","objectID":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/:7:4","tags":["弱电流测量","弱信号测量"],"title":"TIA 弱电流测量措施和经验汇总","uri":"/33tia%E5%BC%B1%E7%94%B5%E6%B5%81%E6%B5%8B%E9%87%8F%E6%8E%AA%E6%96%BD%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"},{"categories":["PublicStuffs"],"content":"这里汇集我的所有开源项目和所写的网络文章。","date":"2021-12-10","objectID":"/publicstuffs/","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"能找到这一页的大佬我们都是有缘人，如想互相交流学习可加QQ（1134763854）或微信（ugetxhy）。 PublicStuffs 这里汇集我的所有 开源项目 和 网络文章。排序不分先后。 开源项目和网络文章发布的网站：Github / Gitee，小站（个人博客），知乎 (zhihu.com)，CSDN。 开源软件项目均使用 AGPL-3.0 开源共享协议。 开源网络文章均遵循 CC BY-NC-SA 4.0 开源共享协议。 🌱 十年饮冰凛冬袭，难凉热血瞰百易。 让杂乱的都清晰再现。让“高科技”的归于寻常百姓家。 目录 [TOC] ","date":"2021-12-10","objectID":"/publicstuffs/:0:0","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"开源项目 开源地址 Github，Gitee，二者同步。下边仅列出 Github 地址。在下面 社交号文章 一节里存在的 Github/Gitee 仓库不再这里列出。 ","date":"2021-12-10","objectID":"/publicstuffs/:1:0","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"“瞰百易” - 嵌入式类 ARM-Linux-Study Staok/ARM-Linux-Study: ARM Linux 的学习历程，文章遵守 CC BY NC SA 4.0 协议。 (github.com)，即 “主线剧情” 系列。 norm-of-software-and-hardware Staok/norm-of-software-and-hardware: 目录贴，个人软硬件规范的索引总贴。以及本科阶段触及的大部分领域及其顺延的小总结。CC-BY-NC-SA 4.0。 (github.com)，即 “规范” 系列之一。 coding-style-and-more Staok/coding-style-and-more: C 编写规范和其他。永远地不定期更新。CC-BY-NC-SA 4.0。 (github.com)，即 “规范” 系列之一。 thoughs-about-hardware-design Staok/thoughs-about-hardware-design: 介绍和罗列关于硬件设计所需要考虑的各个方面。纯个人经验总结，非科班念经。永远地不定期更新。CC-BY-NC-SA 4.0。 (github.com)，即 “规范” 系列之一。 HDL-FPGA-study-and-norms Staok/HDL-FPGA-study-and-norms: HDL \u0026 FPGA 学习和规范。CC-BY-NC-SA 4.0。 (github.com)，即 “规范” 系列之一。 Cpp-Learning Cpp-Learning: C++学习总结备查 (gitee.com)。 stm32_framework Staok/stm32_framework: 一个志在实现STM32F1、F2和F4工程模板的项目，集成了FreeRTOS、LWIP、FATFS、DSP、USB、IAP、菜单库、有限状态机模板等等的组件，以及未来将加入的加密、BPNN、最小二乘、音频图片视频解码、LittlevGL等诸多常用的算法或组件，并具有良好的易用性、解耦性和可剪裁性！ (github.com)。 u-iap Staok/u-iap: 一个志在实现适用于 MCU 的通用 IAP 程序框架，可以从串口、外部 SPI FLASH、外部 SDIO SD 卡、USB Device MSC 或者 USB HOST MSC等等途径更新 MCU 固件。 (github.com)。 IMU-study Staok/IMU-study: 对常见IMU芯片的原理、驱动和数据融合算法整理，以区分某度、某坛上面碎片化严重到影响入坑的乱象 (github.com)。 iBLDC Staok/iBLDC: 月更或者年更。志在做一个纯粹的、包含软硬件的、功率涵盖从小到大的、全套的FOC和BLDC方案，硬件方案包括专用芯片和自编原理图，软件方案包括自编驱动程序和FOC库。 (github.com)。 Awesome-Embeded-AI Staok/Awesome-Embeded-AI: 收集关于嵌入式领域的机器学习算法实现的进展、相关论文和文章、开发库等，帮助初学者快速了解、学习和入门嵌入式领域的机器学习。CC-BY-NC-SA 4.0。 (github.com)。 ","date":"2021-12-10","objectID":"/publicstuffs/:1:1","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"“瞰百易” - 硬件类 PowerBar Staok/PowerBar: 一个实现大功率可调的开关电源，附带多路多种输出和实用功能。方案已基本确定。 (github.com)。 protection-circuits Staok/protection-circuits: 对保护电路中的过流、过压、软起动、防反接、通讯和信号隔离、电平转换、防共地干扰、TVS瞬态抑制、共模抑制和电磁兼容做一个大总结 (github.com)。 iUPS-12V Staok/iUPS-12V: 12V输出的不间断电源，大功率/真稳压/真电池管理 (github.com)。 ","date":"2021-12-10","objectID":"/publicstuffs/:1:2","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"其它 - 嵌入式类 Mini-DSO-WaveGen-in-one Staok/Mini-DSO-WaveGen-in-one: @老刘爱捣鼓 的 “STC8A示波器” 和 “STC15波形发生器” 二合一/重新画板 项目 (github.com)。 Dual-Screen-Stereoscopic Staok/Dual-Screen-Stereoscopic: 双屏动态裸眼立体效果展示器 (github.com)。 Awesome-K210 Staok/Awesome-K210: 收集关于K210的MaixPy开发和SDK IDE开发等的软硬件入门资料，帮助初学者快速了解、学习和入门K210 (github.com)。 STC15-Development-board Staok/STC15-Development-board: 这个项目本是给电子科技实验室做一款入门开发板用于新人学习。 (github.com)。 make-your-own-Arduino Staok/make-your-own-Arduino: 看在Arduino的编程便利性，自己定制Arduino硬件，嵌入到小项目里进行快速开发和原型验证 (github.com)。 esp8266-esp32-development Staok/esp8266-esp32-development: 收集关于esp32和esp8266主流的简便的开发教材、工具和例程，方便快速入门或者快速拾起。 (github.com)。 pid_realize Staok/pid_realize: 实现PID的几种算法：积分分离，变限积分，和可选择的不完全微分、微分先行。 (github.com)。 is_prime_O1 is_prime_O1: 生成一个判断一个数是否为质数的算法时间复杂度为O(1)的程序的程序（整活儿） (gitee.com) ","date":"2021-12-10","objectID":"/publicstuffs/:1:3","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"其它 - 硬件类 Basic-charge-pump Staok/Basic-charge-pump: 一个电荷泵升压电路的基本实现，包含一个MOS高端驱动分立元件原理说明multisim仿真文件 (github.com)。 buck-cc-cv Staok/buck-cc-cv: 一个实现了恒流恒压的电源的简单项目，测试上传 (github.com)。 ","date":"2021-12-10","objectID":"/publicstuffs/:1:4","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"社交号文章 ","date":"2021-12-10","objectID":"/publicstuffs/:2:0","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"【规范】系列 集大成者，愿与君共寻人世间意义。该系列 真-永远更新（有生之年）。 专栏：小站，知乎，CSDN。 【目录贴】嵌入式学习路线参考清单 小站；知乎；CSDN。 【目录贴】软硬件规范化 软硬件规范化的意义、内容、实践方面的介绍，还有远景/展望未来方面的内容。 Github；github；小站；知乎；CSDN；Bilibili。 C \u0026 MCU 编写规范 “低耦合，可重用，参数化，注释全”，个人总结的抽象层面非常实用部分的集大成者。 Github；github；小站；知乎；CSDN。 SCH \u0026 PCB 设计规范和 AD 的使用 个人总结的抽象层面非常实用部分的集大成者。 Github；github；小站；知乎；CSDN。 HDL \u0026 FPGA 学习和规范 对 FPGA 初步学习的一些记录。 Github；github；小站；知乎；CSDN。 ","date":"2021-12-10","objectID":"/publicstuffs/:2:1","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"【主线剧情】系列 吾将上下而求索。主要围绕嵌入式 ARM SoC 以及 Linux 的学习记录。 主线剧情 系列的文章和资料开源仓库：Github，github。专栏：小站，知乎，CSDN。 【主线剧情01】ARM \u0026 i.MX6ULL 基础学习记录 ARM 寄存器、汇编、i.mx6ull 的启动流程、异常与 GIC、ARM SoC 启动文件示例。加深对处理器运行方式的理解。 【主线剧情02】ARM \u0026 Linux 基础学习记录 对 Linux 的系统概念、Linux 文件系统、常用命令、Vim 使用、GCC、Make 与 Makefile 及其模板、ubuntu 包管理、换源等等等做一个大总结，对 ARM Linux 的编译工具链、应用、系统编译的流程做简单介绍，最后对 PC 与 嵌入式板 传输文件的方式做一个汇总。 【主线剧情 番外01】ARM \u0026 SOC 系列快速鸟瞰 现今主流处理器架构和内核层，ARM架构处理器的架构层、内核层和具体芯片（举例），ARM Cortex-A 系列对比、Linux 系统方案的优势介绍。 【主线剧情 03】Uboot 移植基础详解 在非常新的 uboot 版本（2019 以及之后）上面的 i.mx8mm 移植超细步骤，还包括嵌入式领域的 boot 的思想介绍、u-boot 的启动流程细解、mkimage 工具细解、u-boot 常用命令等。 【主线剧情 番外02】设备树详解 设备树基本概念、基本语法、常用节点、标准属性等。关于 Linux 中设备树操作函数 以及 用设备树建立和控制设备 在后面的 Linux 应用编程 文章详解。 【主线剧情 0.0】Linux 学习资源大综合 对收集到的比较丰富的 Linux 学习相关的资料进行整理。 【主线剧情08】Linux应用编程-学习总结备查 记 Linux 应用 相关的基本概念和流程，便于 备查 / 复习。 （大集合）Linux进程和线程的基本编程、通讯和例程【杂记】 对 Linux进程和线程的基本编程、通讯和例程 进行大总结。参考网络文章和官方文档并做多处横向对比，形成系统性 一文全解，给出保姆级别的参考，则避免 同质化（不完全是直接引用，我整理了很好、很漂亮的格式，还为了 句子流畅、整理标点符号 和 补充说明（中文语境的名词混乱、口水话输出等等，你懂的） 做了很多 整理、修改和补充）。 必看：主线剧情 系列 的循序渐进的查看顺序 【主线剧情】Linux 系列，为嵌入式 Linux 的学习记录。这篇文章记录 主线剧情 系列 的循序渐进的查看顺序。 【主线剧情07.1】Linux驱动编程-基本字符设备和设备树维护 Linux驱动编程-基本字符设备和设备树维护。 【主线剧情07.2】Linux驱动编程-各种内核机制总结 Linux驱动编程-各种内核机制总结。 【主线剧情07.3】Linux驱动编程-内核态API总结备查 Linux驱动编程-内核态API总结备查。 ","date":"2021-12-10","objectID":"/publicstuffs/:2:2","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"【读标准】系列 读 IEEE 1451 智能传感器接口标准源文及其周边论文、文章、PPT 等的总结性记录。确定路线后就剩体力劳动，所以画饼人在快乐星球。 读标准 系列的文章和资料开源仓库：Github，github。专栏：小站，知乎，CSDN。 【读标准01】IEEE 1541 智能传感器接口标准介绍 名词/概念释义、标准簇/标准模型、1451.0 标准的 NCAP 与 TIM 的通讯（包括 消息 和 TEDS）、TIM/传感器 的状态图、1451 标准的局限性。 【读标准02】IEEE1541.5 智能无线传感器标准介绍 对 1451.5 中与 1451.0 不同部分的介绍，有 命令集、PHY TEDS、WLAN 等。 【读标准03】IEEE1451.5标准协议尝鲜实现 分别对 TEDS 和 Message 的 数据结构实现 与 帧打包与解析的算法实现。 ","date":"2021-12-10","objectID":"/publicstuffs/:2:3","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"【直达本质入门】系列 循序渐进，快速入门。 专栏：小站，知乎，CSDN。 【简明自控】为什么特征方程如此重要 通俗易懂聊自控，解决问题：啥是自控？怎么建模？怎么分析？ 小站；知乎；CSDN。 超快 STM32 系统入门指南 “真-面向应用”，对于超快 STM32 入门来说就是：听正常人能理解的句子来了解外设概念和意义，然后直接从 API 入手。 Github；小站；知乎；CSDN。 【手撕运放】运放的“第一原理”式定量分析法 介绍通过“放大倍数趋于无穷的极限计算”这种“第一原理性”的运放分析方法，通过这种方法可以以不变应万变！ 小站；知乎；CSDN。 （大集合）数据结构与算法简述和CS综合 数据结构与算法简述和CS综述大整理、大合集。本文会列出大量学习和参考网站，并给出大量 Github 优质仓库 和 面经集合！ Github；小站；知乎；CSDN。 【未来的动力】BLDC的六步法\u0026PMSM的FOC法综合 查阅 n^2 的各方资料，对 BLDC\u0026PMSM 进行一个大综合、大整理，查阅、比较和整理 大量的 网络教程、大厂手册、开源解决方案，在这里形成 原理和解决方案 的打通式介绍。 Github；github；小站；知乎；CSDN。 ","date":"2021-12-10","objectID":"/publicstuffs/:2:4","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"【技术杂文】系列 可供选择的软件开源协议的罗列 罗列各种开源代码的公共协议以供选择。具体每一个协议的含义可以另外找教程文章或看官网原文，这里解决“都有什么”的问题。 Github；github；小站；知乎；CSDN。 FQ Github，github。 【开源项目介绍】叠buff电源板-巧克力板 一个实现大功率可调的开关电源，附带多路多种输出和实用功能。 Github；github；知乎，小站，CSDN。 PCIe接口及其衍生接口大总结 PCIe 接口及其衍生接口大总结，包括 SATA、mSATA、M.2 等。 知乎；小站；CSDN。 装机、资料库结构与文件备份方案 嵌入式领域的学科门类、资料、软件极其多样和广阔，上衔软件下通硬件的，再加上我早期又涉猎异常多的领域，在这几年中，资料库的划分、整理以及备份的架构逐渐形成稳定。 知乎；小站；CSDN。 无线传感网络的定位和时间同步技术简述 多无线传感器所组成的无线传感网络的各个节点的定位和时间同步技术简述。 知乎；小站；CSDN。 【杂记】进程和线程的分配策略 注：【杂记】系列为日常网搜资料的简单堆砌而积累成之。如有错误恭谢指出。标识为“原创”其实不完全是，只是多引用再整理，大都引自网络，侵删！ CSDN。 【杂记】EMC、EMI、EMS、TVS、ESD概念学习总结 注：【杂记】系列为日常网搜资料的简单堆砌而积累成之。如有错误恭谢指出。标识为“原创”其实不完全是，只是多引用再整理，大都引自网络，侵删！ CSDN。 （大集合）嵌入式端的神经网络算法部署和实现综合 Github；github；知乎；小站；CSDN。 （大集合）AI工具和用法汇总—集合的集合 Github；github；小站；知乎；CSDN。 其它 C语言学前班 - 知乎 (zhihu.com)；C 语言学前班 - 欢迎来到 Staok - 瞰百易 (github.io)；C语言学前班。 最简单优雅地解决VsCode的命令行显示中文乱码问题_Real-Staok的博客-CSDN博客_vscode命令行乱码。 ","date":"2021-12-10","objectID":"/publicstuffs/:2:5","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":["PublicStuffs"],"content":"【日常杂文】系列 科幻小说《请留在未来》 Github；github；知乎；小站；Bilibili；点众科幻-已投版-网站无了。 科幻小说《请留在未来》-注解篇 Github；github；知乎；小站；Bilibili。 【杂谈】只剩结论的故事便是短句合集 小站；知乎。 【考研】噫嘘唏，考研个人经验汇总 纯干货，不上升到哲学，提个醒。 知乎；小站；CSDN。 【杂谈】师之传达 记录导师、老师言语。本文非原话，是把日常聊天和开会听到的话的意思记录下。不只是用于科研，放之很多地方都有道理。 小站；知乎。 【杂谈】过往时期 本科简单回顾。 知乎；小站。 【杂谈】给本科实验室的分享PPT-21.7.23 知乎；小站；CSDN。 【杂谈】给本科实验室的分享PPT-回复各种问题 知乎；小站；CSDN。 【杂谈】油管对线 小站，审核不过，删掉了。 批判与扶正歪气 小站；知乎。 抓考研英语单词主要矛盾的经验分享，考研英语真题词频统计 知乎，小站，CSDN。 【目录贴】关于人生、学习的阶段性总结和小窍门（2021及以前） 知乎；小站；CSDN。 Judy Hevenly’s 2022 Predictions that for future reference 知乎；小站；Bilibili。 新生工程导论讲座PPT-17.11.23 知乎；小站；CSDN。 第二次创客沙龙暨平台联合探讨会PPT-18.5.12 知乎；小站；CSDN。 王者荣耀的匹配机制和英雄平衡已经崩了 知乎；小站。 《清单革命》内容梳理\u0026随笔 知乎；小站；CSDN。 收到一个勒索邮件，真的慌了一阵儿 知乎。 用ChatGPT写文章了~关于教育的回答很点题和中肯 知乎。 ","date":"2021-12-10","objectID":"/publicstuffs/:2:6","tags":["PublicStuffs"],"title":"可瞰-PublicStuffs","uri":"/publicstuffs/"},{"categories":null,"content":"Interest / 业内兴趣 嵌入式各种软硬件开发的广泛精修。 整理一些 开源软硬件项目 和 技术分享文章（有 30+W 字了）。 瞰百易计划。 还有待补充的技术上的技能：~~FOC（咕咕咕）、~~SoC bring up、3D 建模（SW 即可）、深度学习。 ","date":"2022-06-13","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Life / 生活 学习新知。看书（科幻小说、技术类、商业类、传记类等）。 逛各种地方。喜欢亲切大自然。 纯音乐，电音，民歌。电影，打小没断过，几百部。动漫（不包含剧场版）：《命运石..》、《..巨人》、《罗小黑..》、《瑞克与莫..》、《鬼灭..》、《间谍过..》等。 中二出院多年但时不时回光返照。 做一些有趣的电子玩楞。 学学钢琴（如果有时间的话..），之后也可以学着搞搞电子音乐。 和 同行 辩论 / battle。观察、思考、记录生活、人、世界与新的东西。 发呆。 希望英年退休，多看看整个地球，做自己喜欢的事。 ","date":"2022-06-13","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Skills / Hobby / 一些玩过的东西 C/C++，Python。 MCU / RTOS / Linux 应用、驱动。 QT（QWidget / QQuick），LVGL。 FPGA 开发，Verilog IP 核 设计 和 仿真，SOPC 开发。 较复杂 优良电源（开关/线性/分立元件）、电机驱动（有刷/无刷/步进）、高速接口、小信号测量、各种保护 等硬件电路设计。至此，已成艺术。 以上均输出文章。 Adobe After Effects，Premiere，视频压制，Photoshop，Audition，KeyShot 等等。做视频、剪视频（早年黑历史）。 田径比赛。 使用互联网。 高中自通一个背圆周率方法几天课余时间到330位。有机会接触一些记忆宫殿等。 Game：红色警戒2、3，鬼泣3、4、5，我的世界，传说之下。 写短篇科幻小说，投稿过《请留在未来》，点众科幻地址（无了） / 知乎地址，注解篇。 ","date":"2022-06-13","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Essence / 个人方法论 挑几个典型。 记得时常主动跳出圈来，在外面去审视，或许一些事的本质会看的清清楚楚。“认知越多越自由”。 关于学习 五连击： 不用学习看的功利：它是习惯、态度，它只能是生活的一部分，要么是为了做自己喜欢的事，要么是提升物质水平和精神水平，要么是未雨绸缪，要么是解闷，等等。 不用学习当成困苦：关于 难学/学不会 的东西 的原因：1、不是没找到适合自己的、好的教程，2、就是没有 找到/遇到 对的人/会讲的人/有逻辑不跳跃的人/有换位思考-共情能力的人 给你力挽狂澜般的 梳理/讲解。没错，学不会不用太客气怪自己，这两个至少占一样，按这两条对症下药即可，人人皆适用。 然后你还就缺一个动力：我告诉你兴趣的起源：能起作用、期待美好或期待奇特的事情发生是 意义或好奇 的一个来源。意义或好奇 是 兴趣 诞生的一个来源。兴趣（或者叫自我实现） 是 解锁世界 的动力的一个来源。或者一句即可：自信源于成就感。 然后你需要一个适合自己的学习习惯：关于学习：反复实践（learning by doing）/推导明白机理 → 梳理/划分层次/理清节点与结构/形成大框图 → 记录备查 → 时不时多次实践并总结更新更正确的认知。经过这些，那才是自己的。 然后做记录备查：写文档、做记录的好处，对于不断学习中的人来说，不言自明。有的人先意识到写的重要性再去写，有的人就爱写比如我，而且要写的规整舒服，写的不同质化，写出新东西。 “二项玻” 定则：简化之合理的简化、组合之有意义的组合。 言归简，行致繁。 让（他人的）偏见化作带有人情的想象，让（这个）想象缓解（其）带有无知的挫败。 从长期的实践来看， 环境安静 且 心静 有更大概率出好活，安静才是好环境，心躁出不了好东西。当然，对于每个人呀不一样。 做完“作业”再玩，而不是一边“写”一边玩，更不是玩完了也不用“写”了（扩展到对于一生，这里“作业”是广义概念）。 TODO: 还有一些更好的表述在曾经发到 知乎 等地方，可以有时间再收集一波到 只剩结果的故事便是短句合集2.md 文章里面 了 ","date":"2022-06-13","objectID":"/about/:4:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Sites / 个人主页 Github / Gitee。 小站（个人博客）。 知乎，CSDN，BiliBili，微博。 Email superxhy@qq.com。 ","date":"2022-06-13","objectID":"/about/:5:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Education / 过往 2015 - 2019 华北理工大学（学士），自动化。 第十二届大学生“恩智浦”杯智能汽车竞赛，国家级一等奖，2017.07。 第十届大学生节能减排竞赛，国家级一等奖，2017.07。 全国大学生电子设计竞赛华北赛区，省级一等奖，2017.08。 其余低于省一的竞赛略（总共二十多张奖项）。另外本科时候发过英文会议一篇、发明专利一篇三作、实用新型专利若干。 本科期间曾任校级 “电子科技创新实验室” 管理层 和 “创客空间实验室” 会长职务。 ​ —— 2020 - 2023 中国海洋大学（硕士）。 个人简历 .png(380KB), .pdf(489KB)。 💥此网页采用 HUGO 工具 + LoveIt 主题完成，后托管于 Github。😘 本小站的留言和站内搜索功能随缘升级，To be continuted… ","date":"2022-06-13","objectID":"/about/:6:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["【直达本质入门】系列"],"content":"简明自动控制——为什么特征方程如此重要","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"简明自控-聊聊啥是自控和特征方程 简明自动控制——为什么特征方程如此重要。 热场视频： 自平衡杆-双轴反作用轮倒立摆_哔哩哔哩_bilibili。 顶个棍子！具有主动脚轮的全向移动机器人_哔哩哔哩_bilibili。 我自行车怎么少个轱辘啊–球轮控制系统_哔哩哔哩_bilibili。 及其富有科技感的–桌面级旋转倒立摆2_哔哩哔哩_bilibili。 文章结构：前序-\u003e一言以蔽之-\u003e建模-\u003e时域分析-\u003eZ变换-\u003e后记 解决问题：啥是自控？怎么建模？怎么分析？ 如果中间不想看，请看一下后记部分吧！ ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:0:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"前序 自动控制，简短截说： 要让家里的室灯的关和开随着日起日落自动变化，上自动控制，你看，自动控制是把曾经需要人观察然后调整到合适的事情让机器自己调整，自动运行起来，这种粗活的去人化； 一个电机带动履带旋转运送东西，众所周知，当运送的东西很重时，由于摩擦力会阻滞电机的转动，从而可能造成转速下降，如何让电机在不同负载时保持同一个转速，上自动控制，你看，自动控制就是人给一个设定值（比如转速、温度、角度等）然后就不用管了，机器会稳定的执行到达你的设定值，无论它受到什么阻碍； 以前，所有的船需要抛瞄从而在茫茫大洋中留在原地，现在的一些船，通过GPS获取自己的位置，如果船向东偏了，船上的动力会自动的将船向西挪挪使之保持在原地； 发射一个导弹，无论是在什么地方发射的，在深远的内陆，亦或在海上、海内和空中，都可以命中目标，因为自动控制，设定目标，导弹自己会到达目标。 以上是一些简化的描述，从以上的过程总结一下有哪些共同之处，一个能够自动控制的系统，都需要设定值，都需要获取要控制的量的实时值（对于电机，要控制的量就是电机转速，对于船，要控制的量就是位置，对于导弹，要控制的量就是飞行方向），以及一些机制或者算法，让要控制的量去自动的跟踪设定值。所谓去人化，就是这一个个机器实现了自动化。 《自动控制原理》和《现代控制理论》这两本书，我完整的翻了不下好几遍。 首先就基础的这本《自动控制原理》而言，一上来，举例和定义很抽象，然后讲系统的分类，后面满书就是纯数学的东西，直接地说，这就不是给初学者看的书，这是适合已经有基础来巩固深化的书；看完之后有的人会说，我理解和尊重科学知识用到了生产生活里面，但我不知道具体是怎么用的，这些书，让我感觉尬尬的。 这本书分为三块，线性连续系统、线性离散系统和非线性系统。离散系统与连续很类似，本文后面只讲时域到离散域转化的一种直观方法；非线性分析部分很基础，如果会了连续系统分析这部分就能看。 本文的目的，就是先不要看书，看我这篇，然后再去看书，被概念绊住，被方法卡主，被找不着方向的几率小很多。（PS.但当我写完本文回头来看，概念和数学介绍起来不是那么简单） 这期是水一期，我从头到尾给你讲一下，传递函数中的特征方程为啥那么重要，这只是自控的自洽完备的理论体系里面的一小点，且在这里碎片化的提一下，给个印象，不是高效的系统性总结，所以是水一期。 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:1:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"传统艺能，一言以蔽之 这里放个图：控制系统抽象出的结构框图（圆叉符号表示加和，控制器的描述为A（理解为放大倍数，增益或者一个函数）被控对象的描述这里暂定为1） 可以用公式写一下： 自动控制原理这门课，所要解决的最内核的问题，就是设计中间的那个控制器的内部算法，让输出能够且更好的跟踪输入。 要想研究，就先量化，要想量化，先定指标。 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:2:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"指标的概念 再看一个图，观察。这是两根随时间变化的曲线，一个是上图中系统的输入值Xi（虚线），另一个是系统的输出值Xo（实线）。 评判自控系统“优劣”的三个指标： 稳定性：输出能否跟踪输入，以及跟踪过程中变化的幅度； 准确性：输出能跟踪输入并且稳定后，两者之间的差是多少； 快速性：输出跟踪输入时，输出由开始到跟上，用的时间是多少。 具体量化指标即： 稳定性：稳定判据；超调量δ = （Xom - Xi）/Xi； 准确性：err（图中的稳态误差）； 快速性：tr（上升时间），tm（峰值时间），ts（调节时间）以及振荡次数μ。 总结：把一个实体系统，建立微分方程、传递函数和频率特性的数学模型，分别在时域、复域和频域三个“维度”，评价这个系统的“稳准快”性能，这本书说完了。目的就是得到“稳准快”这三个指标，初学到此足够。 这三个“维度”，就是三条路，都可以到达目的地，走哪一条都可以，区别就是对于不同的系统和目的，三条路的重要性和难易程度不同。 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:3:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"这本书 这本书：建立数学模型-\u003e微分方程的时域分析-\u003e传递函数的复域分析-\u003e频率特性的频域分析，然后简单介绍一下离散系统和非线性系统的一般计算方法，没了就这些。 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:4:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"建立数学模型 基本模型：电容，电感。 为了把微分方程写成传递函数，去掉零初始值，经过拉普拉斯变换，写成输出比上输入的形式。一次微分当成s，两次微分当成s^2，一次积分当成1/s，依次类推，怎么来的，拉普拉斯变换，降维，把积分微分符号变成乘除，有兴趣去推一推。 电路中，可以直接把电容和电感分别写成阻抗形式，然后就按照普通的欧姆定律计算即可求出该电路的传递函数，在给定输入的情况下，计算出输出，然后把输出反拉氏变换，就得到了输出的时域解，进而画出时域解的图像，或者就求导之类的计算“稳准快”。 下面举一个例子，如何写出一个系统的微分方程、传递函数和频率特性。 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:5:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"正片开始：分析“稳准快”指标与特征根的关系 再举一个例子，看这个电路，这次不但写数学模型，再求解一下“稳准快”指标。 其微分方程可以写成如下形式： 再写传递函数，先别管为什么写，写出来看看： 求一下特征方程的跟： a和b好像与微分方程的解有相同之处（全文点睛），将a和b带入看看： “稳准快”的具体公式： 所以你看，特征方程的跟a+bj决定了系统的“稳准快”指标，即系统动态响应过程与特征跟在复平面的位置有关。对于高阶系统，同样适用。 更形象的理解，看上面的输出公式Uo（t）；a是负数，a如果变大，则Uo（t）的图像曲线会更加“陡”，如果a变小，曲线会温和平静一些，a是管“纵向”幅度的；b在正弦函数里，b变大，曲线会被往右“拉长”，反之同理，b是管“横向”拉伸的。一纵一横，这输出量的图像基本就确定了。 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:6:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"自控原理总结 ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:7:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"Z变换一般方法简析 下面给出一个例子： ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:8:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"},{"categories":["【直达本质入门】系列"],"content":"后记 1、上面对系统进行建模的环节都是拿电路举例，只是举例，这种数学建模思想可以直接平移用到其他系统。 2、说了那么多，那通过数学推导出的控制器，该怎么转变为软件算法呢。相比于实体控制器，这样的好处是控制算法容易修改，容易维护和部署，但缺点是速度可能比实际电路运行的慢些，考虑一下性价比。计算机是离散的，如无处不在的律动，只需把连续传函变为离散传函即可。 3、控制器花样繁多，学自动化或者自动控制，不可不了解的一种，那就是PID，现在工业现场的控制任务，这种算法用的最多，改进型的PID，也多达二十多种，易读易用。 4、让更多的人真正理解这门课的内涵和意义，本篇文字也是简单打一个样子，许多科目本来相当实用和有意思，我想传达这种精神，各位，吃喝玩乐很有意思，因为那些本身就是为了让人感觉好的，但是如果让难的事物，让更有价值的事物在保持能够给人加价的同时，也能变得有意思，这是现代社会的一种内核趋势。 5、说句题外话：我看模电，一次看的电子科大的慕课，并按照每一节知识点作笔记，然后重新梳理笔记，对于BJT，最后我总结的学习路线是由概念到等效模型，到偏置电路及其意义，再到放大电路和三种接法，最后到频率特性，可是视频课程的安排却是概念（上），偏置电路，概念（下），等效模型，放大电路，三种接法第一种，频率特征，三种接法后两种。我觉得我是按照正常人理解的顺序整理的，而视频的讲解顺序有点打乱的感觉，模电原课本更加抽象和厚重，让我觉得不光是考试的时候筛选人才，在这种环境里，其学习的过程都是在筛选。想起很久以前听的一个事，就是日本在其国注册了一些专利，由于产业需要，也要在中国注册这些的专利，给我们看日本的专利文件，念起来是一句话，但句子又长又难懂，东扯西扯，可能是翻译的缘故，但更可能的就是人家故意写的晦涩一些。 在制造技术壁垒上理所当然，但是在学习知识上，有种“我好不容易学得的，你想学也得给我难一些”，可能为人师表的不是这种心理，但是我有权利也有理由怀疑。 6、平衡车，平衡自行车，二阶倒立摆，旋转倒立摆等“神奇”的事物，都是经典和现代控制理论最直接典型的应用，生活中无处不在。应用现代控制理论建模，列状态方程，仿真和实现，现今其实缺乏这种一整套的从无到有的全过程体验和训练。 (over) ","date":"2020-03-22","objectID":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/:9:0","tags":["自动控制"],"title":"【简明自控】聊聊啥是自控和特征方程","uri":"/0%E7%AE%80%E6%98%8E%E8%87%AA%E6%8E%A7-%E8%81%8A%E8%81%8A%E5%95%A5%E6%98%AF%E8%87%AA%E6%8E%A7%E5%92%8C%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"}]