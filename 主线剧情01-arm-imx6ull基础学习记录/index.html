<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>【主线剧情01】ARM IMX6ULL 基础学习记录 - 欢迎来到 瞰百Staok</title><meta name="Description" content="介绍 ARM 和 i.MX6ULL SoC 的基本内容，以及GCC、Makefile等"><meta property="og:title" content="【主线剧情01】ARM IMX6ULL 基础学习记录" />
<meta property="og:description" content="介绍 ARM 和 i.MX6ULL SoC 的基本内容，以及GCC、Makefile等" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-02T13:26:36+08:00" />
<meta property="article:modified_time" content="2023-05-27T15:54:12+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【主线剧情01】ARM IMX6ULL 基础学习记录"/>
<meta name="twitter:description" content="介绍 ARM 和 i.MX6ULL SoC 的基本内容，以及GCC、Makefile等"/>
<meta name="application-name" content="瞰百Staok">
<meta name="apple-mobile-web-app-title" content="瞰百Staok"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" /><link rel="prev" href="https://staok.github.io/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/" /><link rel="next" href="https://staok.github.io/%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "【主线剧情01】ARM IMX6ULL 基础学习记录",
        "inLanguage": "",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/staok.github.io\/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/staok.github.io\/images\/Apple-Devices-Preview.png",
                            "width":  3200 ,
                            "height":  2048 
                        }],"genre": "posts","keywords": "ARM, Linux","wordcount":  11696 ,
        "url": "https:\/\/staok.github.io\/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95\/","datePublished": "2021-04-02T13:26:36+08:00","dateModified": "2023-05-27T15:54:12+08:00","publisher": {
            "@type": "Organization",
            "name": "Staok","logo": {
                    "@type": "ImageObject",
                    "url": "https:\/\/staok.github.io\/images\/avatar.png",
                    "width":  404 ,
                    "height":  392 
                }},"author": {
                "@type": "Person",
                "name": "Staok"
            },"description": "介绍 ARM 和 i.MX6ULL SoC 的基本内容，以及GCC、Makefile等"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="欢迎来到 瞰百Staok"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="欢迎来到 瞰百Staok"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">【主线剧情01】ARM IMX6ULL 基础学习记录</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/Staok" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Staok</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%85linux-%E7%B3%BB%E5%88%97/"><i class="far fa-folder fa-fw"></i>【主线剧情】Linux 系列</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-04-02">2021-04-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 11696 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 24 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#目录">目录</a></li>
    <li><a href="#arm--linux-相关">ARM &amp; Linux 相关</a>
      <ul>
        <li><a href="#cpsr-寄存器详情">cpsr 寄存器详情</a>
          <ul>
            <li><a href="#运行模式">运行模式</a></li>
            <li><a href="#每一种模式对应使用的寄存器">每一种模式对应使用的寄存器</a></li>
            <li><a href="#程序状态寄存器-cpsr">程序状态寄存器 cpsr</a></li>
          </ul>
        </li>
        <li><a href="#大小端模式">大小端模式</a></li>
        <li><a href="#汇编程序调用-c-程序详情">汇编程序调用 C 程序详情</a></li>
      </ul>
    </li>
    <li><a href="#imx6ull-裸机编程相关">imx6ull 裸机编程相关</a>
      <ul>
        <li><a href="#裸机映像文件合成详情">裸机映像文件合成详情</a></li>
        <li><a href="#重定位启动和编译">重定位、启动和编译</a>
          <ul>
            <li><a href="#各段数据重排序">各段数据重排序</a></li>
            <li><a href="#启动文件程序">启动文件程序</a></li>
            <li><a href="#makefile-文件解析">Makefile 文件解析</a></li>
            <li><a href="#清零-bss-段">清零 bss 段</a></li>
            <li><a href="#数据段再单独重定位">数据段再单独重定位</a></li>
            <li><a href="#修改应用在内存中的存放地址">修改应用在内存中的存放地址</a></li>
          </ul>
        </li>
        <li><a href="#100ask-imx6ull-flashing-tool-工具使用">100ASK IMX6ULL Flashing Tool 工具使用</a></li>
        <li><a href="#异常与gic介绍">异常与GIC介绍</a>
          <ul>
            <li><a href="#gic概念">GIC概念</a></li>
            <li><a href="#处理流程">处理流程</a></li>
            <li><a href="#初始化流程">初始化流程</a></li>
            <li><a href="#更多内容">更多内容</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#arm异常处理--启动文件的示例">ARM异常处理 &amp; 启动文件的示例</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="arm--imx6ull-基础学习记录">ARM &amp; i.MX6ULL 基础学习记录</h1>
<p>编辑整理 by <a href="https://github.com/Staok" target="_blank" rel="noopener noreffer">Staok</a>。</p>
<p>本文大部分内容摘自“100ask imx6ull”开发板的配套资料（如《IMX6ULL裸机开发完全手册》等等），侵删。进行了精髓提取，方便日后查阅。过于基础的内容不会在此提及。如有错误恭谢指出！</p>
<p>注：<a href="https://github.com/Staok/ARM-Linux-Study" target="_blank" rel="noopener noreffer">在 Github 上的原版文章日后可能会更新</a>，在其它位置发的不会跟进。<a href="https://gitee.com/staok/ARM-Linux-Study" target="_blank" rel="noopener noreffer">文章的 Gitee 仓库地址，Gitee 访问更流畅</a>。</p>
<hr>
<h2 id="目录">目录</h2>
<p>[TOC]</p>
<hr>
<h2 id="arm--linux-相关">ARM &amp; Linux 相关</h2>
<p><em>p.s 汇编基本指令和 ARM 的汇编启动代码看 “ARM异常处理 及其模板” 文件夹里的 startup.s 文件。</em></p>
<h3 id="cpsr-寄存器详情">cpsr 寄存器详情</h3>
<h4 id="运行模式">运行模式</h4>
<p>Cortex-A7架构的运行模式有9种。运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的，用户模式下需要借助异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>User</td>
<td>用户模式，非特权模式，大部分程序运行的时候就处于此模式</td>
</tr>
<tr>
<td>Sys(System)</td>
<td>系统模式，用于运行特权级的操作系统任务</td>
</tr>
<tr>
<td>FIQ</td>
<td>快速中断模式，进入 FIQ 中断异常</td>
</tr>
<tr>
<td>IRQ</td>
<td>一般中断模式</td>
</tr>
<tr>
<td>ABT(Abort)</td>
<td>数据访问终止模式，用于虚拟存储以及存储保护</td>
</tr>
<tr>
<td>SVC(Supervisor)</td>
<td>超级管理员模式，供操作系统使用</td>
</tr>
<tr>
<td>UND(Undef)</td>
<td>未定义指令终止模式</td>
</tr>
<tr>
<td>MON(Monitor)</td>
<td>用于安全扩展模式</td>
</tr>
<tr>
<td>Hyp</td>
<td>用于虚拟化扩展</td>
</tr>
</tbody>
</table>
<p>几点说明：</p>
<ul>
<li>板子上电时，CPU处于SVC模式，它用的是SVC模式下的寄存器。</li>
<li>程序运行时发生了中断，CPU进入IRQ模式，它用的IRQ模式下的寄存器。</li>
<li>CPU发生某种异常时，比如读取内存出错，它会进入ABT模式，使用ABT模式下的寄存器来处理错误。</li>
</ul>
<h4 id="每一种模式对应使用的寄存器">每一种模式对应使用的寄存器</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/%e6%af%8f%e4%b8%80%e7%a7%8d%e6%a8%a1%e5%bc%8f%e5%af%b9%e5%ba%94%e4%bd%bf%e7%94%a8%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8.png"
        data-srcset="assets/%e6%af%8f%e4%b8%80%e7%a7%8d%e6%a8%a1%e5%bc%8f%e5%af%b9%e5%ba%94%e4%bd%bf%e7%94%a8%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8.png, assets/%e6%af%8f%e4%b8%80%e7%a7%8d%e6%a8%a1%e5%bc%8f%e5%af%b9%e5%ba%94%e4%bd%bf%e7%94%a8%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8.png 1.5x, assets/%e6%af%8f%e4%b8%80%e7%a7%8d%e6%a8%a1%e5%bc%8f%e5%af%b9%e5%ba%94%e4%bd%bf%e7%94%a8%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8.png 2x"
        data-sizes="auto"
        alt="assets/每一种模式对应使用的寄存器.png"
        title="每一种模式对应使用的寄存器" /></p>
<p>几点说明：</p>
<ul>
<li>如果某个程序处于 FIQ 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_fiq。</li>
<li>如果某个程序处于 SVC 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_svc。</li>
<li>除了 FIQ 模式，寄存器 R0~R12 都是通用的，即模式之间切换前这些寄存器的值应该保存。</li>
<li>假如某个ARM处理器是三级流水线：取指-&gt;译码-&gt;执行，循环执行，那么程序计数器 R15(PC) = 当前执行指令地址 + 4 * 2 个字节。</li>
<li>未定义指令异常的个别用法：在某些系统中，代码可能包含用于协处理器（例如VFP协处理器）的指令，但是系统中不存在相应的VFP硬件。另外，VFP硬件有可能无法处理特定指令，而是想调用软件来对其进行模拟。或者，可能会禁用VFP硬件，采用异常处理，以便可以启用它，然后重新执行指令。使用未定义的指令，可以实现一些仿真器（软件模拟硬件的实现）。比如在你的芯片中，它并未支持某条硬件除法指令，但是你还可以在代码中使用它。当CPU执行这条指令时会发生异常，在异常处理函数中，你用软件来实现该指令的功能。对于不是特别设置的未定义指令，在异常处理函数中不能处理它时，通常做法是记录适当的调试信息，并关掉（kill）对应的应用程序。在某些情况下，未定义指令异常的另一个用途是实现用户断点：调试器（如gdb）去修改代码，替换断点位置的指令为一条未定义指令。</li>
<li>SVC异常的个别用法：软中断 swi 指令可以触发此异常，获得 SVC 权限。在Linux中对文件的open/read/write等APP层的系统函数，它的本质都是执行SVC指令，从而进入Linux内核中预设的SVC异常处理函数，在内核里操作文件。可以使用寄存器或者操作码中某个字段将参数传递给SVC处理程序。</li>
</ul>
<h4 id="程序状态寄存器-cpsr">程序状态寄存器 cpsr</h4>
<p>所有运行模式都共用一个 CPSR 物理存在的寄存器叫 程序状态寄存器，CPSR 可以在任何模式下被访问。当特定异常中断发生时，备份程序状态寄存器 SPSR 用来保存 CPSR 的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/%e7%a8%8b%e5%ba%8f%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8-cpsr.png"
        data-srcset="assets/%e7%a8%8b%e5%ba%8f%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8-cpsr.png, assets/%e7%a8%8b%e5%ba%8f%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8-cpsr.png 1.5x, assets/%e7%a8%8b%e5%ba%8f%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8-cpsr.png 2x"
        data-sizes="auto"
        alt="assets/程序状态寄存器-cpsr.png"
        title="程序状态寄存器 cpsr" /></p>
<p>各个位的说明：</p>
<ul>
<li>
<p>N(bit31)：当两个有符号整数(补码表示)运算时，结果用N表示，N=1/0 表示 负数/正数。</p>
</li>
<li>
<p>Z(bit30)：对于 CMP 指令，Z=1 表示进行比较的两个数大小相等。</p>
</li>
<li>
<p>C(bit29)：</p>
<ul>
<li>在加法指令中，当结果产生了进位，则C=1，表示无符号数运算发生上溢，其它情况下 C=0；</li>
<li>在减法指令中，当运算中发生借位，则C=0，表示无符号数运算发生下溢，其它情况下 C=1；</li>
<li>对于包含移位操作的非加/减法运算指令，C 中包含最后一次溢出的位的数值；</li>
<li>对于其它非加/减运算指令，C 位的值通常不受影响。</li>
</ul>
</li>
<li>
<p>V(bit28)：对于加/减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V=1 表示符号位溢出，通常其他位不影响 V 位。</p>
</li>
<li>
<p>Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q=1/0 表示累积饱和/累积不饱和。</p>
</li>
<li>
<p>IT[1:0] (bit26:25) 和 IT[7:2] (bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。</p>
</li>
<li>
<p>J(bit24) 和 T(bit5)：控制指令执行状态，表明本指令是ARM指令还是Thumb指令。{J,T} = b00 为 ARM；= b01 为 Thumb；= b11 为 ThumbEE；= b10 为 Jazelle。</p>
</li>
<li>
<p>GE[3:0] (bit19:16)：SIMD（单指令多数据，处理器为提升并行操作的一种功能） 指令有效，大于或等于。</p>
</li>
<li>
<p>E(bit9)：大小端控制位，E=1/0 表示大/小端模式。</p>
</li>
<li>
<p>A(bit8)：禁止异步中断位，A=1 表示禁止异步中断。</p>
</li>
<li>
<p>I(bit7)：I=1/0 代表 禁止/使能 IRQ。</p>
</li>
<li>
<p>F(bit6)：F=1/0 代表 禁止/使能 FIQ。</p>
</li>
<li>
<p>M[4:0]：运行模式控制位，如表</p>
<table>
<thead>
<tr>
<th>M[4:0]</th>
<th>运行模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>User 模式</td>
</tr>
<tr>
<td>10001</td>
<td>FIQ 模式</td>
</tr>
<tr>
<td>10010</td>
<td>IRQ 模式</td>
</tr>
<tr>
<td>10011</td>
<td>Supervisor(SVC)模式</td>
</tr>
<tr>
<td>10110</td>
<td>Monitor(MON)模式</td>
</tr>
<tr>
<td>10111</td>
<td>Abort(ABT)模式</td>
</tr>
<tr>
<td>11010</td>
<td>Hyp(HYP)模式</td>
</tr>
<tr>
<td>11011</td>
<td>Undef(UND)模式</td>
</tr>
<tr>
<td>11111</td>
<td>System(SYS)模式</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>在用户模式下，无法改变处理器模式的M位[4：0]来切换模式和A，I和F位来使能或者禁止异步中止、IRQ和FIQ。</p>
<h3 id="大小端模式">大小端模式</h3>
<ul>
<li>大端模式（Big-endian），是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。</li>
<li>小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。</li>
</ul>
<h3 id="汇编程序调用-c-程序详情">汇编程序调用 C 程序详情</h3>
<p>在 C 程序和 ARM 汇编程序之间相互调用时必须遵守 ATPCS 规则，其是基于 ARM 指令集和 THUMB 指令集过程调用的规范，规定了调用函数如何传递参数，被调用函数如何获取参数，以何种方式传递函数返回值。</p>
<ol>
<li>寄存器 R0~R15 在 ATPCS 规则的使用
<ul>
<li>在函数中，通过寄存器 R0~R3 来传递参数，被调用的函数在返回前无需恢复寄存器 R0~R3 的内容。</li>
<li>在函数中，通过寄存器 R4~R11 来保存局部变量。</li>
<li>寄存器 R12 用作函数间 scratch 寄存器。</li>
<li>寄存器 R13 用作栈指针，记作 SP ，在函数中寄存器 R13 不能用做其他用途，寄存器 SP 在进入函数时的值和退出函数时的值必须相等。</li>
<li>寄存器 R14 用作链接寄存器，记作 LR ，它用于保存函数的返回地址，如果在函数中保存了返回地址，则 R14 可用作其它的用途。</li>
<li>寄存器 R15 是程序计数器，记作 PC ，它不能用作其他用途。</li>
</ul>
</li>
<li>汇编程序向 C 程序函数传递参数
<ul>
<li>当参数小于等于 4 个时，使用寄存器 R0~R3 来进行参数传递。</li>
<li>当参数大于 4 个时，前四个参数按照上面方法传递，剩余参数传送到栈中，入栈的顺序与参数顺序相反，即最后一个参数先入栈。</li>
</ul>
</li>
<li>C 程序函数返回结果给汇编程序
<ul>
<li>结果为一个 32 位的整数时，通过寄存器 R0 返回。</li>
<li>结果为一个 64 位整数时，通过 R0 和 R1 返回，依此类推。</li>
<li>结果为一个浮点数时，通过浮点运算部件的寄存器 f0，d0 或 s0 返回。</li>
<li>结果为一个复合的浮点数时，通过寄存器 f0-fN 或者 d0~dN 返回。</li>
<li>对于位数更多的结果，通过调用内存来传递。</li>
</ul>
</li>
<li>当 C 程序从一个函数跳转到另一个函数时，会先把源函数的 CPU 的寄存器和函数内的局部变量都入栈，当跳回时再出栈，这一过程的汇编代码是当 C 程序编译成汇编时被编译器自动添加。</li>
</ol>
<hr>
<h2 id="imx6ull-裸机编程相关">imx6ull 裸机编程相关</h2>
<p>这里是处理器启动流程等的介绍，属于科普环节，有个印象，会加深对于处理器如何运行的理解，非必要记住，而是为以后的操作说明每一个步骤都在做什么事情。此部分理解为主。</p>
<h3 id="裸机映像文件合成详情">裸机映像文件合成详情</h3>
<p>先说原理，看 imx6ull 芯片手册可知，芯片上电时内部的 boot ROM 固化的程序会通过外部引脚确定启动方式（USB\NAND\EMMC\SD等），将应用的二进制数据（app.bin）从存储区（NAND\EMMC\SD等）搬运到内存区（DDR2\3等），然后跳转到内存区的程序处开始执行程序。这个过程是这个芯片自动完成的，但是需要根据规定合成烧录到存储区的映像文件， 在编译得到应用的二进制文件 app.bin（这个就是比如 裸机应用固件 或 Linux 固件等）之后，再用 mkimage 工具（gcc-arm-linux-gnueabihf-6.2.1 编译器自带的）根据 imximage.cfg.cfgtmp 这个文件的信息，合成头部信息，再与 app.bin 组合生成 .imx 文件， .imx 的头部再添加 1KB 的数据（可以全为0，也可包含分区表等数据） 组合生成 .img 文件，具体如下：</p>
<ul>
<li>.imx 文件 = 头部信息（ IVT + Boot data + DCD） + app.bin      -&gt;    用于在烧写工具中烧写到 EMMC 中，烧写工具会自动将其烧写到 1KB 偏移处。</li>
<li>.img 文件 = 1k.bin + .imx 文件 = 1k.bin + 头部信息（ IVT + Boot data + DCD） + app.bin    -&gt;    用于在烧写工具中烧写到 SD 中，烧写工具会将其烧写到 0 位置处（对与 SD 的烧写，此工具不会自动加 1KB 偏移&hellip;）。</li>
</ul>
<p>头部信息包含了指示 boot ROM 程序要把 app.bin 数据搬运到内存的何处，其大小，以及包含了配置 DDR 的寄存器、引脚等数据等待，具体如下：</p>
<ul>
<li>
<p>IVT：Image vector table，含 header（含 tag、length、version，这 3 项，length 表示 IVT 的大小）、entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）、dcd（指示 DCD 数据 在内存中的位置）、boot_data（指示 Boot data 在内存中的位置）、self（指示 IVT 在内存中的位置）等，共占 32*8bit 大小，entry 为 app.bin 要在内存中的目的地址。</p>
</li>
<li>
<p>Boot data：start（映像文件在内存中的地址，为 IVT 在内存中的绝对地址减去 1024 偏移）、length（整个映像文件的长度，含 1k.bin）、plugin，共占 32*3bit 大小。</p>
</li>
<li>
<p>DCD：配 imx6ull 芯片的寄存器，如 DDR 的配置等，可自定，复杂，mkimage 根据 imximage.cfg.cfgtmp 这个文件的信息合成。</p>
<p>其中，entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）的地址在 Makefile 中调用 mkimage  工具时是可以指定的，在&quot;重定位&quot;章节会细说。</p>
</li>
</ul>
<p>具体分布：</p>
<ul>
<li>
<p>头部数据和偏移区使用 mkimage 工具生成，官方都会提供的。</p>
</li>
<li>
<p>最前面的灰色部分就是偏移数据区，对于EMMC/SD存储区设备是 1KB，对于 NAND 是256B，具体看手册。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/IVT%e6%89%80%e5%9c%a8%e7%9a%84%e5%9c%b0%e5%9d%80%e5%81%8f%e7%a7%bb.png"
        data-srcset="assets/IVT%e6%89%80%e5%9c%a8%e7%9a%84%e5%9c%b0%e5%9d%80%e5%81%8f%e7%a7%bb.png, assets/IVT%e6%89%80%e5%9c%a8%e7%9a%84%e5%9c%b0%e5%9d%80%e5%81%8f%e7%a7%bb.png 1.5x, assets/IVT%e6%89%80%e5%9c%a8%e7%9a%84%e5%9c%b0%e5%9d%80%e5%81%8f%e7%a7%bb.png 2x"
        data-sizes="auto"
        alt="assets/IVT所在的地址偏移.png"
        title="IVT所在的地址偏移" /></p>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/%e5%a4%b4%e9%83%a8%e4%bf%a1%e6%81%af%e5%8d%b3%e5%ba%94%e7%94%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%b7%e4%bd%93%e5%88%86%e5%b8%83.png"
        data-srcset="assets/%e5%a4%b4%e9%83%a8%e4%bf%a1%e6%81%af%e5%8d%b3%e5%ba%94%e7%94%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%b7%e4%bd%93%e5%88%86%e5%b8%83.png, assets/%e5%a4%b4%e9%83%a8%e4%bf%a1%e6%81%af%e5%8d%b3%e5%ba%94%e7%94%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%b7%e4%bd%93%e5%88%86%e5%b8%83.png 1.5x, assets/%e5%a4%b4%e9%83%a8%e4%bf%a1%e6%81%af%e5%8d%b3%e5%ba%94%e7%94%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%b7%e4%bd%93%e5%88%86%e5%b8%83.png 2x"
        data-sizes="auto"
        alt="assets/头部信息即应用数据的具体分布.png"
        title="头部信息即应用数据的具体分布" /></p>
<p>最终生成的 .img 文件结构：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/%e6%9c%80%e7%bb%88%e7%94%9f%e6%88%90%e7%9a%84.img%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png"
        data-srcset="assets/%e6%9c%80%e7%bb%88%e7%94%9f%e6%88%90%e7%9a%84.img%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png, assets/%e6%9c%80%e7%bb%88%e7%94%9f%e6%88%90%e7%9a%84.img%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png 1.5x, assets/%e6%9c%80%e7%bb%88%e7%94%9f%e6%88%90%e7%9a%84.img%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84.png 2x"
        data-sizes="auto"
        alt="assets/最终生成的.img文件结构.png"
        title="最终生成的.img文件结构" /></p>
<p>imx6ull 上电启动过程分析：</p>
<ol>
<li>
<p>boot Rom 会把 EMMC 或 SD 卡的前 4K 数据（涵盖了头部信息（ IVT + Boot data + DCD）这些等）读入到芯片内部 RAM 运行。</p>
</li>
<li>
<p>boot Rom 根据 DCD 进行初始化 DDR。</p>
</li>
<li>
<p>boot Rom 根据 IVT，从 EMMC 或 SD 卡中将 app.bin 读到 DDR 的 0x80100000 地址（IVT 的 entry，如上图所示）。</p>
</li>
<li>
<p>跳转到 DDR 的 0x80100000 地址执行，即 CPU 开始从内存 0x80100000 地址开始执行机器码。</p>
<p>以上步骤执行完之后的 DDR 内存图示：（这是反汇编 应用固件 产生的 机器码-汇编码 相互对应的内容）</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/imx6ull-%e4%b8%8a%e7%94%b5%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b%e5%88%86%e6%9e%90.png"
        data-srcset="assets/imx6ull-%e4%b8%8a%e7%94%b5%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b%e5%88%86%e6%9e%90.png, assets/imx6ull-%e4%b8%8a%e7%94%b5%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b%e5%88%86%e6%9e%90.png 1.5x, assets/imx6ull-%e4%b8%8a%e7%94%b5%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b%e5%88%86%e6%9e%90.png 2x"
        data-sizes="auto"
        alt="assets/imx6ull-上电启动过程分析.png"
        title="imx6ull-上电启动过程分析" /></p>
</li>
</ol>
<h3 id="重定位启动和编译">重定位、启动和编译</h3>
<h4 id="各段数据重排序">各段数据重排序</h4>
<p>每一个汇编成机器码的 .o 文件都会分为这几个数据段：</p>
<ul>
<li>代码段(.text)：存放代码指令；</li>
<li>只读数据段(.rodata)：存放有初始值并且 const 修饰的全局类变量；</li>
<li>数据段(.data)：存放有初始值的全局类变量（有非零初始值的变量，如 <code>char A = 'A';</code>）；</li>
<li>零初始化段(.bss)：存放没有初始值或初始值为0的全局类变量（如 <code>int g_intA = 0;int g_intB;</code>，这些存放在 .bss 段）；</li>
<li>注释段(.comment)：存放注释。</li>
</ul>
<p>在 Makefile 文件中，在链接步骤，通过 LD 工具，把各个 .o 文件的各个数据段，按照 imx6ull.lds 定义的顺序安放，即各段数据重排序，最后合成一个二进制文件 app.bin，其中的代码段(.text)、只读数据段(.rodata)和数据段(.data)等都来自于前面各个 .o 文件，每个段 的顺序按照  imx6ull.lds 安放。</p>
<p>链接脚本 imx6ull.lds 解析（一体式链接脚本格式）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SECTIONS {
    . = 0x80100000;                      //设定链接地址为0x80100000

    . = ALIGN(4);                        //将当前地址以4字节为标准对齐
    .text      :                         //创建段，其名称为 .text
    {                                    //.text包含的内容为所有链接文件的数据段
        *(.text)                         // *：表示所有文件
    }

    . = ALIGN(4);                        //将当前地址以4字节为标准对齐
    .rodata : { *(.rodata) }             //.rodata存放在.text之后,包含所有链接文件的只读数据段

    . = ALIGN(4);
    .data : { *(.data) }                 //.data存放在.rodata之后，包含所有链接文件的只读数据段

    . = ALIGN(4);
    __bss_start = .;                     //将当前地址的值存储为变量__bss_start
    .bss : { *(.bss) *(.COMMON) }        //.bss存放在.data段之后, 包含所有文件的bss段和注释段
    __bss_end = .;                       //将当前地址的值存储为变量__bss_end
}

</code></pre></td></tr></table>
</div>
</div><p>可见 imx6ull.lds 文件给出 .bss 段的头、尾地址标识：<code>__ bss_start</code> 和 <code>__ bss_end</code>。</p>
<h4 id="启动文件程序">启动文件程序</h4>
<p>以最简单的裸机点灯程序的启动文件 start.S 为例。仅为示例，过于简单，完整示例可看 下面 “ARM异常处理 &amp; 启动文件的示例” 一节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">.text
.global  _start
_start: 				
    /* 设置栈地址 */
	ldr  sp,=0x80200000
	bl main

halt:
	b  halt
</code></pre></td></tr></table>
</div>
</div><h4 id="makefile-文件解析">Makefile 文件解析</h4>
<p>以最简单的裸机点灯程序的 makefile 为例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nv">PREFIX</span><span class="o">=</span>arm-linux-gnueabihf-
<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PREFIX<span class="k">)</span>gcc
<span class="nv">LD</span><span class="o">=</span><span class="k">$(</span>PREFIX<span class="k">)</span>ld
<span class="nv">AR</span><span class="o">=</span><span class="k">$(</span>PREFIX<span class="k">)</span>ar
<span class="nv">OBJCOPY</span><span class="o">=</span><span class="k">$(</span>PREFIX<span class="k">)</span>objcopy
<span class="nv">OBJDUMP</span><span class="o">=</span><span class="k">$(</span>PREFIX<span class="k">)</span>objdump

<span class="nf">led.img </span><span class="o">:</span> <span class="n">start</span>.<span class="n">S</span>  <span class="n">led</span>.<span class="n">c</span> <span class="n">main</span>.<span class="n">c</span>
	<span class="k">$(</span>CC<span class="k">)</span> -nostdlib -g -c -o start.o start.S                 <span class="c1"># 把启动文件 .s 和各个 .c 文件都汇编为机器码文件 .o</span>
	<span class="k">$(</span>CC<span class="k">)</span> -nostdlib -g -c -o led.o led.c	
	<span class="k">$(</span>CC<span class="k">)</span> -nostdlib -g -c -o main.o main.c	
	
	<span class="k">$(</span>LD<span class="k">)</span> -T imx6ull.lds -g start.o led.o main.o -o led.elf  <span class="c1"># 链接，按照 imx6ull.lds 定义的格式，各段数据重排序，把各个 .o 文件组成 .elf 文件</span>
	
	<span class="k">$(</span>OBJCOPY<span class="k">)</span> -O binary -S led.elf  led.bin                 <span class="c1"># .elf 转为 .bin 二进制文件，应用二进制文件</span>
	<span class="k">$(</span>OBJDUMP<span class="k">)</span> -D -m arm  led.elf  &gt; led.dis	
	mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80100000 -d led.bin led.imx
	                                                         <span class="c1"># 使用 mkimage 生成 头部数据，并与 .bin 组合，产生 .imx 文件</span>
	dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>1k.bin <span class="nv">bs</span><span class="o">=</span><span class="m">1024</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span>                <span class="c1"># 创建一个 1KB 的空文件 1k.bin</span>
	cat 1k.bin led.imx &gt; led.img                             <span class="c1"># 把 1k.bin 放在 .imx 前头，组合成 .img 文件</span>

<span class="nf">clean</span><span class="o">:</span>
	rm -f led.dis  led.bin led.elf led.imx led.img *.o

</code></pre></td></tr></table>
</div>
</div><h4 id="清零-bss-段">清零 bss 段</h4>
<p>在 启动文件 汇编程序中，根据 .bss 段的头、尾地址（<code>__ bss_start</code>、<code>__ bss_end</code>）来对此区域清零，让 C 程序中未定义初始值或零初始值的变量在初始化时都为零值，而非随机值。</p>
<p>附程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">clean_bss:
    ldr r1, =__bss_start    @ 将链接脚本变量__bss_start变量保存于r1
    ldr r2, =__bss_end      @ 将链接脚本变量__bss_end变量保存于r2
    mov r3, #0
clean:
    strb r3, [r1]           @ 将当前地址下的数据清零
    add r1, r1, #1          @ 将r1内存储的地址+1
    cmp r1, r2              @ 相等：清零操作结束；否则继续执行clean函数清零bss段
    bne clean
    
    mov pc, lr
</code></pre></td></tr></table>
</div>
</div><p>并在进入主函数前调用 <code>bl clean_bss  /* 清零bss段 */</code>。</p>
<h4 id="数据段再单独重定位">数据段再单独重定位</h4>
<p>事出有因，想要把 .data 段的数据放到 片内内存中以加快访问速度，参考芯片手册得到片内RAM的地址为：0x900000 ~ 0x91FFFF，共128KB（当然不会很大，也就裸机下的编一编、学一学行，Linux 系统等的大型工程就不适合了），所以我们将 .data 段重定位后的地址设置为0x900000。</p>
<p>第一步：把链接脚本 imx6ull.lds 中的 <code>.data : { *(.data) }</code>换成下面的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">     data_load_addr = .;					
     .data 0x900000 : AT(data_load_addr) 
     {
       data_start = . ;                  //addr = 0x900000
       *(.data)
       data_end = . ;                    //addr = 0x900000 + SIZEOF(.data)
     }
</code></pre></td></tr></table>
</div>
</div><p>第二步：在启动文件中，复制 data 段数据到片内内存 data_start</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"> copy_data:
      /* 重定位data段 */
      ldr r1, =data_load_addr	  /* data段的加载地址, 从链接脚本中得到, 0x8010xxxx */
      ldr r2, =data_start		 /* data段重定位地址, 从链接脚本中得到, 0x900000 */
      ldr r3, =data_end		     /* data段结束地址, 从链接脚本中得到,0x90xxxx */
 cpy:
      ldr r4, [r1]		        /* 从r1读到r4 */
      str r4, [r2]		        /* r4存放到r2 */
      add r1, r1, #4		   /* r1+1 */
      add r2, r2, #4		   /* r2+1 */
      cmp r2, r3		       /* r2 r3比较 */
      bne cpy			       /* 如果不等则继续拷贝 */

      mov pc, lr		       /* 跳转回调用copy_data函数之前的地址 */
</code></pre></td></tr></table>
</div>
</div><p>并在进入主函数前调用 <code>bl copy_data  /* 复制 data 段数据到片内内存 data_start */</code></p>
<p>100ask imx6ull 的 《IMX6ULL裸机开发完全手册》中的 &ldquo;第13篇 IMX6ULL裸机开发 - 9.4.3 总结:如何在C函数中使用链接脚本变量&rdquo; 章节讲了如何在 C 程序中调用链接脚本中的表示地址的变量，从而可以在 C 程序中实现 &ldquo;清零 bss 段&quot;和&quot;数据段搬运到片内内存&rdquo;，而不用在启动代码里完成这些操作。</p>
<p>100ask imx6ull 的 《IMX6ULL裸机开发完全手册》中的 &ldquo;第13篇 IMX6ULL裸机开发 - 9.5 重定位全部代码&rdquo; 章节讲了将全部应用的二进制数据搬到芯片的内部内存（128KB），并在其内运行，并且使用 C 程序实现 bss 段清零。其步骤是：第一步，修改链接脚本，段顶位置加上 <code>. = 0x900000;</code>，并加上头、尾的地址标识字符；第二步，在 C 程序中利用头、尾的地址标识字符将其间的数据搬运到芯片内部内存地址；第三步，修改启动文件汇编程序，跳转到内部内存的应用数据处执行。</p>
<h4 id="修改应用在内存中的存放地址">修改应用在内存中的存放地址</h4>
<p>IVT 中的 entry（指示 app.bin 在内存中的位置，即程序数据被复制到内存哪里）的地址在 Makefile 中调用 mkimage  工具时是可以指定，需要改相关联的几个地方如下：</p>
<p>假设应用的二进制数据（app.bin）原来是要存放在内存的 0x80100000 位置，现在要改为 app_address 处。</p>
<ol>
<li>Makefile 文件中修改 -e 选项后的地址 <code>mkimage -n ./tools/imximage.cfg.cfgtmp -T imximage -e 0x80100000 -d relocate.bin relocate.imx</code>。</li>
<li>链接脚本 imx6ull.lds 中 <code>SECTIONS { . = 0x80100000;...</code> 此处改为 app_address 。</li>
<li>启动文件 start.S 内，要修改栈地址 sp，<code>ldr sp,=0x80200000</code> 此处根据 app_address 与 0x80100000 的偏移相应修改，对于小的裸机程序，可以至少比 app_address  大 0x00100000。</li>
</ol>
<h3 id="100ask-imx6ull-flashing-tool-工具使用">100ASK IMX6ULL Flashing Tool 工具使用</h3>
<ul>
<li>
<p>通过 USB 运行裸机程序（不需要烧写，通过u-boot直接在内存中运行）：</p>
<p>板子设到 USB 启动，在 100ask_imx6ull_flashing_tool  工具中的“专业版”界面，打开 .imx 文件，直接点运行。</p>
</li>
<li>
<p>通过 USB 烧写裸机程序：</p>
<p>板子设到 USB 启动，在 Tool 中的“基础版”界面，若选 EMMC ，则用 .imx 文件，若选 SD ，则用 .img 文件。成功后，断电，切到 EMMC 或 SD 启动模式，再上电。</p>
<p>或者在 win 上，用 win disk imager 工具，把 .img 文件写到 SD 卡。</p>
</li>
<li>
<p>基础版界面详情：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>按钮</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>烧写整个系统</td>
<td style="text-align:left">“选择设备”为EMMC时，把emmc.img烧到EMMC上；  “选择设备”为SD/TF时，把sdcard.img烧到SD/TF卡上；  “选择设备”为NAND时，把rootfs.ubi烧到Nand Flash上；  并且会烧写对应的U-Boot，请看下面的“更新Uboot”按钮说明。</td>
</tr>
<tr>
<td>更新内核</td>
<td style="text-align:left">把zImage上传到根文件系统的/boot目录  (对于Nand，是直接烧到内核分区)</td>
</tr>
<tr>
<td>更新设备树</td>
<td style="text-align:left">把100ask_imx6ull-14x14.dtb上传到根文件系统的/boot目录  (对于Nand，是直接烧到设备树分区)</td>
</tr>
<tr>
<td>更新Uboot</td>
<td style="text-align:left">对于IMX6ULL全功能版：  ①“选择设备”为EMMC时，把u-boot-dtb.imx烧写到EMMC  ②“选择设备”为SD/TF时，把u-boot-dtb.imx烧写到SD/TF卡  对于IMX6ULL mini nand版：  ①“选择设备”为NAND时，把u-boot-dtb_nand.imx烧写到Nand Flash  ②“选择设备”为SD/TF时，把u-boot-dtb_nandsd.imx烧写到SD/TF卡</td>
</tr>
<tr>
<td>烧写裸机</td>
<td style="text-align:left">把所选裸机文件，烧写到EMMC、SD/TF卡或Nand  Flash</td>
</tr>
<tr>
<td>上传文件</td>
<td style="text-align:left">把所选用户文件，上传到根文件系统的/目录  对于imx6ull mini nand版，无法上传文件(只支持ext4文件系统，而它不是)</td>
</tr>
</tbody>
</table>
<h3 id="异常与gic介绍">异常与GIC介绍</h3>
<h4 id="gic概念">GIC概念</h4>
<p>念课本（以下内容都是针对&quot;通用中断控制器（GIC）&ldquo;而言，直接摘录的，有的地方可能不符人类的理解方式）：</p>
<p>通用中断控制器（GIC）架构提供了严格的规范，不同厂商的中断控制器之间具有很高的一致性；该控制器包括一组用于管理单核或多核系统中的中断的硬件资源。GIC提供了内存映射寄存器，可用于管理中断源和行为，以及（在多核系统中）用于将中断路由到各个CPU核。它使软件能够屏蔽、启用和禁用来自各个中断源的中断，以（在硬件中）对各个中断源进行优先级排序和生成软件触发中断。它还提供对TrustZone安全性扩展的支持。GIC接受系统级别中断的产生，并可以发信号通知给它所连接的每个内核，从而有可能导致IRQ或FIQ异常发生。</p>
<p>通用中断控制器的工作流程。GIC分为两部分：分发器（Distributor）和CPU接口（CPU interface）。系统中的所有中断源都连接到分发器。可以通过仲裁单元的寄存器来控制各个中断源的属性，例如优先级、状态、安全性、触发方式和使能状态。中断的优先级和可接收中断的核都在分发器中配置。分发器把中断输出到“CPU接口单元”，后者决定将哪个中断转发给CPU核。CPU接口单元寄存器用于屏蔽、识别和控制转发到CPU核的中断的状态。系统中的每个CPU核心都有一个单独的CPU接口，一个CPU核不可能访问另一个CPU核的CPU接口。中断处理详情请看下面的&quot;处理中断&quot;部分。</p>
<p>GIC作为内存映射的外围设备，被软件访问。所有内核都可以访问公共的 GIC的分发器 单元。</p>
<p>中断在软件中由一个称为中断ID的数字标识。中断ID唯一对应于一个中断源。软件可以使用中断ID来识别中断源并调用相应的处理程序来处理中断。呈现给软件的中断ID由系统设计确定，一般在SOC的数据手册有记录。</p>
<p>中断可以有多种不同的类型：</p>
<ul>
<li>软件触发中断（SGI，Software Generated Interrupt）。这是由软件通过写入专用仲裁单元的寄存器即软件触发中断寄存器（ICDSGIR）显式生成的。它最常用于CPU核间通信。SGI既可以发给所有的核，也可以发送给系统中选定的一组核心。中断号0-15保留用于SGI的中断号。用于通信的确切中断号由软件决定。</li>
<li>私有外设中断（PPI，Private Peripheral Interrupt）这是由单个CPU核私有的外设生成的。PPI的中断号为16-31。它们标识CPU核私有的中断源，并且独立于另一个内核上的相同中断源，比如，每个核的计时器。</li>
<li>共享外设中断（SPI，Shared Peripheral Interrupt）。这是由外设生成的，中断控制器可以将其路由到多个核。中断号为32-1020。SPI用于从整个系统可访问的各种外围设备发出中断信号。</li>
</ul>
<p>GIC分发器 拥有许多寄存器，可以通过它们配置各个中断的属性。这些可配置属性是：</p>
<ul>
<li>中断优先级：GIC分发器使用它来确定接下来将哪个中断转发到CPU接口。</li>
<li>中断配置：这确定中断是对电平触发还是边沿触发。</li>
<li>中断目标：这确定了可以将中断发给哪些CPU核。</li>
<li>中断启用或禁用状态：只有GIC分发器中启用的那些中断变为挂起状态时，才有资格转发。</li>
<li>中断安全性：确定将中断分配给Secure还是Normal world软件。</li>
<li>中断状态。中断标志位需要软件清除。</li>
<li>GIC分发器还提供优先级屏蔽，可防止低于某个优先级的中断发送给CPU核。</li>
</ul>
<h4 id="处理流程">处理流程</h4>
<p>众多的中断源，汇集于中断管理器，由中断管理器选择优先级最高的中断并通知CPU。CPU会根据中断的类型到跳转到不同的地址处理中断。当CPU核接收到中断时，它会跳转到异常向量表执行。顶层中断处理程序读取CPU接口模块的Interrupt Acknowledge Register，以获取中断ID。除了返回中断ID之外，读取操作还会使该中断在GIC分发器中标记为active状态。一旦知道了中断ID（标识中断源），顶层处理程序就可以根据中断ID来执行相应的处理任务。</p>
<p>当特定于设备的处理程序完成执行时，顶级处理程序将相同的中断ID写入CPU interface模块中的End of Interrupt register中断结束寄存器，指示中断处理结束。除了把当前中断移除active状态之外，这将使最终中断状态变为inactive或pending（如果状态为inactive and pending），这将使CPU interface能够将更多待处理pending的中断转发给CPU核。这样就结束了单个中断的处理。</p>
<p>同一CPU核上可能有多个中断等待服务，但是CPU interface一次只能发出一个中断信号。顶层中断处理程序重复上述顺序，直到读取特殊的中断ID值1023，表明该内核不再有任何待处理的中断。这个特殊的中断ID被称为伪中断ID（spurious interrupt ID），伪中断ID是保留值，不能分配给系统中的任何设备。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/%e5%a4%84%e7%90%86%e4%b8%ad%e6%96%ad%e7%9a%84%e6%b5%81%e7%a8%8b.png"
        data-srcset="assets/%e5%a4%84%e7%90%86%e4%b8%ad%e6%96%ad%e7%9a%84%e6%b5%81%e7%a8%8b.png, assets/%e5%a4%84%e7%90%86%e4%b8%ad%e6%96%ad%e7%9a%84%e6%b5%81%e7%a8%8b.png 1.5x, assets/%e5%a4%84%e7%90%86%e4%b8%ad%e6%96%ad%e7%9a%84%e6%b5%81%e7%a8%8b.png 2x"
        data-sizes="auto"
        alt="assets/处理中断的流程.png"
        title="处理中断的流程" /></p>
<p>再讲一遍，中断信号先到达分发器，分发器根据该中断所设定的CPU，把中断发送到CPU对应的CPU interface上；在CPU interface里判断该中断的优先级是否足够高，能否抢断或打断当前的中断处理，如果可以，CPU interface就会发送一个物理的信号到CPU的IRQ（或FIQ）线上；CPU接收到中断信号，转到中断处理地址进行处理。</p>
<h4 id="初始化流程">初始化流程</h4>
<p>复位后，必须初始化GIC，中断才能生效。在初始化中断时，要初始化这4部分：产生中断的源头(GPIO模块或UART模块等)、GIC(内部有Distributor或CPU interface)、CPU本身(设置CPSR寄存器)。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="assets/%e4%b8%ad%e6%96%ad%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b5%81%e7%a8%8b.png"
        data-srcset="assets/%e4%b8%ad%e6%96%ad%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b5%81%e7%a8%8b.png, assets/%e4%b8%ad%e6%96%ad%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b5%81%e7%a8%8b.png 1.5x, assets/%e4%b8%ad%e6%96%ad%e5%88%9d%e5%a7%8b%e5%8c%96%e6%b5%81%e7%a8%8b.png 2x"
        data-sizes="auto"
        alt="assets/中断初始化流程.png"
        title="中断初始化流程" /></p>
<p>最后提一句，相关的初始化和处理的代码，芯片官方会提供裸机编程的框架，提供基本的所有寄存器及其结构体的 .h 文件，以及相关使用例程代码，用时看懂就行。</p>
<p>前文根据 100ask的《imx6ull裸机编程》部分的 第十章 “异常与中断” 一节 进行简单总结，后面再看100ask的《imx6ull裸机编程》部分的 第十一章 “GPIO中断” 内容可了解裸机编程中的中断部分。</p>
<h4 id="更多内容">更多内容</h4>
<ul>
<li><a href="https://blog.csdn.net/lgjjeff/category_11580189.html" target="_blank" rel="noopener noreffer">中断管理_lgjjeff的博客-CSDN博客</a>。</li>
<li>&hellip;</li>
</ul>
<hr>
<h2 id="arm异常处理--启动文件的示例">ARM异常处理 &amp; 启动文件的示例</h2>
<p>这里根据 100ask的《imx6ull裸机编程》部分的介绍内容，给出一个 比较丰富的、删去无关代码保留中断处理的、注释丰富的一个 启动文件 汇编程序示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">	@ 本程序仅仅是一个示例
	@ 不同ARM内核的中断向量表不同，具体看手册
	@ 现在的微处理器寄存器结构非常复杂，不建议硬刚芯片手册手写配置代码，直接参考厂家和网络高手的例子特别省事
	@ 一些基础的、不变的、规律性的则必须要会
	
	@ 中断的保存、恢复现场，以及分辨中断号和调用相应中断函数，Cortex M3/M4 是硬件完成的， Cortex A7 是软件实现的
	
	.text					@ 代码段(.text)，表示代码段
							@ 其他段介绍：
							@ 只读数据段(.rodata)：存放有初始值并且const修饰的全局类变量（全局变量或static修饰的局部变量）
							@ 数据段(.data)：存放有初始值的全局类变量
							@ 注释段(.comment)：存放注释，注释段里面的机器码是用来表示文字的
							@ 零初始化段(.bss)：存放没有初始值或初始值为0的全局类变量
							@ 注：bss段和注释段不保存在bin/elf文件中，
							@ 所以如果bss段的数据没有清0的话，没有初始值的变量在初始化时会是随机的，但个人觉得清不清0不是特别重要。
	
	.global start			@ .global 表示 start 是一个全局符号
	
start:						@ 程序入口
	@异常向量表
	b	reset				@ 0x00 reset
	ldr pc,=_undef			@ 0x04 undef 未定义指令异常
	ldr pc,=_swi_handler	@ 0x08 swi 软中断入口 （如果用 mov 指令有32M地址大小限制）
	ldr pc,=_pre_fetch		@ 0x0c prefetch abort
	ldr pc,=_data_abort		@ 0x10 data abort
	nop						@ 0x14 reserved
	ldr pc,=_irq			@ 0x18 irq
	ldr pc,=_fiq			@ 0x1c fiq
	
_undef:			.word		_undef
_swi_handler:	.word		_swi_handler
_pre_fetch:		.word		_pre_fetch
_data_abort:	.word		_data_abort
_irq:			.word		_irq
_fiq:			.word		_fiq


_swi_handler:
	stmfd sp!,{r0-r12,lr}	@ 把 r0-r12 和 lr 寄存器内容进栈，即保护现场
	sub r0,lr,#4			@ 软中断号被保存到 lr 寄存器的上一个指令地址，将其临时保存到 r0
	ldr r0,[r0]				@ 取 r0 保存的地址所指向的值
	bic r0,#0xff000000		@ 根据手册，软中断号被保存在低 24 位，则把高八位内容清 0
	bl swi_user_handle		@ 跳转到 swi_user_handle 软中断用户处理程序，并把下一指令的地址保存到 lr 中
	ldmfd sp!,{r0-r12,pc}^	@ 从栈恢复 r0-r12 寄存器内容，并把原来的 lr 内容 恢复到 pc 中，
							@ 并从 spsr（cpsr的影子寄存器）恢复到 cpsr，即恢复现场
swi_user_handle:
	@... 软中断的用户应用程序，可以调用 c 函数
	
	cmp r0,#2				@ 判断软中断号是否为2，是则执行后面尾缀带eq的指令
	moveq r7,#2
	
	cmp r0,#5				@ 判断软中断号是否为5，是则执行后面尾缀带eq的指令
	moveq r7,#5
	
	cmp r0,#7				@ 判断软中断号是否为7，是则执行后面尾缀带eq的指令
	moveq r7,#7
	
	ldr pc,lr				@ 跳回
	
_irq:
	sub lr,lr,#4
	stmfd sp!,{r0-r12,lr}
	bl irq_user_handle
	ldmfd sp!,{r0-r12,pc}^
	
irq_user_handle:
	@... 外中断的用户应用程序，可以调用 c 函数
	@并在用户程序中，从中断控制器的寄存器中读出当前的中断号，做相应的相应，然后清中断标志位
	@现在的微处理器寄存器结构非常复杂，不建议硬刚芯片手册手写配置代码，直接参考厂家和网络高手的例子特别省事
	
	ldr pc,lr

reset:
	ldr sp,=stack_base		@ 分配栈地址到 sp 寄存器
	msr cpsr,#0x10			@ 切换到 user 模式
	
	@... 用户应用程序，可以调用 c 函数
	
	swi 2					@ 触发软中断，自动跳转到软中断程序入口
							@ 并自动把返回地址（下一个指令的地址）保存到 LR 寄存器
							@ 并自动切换到 SVC（超级用户） 模式
	nop
	nop
	
	
	swi 5
	nop
	nop
	
	
	swi 7
	nop
	nop
	
	/*
		@ 这一段是调用 c 程序里面的 void print_test_string(unsigned int cpsr, char *str) 函数
		@ 给它传入的两个实参为 r0 和 r1
		@ 这时 ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）所规定的
		mrs r0, cpsr
		ldr r1, =test_string
		bl print_test_string
	*/
	
	b reset					@ 返回 reset 地址，大循环

/*
		test_string:
			.string &#34;test_string&#34;	
*/
	
	@ 定义栈空间和地址，buf 为栈的开头地址，stack_base 为栈的尾地址，中间有 32 个 word 空间
	@ 我们使用进出栈的指令是 stmfd 和 ldmfd
	@ 这两个指令，为从 stack_base 开始向上递进存，向下递进取的顺序，与这里定义的顺序一致
	
	/*
		ldr sp,=0x80200000
		stmfd sp!, {r0-r2} @ 入栈
		ldmfd sp!, {r0-r2} @ 出栈
		
		结果：
				0x00000000
				...
				0x801FFFF4	-&gt; 	R0
							   R1
				0x80200000	-&gt; 	R2	sp指针的移动方向：存向上，取向下
		
		也可以用下面指令，效果一样
		push {r0-r2} @ 入栈
		pop {r0-r2}  @ 出栈

	*/
	
	/*
		栈的存取方式
		栈的存取方式，为后进先出（LIFO），是由于进出栈指令的作用方式决定的，数据在栈指针处入栈时，
		如 stmfd sp!,{r0-r12,lr}，根据这个指令的含义，栈指针sp会根据数据存放的方向自增或自减，出栈的时候过程相反，
		在外界看来，这种方式就是只能在头部进出数据的线性表，从算法上来说是一种特殊的线性表，这种
		方式是由汇编指令和硬件的易实现性所决定的。
		
		堆是一块空闲空间，使用 malloc 函数来管理它，malloc 函数可以自己写
		
		&#34;stack_base:&#34; 这种带冒号的标签表示地址位置，通过其得到指令/数据地址
	*/
	.data					
buf:
	.space 32
stack_base:
	
	
	
	.end

</code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-05-27</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" data-title="【主线剧情01】ARM IMX6ULL 基础学习记录" data-hashtags="ARM,Linux"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" data-hashtag="ARM"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><i class="fab fa-linkedin fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://staok.github.io/%E4%B8%BB%E7%BA%BF%E5%89%A7%E6%83%8501-arm-imx6ull%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" data-title="【主线剧情01】ARM IMX6ULL 基础学习记录" data-ralateuid="u/3585238893"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/arm/">ARM</a>,&nbsp;<a href="/tags/linux/">Linux</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/1%E8%AF%B7%E7%95%99%E5%9C%A8%E6%9C%AA%E6%9D%A5/" class="prev" rel="prev" title="科幻小说《请留在未来》"><i class="fas fa-angle-left fa-fw"></i>科幻小说《请留在未来》</a>
            <a href="/%E8%AF%BB%E6%A0%87%E5%87%8601-ieee1451-%E6%99%BA%E8%83%BD%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86%E4%BB%8B%E7%BB%8D/" class="next" rel="next" title="【读标准01】IEEE1451 智能传感器接口标准介绍">【读标准01】IEEE1451 智能传感器接口标准介绍<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.84.4">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2024</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{},"data":{"id-1":"回家","id-2":"回家"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
